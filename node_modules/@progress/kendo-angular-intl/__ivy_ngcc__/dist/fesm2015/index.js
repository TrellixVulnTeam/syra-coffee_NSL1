/**-----------------------------------------------------------------------------------------
* Copyright © 2020 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { __decorate, __metadata, __param } from 'tslib';
import { EventEmitter, ɵɵdefineInjectable, ɵɵinject, LOCALE_ID, Injectable, Inject, Pipe, NgModule } from '@angular/core';
import { validatePackage } from '@progress/kendo-licensing';
import { dateFormatNames, dateFieldName, firstDay, format, formatDate, formatNumber, load, numberSymbols, parseDate, parseNumber, splitDateFormat, toString, weekendRange, setData, localeInfo } from '@telerik/kendo-intl';

/**
 * @hidden
 */
import * as ɵngcc0 from '@angular/core';
const packageMetadata = {
    name: '@progress/kendo-angular-intl',
    productName: 'Kendo UI for Angular',
    productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],
    publishDate: 1620213344,
    version: '',
    licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'
};

const DOCS_URL = 'http://www.telerik.com/kendo-angular-ui/components/internationalization/troubleshooting/';
/**
 * @hidden
 */
const errorSolutions = {
    'NoCurrency': `Solution: ${DOCS_URL}#toc-no-currency`,
    'NoCurrencyDisplay': `Solution: ${DOCS_URL}#toc-no-currency-display`,
    'NoCurrencyRegion': `Solution: ${DOCS_URL}#toc-no-currency-region`,
    'NoDateFieldNames': `Solution: ${DOCS_URL}#toc-no-date-filed-names`,
    'NoFirstDay': `Solution: ${DOCS_URL}#toc-no-first-day`,
    'NoGMTInfo': `Solution: ${DOCS_URL}#toc-no-gmt-info`,
    'NoLocale': `Solution: ${DOCS_URL}#toc-no-locale`,
    'NoValidCurrency': `Solution: ${DOCS_URL}#toc-no-valid-currency`,
    'NoWeekData': `Solution: ${DOCS_URL}#toc-no-week-data`
};

function formatMessage(error) {
    const message = error.message;
    const errorSolution = errorSolutions[Object.keys(errorSolutions).filter(key => message.indexOf(key) === 0)[0]];
    return errorSolution ? `${message} ${errorSolution}` : message;
}
function intlMethod(fn) {
    return function (...values) {
        try {
            return fn.apply(null, values);
        }
        catch (error) {
            error.message = formatMessage(error);
            throw error;
        }
    };
}
/**
 * @hidden
 */
const dateFormatNames$1 = intlMethod(dateFormatNames);
/**
 * @hidden
 */
const dateFieldName$1 = intlMethod(dateFieldName);
/**
 * @hidden
 */
const firstDay$1 = intlMethod(firstDay);
/**
 * @hidden
 */
const format$1 = intlMethod(format);
/**
 * @hidden
 */
const formatDate$1 = intlMethod(formatDate);
/**
 * @hidden
 */
const formatNumber$1 = intlMethod(formatNumber);
/**
 * @hidden
 */
const load$1 = intlMethod(load);
/**
 * @hidden
 */
const numberSymbols$1 = intlMethod(numberSymbols);
/**
 * @hidden
 */
const parseDate$1 = intlMethod(parseDate);
/**
 * @hidden
 */
const parseNumber$1 = intlMethod(parseNumber);
/**
 * @hidden
 */
const splitDateFormat$1 = intlMethod(splitDateFormat);
/**
 * @hidden
 */
const toString$1 = intlMethod(toString);
/**
 * @hidden
 */
const weekendRange$1 = intlMethod(weekendRange);
/**
 * Sets a pre-built locale.
 *
 * @params data - The pre-built locale data.
 */
const setData$1 = (data) => setData(data);
/**
 * Retrieves the locale data for the specified locale.
 *
 * @params locale - The locale id.
 * @returns data - The locale data.
 */
const localeData = (locale) => {
    try {
        return localeInfo(locale);
    }
    catch (error) {
        error.message = formatMessage(error);
        throw error;
    }
};

const LOCALE_REGEX = /_/g;
/**
 * @hidden
 */
function cldrServiceFactory(localeId) {
    return new CldrIntlService(localeId);
}
/**
 * An abstract base class that implements
 * the Internationalization service methods
 * for the current locale.
 */
let IntlService = class IntlService {
    /**
     * @hidden
     */
    constructor() {
        /**
         * @hidden
         */
        this.changes = new EventEmitter();
        validatePackage(packageMetadata);
    }
    /**
     * Notifies that the service was changed.
     */
    notify() {
        this.changes.emit();
    }
};
IntlService.ɵfac = function IntlService_Factory(t) { return new (t || IntlService)(); };
IntlService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IntlService, factory: function IntlService_Factory(t) { let r = null; if (t) {
        r = new t();
    }
    else {
        r = cldrServiceFactory(ɵngcc0.ɵɵinject(LOCALE_ID));
    } return r; }, providedIn: 'root' });
IntlService.ngInjectableDef = ɵɵdefineInjectable({ factory: function IntlService_Factory() { return cldrServiceFactory(ɵɵinject(LOCALE_ID)); }, token: IntlService, providedIn: "root" });
IntlService = __decorate([ __metadata("design:paramtypes", [])
], IntlService);
/**
 * The Internationalization service implemented by using
 * the CLDR Database via the `@telerik/kendo-intl` package.
 */
let CldrIntlService = class CldrIntlService extends IntlService {
    /**
     * Creates a new instance of the service with the ID of the specified locale.
     *
     * Note that the parts of the locale ID can be separated by either `_` (underscore)
     * or `-` (dash).
     *
     * @param localeId - The default locale ID.
     */
    constructor(localeId) {
        super();
        this.localeId = localeId;
    }
    /**
     * Gets or sets the current locale ID.
     */
    get localeId() {
        return this.locale;
    }
    set localeId(value) {
        // Angular locales use underscore, for example, en_US
        // while IETF BCP-47 specifies a dash.
        // https://tools.ietf.org/html/bcp47
        const locale = value.replace(LOCALE_REGEX, '-');
        if (locale !== this.locale) {
            this.locale = locale;
            this.notify();
        }
    }
    /**
     * Formats a string with placeholders such as
     * `Total amount {0:c}`.
     *
     * @param format - The format string.
     * @param values - One or more values to output in the format string placeholders.
     * @return - The formatted string.
     */
    format(format$$1, ...values) {
        return format$1(format$$1, values, this.localeId);
    }
    /**
     * Converts an object into a string based on the specified format.
     *
     * @param value - The value to format.
     * @param format - The format to use.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return The formatted object.
     */
    toString(value, format$$1, localeId) {
        return toString$1(value, format$$1, localeId || this.localeId);
    }
    /**
     * Converts a `Date` object into a string based on the specified format.
     * If no format is provided, the default short date format is used.
     *
     * @param value - The date to format.
     * @param format - The format string or options.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return The formatted date.
     */
    formatDate(value, format$$1, localeId) {
        return formatDate$1(value, format$$1, localeId || this.localeId);
    }
    /**
     * Converts a string into a `Date` object based on the specified format.
     *
     * @param value - The string to convert.
     * @param format - The format strings or options.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return The parsed date.
     */
    parseDate(value, format$$1, localeId) {
        return parseDate$1(value, format$$1, localeId || this.localeId);
    }
    /**
     * Converts a string into a `Number`.
     *
     * @param value - The string to convert.
     * @param format - The format string or options.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return The parsed number.
     */
    parseNumber(value, format$$1, localeId) {
        return parseNumber$1(value, localeId || this.localeId, format$$1);
    }
    /**
     * Converts a `Number` into a string based on the specified format.
     *
     * @param value - The number to format.
     * @param format - The format string or options.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return The formatted number.
     */
    formatNumber(value, format$$1, localeId) {
        return formatNumber$1(value, format$$1, localeId || this.localeId);
    }
    /**
     * Returns the date names from the current locale based on the option.
     *
     * The available `type` values are:
     * - `era`
     * - `year`
     * - `quarter`
     * - `month`
     * - `week`
     * - `day`
     * - `dayperiod`
     * - `hour`
     * - `minute`
     * - `second`
     * - `zone`
     *
     * The available `nameType` values are:
     * - `wide`
     * - `narrow`
     * - `short`
     *
     * @param options - Detailed configuration for the desired date field name.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return - The day names from the current locale based on the option.
     * @returns The localized date field name from the current locale based on the option.
     *
     * @example
     * ```
     * dateFieldName({ type: 'day' });                      //returns 'day';
     * dateFieldName({ type: 'day', nameType: 'wide' });    //returns 'day';
     * dateFieldName({ type: 'month', nameType: 'short' }); //returns 'mo.';
     * dateFieldName({ type: 'month', nameType: 'wide' });  //returns 'month';
     * ```
     */
    dateFieldName(options, localeId) {
        return dateFieldName$1(options, localeId || this.localeId);
    }
    /**
     * Returns a localized date field name based on specific dateFieldName options.
     *
     * The available type values are:
     * - `day`
     * - `dayperiod`
     * - `months`
     * - `quarters`
     * - `eras`
     *
     * @param options - Detailed configuration for the desired date format.
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return - The day names from the current locale based on the option.
     */
    dateFormatNames(options, localeId) {
        return dateFormatNames$1(localeId || this.localeId, options);
    }
    /**
     * Splits the date format into objects containing information about each part of the pattern.
     *
     * @param format The format string or options.
     * @param localeId The optional locale id. If not specified, the `"en"` locale id is used.
     * @returns The date format parts.
     */
    splitDateFormat(format$$1, localeId) {
        return splitDateFormat$1(format$$1, localeId || this.localeId);
    }
    /**
     * Returns the number symbols from the current locale based on the option.
     *
     * @param localeId - The locale ID to use in place of the default one. Optional.
     * @return - The number symbols from the current locale.
     */
    numberSymbols(localeId) {
        return numberSymbols$1(localeId || this.localeId);
    }
    /**
     * Returns the first day index starting from Sunday.
     *
     * @param localeId - The locale ID. Defaults to the current locale ID.
     * @return - The index of the first day of the week (0 == Sunday).
     */
    firstDay(localeId) {
        return firstDay$1(localeId || this.localeId);
    }
    /**
     * Returns the start and end index of the locale weekend starting from Sunday.
     *
     * @param localeId - The locale ID. Defaults to the current locale ID.
     * @return - The the start and end index of the locale weekend (0 == Sunday).
     */
    weekendRange(localeId) {
        return weekendRange$1(localeId || this.localeId);
    }
};
CldrIntlService.ɵfac = function CldrIntlService_Factory(t) { return new (t || CldrIntlService)(ɵngcc0.ɵɵinject(LOCALE_ID)); };
CldrIntlService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: CldrIntlService, factory: function (t) { return CldrIntlService.ɵfac(t); } });
CldrIntlService = __decorate([ __param(0, Inject(LOCALE_ID)),
    __metadata("design:paramtypes", [String])
], CldrIntlService);

const isNumeric = (value) => !isNaN(value - parseFloat(value));
const ɵ0 = isNumeric;
/**
 * Formats a date value to a string based on the requested format.
 * This pipe uses the [IntlService]({% slug api_intl_intlservice %}).
 *
 * @example
 * ```ng-template-no-run
 * <ul>
 *    <li>{{date | kendoDate }}</li>
 *    <li>{{milliseconds | kendoDate: 'M/dd/yyy' }}</li>
 *    <li>{{stringDate | kendoDate: 'G' }}</li>
 * </ul>
 * ```
 */
let DatePipe = class DatePipe {
    /**
     * @hidden
     */
    constructor(intlService) {
        this.intlService = intlService;
    }
    /**
     * Converts a `Date` object into a string based on the specified format.
     * If no format is provided, the default short date format is used.
     *
     * @param value - The date to format.
     * @param format - The format string or options.
     * @param localeId - (Optional) The ID of the locale which will be used instead of the default one.
     * @return - The formatted date.
     */
    transform(value, format$$1 = "", localeId) {
        value = this.normalize(value);
        if (value) {
            return this.intlService.formatDate(value, format$$1, localeId);
        }
        return value;
    }
    normalize(value) {
        if (value && typeof value === 'string') {
            value = this.intlService.parseDate(value);
        }
        else if (value && isNumeric(value)) {
            value = new Date(parseFloat(value));
        }
        return value;
    }
};
DatePipe.ɵfac = function DatePipe_Factory(t) { return new (t || DatePipe)(ɵngcc0.ɵɵdirectiveInject(IntlService)); };
DatePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "kendoDate", type: DatePipe, pure: true });
DatePipe = __decorate([ __metadata("design:paramtypes", [IntlService])
], DatePipe);

/**
 * Formats a number value to a string based on the requested format.
 * This pipe uses the [`IntlService`]({% slug api_intl_intlservice %}).
 *
 * @example
 * ```ng-template-no-run
 *   <ul>
 *     <li>{{decimal | kendoNumber:'c' }}</li>
 *     <li>{{stringNumber | kendoNumber:'p' }}</li>
 *     <li>{{int | kendoNumber:'##.00' }}</li>
 *  </ul>
 * ```
 */
let NumberPipe = class NumberPipe {
    /**
     * @hidden
     */
    constructor(intlService) {
        this.intlService = intlService;
    }
    /**
     * Converts a `Number` object into a string based on the specified format.
     * If no format is provided, the value is formatted as decimal number using the
     * [`"n"`](https://github.com/telerik/kendo-intl/blob/master/docs/num-formatting/index.md#standard) format.
     *
     * @param value - The numer that will be formatted.
     * @param format - The format string or options.
     * @param localeId - (Optional) The locale ID that will be used in place of the default one.
     * @return - The formatted number.
     */
    transform(value, format$$1, localeId) {
        if (typeof value === 'string') {
            value = this.intlService.parseNumber(value);
        }
        if (value !== null && value !== undefined) {
            return this.intlService.formatNumber(value, format$$1, localeId);
        }
        return value;
    }
};
NumberPipe.ɵfac = function NumberPipe_Factory(t) { return new (t || NumberPipe)(ɵngcc0.ɵɵdirectiveInject(IntlService)); };
NumberPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "kendoNumber", type: NumberPipe, pure: true });
NumberPipe = __decorate([ __metadata("design:paramtypes", [IntlService])
], NumberPipe);

const pipes = [
    DatePipe,
    NumberPipe
];
/**
 * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }}docs/ts/latest/guide/ngmodule.html)
 * definition for the Intl services.
 */
let IntlModule = class IntlModule {
};
IntlModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IntlModule });
IntlModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IntlModule_Factory(t) { return new (t || IntlModule)(); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IntlService, [{
        type: Injectable,
        args: [{
                providedIn: 'root',
                useFactory: cldrServiceFactory,
                deps: [LOCALE_ID]
            }]
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CldrIntlService, [{
        type: Injectable
    }], function () { return [{ type: String, decorators: [{
                type: Inject,
                args: [LOCALE_ID]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DatePipe, [{
        type: Pipe,
        args: [{
                name: 'kendoDate'
            }]
    }], function () { return [{ type: IntlService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NumberPipe, [{
        type: Pipe,
        args: [{
                name: 'kendoNumber'
            }]
    }], function () { return [{ type: IntlService }]; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IntlModule, { declarations: [DatePipe, NumberPipe], exports: [DatePipe, NumberPipe] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IntlModule, [{
        type: NgModule,
        args: [{
                declarations: [pipes],
                exports: [pipes]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { cldrServiceFactory, IntlService, CldrIntlService, DatePipe, ɵ0, NumberPipe, IntlModule, dateFormatNames$1 as dateFormatNames, dateFieldName$1 as dateFieldName, firstDay$1 as firstDay, format$1 as format, formatDate$1 as formatDate, formatNumber$1 as formatNumber, load$1 as load, numberSymbols$1 as numberSymbols, parseDate$1 as parseDate, parseNumber$1 as parseNumber, splitDateFormat$1 as splitDateFormat, toString$1 as toString, weekendRange$1 as weekendRange, setData$1 as setData, localeData };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozt5Q0FBRTtBQUNGO0FBQ0EsMEJBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7eUlBQUU7QUFDRiw4QkFFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7d0ZBQUU7QUFDRix1QkFJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OEZBQUU7QUFDRix5QkFJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQU1lO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiLyoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiogQ29weXJpZ2h0IMKpIDIwMjAgUHJvZ3Jlc3MgU29mdHdhcmUgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qIExpY2Vuc2VkIHVuZGVyIGNvbW1lcmNpYWwgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbW9yZSBpbmZvcm1hdGlvblxuKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgX19kZWNvcmF0ZSwgX19tZXRhZGF0YSwgX19wYXJhbSB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciwgybXJtWRlZmluZUluamVjdGFibGUsIMm1ybVpbmplY3QsIExPQ0FMRV9JRCwgSW5qZWN0YWJsZSwgSW5qZWN0LCBQaXBlLCBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgdmFsaWRhdGVQYWNrYWdlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWxpY2Vuc2luZyc7XG5pbXBvcnQgeyBkYXRlRm9ybWF0TmFtZXMsIGRhdGVGaWVsZE5hbWUsIGZpcnN0RGF5LCBmb3JtYXQsIGZvcm1hdERhdGUsIGZvcm1hdE51bWJlciwgbG9hZCwgbnVtYmVyU3ltYm9scywgcGFyc2VEYXRlLCBwYXJzZU51bWJlciwgc3BsaXREYXRlRm9ybWF0LCB0b1N0cmluZywgd2Vla2VuZFJhbmdlLCBzZXREYXRhLCBsb2NhbGVJbmZvIH0gZnJvbSAnQHRlbGVyaWsva2VuZG8taW50bCc7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBwYWNrYWdlTWV0YWRhdGEgPSB7XG4gICAgbmFtZTogJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWludGwnLFxuICAgIHByb2R1Y3ROYW1lOiAnS2VuZG8gVUkgZm9yIEFuZ3VsYXInLFxuICAgIHByb2R1Y3RDb2RlczogWydLRU5ET1VJQU5HVUxBUicsICdLRU5ET1VJQ09NUExFVEUnXSxcbiAgICBwdWJsaXNoRGF0ZTogMTYyMDIxMzM0NCxcbiAgICB2ZXJzaW9uOiAnJyxcbiAgICBsaWNlbnNpbmdEb2NzVXJsOiAnaHR0cHM6Ly93d3cudGVsZXJpay5jb20va2VuZG8tYW5ndWxhci11aS9teS1saWNlbnNlLz91dG1fbWVkaXVtPXByb2R1Y3QmdXRtX3NvdXJjZT1rZW5kb2FuZ3VsYXImdXRtX2NhbXBhaWduPWtlbmRvLXVpLWFuZ3VsYXItcHVyY2hhc2UtbGljZW5zZS1rZXlzLXdhcm5pbmcnXG59O1xuXG5jb25zdCBET0NTX1VSTCA9ICdodHRwOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvY29tcG9uZW50cy9pbnRlcm5hdGlvbmFsaXphdGlvbi90cm91Ymxlc2hvb3RpbmcvJztcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBlcnJvclNvbHV0aW9ucyA9IHtcbiAgICAnTm9DdXJyZW5jeSc6IGBTb2x1dGlvbjogJHtET0NTX1VSTH0jdG9jLW5vLWN1cnJlbmN5YCxcbiAgICAnTm9DdXJyZW5jeURpc3BsYXknOiBgU29sdXRpb246ICR7RE9DU19VUkx9I3RvYy1uby1jdXJyZW5jeS1kaXNwbGF5YCxcbiAgICAnTm9DdXJyZW5jeVJlZ2lvbic6IGBTb2x1dGlvbjogJHtET0NTX1VSTH0jdG9jLW5vLWN1cnJlbmN5LXJlZ2lvbmAsXG4gICAgJ05vRGF0ZUZpZWxkTmFtZXMnOiBgU29sdXRpb246ICR7RE9DU19VUkx9I3RvYy1uby1kYXRlLWZpbGVkLW5hbWVzYCxcbiAgICAnTm9GaXJzdERheSc6IGBTb2x1dGlvbjogJHtET0NTX1VSTH0jdG9jLW5vLWZpcnN0LWRheWAsXG4gICAgJ05vR01USW5mbyc6IGBTb2x1dGlvbjogJHtET0NTX1VSTH0jdG9jLW5vLWdtdC1pbmZvYCxcbiAgICAnTm9Mb2NhbGUnOiBgU29sdXRpb246ICR7RE9DU19VUkx9I3RvYy1uby1sb2NhbGVgLFxuICAgICdOb1ZhbGlkQ3VycmVuY3knOiBgU29sdXRpb246ICR7RE9DU19VUkx9I3RvYy1uby12YWxpZC1jdXJyZW5jeWAsXG4gICAgJ05vV2Vla0RhdGEnOiBgU29sdXRpb246ICR7RE9DU19VUkx9I3RvYy1uby13ZWVrLWRhdGFgXG59O1xuXG5mdW5jdGlvbiBmb3JtYXRNZXNzYWdlKGVycm9yKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgY29uc3QgZXJyb3JTb2x1dGlvbiA9IGVycm9yU29sdXRpb25zW09iamVjdC5rZXlzKGVycm9yU29sdXRpb25zKS5maWx0ZXIoa2V5ID0+IG1lc3NhZ2UuaW5kZXhPZihrZXkpID09PSAwKVswXV07XG4gICAgcmV0dXJuIGVycm9yU29sdXRpb24gPyBgJHttZXNzYWdlfSAke2Vycm9yU29sdXRpb259YCA6IG1lc3NhZ2U7XG59XG5mdW5jdGlvbiBpbnRsTWV0aG9kKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi52YWx1ZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCB2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9IGZvcm1hdE1lc3NhZ2UoZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGRhdGVGb3JtYXROYW1lcyQxID0gaW50bE1ldGhvZChkYXRlRm9ybWF0TmFtZXMpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGRhdGVGaWVsZE5hbWUkMSA9IGludGxNZXRob2QoZGF0ZUZpZWxkTmFtZSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZmlyc3REYXkkMSA9IGludGxNZXRob2QoZmlyc3REYXkpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGZvcm1hdCQxID0gaW50bE1ldGhvZChmb3JtYXQpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGZvcm1hdERhdGUkMSA9IGludGxNZXRob2QoZm9ybWF0RGF0ZSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZm9ybWF0TnVtYmVyJDEgPSBpbnRsTWV0aG9kKGZvcm1hdE51bWJlcik7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgbG9hZCQxID0gaW50bE1ldGhvZChsb2FkKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBudW1iZXJTeW1ib2xzJDEgPSBpbnRsTWV0aG9kKG51bWJlclN5bWJvbHMpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHBhcnNlRGF0ZSQxID0gaW50bE1ldGhvZChwYXJzZURhdGUpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHBhcnNlTnVtYmVyJDEgPSBpbnRsTWV0aG9kKHBhcnNlTnVtYmVyKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBzcGxpdERhdGVGb3JtYXQkMSA9IGludGxNZXRob2Qoc3BsaXREYXRlRm9ybWF0KTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCB0b1N0cmluZyQxID0gaW50bE1ldGhvZCh0b1N0cmluZyk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgd2Vla2VuZFJhbmdlJDEgPSBpbnRsTWV0aG9kKHdlZWtlbmRSYW5nZSk7XG4vKipcbiAqIFNldHMgYSBwcmUtYnVpbHQgbG9jYWxlLlxuICpcbiAqIEBwYXJhbXMgZGF0YSAtIFRoZSBwcmUtYnVpbHQgbG9jYWxlIGRhdGEuXG4gKi9cbmNvbnN0IHNldERhdGEkMSA9IChkYXRhKSA9PiBzZXREYXRhKGRhdGEpO1xuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGxvY2FsZSBkYXRhIGZvciB0aGUgc3BlY2lmaWVkIGxvY2FsZS5cbiAqXG4gKiBAcGFyYW1zIGxvY2FsZSAtIFRoZSBsb2NhbGUgaWQuXG4gKiBAcmV0dXJucyBkYXRhIC0gVGhlIGxvY2FsZSBkYXRhLlxuICovXG5jb25zdCBsb2NhbGVEYXRhID0gKGxvY2FsZSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBsb2NhbGVJbmZvKGxvY2FsZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBlcnJvci5tZXNzYWdlID0gZm9ybWF0TWVzc2FnZShlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn07XG5cbmNvbnN0IExPQ0FMRV9SRUdFWCA9IC9fL2c7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gY2xkclNlcnZpY2VGYWN0b3J5KGxvY2FsZUlkKSB7XG4gICAgcmV0dXJuIG5ldyBDbGRySW50bFNlcnZpY2UobG9jYWxlSWQpO1xufVxuLyoqXG4gKiBBbiBhYnN0cmFjdCBiYXNlIGNsYXNzIHRoYXQgaW1wbGVtZW50c1xuICogdGhlIEludGVybmF0aW9uYWxpemF0aW9uIHNlcnZpY2UgbWV0aG9kc1xuICogZm9yIHRoZSBjdXJyZW50IGxvY2FsZS5cbiAqL1xubGV0IEludGxTZXJ2aWNlID0gY2xhc3MgSW50bFNlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdmFsaWRhdGVQYWNrYWdlKHBhY2thZ2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vdGlmaWVzIHRoYXQgdGhlIHNlcnZpY2Ugd2FzIGNoYW5nZWQuXG4gICAgICovXG4gICAgbm90aWZ5KCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMuZW1pdCgpO1xuICAgIH1cbn07XG5JbnRsU2VydmljZS5uZ0luamVjdGFibGVEZWYgPSDJtcm1ZGVmaW5lSW5qZWN0YWJsZSh7IGZhY3Rvcnk6IGZ1bmN0aW9uIEludGxTZXJ2aWNlX0ZhY3RvcnkoKSB7IHJldHVybiBjbGRyU2VydmljZUZhY3RvcnkoybXJtWluamVjdChMT0NBTEVfSUQpKTsgfSwgdG9rZW46IEludGxTZXJ2aWNlLCBwcm92aWRlZEluOiBcInJvb3RcIiB9KTtcbkludGxTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSh7XG4gICAgICAgIHByb3ZpZGVkSW46ICdyb290JyxcbiAgICAgICAgdXNlRmFjdG9yeTogY2xkclNlcnZpY2VGYWN0b3J5LFxuICAgICAgICBkZXBzOiBbTE9DQUxFX0lEXVxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIEludGxTZXJ2aWNlKTtcbi8qKlxuICogVGhlIEludGVybmF0aW9uYWxpemF0aW9uIHNlcnZpY2UgaW1wbGVtZW50ZWQgYnkgdXNpbmdcbiAqIHRoZSBDTERSIERhdGFiYXNlIHZpYSB0aGUgYEB0ZWxlcmlrL2tlbmRvLWludGxgIHBhY2thZ2UuXG4gKi9cbmxldCBDbGRySW50bFNlcnZpY2UgPSBjbGFzcyBDbGRySW50bFNlcnZpY2UgZXh0ZW5kcyBJbnRsU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgc2VydmljZSB3aXRoIHRoZSBJRCBvZiB0aGUgc3BlY2lmaWVkIGxvY2FsZS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGUgcGFydHMgb2YgdGhlIGxvY2FsZSBJRCBjYW4gYmUgc2VwYXJhdGVkIGJ5IGVpdGhlciBgX2AgKHVuZGVyc2NvcmUpXG4gICAgICogb3IgYC1gIChkYXNoKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBkZWZhdWx0IGxvY2FsZSBJRC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGVJZCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxvY2FsZUlkID0gbG9jYWxlSWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgY3VycmVudCBsb2NhbGUgSUQuXG4gICAgICovXG4gICAgZ2V0IGxvY2FsZUlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGU7XG4gICAgfVxuICAgIHNldCBsb2NhbGVJZCh2YWx1ZSkge1xuICAgICAgICAvLyBBbmd1bGFyIGxvY2FsZXMgdXNlIHVuZGVyc2NvcmUsIGZvciBleGFtcGxlLCBlbl9VU1xuICAgICAgICAvLyB3aGlsZSBJRVRGIEJDUC00NyBzcGVjaWZpZXMgYSBkYXNoLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvYmNwNDdcbiAgICAgICAgY29uc3QgbG9jYWxlID0gdmFsdWUucmVwbGFjZShMT0NBTEVfUkVHRVgsICctJyk7XG4gICAgICAgIGlmIChsb2NhbGUgIT09IHRoaXMubG9jYWxlKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZTtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9ybWF0cyBhIHN0cmluZyB3aXRoIHBsYWNlaG9sZGVycyBzdWNoIGFzXG4gICAgICogYFRvdGFsIGFtb3VudCB7MDpjfWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCBzdHJpbmcuXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIE9uZSBvciBtb3JlIHZhbHVlcyB0byBvdXRwdXQgaW4gdGhlIGZvcm1hdCBzdHJpbmcgcGxhY2Vob2xkZXJzLlxuICAgICAqIEByZXR1cm4gLSBUaGUgZm9ybWF0dGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBmb3JtYXQoZm9ybWF0JCQxLCAuLi52YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdCQxKGZvcm1hdCQkMSwgdmFsdWVzLCB0aGlzLmxvY2FsZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gb2JqZWN0IGludG8gYSBzdHJpbmcgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZm9ybWF0LlxuICAgICAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgbG9jYWxlIElEIHRvIHVzZSBpbiBwbGFjZSBvZiB0aGUgZGVmYXVsdCBvbmUuIE9wdGlvbmFsLlxuICAgICAqIEByZXR1cm4gVGhlIGZvcm1hdHRlZCBvYmplY3QuXG4gICAgICovXG4gICAgdG9TdHJpbmcodmFsdWUsIGZvcm1hdCQkMSwgbG9jYWxlSWQpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nJDEodmFsdWUsIGZvcm1hdCQkMSwgbG9jYWxlSWQgfHwgdGhpcy5sb2NhbGVJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgYERhdGVgIG9iamVjdCBpbnRvIGEgc3RyaW5nIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgZm9ybWF0LlxuICAgICAqIElmIG5vIGZvcm1hdCBpcyBwcm92aWRlZCwgdGhlIGRlZmF1bHQgc2hvcnQgZGF0ZSBmb3JtYXQgaXMgdXNlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBkYXRlIHRvIGZvcm1hdC5cbiAgICAgKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCBzdHJpbmcgb3Igb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgbG9jYWxlIElEIHRvIHVzZSBpbiBwbGFjZSBvZiB0aGUgZGVmYXVsdCBvbmUuIE9wdGlvbmFsLlxuICAgICAqIEByZXR1cm4gVGhlIGZvcm1hdHRlZCBkYXRlLlxuICAgICAqL1xuICAgIGZvcm1hdERhdGUodmFsdWUsIGZvcm1hdCQkMSwgbG9jYWxlSWQpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdERhdGUkMSh2YWx1ZSwgZm9ybWF0JCQxLCBsb2NhbGVJZCB8fCB0aGlzLmxvY2FsZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBzdHJpbmcgaW50byBhIGBEYXRlYCBvYmplY3QgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIGZvcm1hdCAtIFRoZSBmb3JtYXQgc3RyaW5ncyBvciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0IG9uZS4gT3B0aW9uYWwuXG4gICAgICogQHJldHVybiBUaGUgcGFyc2VkIGRhdGUuXG4gICAgICovXG4gICAgcGFyc2VEYXRlKHZhbHVlLCBmb3JtYXQkJDEsIGxvY2FsZUlkKSB7XG4gICAgICAgIHJldHVybiBwYXJzZURhdGUkMSh2YWx1ZSwgZm9ybWF0JCQxLCBsb2NhbGVJZCB8fCB0aGlzLmxvY2FsZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBzdHJpbmcgaW50byBhIGBOdW1iZXJgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IHN0cmluZyBvciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0IG9uZS4gT3B0aW9uYWwuXG4gICAgICogQHJldHVybiBUaGUgcGFyc2VkIG51bWJlci5cbiAgICAgKi9cbiAgICBwYXJzZU51bWJlcih2YWx1ZSwgZm9ybWF0JCQxLCBsb2NhbGVJZCkge1xuICAgICAgICByZXR1cm4gcGFyc2VOdW1iZXIkMSh2YWx1ZSwgbG9jYWxlSWQgfHwgdGhpcy5sb2NhbGVJZCwgZm9ybWF0JCQxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBgTnVtYmVyYCBpbnRvIGEgc3RyaW5nIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgZm9ybWF0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIG51bWJlciB0byBmb3JtYXQuXG4gICAgICogQHBhcmFtIGZvcm1hdCAtIFRoZSBmb3JtYXQgc3RyaW5nIG9yIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIC0gVGhlIGxvY2FsZSBJRCB0byB1c2UgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgb25lLiBPcHRpb25hbC5cbiAgICAgKiBAcmV0dXJuIFRoZSBmb3JtYXR0ZWQgbnVtYmVyLlxuICAgICAqL1xuICAgIGZvcm1hdE51bWJlcih2YWx1ZSwgZm9ybWF0JCQxLCBsb2NhbGVJZCkge1xuICAgICAgICByZXR1cm4gZm9ybWF0TnVtYmVyJDEodmFsdWUsIGZvcm1hdCQkMSwgbG9jYWxlSWQgfHwgdGhpcy5sb2NhbGVJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRhdGUgbmFtZXMgZnJvbSB0aGUgY3VycmVudCBsb2NhbGUgYmFzZWQgb24gdGhlIG9wdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZSBhdmFpbGFibGUgYHR5cGVgIHZhbHVlcyBhcmU6XG4gICAgICogLSBgZXJhYFxuICAgICAqIC0gYHllYXJgXG4gICAgICogLSBgcXVhcnRlcmBcbiAgICAgKiAtIGBtb250aGBcbiAgICAgKiAtIGB3ZWVrYFxuICAgICAqIC0gYGRheWBcbiAgICAgKiAtIGBkYXlwZXJpb2RgXG4gICAgICogLSBgaG91cmBcbiAgICAgKiAtIGBtaW51dGVgXG4gICAgICogLSBgc2Vjb25kYFxuICAgICAqIC0gYHpvbmVgXG4gICAgICpcbiAgICAgKiBUaGUgYXZhaWxhYmxlIGBuYW1lVHlwZWAgdmFsdWVzIGFyZTpcbiAgICAgKiAtIGB3aWRlYFxuICAgICAqIC0gYG5hcnJvd2BcbiAgICAgKiAtIGBzaG9ydGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gRGV0YWlsZWQgY29uZmlndXJhdGlvbiBmb3IgdGhlIGRlc2lyZWQgZGF0ZSBmaWVsZCBuYW1lLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0IG9uZS4gT3B0aW9uYWwuXG4gICAgICogQHJldHVybiAtIFRoZSBkYXkgbmFtZXMgZnJvbSB0aGUgY3VycmVudCBsb2NhbGUgYmFzZWQgb24gdGhlIG9wdGlvbi5cbiAgICAgKiBAcmV0dXJucyBUaGUgbG9jYWxpemVkIGRhdGUgZmllbGQgbmFtZSBmcm9tIHRoZSBjdXJyZW50IGxvY2FsZSBiYXNlZCBvbiB0aGUgb3B0aW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBcbiAgICAgKiBkYXRlRmllbGROYW1lKHsgdHlwZTogJ2RheScgfSk7ICAgICAgICAgICAgICAgICAgICAgIC8vcmV0dXJucyAnZGF5JztcbiAgICAgKiBkYXRlRmllbGROYW1lKHsgdHlwZTogJ2RheScsIG5hbWVUeXBlOiAnd2lkZScgfSk7ICAgIC8vcmV0dXJucyAnZGF5JztcbiAgICAgKiBkYXRlRmllbGROYW1lKHsgdHlwZTogJ21vbnRoJywgbmFtZVR5cGU6ICdzaG9ydCcgfSk7IC8vcmV0dXJucyAnbW8uJztcbiAgICAgKiBkYXRlRmllbGROYW1lKHsgdHlwZTogJ21vbnRoJywgbmFtZVR5cGU6ICd3aWRlJyB9KTsgIC8vcmV0dXJucyAnbW9udGgnO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGRhdGVGaWVsZE5hbWUob3B0aW9ucywgbG9jYWxlSWQpIHtcbiAgICAgICAgcmV0dXJuIGRhdGVGaWVsZE5hbWUkMShvcHRpb25zLCBsb2NhbGVJZCB8fCB0aGlzLmxvY2FsZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxvY2FsaXplZCBkYXRlIGZpZWxkIG5hbWUgYmFzZWQgb24gc3BlY2lmaWMgZGF0ZUZpZWxkTmFtZSBvcHRpb25zLlxuICAgICAqXG4gICAgICogVGhlIGF2YWlsYWJsZSB0eXBlIHZhbHVlcyBhcmU6XG4gICAgICogLSBgZGF5YFxuICAgICAqIC0gYGRheXBlcmlvZGBcbiAgICAgKiAtIGBtb250aHNgXG4gICAgICogLSBgcXVhcnRlcnNgXG4gICAgICogLSBgZXJhc2BcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gRGV0YWlsZWQgY29uZmlndXJhdGlvbiBmb3IgdGhlIGRlc2lyZWQgZGF0ZSBmb3JtYXQuXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIC0gVGhlIGxvY2FsZSBJRCB0byB1c2UgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgb25lLiBPcHRpb25hbC5cbiAgICAgKiBAcmV0dXJuIC0gVGhlIGRheSBuYW1lcyBmcm9tIHRoZSBjdXJyZW50IGxvY2FsZSBiYXNlZCBvbiB0aGUgb3B0aW9uLlxuICAgICAqL1xuICAgIGRhdGVGb3JtYXROYW1lcyhvcHRpb25zLCBsb2NhbGVJZCkge1xuICAgICAgICByZXR1cm4gZGF0ZUZvcm1hdE5hbWVzJDEobG9jYWxlSWQgfHwgdGhpcy5sb2NhbGVJZCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNwbGl0cyB0aGUgZGF0ZSBmb3JtYXQgaW50byBvYmplY3RzIGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgZWFjaCBwYXJ0IG9mIHRoZSBwYXR0ZXJuLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZvcm1hdCBUaGUgZm9ybWF0IHN0cmluZyBvciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCBUaGUgb3B0aW9uYWwgbG9jYWxlIGlkLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgYFwiZW5cImAgbG9jYWxlIGlkIGlzIHVzZWQuXG4gICAgICogQHJldHVybnMgVGhlIGRhdGUgZm9ybWF0IHBhcnRzLlxuICAgICAqL1xuICAgIHNwbGl0RGF0ZUZvcm1hdChmb3JtYXQkJDEsIGxvY2FsZUlkKSB7XG4gICAgICAgIHJldHVybiBzcGxpdERhdGVGb3JtYXQkMShmb3JtYXQkJDEsIGxvY2FsZUlkIHx8IHRoaXMubG9jYWxlSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgc3ltYm9scyBmcm9tIHRoZSBjdXJyZW50IGxvY2FsZSBiYXNlZCBvbiB0aGUgb3B0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIC0gVGhlIGxvY2FsZSBJRCB0byB1c2UgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgb25lLiBPcHRpb25hbC5cbiAgICAgKiBAcmV0dXJuIC0gVGhlIG51bWJlciBzeW1ib2xzIGZyb20gdGhlIGN1cnJlbnQgbG9jYWxlLlxuICAgICAqL1xuICAgIG51bWJlclN5bWJvbHMobG9jYWxlSWQpIHtcbiAgICAgICAgcmV0dXJuIG51bWJlclN5bWJvbHMkMShsb2NhbGVJZCB8fCB0aGlzLmxvY2FsZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgZGF5IGluZGV4IHN0YXJ0aW5nIGZyb20gU3VuZGF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIC0gVGhlIGxvY2FsZSBJRC4gRGVmYXVsdHMgdG8gdGhlIGN1cnJlbnQgbG9jYWxlIElELlxuICAgICAqIEByZXR1cm4gLSBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlayAoMCA9PSBTdW5kYXkpLlxuICAgICAqL1xuICAgIGZpcnN0RGF5KGxvY2FsZUlkKSB7XG4gICAgICAgIHJldHVybiBmaXJzdERheSQxKGxvY2FsZUlkIHx8IHRoaXMubG9jYWxlSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdGFydCBhbmQgZW5kIGluZGV4IG9mIHRoZSBsb2NhbGUgd2Vla2VuZCBzdGFydGluZyBmcm9tIFN1bmRheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQuIERlZmF1bHRzIHRvIHRoZSBjdXJyZW50IGxvY2FsZSBJRC5cbiAgICAgKiBAcmV0dXJuIC0gVGhlIHRoZSBzdGFydCBhbmQgZW5kIGluZGV4IG9mIHRoZSBsb2NhbGUgd2Vla2VuZCAoMCA9PSBTdW5kYXkpLlxuICAgICAqL1xuICAgIHdlZWtlbmRSYW5nZShsb2NhbGVJZCkge1xuICAgICAgICByZXR1cm4gd2Vla2VuZFJhbmdlJDEobG9jYWxlSWQgfHwgdGhpcy5sb2NhbGVJZCk7XG4gICAgfVxufTtcbkNsZHJJbnRsU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX3BhcmFtKDAsIEluamVjdChMT0NBTEVfSUQpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBDbGRySW50bFNlcnZpY2UpO1xuXG5jb25zdCBpc051bWVyaWMgPSAodmFsdWUpID0+ICFpc05hTih2YWx1ZSAtIHBhcnNlRmxvYXQodmFsdWUpKTtcbmNvbnN0IMm1MCA9IGlzTnVtZXJpYztcbi8qKlxuICogRm9ybWF0cyBhIGRhdGUgdmFsdWUgdG8gYSBzdHJpbmcgYmFzZWQgb24gdGhlIHJlcXVlc3RlZCBmb3JtYXQuXG4gKiBUaGlzIHBpcGUgdXNlcyB0aGUgW0ludGxTZXJ2aWNlXSh7JSBzbHVnIGFwaV9pbnRsX2ludGxzZXJ2aWNlICV9KS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgbmctdGVtcGxhdGUtbm8tcnVuXG4gKiA8dWw+XG4gKiAgICA8bGk+e3tkYXRlIHwga2VuZG9EYXRlIH19PC9saT5cbiAqICAgIDxsaT57e21pbGxpc2Vjb25kcyB8IGtlbmRvRGF0ZTogJ00vZGQveXl5JyB9fTwvbGk+XG4gKiAgICA8bGk+e3tzdHJpbmdEYXRlIHwga2VuZG9EYXRlOiAnRycgfX08L2xpPlxuICogPC91bD5cbiAqIGBgYFxuICovXG5sZXQgRGF0ZVBpcGUgPSBjbGFzcyBEYXRlUGlwZSB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGludGxTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuaW50bFNlcnZpY2UgPSBpbnRsU2VydmljZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBgRGF0ZWAgb2JqZWN0IGludG8gYSBzdHJpbmcgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBmb3JtYXQuXG4gICAgICogSWYgbm8gZm9ybWF0IGlzIHByb3ZpZGVkLCB0aGUgZGVmYXVsdCBzaG9ydCBkYXRlIGZvcm1hdCBpcyB1c2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIGRhdGUgdG8gZm9ybWF0LlxuICAgICAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IHN0cmluZyBvciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIChPcHRpb25hbCkgVGhlIElEIG9mIHRoZSBsb2NhbGUgd2hpY2ggd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgb25lLlxuICAgICAqIEByZXR1cm4gLSBUaGUgZm9ybWF0dGVkIGRhdGUuXG4gICAgICovXG4gICAgdHJhbnNmb3JtKHZhbHVlLCBmb3JtYXQkJDEgPSBcIlwiLCBsb2NhbGVJZCkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMubm9ybWFsaXplKHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRsU2VydmljZS5mb3JtYXREYXRlKHZhbHVlLCBmb3JtYXQkJDEsIGxvY2FsZUlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIG5vcm1hbGl6ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmludGxTZXJ2aWNlLnBhcnNlRGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgJiYgaXNOdW1lcmljKHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZShwYXJzZUZsb2F0KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn07XG5EYXRlUGlwZSA9IF9fZGVjb3JhdGUoW1xuICAgIFBpcGUoe1xuICAgICAgICBuYW1lOiAna2VuZG9EYXRlJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbSW50bFNlcnZpY2VdKVxuXSwgRGF0ZVBpcGUpO1xuXG4vKipcbiAqIEZvcm1hdHMgYSBudW1iZXIgdmFsdWUgdG8gYSBzdHJpbmcgYmFzZWQgb24gdGhlIHJlcXVlc3RlZCBmb3JtYXQuXG4gKiBUaGlzIHBpcGUgdXNlcyB0aGUgW2BJbnRsU2VydmljZWBdKHslIHNsdWcgYXBpX2ludGxfaW50bHNlcnZpY2UgJX0pLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBuZy10ZW1wbGF0ZS1uby1ydW5cbiAqICAgPHVsPlxuICogICAgIDxsaT57e2RlY2ltYWwgfCBrZW5kb051bWJlcjonYycgfX08L2xpPlxuICogICAgIDxsaT57e3N0cmluZ051bWJlciB8IGtlbmRvTnVtYmVyOidwJyB9fTwvbGk+XG4gKiAgICAgPGxpPnt7aW50IHwga2VuZG9OdW1iZXI6JyMjLjAwJyB9fTwvbGk+XG4gKiAgPC91bD5cbiAqIGBgYFxuICovXG5sZXQgTnVtYmVyUGlwZSA9IGNsYXNzIE51bWJlclBpcGUge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpbnRsU2VydmljZSkge1xuICAgICAgICB0aGlzLmludGxTZXJ2aWNlID0gaW50bFNlcnZpY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgYE51bWJlcmAgb2JqZWN0IGludG8gYSBzdHJpbmcgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBmb3JtYXQuXG4gICAgICogSWYgbm8gZm9ybWF0IGlzIHByb3ZpZGVkLCB0aGUgdmFsdWUgaXMgZm9ybWF0dGVkIGFzIGRlY2ltYWwgbnVtYmVyIHVzaW5nIHRoZVxuICAgICAqIFtgXCJuXCJgXShodHRwczovL2dpdGh1Yi5jb20vdGVsZXJpay9rZW5kby1pbnRsL2Jsb2IvbWFzdGVyL2RvY3MvbnVtLWZvcm1hdHRpbmcvaW5kZXgubWQjc3RhbmRhcmQpIGZvcm1hdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBudW1lciB0aGF0IHdpbGwgYmUgZm9ybWF0dGVkLlxuICAgICAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IHN0cmluZyBvciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIChPcHRpb25hbCkgVGhlIGxvY2FsZSBJRCB0aGF0IHdpbGwgYmUgdXNlZCBpbiBwbGFjZSBvZiB0aGUgZGVmYXVsdCBvbmUuXG4gICAgICogQHJldHVybiAtIFRoZSBmb3JtYXR0ZWQgbnVtYmVyLlxuICAgICAqL1xuICAgIHRyYW5zZm9ybSh2YWx1ZSwgZm9ybWF0JCQxLCBsb2NhbGVJZCkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmludGxTZXJ2aWNlLnBhcnNlTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50bFNlcnZpY2UuZm9ybWF0TnVtYmVyKHZhbHVlLCBmb3JtYXQkJDEsIGxvY2FsZUlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufTtcbk51bWJlclBpcGUgPSBfX2RlY29yYXRlKFtcbiAgICBQaXBlKHtcbiAgICAgICAgbmFtZTogJ2tlbmRvTnVtYmVyJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbSW50bFNlcnZpY2VdKVxuXSwgTnVtYmVyUGlwZSk7XG5cbmNvbnN0IHBpcGVzID0gW1xuICAgIERhdGVQaXBlLFxuICAgIE51bWJlclBpcGVcbl07XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtOZ01vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVhcGknXSB9fWRvY3MvdHMvbGF0ZXN0L2d1aWRlL25nbW9kdWxlLmh0bWwpXG4gKiBkZWZpbml0aW9uIGZvciB0aGUgSW50bCBzZXJ2aWNlcy5cbiAqL1xubGV0IEludGxNb2R1bGUgPSBjbGFzcyBJbnRsTW9kdWxlIHtcbn07XG5JbnRsTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBkZWNsYXJhdGlvbnM6IFtwaXBlc10sXG4gICAgICAgIGV4cG9ydHM6IFtwaXBlc11cbiAgICB9KVxuXSwgSW50bE1vZHVsZSk7XG5cbi8qKlxuICogR2VuZXJhdGVkIGJ1bmRsZSBpbmRleC4gRG8gbm90IGVkaXQuXG4gKi9cblxuZXhwb3J0IHsgY2xkclNlcnZpY2VGYWN0b3J5LCBJbnRsU2VydmljZSwgQ2xkckludGxTZXJ2aWNlLCBEYXRlUGlwZSwgybUwLCBOdW1iZXJQaXBlLCBJbnRsTW9kdWxlLCBkYXRlRm9ybWF0TmFtZXMkMSBhcyBkYXRlRm9ybWF0TmFtZXMsIGRhdGVGaWVsZE5hbWUkMSBhcyBkYXRlRmllbGROYW1lLCBmaXJzdERheSQxIGFzIGZpcnN0RGF5LCBmb3JtYXQkMSBhcyBmb3JtYXQsIGZvcm1hdERhdGUkMSBhcyBmb3JtYXREYXRlLCBmb3JtYXROdW1iZXIkMSBhcyBmb3JtYXROdW1iZXIsIGxvYWQkMSBhcyBsb2FkLCBudW1iZXJTeW1ib2xzJDEgYXMgbnVtYmVyU3ltYm9scywgcGFyc2VEYXRlJDEgYXMgcGFyc2VEYXRlLCBwYXJzZU51bWJlciQxIGFzIHBhcnNlTnVtYmVyLCBzcGxpdERhdGVGb3JtYXQkMSBhcyBzcGxpdERhdGVGb3JtYXQsIHRvU3RyaW5nJDEgYXMgdG9TdHJpbmcsIHdlZWtlbmRSYW5nZSQxIGFzIHdlZWtlbmRSYW5nZSwgc2V0RGF0YSQxIGFzIHNldERhdGEsIGxvY2FsZURhdGEgfTtcbiJdfQ==