{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{XhcP:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return sidenav_MatSidenav}),__webpack_require__.d(__webpack_exports__,\"b\",function(){return sidenav_MatSidenavContainer}),__webpack_require__.d(__webpack_exports__,\"c\",function(){return sidenav_MatSidenavContent}),__webpack_require__.d(__webpack_exports__,\"d\",function(){return sidenav_MatSidenavModule});var platform=__webpack_require__(\"nLfN\"),scrolling=__webpack_require__(\"vxfF\"),common=__webpack_require__(\"ofXK\"),core=__webpack_require__(\"fXoL\"),fesm2015_core=__webpack_require__(\"FKr1\"),coercion=__webpack_require__(\"8LU1\"),keycodes=__webpack_require__(\"FtGj\"),Subject=__webpack_require__(\"XNiG\"),fromEvent=__webpack_require__(\"xgIS\"),merge=__webpack_require__(\"VRyK\"),filter=__webpack_require__(\"pLZG\"),map=__webpack_require__(\"lJxs\"),Subscriber=__webpack_require__(\"7o/Q\");function mapTo(value){return source=>source.lift(new MapToOperator(value))}class MapToOperator{constructor(value){this.value=value}call(subscriber,source){return source.subscribe(new mapTo_MapToSubscriber(subscriber,this.value))}}class mapTo_MapToSubscriber extends Subscriber.a{constructor(destination,value){super(destination),this.value=value}_next(x){this.destination.next(this.value)}}var takeUntil=__webpack_require__(\"1G5W\"),distinctUntilChanged=__webpack_require__(\"/uUt\"),take=__webpack_require__(\"IzEk\"),startWith=__webpack_require__(\"JX91\"),debounceTime=__webpack_require__(\"Kj3r\"),animations=__webpack_require__(\"R0Ic\"),fesm2015_animations=__webpack_require__(\"R1ws\"),a11y=__webpack_require__(\"u47x\"),bidi=__webpack_require__(\"cH1L\");const _c0=[\"*\"];function MatDrawerContainer_div_0_Template(rf,ctx){if(1&rf){const _r3=core.Wb();core.Vb(0,\"div\",2),core.gc(\"click\",function(){return core.Ac(_r3),core.kc()._onBackdropClicked()}),core.Ub()}if(2&rf){const ctx_r0=core.kc();core.Hb(\"mat-drawer-shown\",ctx_r0._isShowingBackdrop())}}function MatDrawerContainer_mat_drawer_content_3_Template(rf,ctx){1&rf&&(core.Vb(0,\"mat-drawer-content\"),core.nc(1,2),core.Ub())}const _c1=[[[\"mat-drawer\"]],[[\"mat-drawer-content\"]],\"*\"],_c2=[\"mat-drawer\",\"mat-drawer-content\",\"*\"];function MatSidenavContainer_div_0_Template(rf,ctx){if(1&rf){const _r3=core.Wb();core.Vb(0,\"div\",2),core.gc(\"click\",function(){return core.Ac(_r3),core.kc()._onBackdropClicked()}),core.Ub()}if(2&rf){const ctx_r0=core.kc();core.Hb(\"mat-drawer-shown\",ctx_r0._isShowingBackdrop())}}function MatSidenavContainer_mat_sidenav_content_3_Template(rf,ctx){1&rf&&(core.Vb(0,\"mat-sidenav-content\",3),core.nc(1,2),core.Ub())}const _c3=[[[\"mat-sidenav\"]],[[\"mat-sidenav-content\"]],\"*\"],_c4=[\"mat-sidenav\",\"mat-sidenav-content\",\"*\"],_c5=\".mat-drawer-container{position:relative;z-index:1;box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}.cdk-high-contrast-active .mat-drawer-backdrop{opacity:.5}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}.cdk-high-contrast-active .mat-drawer,.cdk-high-contrast-active [dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}.cdk-high-contrast-active [dir=rtl] .mat-drawer,.cdk-high-contrast-active .mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer{transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch}.mat-sidenav-fixed{position:fixed}\\n\",matDrawerAnimations={transformDrawer:Object(animations.m)(\"transform\",[Object(animations.j)(\"open, open-instant\",Object(animations.k)({transform:\"none\",visibility:\"visible\"})),Object(animations.j)(\"void\",Object(animations.k)({\"box-shadow\":\"none\",visibility:\"hidden\"})),Object(animations.l)(\"void => open-instant\",Object(animations.e)(\"0ms\")),Object(animations.l)(\"void <=> open, open-instant => void\",Object(animations.e)(\"400ms cubic-bezier(0.25, 0.8, 0.25, 1)\"))])},MAT_DRAWER_DEFAULT_AUTOSIZE=new core.s(\"MAT_DRAWER_DEFAULT_AUTOSIZE\",{providedIn:\"root\",factory:function(){return!1}}),MAT_DRAWER_CONTAINER=new core.s(\"MAT_DRAWER_CONTAINER\");let sidenav_MatDrawerContent=(()=>{class MatDrawerContent extends scrolling.a{constructor(_changeDetectorRef,_container,elementRef,scrollDispatcher,ngZone){super(elementRef,scrollDispatcher,ngZone),this._changeDetectorRef=_changeDetectorRef,this._container=_container}ngAfterContentInit(){this._container._contentMarginChanges.subscribe(()=>{this._changeDetectorRef.markForCheck()})}}return MatDrawerContent.ɵfac=function(t){return new(t||MatDrawerContent)(core.Pb(core.h),core.Pb(Object(core.W)(()=>sidenav_MatDrawerContainer)),core.Pb(core.l),core.Pb(scrolling.c),core.Pb(core.B))},MatDrawerContent.ɵcmp=core.Jb({type:MatDrawerContent,selectors:[[\"mat-drawer-content\"]],hostAttrs:[1,\"mat-drawer-content\"],hostVars:4,hostBindings:function(rf,ctx){2&rf&&core.Hc(\"margin-left\",ctx._container._contentMargins.left,\"px\")(\"margin-right\",ctx._container._contentMargins.right,\"px\")},features:[core.zb],ngContentSelectors:_c0,decls:1,vars:0,template:function(rf,ctx){1&rf&&(core.oc(),core.nc(0))},encapsulation:2,changeDetection:0}),MatDrawerContent})(),sidenav_MatDrawer=(()=>{class MatDrawer{constructor(_elementRef,_focusTrapFactory,_focusMonitor,_platform,_ngZone,_doc,_container){this._elementRef=_elementRef,this._focusTrapFactory=_focusTrapFactory,this._focusMonitor=_focusMonitor,this._platform=_platform,this._ngZone=_ngZone,this._doc=_doc,this._container=_container,this._elementFocusedBeforeDrawerWasOpened=null,this._enableAnimations=!1,this._position=\"start\",this._mode=\"over\",this._disableClose=!1,this._opened=!1,this._animationStarted=new Subject.a,this._animationEnd=new Subject.a,this._animationState=\"void\",this.openedChange=new core.o(!0),this._openedStream=this.openedChange.pipe(Object(filter.a)(o=>o),Object(map.a)(()=>{})),this.openedStart=this._animationStarted.pipe(Object(filter.a)(e=>e.fromState!==e.toState&&0===e.toState.indexOf(\"open\")),mapTo(void 0)),this._closedStream=this.openedChange.pipe(Object(filter.a)(o=>!o),Object(map.a)(()=>{})),this.closedStart=this._animationStarted.pipe(Object(filter.a)(e=>e.fromState!==e.toState&&\"void\"===e.toState),mapTo(void 0)),this._destroyed=new Subject.a,this.onPositionChanged=new core.o,this._modeChanged=new Subject.a,this.openedChange.subscribe(opened=>{opened?(this._doc&&(this._elementFocusedBeforeDrawerWasOpened=this._doc.activeElement),this._takeFocus()):this._isFocusWithinDrawer()&&this._restoreFocus()}),this._ngZone.runOutsideAngular(()=>{Object(fromEvent.a)(this._elementRef.nativeElement,\"keydown\").pipe(Object(filter.a)(event=>event.keyCode===keycodes.h&&!this.disableClose&&!Object(keycodes.t)(event)),Object(takeUntil.a)(this._destroyed)).subscribe(event=>this._ngZone.run(()=>{this.close(),event.stopPropagation(),event.preventDefault()}))}),this._animationEnd.pipe(Object(distinctUntilChanged.a)((x,y)=>x.fromState===y.fromState&&x.toState===y.toState)).subscribe(event=>{const{fromState:fromState,toState:toState}=event;(0===toState.indexOf(\"open\")&&\"void\"===fromState||\"void\"===toState&&0===fromState.indexOf(\"open\"))&&this.openedChange.emit(this._opened)})}get position(){return this._position}set position(value){(value=\"end\"===value?\"end\":\"start\")!=this._position&&(this._position=value,this.onPositionChanged.emit())}get mode(){return this._mode}set mode(value){this._mode=value,this._updateFocusTrapState(),this._modeChanged.next()}get disableClose(){return this._disableClose}set disableClose(value){this._disableClose=Object(coercion.c)(value)}get autoFocus(){const value=this._autoFocus;return null==value?\"side\"!==this.mode:value}set autoFocus(value){this._autoFocus=Object(coercion.c)(value)}get opened(){return this._opened}set opened(value){this.toggle(Object(coercion.c)(value))}_takeFocus(){this.autoFocus&&this._focusTrap&&this._focusTrap.focusInitialElementWhenReady().then(hasMovedFocus=>{hasMovedFocus||\"function\"!=typeof this._elementRef.nativeElement.focus||this._elementRef.nativeElement.focus()})}_restoreFocus(){this.autoFocus&&(this._elementFocusedBeforeDrawerWasOpened?this._focusMonitor.focusVia(this._elementFocusedBeforeDrawerWasOpened,this._openedVia):this._elementRef.nativeElement.blur(),this._elementFocusedBeforeDrawerWasOpened=null,this._openedVia=null)}_isFocusWithinDrawer(){var _a;const activeEl=null===(_a=this._doc)||void 0===_a?void 0:_a.activeElement;return!!activeEl&&this._elementRef.nativeElement.contains(activeEl)}ngAfterContentInit(){this._focusTrap=this._focusTrapFactory.create(this._elementRef.nativeElement),this._updateFocusTrapState()}ngAfterContentChecked(){this._platform.isBrowser&&(this._enableAnimations=!0)}ngOnDestroy(){this._focusTrap&&this._focusTrap.destroy(),this._animationStarted.complete(),this._animationEnd.complete(),this._modeChanged.complete(),this._destroyed.next(),this._destroyed.complete()}open(openedVia){return this.toggle(!0,openedVia)}close(){return this.toggle(!1)}_closeViaBackdropClick(){return this._setOpen(!1,!0)}toggle(isOpen=!this.opened,openedVia){return this._setOpen(isOpen,!isOpen&&this._isFocusWithinDrawer(),openedVia)}_setOpen(isOpen,restoreFocus,openedVia=\"program\"){return this._opened=isOpen,isOpen?(this._animationState=this._enableAnimations?\"open\":\"open-instant\",this._openedVia=openedVia):(this._animationState=\"void\",restoreFocus&&this._restoreFocus()),this._updateFocusTrapState(),new Promise(resolve=>{this.openedChange.pipe(Object(take.a)(1)).subscribe(open=>resolve(open?\"open\":\"close\"))})}_getWidth(){return this._elementRef.nativeElement&&this._elementRef.nativeElement.offsetWidth||0}_updateFocusTrapState(){this._focusTrap&&(this._focusTrap.enabled=this.opened&&\"side\"!==this.mode)}_animationStartListener(event){this._animationStarted.next(event)}_animationDoneListener(event){this._animationEnd.next(event)}}return MatDrawer.ɵfac=function(t){return new(t||MatDrawer)(core.Pb(core.l),core.Pb(a11y.i),core.Pb(a11y.h),core.Pb(platform.a),core.Pb(core.B),core.Pb(common.d,8),core.Pb(MAT_DRAWER_CONTAINER,8))},MatDrawer.ɵcmp=core.Jb({type:MatDrawer,selectors:[[\"mat-drawer\"]],hostAttrs:[\"tabIndex\",\"-1\",1,\"mat-drawer\"],hostVars:12,hostBindings:function(rf,ctx){1&rf&&core.Ic(\"@transform.start\",function($event){return ctx._animationStartListener($event)})(\"@transform.done\",function($event){return ctx._animationDoneListener($event)}),2&rf&&(core.Db(\"align\",null),core.Jc(\"@transform\",ctx._animationState),core.Hb(\"mat-drawer-end\",\"end\"===ctx.position)(\"mat-drawer-over\",\"over\"===ctx.mode)(\"mat-drawer-push\",\"push\"===ctx.mode)(\"mat-drawer-side\",\"side\"===ctx.mode)(\"mat-drawer-opened\",ctx.opened))},inputs:{position:\"position\",mode:\"mode\",disableClose:\"disableClose\",autoFocus:\"autoFocus\",opened:\"opened\"},outputs:{openedChange:\"openedChange\",_openedStream:\"opened\",openedStart:\"openedStart\",_closedStream:\"closed\",closedStart:\"closedStart\",onPositionChanged:\"positionChanged\"},exportAs:[\"matDrawer\"],ngContentSelectors:_c0,decls:2,vars:0,consts:[[1,\"mat-drawer-inner-container\"]],template:function(rf,ctx){1&rf&&(core.oc(),core.Vb(0,\"div\",0),core.nc(1),core.Ub())},encapsulation:2,data:{animation:[matDrawerAnimations.transformDrawer]},changeDetection:0}),MatDrawer})(),sidenav_MatDrawerContainer=(()=>{class MatDrawerContainer{constructor(_dir,_element,_ngZone,_changeDetectorRef,viewportRuler,defaultAutosize=!1,_animationMode){this._dir=_dir,this._element=_element,this._ngZone=_ngZone,this._changeDetectorRef=_changeDetectorRef,this._animationMode=_animationMode,this._drawers=new core.F,this.backdropClick=new core.o,this._destroyed=new Subject.a,this._doCheckSubject=new Subject.a,this._contentMargins={left:null,right:null},this._contentMarginChanges=new Subject.a,_dir&&_dir.change.pipe(Object(takeUntil.a)(this._destroyed)).subscribe(()=>{this._validateDrawers(),this.updateContentMargins()}),viewportRuler.change().pipe(Object(takeUntil.a)(this._destroyed)).subscribe(()=>this.updateContentMargins()),this._autosize=defaultAutosize}get start(){return this._start}get end(){return this._end}get autosize(){return this._autosize}set autosize(value){this._autosize=Object(coercion.c)(value)}get hasBackdrop(){return null==this._backdropOverride?!this._start||\"side\"!==this._start.mode||!this._end||\"side\"!==this._end.mode:this._backdropOverride}set hasBackdrop(value){this._backdropOverride=null==value?null:Object(coercion.c)(value)}get scrollable(){return this._userContent||this._content}ngAfterContentInit(){this._allDrawers.changes.pipe(Object(startWith.a)(this._allDrawers),Object(takeUntil.a)(this._destroyed)).subscribe(drawer=>{this._drawers.reset(drawer.filter(item=>!item._container||item._container===this)),this._drawers.notifyOnChanges()}),this._drawers.changes.pipe(Object(startWith.a)(null)).subscribe(()=>{this._validateDrawers(),this._drawers.forEach(drawer=>{this._watchDrawerToggle(drawer),this._watchDrawerPosition(drawer),this._watchDrawerMode(drawer)}),(!this._drawers.length||this._isDrawerOpen(this._start)||this._isDrawerOpen(this._end))&&this.updateContentMargins(),this._changeDetectorRef.markForCheck()}),this._ngZone.runOutsideAngular(()=>{this._doCheckSubject.pipe(Object(debounceTime.a)(10),Object(takeUntil.a)(this._destroyed)).subscribe(()=>this.updateContentMargins())})}ngOnDestroy(){this._contentMarginChanges.complete(),this._doCheckSubject.complete(),this._drawers.destroy(),this._destroyed.next(),this._destroyed.complete()}open(){this._drawers.forEach(drawer=>drawer.open())}close(){this._drawers.forEach(drawer=>drawer.close())}updateContentMargins(){let left=0,right=0;if(this._left&&this._left.opened)if(\"side\"==this._left.mode)left+=this._left._getWidth();else if(\"push\"==this._left.mode){const width=this._left._getWidth();left+=width,right-=width}if(this._right&&this._right.opened)if(\"side\"==this._right.mode)right+=this._right._getWidth();else if(\"push\"==this._right.mode){const width=this._right._getWidth();right+=width,left-=width}left=left||null,right=right||null,left===this._contentMargins.left&&right===this._contentMargins.right||(this._contentMargins={left:left,right:right},this._ngZone.run(()=>this._contentMarginChanges.next(this._contentMargins)))}ngDoCheck(){this._autosize&&this._isPushed()&&this._ngZone.runOutsideAngular(()=>this._doCheckSubject.next())}_watchDrawerToggle(drawer){drawer._animationStarted.pipe(Object(filter.a)(event=>event.fromState!==event.toState),Object(takeUntil.a)(this._drawers.changes)).subscribe(event=>{\"open-instant\"!==event.toState&&\"NoopAnimations\"!==this._animationMode&&this._element.nativeElement.classList.add(\"mat-drawer-transition\"),this.updateContentMargins(),this._changeDetectorRef.markForCheck()}),\"side\"!==drawer.mode&&drawer.openedChange.pipe(Object(takeUntil.a)(this._drawers.changes)).subscribe(()=>this._setContainerClass(drawer.opened))}_watchDrawerPosition(drawer){drawer&&drawer.onPositionChanged.pipe(Object(takeUntil.a)(this._drawers.changes)).subscribe(()=>{this._ngZone.onMicrotaskEmpty.pipe(Object(take.a)(1)).subscribe(()=>{this._validateDrawers()})})}_watchDrawerMode(drawer){drawer&&drawer._modeChanged.pipe(Object(takeUntil.a)(Object(merge.a)(this._drawers.changes,this._destroyed))).subscribe(()=>{this.updateContentMargins(),this._changeDetectorRef.markForCheck()})}_setContainerClass(isAdd){const classList=this._element.nativeElement.classList,className=\"mat-drawer-container-has-open\";isAdd?classList.add(className):classList.remove(className)}_validateDrawers(){this._start=this._end=null,this._drawers.forEach(drawer=>{\"end\"==drawer.position?this._end=drawer:this._start=drawer}),this._right=this._left=null,this._dir&&\"rtl\"===this._dir.value?(this._left=this._end,this._right=this._start):(this._left=this._start,this._right=this._end)}_isPushed(){return this._isDrawerOpen(this._start)&&\"over\"!=this._start.mode||this._isDrawerOpen(this._end)&&\"over\"!=this._end.mode}_onBackdropClicked(){this.backdropClick.emit(),this._closeModalDrawersViaBackdrop()}_closeModalDrawersViaBackdrop(){[this._start,this._end].filter(drawer=>drawer&&!drawer.disableClose&&this._canHaveBackdrop(drawer)).forEach(drawer=>drawer._closeViaBackdropClick())}_isShowingBackdrop(){return this._isDrawerOpen(this._start)&&this._canHaveBackdrop(this._start)||this._isDrawerOpen(this._end)&&this._canHaveBackdrop(this._end)}_canHaveBackdrop(drawer){return\"side\"!==drawer.mode||!!this._backdropOverride}_isDrawerOpen(drawer){return null!=drawer&&drawer.opened}}return MatDrawerContainer.ɵfac=function(t){return new(t||MatDrawerContainer)(core.Pb(bidi.b,8),core.Pb(core.l),core.Pb(core.B),core.Pb(core.h),core.Pb(scrolling.e),core.Pb(MAT_DRAWER_DEFAULT_AUTOSIZE),core.Pb(fesm2015_animations.a,8))},MatDrawerContainer.ɵcmp=core.Jb({type:MatDrawerContainer,selectors:[[\"mat-drawer-container\"]],contentQueries:function(rf,ctx,dirIndex){if(1&rf&&(core.Ib(dirIndex,sidenav_MatDrawerContent,!0),core.Ib(dirIndex,sidenav_MatDrawer,!0)),2&rf){let _t;core.wc(_t=core.hc())&&(ctx._content=_t.first),core.wc(_t=core.hc())&&(ctx._allDrawers=_t)}},viewQuery:function(rf,ctx){if(1&rf&&core.Rc(sidenav_MatDrawerContent,!0),2&rf){let _t;core.wc(_t=core.hc())&&(ctx._userContent=_t.first)}},hostAttrs:[1,\"mat-drawer-container\"],hostVars:2,hostBindings:function(rf,ctx){2&rf&&core.Hb(\"mat-drawer-container-explicit-backdrop\",ctx._backdropOverride)},inputs:{autosize:\"autosize\",hasBackdrop:\"hasBackdrop\"},outputs:{backdropClick:\"backdropClick\"},exportAs:[\"matDrawerContainer\"],features:[core.Bb([{provide:MAT_DRAWER_CONTAINER,useExisting:MatDrawerContainer}])],ngContentSelectors:_c2,decls:4,vars:2,consts:[[\"class\",\"mat-drawer-backdrop\",3,\"mat-drawer-shown\",\"click\",4,\"ngIf\"],[4,\"ngIf\"],[1,\"mat-drawer-backdrop\",3,\"click\"]],template:function(rf,ctx){1&rf&&(core.oc(_c1),core.Kc(0,MatDrawerContainer_div_0_Template,1,2,\"div\",0),core.nc(1),core.nc(2,1),core.Kc(3,MatDrawerContainer_mat_drawer_content_3_Template,2,0,\"mat-drawer-content\",1)),2&rf&&(core.pc(\"ngIf\",ctx.hasBackdrop),core.Cb(3),core.pc(\"ngIf\",!ctx._content))},directives:[common.l,sidenav_MatDrawerContent],styles:[_c5],encapsulation:2,changeDetection:0}),MatDrawerContainer})(),sidenav_MatSidenavContent=(()=>{class MatSidenavContent extends sidenav_MatDrawerContent{constructor(changeDetectorRef,container,elementRef,scrollDispatcher,ngZone){super(changeDetectorRef,container,elementRef,scrollDispatcher,ngZone)}}return MatSidenavContent.ɵfac=function(t){return new(t||MatSidenavContent)(core.Pb(core.h),core.Pb(Object(core.W)(()=>sidenav_MatSidenavContainer)),core.Pb(core.l),core.Pb(scrolling.c),core.Pb(core.B))},MatSidenavContent.ɵcmp=core.Jb({type:MatSidenavContent,selectors:[[\"mat-sidenav-content\"]],hostAttrs:[1,\"mat-drawer-content\",\"mat-sidenav-content\"],hostVars:4,hostBindings:function(rf,ctx){2&rf&&core.Hc(\"margin-left\",ctx._container._contentMargins.left,\"px\")(\"margin-right\",ctx._container._contentMargins.right,\"px\")},features:[core.zb],ngContentSelectors:_c0,decls:1,vars:0,template:function(rf,ctx){1&rf&&(core.oc(),core.nc(0))},encapsulation:2,changeDetection:0}),MatSidenavContent})(),sidenav_MatSidenav=(()=>{class MatSidenav extends sidenav_MatDrawer{constructor(){super(...arguments),this._fixedInViewport=!1,this._fixedTopGap=0,this._fixedBottomGap=0}get fixedInViewport(){return this._fixedInViewport}set fixedInViewport(value){this._fixedInViewport=Object(coercion.c)(value)}get fixedTopGap(){return this._fixedTopGap}set fixedTopGap(value){this._fixedTopGap=Object(coercion.f)(value)}get fixedBottomGap(){return this._fixedBottomGap}set fixedBottomGap(value){this._fixedBottomGap=Object(coercion.f)(value)}}return MatSidenav.ɵfac=function(t){return ɵMatSidenav_BaseFactory(t||MatSidenav)},MatSidenav.ɵcmp=core.Jb({type:MatSidenav,selectors:[[\"mat-sidenav\"]],hostAttrs:[\"tabIndex\",\"-1\",1,\"mat-drawer\",\"mat-sidenav\"],hostVars:17,hostBindings:function(rf,ctx){2&rf&&(core.Db(\"align\",null),core.Hc(\"top\",ctx.fixedInViewport?ctx.fixedTopGap:null,\"px\")(\"bottom\",ctx.fixedInViewport?ctx.fixedBottomGap:null,\"px\"),core.Hb(\"mat-drawer-end\",\"end\"===ctx.position)(\"mat-drawer-over\",\"over\"===ctx.mode)(\"mat-drawer-push\",\"push\"===ctx.mode)(\"mat-drawer-side\",\"side\"===ctx.mode)(\"mat-drawer-opened\",ctx.opened)(\"mat-sidenav-fixed\",ctx.fixedInViewport))},inputs:{fixedInViewport:\"fixedInViewport\",fixedTopGap:\"fixedTopGap\",fixedBottomGap:\"fixedBottomGap\"},exportAs:[\"matSidenav\"],features:[core.zb],ngContentSelectors:_c0,decls:2,vars:0,consts:[[1,\"mat-drawer-inner-container\"]],template:function(rf,ctx){1&rf&&(core.oc(),core.Vb(0,\"div\",0),core.nc(1),core.Ub())},encapsulation:2,data:{animation:[matDrawerAnimations.transformDrawer]},changeDetection:0}),MatSidenav})();const ɵMatSidenav_BaseFactory=core.Xb(sidenav_MatSidenav);let sidenav_MatSidenavContainer=(()=>{class MatSidenavContainer extends sidenav_MatDrawerContainer{}return MatSidenavContainer.ɵfac=function(t){return ɵMatSidenavContainer_BaseFactory(t||MatSidenavContainer)},MatSidenavContainer.ɵcmp=core.Jb({type:MatSidenavContainer,selectors:[[\"mat-sidenav-container\"]],contentQueries:function(rf,ctx,dirIndex){if(1&rf&&(core.Ib(dirIndex,sidenav_MatSidenavContent,!0),core.Ib(dirIndex,sidenav_MatSidenav,!0)),2&rf){let _t;core.wc(_t=core.hc())&&(ctx._content=_t.first),core.wc(_t=core.hc())&&(ctx._allDrawers=_t)}},hostAttrs:[1,\"mat-drawer-container\",\"mat-sidenav-container\"],hostVars:2,hostBindings:function(rf,ctx){2&rf&&core.Hb(\"mat-drawer-container-explicit-backdrop\",ctx._backdropOverride)},exportAs:[\"matSidenavContainer\"],features:[core.Bb([{provide:MAT_DRAWER_CONTAINER,useExisting:MatSidenavContainer}]),core.zb],ngContentSelectors:_c4,decls:4,vars:2,consts:[[\"class\",\"mat-drawer-backdrop\",3,\"mat-drawer-shown\",\"click\",4,\"ngIf\"],[\"cdkScrollable\",\"\",4,\"ngIf\"],[1,\"mat-drawer-backdrop\",3,\"click\"],[\"cdkScrollable\",\"\"]],template:function(rf,ctx){1&rf&&(core.oc(_c3),core.Kc(0,MatSidenavContainer_div_0_Template,1,2,\"div\",0),core.nc(1),core.nc(2,1),core.Kc(3,MatSidenavContainer_mat_sidenav_content_3_Template,2,0,\"mat-sidenav-content\",1)),2&rf&&(core.pc(\"ngIf\",ctx.hasBackdrop),core.Cb(3),core.pc(\"ngIf\",!ctx._content))},directives:[common.l,sidenav_MatSidenavContent,scrolling.a],styles:[_c5],encapsulation:2,changeDetection:0}),MatSidenavContainer})();const ɵMatSidenavContainer_BaseFactory=core.Xb(sidenav_MatSidenavContainer);let sidenav_MatSidenavModule=(()=>{class MatSidenavModule{}return MatSidenavModule.ɵmod=core.Nb({type:MatSidenavModule}),MatSidenavModule.ɵinj=core.Mb({factory:function(t){return new(t||MatSidenavModule)},imports:[[common.c,fesm2015_core.i,platform.b,scrolling.b],scrolling.b,fesm2015_core.i]}),MatSidenavModule})()}}]);","name":"3-es2015.337a79e12c8c47fa0d9d.js","input":"(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[3],{\n\n/***/ \"XhcP\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ sidenav_MatSidenav; });\n__webpack_require__.d(__webpack_exports__, \"b\", function() { return /* binding */ sidenav_MatSidenavContainer; });\n__webpack_require__.d(__webpack_exports__, \"c\", function() { return /* binding */ sidenav_MatSidenavContent; });\n__webpack_require__.d(__webpack_exports__, \"d\", function() { return /* binding */ sidenav_MatSidenavModule; });\n\n// UNUSED EXPORTS: MAT_DRAWER_DEFAULT_AUTOSIZE, MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY, MatDrawer, MatDrawerContainer, MatDrawerContent, matDrawerAnimations, throwMatDuplicatedDrawerError, ɵangular_material_src_material_sidenav_sidenav_a\n\n// EXTERNAL MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/platform.js\nvar platform = __webpack_require__(\"nLfN\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/scrolling.js + 11 modules\nvar scrolling = __webpack_require__(\"vxfF\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/common/__ivy_ngcc__/fesm2015/common.js\nvar common = __webpack_require__(\"ofXK\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js\nvar core = __webpack_require__(\"fXoL\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/core.js + 1 modules\nvar fesm2015_core = __webpack_require__(\"FKr1\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/cdk/fesm2015/coercion.js\nvar coercion = __webpack_require__(\"8LU1\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/keycodes.js\nvar keycodes = __webpack_require__(\"FtGj\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subject.js\nvar Subject = __webpack_require__(\"XNiG\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/fromEvent.js\nvar fromEvent = __webpack_require__(\"xgIS\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/merge.js\nvar merge = __webpack_require__(\"VRyK\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/filter.js\nvar filter = __webpack_require__(\"pLZG\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/map.js\nvar map = __webpack_require__(\"lJxs\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subscriber.js\nvar Subscriber = __webpack_require__(\"7o/Q\");\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/mapTo.js\n\nfunction mapTo(value) {\n    return (source) => source.lift(new MapToOperator(value));\n}\nclass MapToOperator {\n    constructor(value) {\n        this.value = value;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new mapTo_MapToSubscriber(subscriber, this.value));\n    }\n}\nclass mapTo_MapToSubscriber extends Subscriber[\"a\" /* Subscriber */] {\n    constructor(destination, value) {\n        super(destination);\n        this.value = value;\n    }\n    _next(x) {\n        this.destination.next(this.value);\n    }\n}\n//# sourceMappingURL=mapTo.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/takeUntil.js\nvar takeUntil = __webpack_require__(\"1G5W\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/distinctUntilChanged.js\nvar distinctUntilChanged = __webpack_require__(\"/uUt\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/take.js\nvar take = __webpack_require__(\"IzEk\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/startWith.js\nvar startWith = __webpack_require__(\"JX91\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/debounceTime.js\nvar debounceTime = __webpack_require__(\"Kj3r\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/animations/__ivy_ngcc__/fesm2015/animations.js\nvar animations = __webpack_require__(\"R0Ic\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/platform-browser/__ivy_ngcc__/fesm2015/animations.js + 1 modules\nvar fesm2015_animations = __webpack_require__(\"R1ws\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/a11y.js\nvar a11y = __webpack_require__(\"u47x\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/bidi.js\nvar bidi = __webpack_require__(\"cH1L\");\n\n// CONCATENATED MODULE: ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/sidenav.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Animations used by the Material drawers.\n * @docs-private\n */\n\n\n\n\n\n\nconst _c0 = [\"*\"];\nfunction MatDrawerContainer_div_0_Template(rf, ctx) {\n    if (rf & 1) {\n        const _r3 = core[\"Wb\" /* ɵɵgetCurrentView */]();\n        core[\"Vb\" /* ɵɵelementStart */](0, \"div\", 2);\n        core[\"gc\" /* ɵɵlistener */](\"click\", function MatDrawerContainer_div_0_Template_div_click_0_listener() { core[\"Ac\" /* ɵɵrestoreView */](_r3); const ctx_r2 = core[\"kc\" /* ɵɵnextContext */](); return ctx_r2._onBackdropClicked(); });\n        core[\"Ub\" /* ɵɵelementEnd */]();\n    }\n    if (rf & 2) {\n        const ctx_r0 = core[\"kc\" /* ɵɵnextContext */]();\n        core[\"Hb\" /* ɵɵclassProp */](\"mat-drawer-shown\", ctx_r0._isShowingBackdrop());\n    }\n}\nfunction MatDrawerContainer_mat_drawer_content_3_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Vb\" /* ɵɵelementStart */](0, \"mat-drawer-content\");\n        core[\"nc\" /* ɵɵprojection */](1, 2);\n        core[\"Ub\" /* ɵɵelementEnd */]();\n    }\n}\nconst _c1 = [[[\"mat-drawer\"]], [[\"mat-drawer-content\"]], \"*\"];\nconst _c2 = [\"mat-drawer\", \"mat-drawer-content\", \"*\"];\nfunction MatSidenavContainer_div_0_Template(rf, ctx) {\n    if (rf & 1) {\n        const _r3 = core[\"Wb\" /* ɵɵgetCurrentView */]();\n        core[\"Vb\" /* ɵɵelementStart */](0, \"div\", 2);\n        core[\"gc\" /* ɵɵlistener */](\"click\", function MatSidenavContainer_div_0_Template_div_click_0_listener() { core[\"Ac\" /* ɵɵrestoreView */](_r3); const ctx_r2 = core[\"kc\" /* ɵɵnextContext */](); return ctx_r2._onBackdropClicked(); });\n        core[\"Ub\" /* ɵɵelementEnd */]();\n    }\n    if (rf & 2) {\n        const ctx_r0 = core[\"kc\" /* ɵɵnextContext */]();\n        core[\"Hb\" /* ɵɵclassProp */](\"mat-drawer-shown\", ctx_r0._isShowingBackdrop());\n    }\n}\nfunction MatSidenavContainer_mat_sidenav_content_3_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Vb\" /* ɵɵelementStart */](0, \"mat-sidenav-content\", 3);\n        core[\"nc\" /* ɵɵprojection */](1, 2);\n        core[\"Ub\" /* ɵɵelementEnd */]();\n    }\n}\nconst _c3 = [[[\"mat-sidenav\"]], [[\"mat-sidenav-content\"]], \"*\"];\nconst _c4 = [\"mat-sidenav\", \"mat-sidenav-content\", \"*\"];\nconst _c5 = \".mat-drawer-container{position:relative;z-index:1;box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}.cdk-high-contrast-active .mat-drawer-backdrop{opacity:.5}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}.cdk-high-contrast-active .mat-drawer,.cdk-high-contrast-active [dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}.cdk-high-contrast-active [dir=rtl] .mat-drawer,.cdk-high-contrast-active .mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer{transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch}.mat-sidenav-fixed{position:fixed}\\n\";\nconst matDrawerAnimations = {\n    /** Animation that slides a drawer in and out. */\n    transformDrawer: /*@__PURE__*/ Object(animations[\"m\" /* trigger */])('transform', [\n        // We remove the `transform` here completely, rather than setting it to zero, because:\n        // 1. Having a transform can cause elements with ripples or an animated\n        //    transform to shift around in Chrome with an RTL layout (see #10023).\n        // 2. 3d transforms causes text to appear blurry on IE and Edge.\n        /*@__PURE__*/ Object(animations[\"j\" /* state */])('open, open-instant', /*@__PURE__*/ Object(animations[\"k\" /* style */])({\n            'transform': 'none',\n            'visibility': 'visible',\n        })),\n        /*@__PURE__*/ Object(animations[\"j\" /* state */])('void', /*@__PURE__*/ Object(animations[\"k\" /* style */])({\n            // Avoids the shadow showing up when closed in SSR.\n            'box-shadow': 'none',\n            'visibility': 'hidden',\n        })),\n        /*@__PURE__*/ Object(animations[\"l\" /* transition */])('void => open-instant', /*@__PURE__*/ Object(animations[\"e\" /* animate */])('0ms')),\n        /*@__PURE__*/ Object(animations[\"l\" /* transition */])('void <=> open, open-instant => void', /*@__PURE__*/ Object(animations[\"e\" /* animate */])('400ms cubic-bezier(0.25, 0.8, 0.25, 1)'))\n    ])\n};\n/**\n * Throws an exception when two MatDrawer are matching the same position.\n * @docs-private\n */\nfunction throwMatDuplicatedDrawerError(position) {\n    throw Error(`A drawer was already declared for 'position=\"${position}\"'`);\n}\n/** Configures whether drawers should use auto sizing by default. */\nconst MAT_DRAWER_DEFAULT_AUTOSIZE = /*@__PURE__*/ new core[\"s\" /* InjectionToken */]('MAT_DRAWER_DEFAULT_AUTOSIZE', {\n    providedIn: 'root',\n    factory: MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY,\n});\n/**\n * Used to provide a drawer container to a drawer while avoiding circular references.\n * @docs-private\n */\nconst MAT_DRAWER_CONTAINER = /*@__PURE__*/ new core[\"s\" /* InjectionToken */]('MAT_DRAWER_CONTAINER');\n/** @docs-private */\nfunction MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY() {\n    return false;\n}\nlet sidenav_MatDrawerContent = /*@__PURE__*/ (() => {\n    class MatDrawerContent extends scrolling[\"a\" /* CdkScrollable */] {\n        constructor(_changeDetectorRef, _container, elementRef, scrollDispatcher, ngZone) {\n            super(elementRef, scrollDispatcher, ngZone);\n            this._changeDetectorRef = _changeDetectorRef;\n            this._container = _container;\n        }\n        ngAfterContentInit() {\n            this._container._contentMarginChanges.subscribe(() => {\n                this._changeDetectorRef.markForCheck();\n            });\n        }\n    }\n    MatDrawerContent.ɵfac = function MatDrawerContent_Factory(t) { return new (t || MatDrawerContent)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"h\" /* ChangeDetectorRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](Object(core[\"W\" /* forwardRef */])(() => sidenav_MatDrawerContainer)), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](scrolling[\"c\" /* ScrollDispatcher */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */])); };\n    MatDrawerContent.ɵcmp = /*@__PURE__*/ core[\"Jb\" /* ɵɵdefineComponent */]({ type: MatDrawerContent, selectors: [[\"mat-drawer-content\"]], hostAttrs: [1, \"mat-drawer-content\"], hostVars: 4, hostBindings: function MatDrawerContent_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Hc\" /* ɵɵstyleProp */](\"margin-left\", ctx._container._contentMargins.left, \"px\")(\"margin-right\", ctx._container._contentMargins.right, \"px\");\n            }\n        }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], ngContentSelectors: _c0, decls: 1, vars: 0, template: function MatDrawerContent_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"oc\" /* ɵɵprojectionDef */]();\n                core[\"nc\" /* ɵɵprojection */](0);\n            }\n        }, encapsulation: 2, changeDetection: 0 });\n    return MatDrawerContent;\n})();\nlet sidenav_MatDrawer = /*@__PURE__*/ (() => {\n    class MatDrawer {\n        constructor(_elementRef, _focusTrapFactory, _focusMonitor, _platform, _ngZone, _doc, _container) {\n            this._elementRef = _elementRef;\n            this._focusTrapFactory = _focusTrapFactory;\n            this._focusMonitor = _focusMonitor;\n            this._platform = _platform;\n            this._ngZone = _ngZone;\n            this._doc = _doc;\n            this._container = _container;\n            this._elementFocusedBeforeDrawerWasOpened = null;\n            /** Whether the drawer is initialized. Used for disabling the initial animation. */\n            this._enableAnimations = false;\n            this._position = 'start';\n            this._mode = 'over';\n            this._disableClose = false;\n            this._opened = false;\n            /** Emits whenever the drawer has started animating. */\n            this._animationStarted = new Subject[\"a\" /* Subject */]();\n            /** Emits whenever the drawer is done animating. */\n            this._animationEnd = new Subject[\"a\" /* Subject */]();\n            /** Current state of the sidenav animation. */\n            // @HostBinding is used in the class as it is expected to be extended.  Since @Component decorator\n            // metadata is not inherited by child classes, instead the host binding data is defined in a way\n            // that can be inherited.\n            // tslint:disable:no-host-decorator-in-concrete\n            this._animationState = 'void';\n            /** Event emitted when the drawer open state is changed. */\n            this.openedChange =\n                // Note this has to be async in order to avoid some issues with two-bindings (see #8872).\n                new core[\"o\" /* EventEmitter */](/* isAsync */ true);\n            /** Event emitted when the drawer has been opened. */\n            this._openedStream = this.openedChange.pipe(Object(filter[\"a\" /* filter */])(o => o), Object(map[\"a\" /* map */])(() => { }));\n            /** Event emitted when the drawer has started opening. */\n            this.openedStart = this._animationStarted.pipe(Object(filter[\"a\" /* filter */])(e => e.fromState !== e.toState && e.toState.indexOf('open') === 0), mapTo(undefined));\n            /** Event emitted when the drawer has been closed. */\n            this._closedStream = this.openedChange.pipe(Object(filter[\"a\" /* filter */])(o => !o), Object(map[\"a\" /* map */])(() => { }));\n            /** Event emitted when the drawer has started closing. */\n            this.closedStart = this._animationStarted.pipe(Object(filter[\"a\" /* filter */])(e => e.fromState !== e.toState && e.toState === 'void'), mapTo(undefined));\n            /** Emits when the component is destroyed. */\n            this._destroyed = new Subject[\"a\" /* Subject */]();\n            /** Event emitted when the drawer's position changes. */\n            // tslint:disable-next-line:no-output-on-prefix\n            this.onPositionChanged = new core[\"o\" /* EventEmitter */]();\n            /**\n             * An observable that emits when the drawer mode changes. This is used by the drawer container to\n             * to know when to when the mode changes so it can adapt the margins on the content.\n             */\n            this._modeChanged = new Subject[\"a\" /* Subject */]();\n            this.openedChange.subscribe((opened) => {\n                if (opened) {\n                    if (this._doc) {\n                        this._elementFocusedBeforeDrawerWasOpened = this._doc.activeElement;\n                    }\n                    this._takeFocus();\n                }\n                else if (this._isFocusWithinDrawer()) {\n                    this._restoreFocus();\n                }\n            });\n            /**\n             * Listen to `keydown` events outside the zone so that change detection is not run every\n             * time a key is pressed. Instead we re-enter the zone only if the `ESC` key is pressed\n             * and we don't have close disabled.\n             */\n            this._ngZone.runOutsideAngular(() => {\n                Object(fromEvent[\"a\" /* fromEvent */])(this._elementRef.nativeElement, 'keydown').pipe(Object(filter[\"a\" /* filter */])(event => {\n                    return event.keyCode === keycodes[\"h\" /* ESCAPE */] && !this.disableClose && !Object(keycodes[\"t\" /* hasModifierKey */])(event);\n                }), Object(takeUntil[\"a\" /* takeUntil */])(this._destroyed)).subscribe(event => this._ngZone.run(() => {\n                    this.close();\n                    event.stopPropagation();\n                    event.preventDefault();\n                }));\n            });\n            // We need a Subject with distinctUntilChanged, because the `done` event\n            // fires twice on some browsers. See https://github.com/angular/angular/issues/24084\n            this._animationEnd.pipe(Object(distinctUntilChanged[\"a\" /* distinctUntilChanged */])((x, y) => {\n                return x.fromState === y.fromState && x.toState === y.toState;\n            })).subscribe((event) => {\n                const { fromState, toState } = event;\n                if ((toState.indexOf('open') === 0 && fromState === 'void') ||\n                    (toState === 'void' && fromState.indexOf('open') === 0)) {\n                    this.openedChange.emit(this._opened);\n                }\n            });\n        }\n        /** The side that the drawer is attached to. */\n        get position() { return this._position; }\n        set position(value) {\n            // Make sure we have a valid value.\n            value = value === 'end' ? 'end' : 'start';\n            if (value != this._position) {\n                this._position = value;\n                this.onPositionChanged.emit();\n            }\n        }\n        /** Mode of the drawer; one of 'over', 'push' or 'side'. */\n        get mode() { return this._mode; }\n        set mode(value) {\n            this._mode = value;\n            this._updateFocusTrapState();\n            this._modeChanged.next();\n        }\n        /** Whether the drawer can be closed with the escape key or by clicking on the backdrop. */\n        get disableClose() { return this._disableClose; }\n        set disableClose(value) { this._disableClose = Object(coercion[\"c\" /* coerceBooleanProperty */])(value); }\n        /**\n         * Whether the drawer should focus the first focusable element automatically when opened.\n         * Defaults to false in when `mode` is set to `side`, otherwise defaults to `true`. If explicitly\n         * enabled, focus will be moved into the sidenav in `side` mode as well.\n         */\n        get autoFocus() {\n            const value = this._autoFocus;\n            // Note that usually we disable auto focusing in `side` mode, because we don't know how the\n            // sidenav is being used, but in some cases it still makes sense to do it. If the consumer\n            // explicitly enabled `autoFocus`, we take it as them always wanting to enable it.\n            return value == null ? this.mode !== 'side' : value;\n        }\n        set autoFocus(value) { this._autoFocus = Object(coercion[\"c\" /* coerceBooleanProperty */])(value); }\n        /**\n         * Whether the drawer is opened. We overload this because we trigger an event when it\n         * starts or end.\n         */\n        get opened() { return this._opened; }\n        set opened(value) { this.toggle(Object(coercion[\"c\" /* coerceBooleanProperty */])(value)); }\n        /**\n         * Moves focus into the drawer. Note that this works even if\n         * the focus trap is disabled in `side` mode.\n         */\n        _takeFocus() {\n            if (!this.autoFocus || !this._focusTrap) {\n                return;\n            }\n            this._focusTrap.focusInitialElementWhenReady().then(hasMovedFocus => {\n                // If there were no focusable elements, focus the sidenav itself so the keyboard navigation\n                // still works. We need to check that `focus` is a function due to Universal.\n                if (!hasMovedFocus && typeof this._elementRef.nativeElement.focus === 'function') {\n                    this._elementRef.nativeElement.focus();\n                }\n            });\n        }\n        /**\n         * Restores focus to the element that was originally focused when the drawer opened.\n         * If no element was focused at that time, the focus will be restored to the drawer.\n         */\n        _restoreFocus() {\n            if (!this.autoFocus) {\n                return;\n            }\n            // Note that we don't check via `instanceof HTMLElement` so that we can cover SVGs as well.\n            if (this._elementFocusedBeforeDrawerWasOpened) {\n                this._focusMonitor.focusVia(this._elementFocusedBeforeDrawerWasOpened, this._openedVia);\n            }\n            else {\n                this._elementRef.nativeElement.blur();\n            }\n            this._elementFocusedBeforeDrawerWasOpened = null;\n            this._openedVia = null;\n        }\n        /** Whether focus is currently within the drawer. */\n        _isFocusWithinDrawer() {\n            var _a;\n            const activeEl = (_a = this._doc) === null || _a === void 0 ? void 0 : _a.activeElement;\n            return !!activeEl && this._elementRef.nativeElement.contains(activeEl);\n        }\n        ngAfterContentInit() {\n            this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);\n            this._updateFocusTrapState();\n        }\n        ngAfterContentChecked() {\n            // Enable the animations after the lifecycle hooks have run, in order to avoid animating\n            // drawers that are open by default. When we're on the server, we shouldn't enable the\n            // animations, because we don't want the drawer to animate the first time the user sees\n            // the page.\n            if (this._platform.isBrowser) {\n                this._enableAnimations = true;\n            }\n        }\n        ngOnDestroy() {\n            if (this._focusTrap) {\n                this._focusTrap.destroy();\n            }\n            this._animationStarted.complete();\n            this._animationEnd.complete();\n            this._modeChanged.complete();\n            this._destroyed.next();\n            this._destroyed.complete();\n        }\n        /**\n         * Open the drawer.\n         * @param openedVia Whether the drawer was opened by a key press, mouse click or programmatically.\n         * Used for focus management after the sidenav is closed.\n         */\n        open(openedVia) {\n            return this.toggle(true, openedVia);\n        }\n        /** Close the drawer. */\n        close() {\n            return this.toggle(false);\n        }\n        /** Closes the drawer with context that the backdrop was clicked. */\n        _closeViaBackdropClick() {\n            // If the drawer is closed upon a backdrop click, we always want to restore focus. We\n            // don't need to check whether focus is currently in the drawer, as clicking on the\n            // backdrop causes blurring of the active element.\n            return this._setOpen(/* isOpen */ false, /* restoreFocus */ true);\n        }\n        /**\n         * Toggle this drawer.\n         * @param isOpen Whether the drawer should be open.\n         * @param openedVia Whether the drawer was opened by a key press, mouse click or programmatically.\n         * Used for focus management after the sidenav is closed.\n         */\n        toggle(isOpen = !this.opened, openedVia) {\n            // If the focus is currently inside the drawer content and we are closing the drawer,\n            // restore the focus to the initially focused element (when the drawer opened).\n            return this._setOpen(isOpen, /* restoreFocus */ !isOpen && this._isFocusWithinDrawer(), openedVia);\n        }\n        /**\n         * Toggles the opened state of the drawer.\n         * @param isOpen Whether the drawer should open or close.\n         * @param restoreFocus Whether focus should be restored on close.\n         * @param openedVia Focus origin that can be optionally set when opening a drawer. The\n         *   origin will be used later when focus is restored on drawer close.\n         */\n        _setOpen(isOpen, restoreFocus, openedVia = 'program') {\n            this._opened = isOpen;\n            if (isOpen) {\n                this._animationState = this._enableAnimations ? 'open' : 'open-instant';\n                this._openedVia = openedVia;\n            }\n            else {\n                this._animationState = 'void';\n                if (restoreFocus) {\n                    this._restoreFocus();\n                }\n            }\n            this._updateFocusTrapState();\n            return new Promise(resolve => {\n                this.openedChange.pipe(Object(take[\"a\" /* take */])(1)).subscribe(open => resolve(open ? 'open' : 'close'));\n            });\n        }\n        _getWidth() {\n            return this._elementRef.nativeElement ? (this._elementRef.nativeElement.offsetWidth || 0) : 0;\n        }\n        /** Updates the enabled state of the focus trap. */\n        _updateFocusTrapState() {\n            if (this._focusTrap) {\n                // The focus trap is only enabled when the drawer is open in any mode other than side.\n                this._focusTrap.enabled = this.opened && this.mode !== 'side';\n            }\n        }\n        // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\n        // In Ivy the `host` bindings will be merged when this class is extended, whereas in\n        // ViewEngine they're overwritten.\n        // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\n        // tslint:disable-next-line:no-host-decorator-in-concrete\n        _animationStartListener(event) {\n            this._animationStarted.next(event);\n        }\n        // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\n        // In Ivy the `host` bindings will be merged when this class is extended, whereas in\n        // ViewEngine they're overwritten.\n        // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\n        // tslint:disable-next-line:no-host-decorator-in-concrete\n        _animationDoneListener(event) {\n            this._animationEnd.next(event);\n        }\n    }\n    MatDrawer.ɵfac = function MatDrawer_Factory(t) { return new (t || MatDrawer)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](a11y[\"i\" /* FocusTrapFactory */]), core[\"Pb\" /* ɵɵdirectiveInject */](a11y[\"h\" /* FocusMonitor */]), core[\"Pb\" /* ɵɵdirectiveInject */](platform[\"a\" /* Platform */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */]), core[\"Pb\" /* ɵɵdirectiveInject */](common[\"d\" /* DOCUMENT */], 8), core[\"Pb\" /* ɵɵdirectiveInject */](MAT_DRAWER_CONTAINER, 8)); };\n    MatDrawer.ɵcmp = /*@__PURE__*/ core[\"Jb\" /* ɵɵdefineComponent */]({ type: MatDrawer, selectors: [[\"mat-drawer\"]], hostAttrs: [\"tabIndex\", \"-1\", 1, \"mat-drawer\"], hostVars: 12, hostBindings: function MatDrawer_HostBindings(rf, ctx) {\n            if (rf & 1) {\n                core[\"Ic\" /* ɵɵsyntheticHostListener */](\"@transform.start\", function MatDrawer_animation_transform_start_HostBindingHandler($event) { return ctx._animationStartListener($event); })(\"@transform.done\", function MatDrawer_animation_transform_done_HostBindingHandler($event) { return ctx._animationDoneListener($event); });\n            }\n            if (rf & 2) {\n                core[\"Db\" /* ɵɵattribute */](\"align\", null);\n                core[\"Jc\" /* ɵɵsyntheticHostProperty */](\"@transform\", ctx._animationState);\n                core[\"Hb\" /* ɵɵclassProp */](\"mat-drawer-end\", ctx.position === \"end\")(\"mat-drawer-over\", ctx.mode === \"over\")(\"mat-drawer-push\", ctx.mode === \"push\")(\"mat-drawer-side\", ctx.mode === \"side\")(\"mat-drawer-opened\", ctx.opened);\n            }\n        }, inputs: { position: \"position\", mode: \"mode\", disableClose: \"disableClose\", autoFocus: \"autoFocus\", opened: \"opened\" }, outputs: { openedChange: \"openedChange\", _openedStream: \"opened\", openedStart: \"openedStart\", _closedStream: \"closed\", closedStart: \"closedStart\", onPositionChanged: \"positionChanged\" }, exportAs: [\"matDrawer\"], ngContentSelectors: _c0, decls: 2, vars: 0, consts: [[1, \"mat-drawer-inner-container\"]], template: function MatDrawer_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"oc\" /* ɵɵprojectionDef */]();\n                core[\"Vb\" /* ɵɵelementStart */](0, \"div\", 0);\n                core[\"nc\" /* ɵɵprojection */](1);\n                core[\"Ub\" /* ɵɵelementEnd */]();\n            }\n        }, encapsulation: 2, data: { animation: [matDrawerAnimations.transformDrawer] }, changeDetection: 0 });\n    return MatDrawer;\n})();\nlet sidenav_MatDrawerContainer = /*@__PURE__*/ (() => {\n    class MatDrawerContainer {\n        constructor(_dir, _element, _ngZone, _changeDetectorRef, viewportRuler, defaultAutosize = false, _animationMode) {\n            this._dir = _dir;\n            this._element = _element;\n            this._ngZone = _ngZone;\n            this._changeDetectorRef = _changeDetectorRef;\n            this._animationMode = _animationMode;\n            /** Drawers that belong to this container. */\n            this._drawers = new core[\"F\" /* QueryList */]();\n            /** Event emitted when the drawer backdrop is clicked. */\n            this.backdropClick = new core[\"o\" /* EventEmitter */]();\n            /** Emits when the component is destroyed. */\n            this._destroyed = new Subject[\"a\" /* Subject */]();\n            /** Emits on every ngDoCheck. Used for debouncing reflows. */\n            this._doCheckSubject = new Subject[\"a\" /* Subject */]();\n            /**\n             * Margins to be applied to the content. These are used to push / shrink the drawer content when a\n             * drawer is open. We use margin rather than transform even for push mode because transform breaks\n             * fixed position elements inside of the transformed element.\n             */\n            this._contentMargins = { left: null, right: null };\n            this._contentMarginChanges = new Subject[\"a\" /* Subject */]();\n            // If a `Dir` directive exists up the tree, listen direction changes\n            // and update the left/right properties to point to the proper start/end.\n            if (_dir) {\n                _dir.change.pipe(Object(takeUntil[\"a\" /* takeUntil */])(this._destroyed)).subscribe(() => {\n                    this._validateDrawers();\n                    this.updateContentMargins();\n                });\n            }\n            // Since the minimum width of the sidenav depends on the viewport width,\n            // we need to recompute the margins if the viewport changes.\n            viewportRuler.change()\n                .pipe(Object(takeUntil[\"a\" /* takeUntil */])(this._destroyed))\n                .subscribe(() => this.updateContentMargins());\n            this._autosize = defaultAutosize;\n        }\n        /** The drawer child with the `start` position. */\n        get start() { return this._start; }\n        /** The drawer child with the `end` position. */\n        get end() { return this._end; }\n        /**\n         * Whether to automatically resize the container whenever\n         * the size of any of its drawers changes.\n         *\n         * **Use at your own risk!** Enabling this option can cause layout thrashing by measuring\n         * the drawers on every change detection cycle. Can be configured globally via the\n         * `MAT_DRAWER_DEFAULT_AUTOSIZE` token.\n         */\n        get autosize() { return this._autosize; }\n        set autosize(value) { this._autosize = Object(coercion[\"c\" /* coerceBooleanProperty */])(value); }\n        /**\n         * Whether the drawer container should have a backdrop while one of the sidenavs is open.\n         * If explicitly set to `true`, the backdrop will be enabled for drawers in the `side`\n         * mode as well.\n         */\n        get hasBackdrop() {\n            if (this._backdropOverride == null) {\n                return !this._start || this._start.mode !== 'side' || !this._end || this._end.mode !== 'side';\n            }\n            return this._backdropOverride;\n        }\n        set hasBackdrop(value) {\n            this._backdropOverride = value == null ? null : Object(coercion[\"c\" /* coerceBooleanProperty */])(value);\n        }\n        /** Reference to the CdkScrollable instance that wraps the scrollable content. */\n        get scrollable() {\n            return this._userContent || this._content;\n        }\n        ngAfterContentInit() {\n            this._allDrawers.changes\n                .pipe(Object(startWith[\"a\" /* startWith */])(this._allDrawers), Object(takeUntil[\"a\" /* takeUntil */])(this._destroyed))\n                .subscribe((drawer) => {\n                this._drawers.reset(drawer.filter(item => !item._container || item._container === this));\n                this._drawers.notifyOnChanges();\n            });\n            this._drawers.changes.pipe(Object(startWith[\"a\" /* startWith */])(null)).subscribe(() => {\n                this._validateDrawers();\n                this._drawers.forEach((drawer) => {\n                    this._watchDrawerToggle(drawer);\n                    this._watchDrawerPosition(drawer);\n                    this._watchDrawerMode(drawer);\n                });\n                if (!this._drawers.length ||\n                    this._isDrawerOpen(this._start) ||\n                    this._isDrawerOpen(this._end)) {\n                    this.updateContentMargins();\n                }\n                this._changeDetectorRef.markForCheck();\n            });\n            // Avoid hitting the NgZone through the debounce timeout.\n            this._ngZone.runOutsideAngular(() => {\n                this._doCheckSubject.pipe(Object(debounceTime[\"a\" /* debounceTime */])(10), // Arbitrary debounce time, less than a frame at 60fps\n                Object(takeUntil[\"a\" /* takeUntil */])(this._destroyed)).subscribe(() => this.updateContentMargins());\n            });\n        }\n        ngOnDestroy() {\n            this._contentMarginChanges.complete();\n            this._doCheckSubject.complete();\n            this._drawers.destroy();\n            this._destroyed.next();\n            this._destroyed.complete();\n        }\n        /** Calls `open` of both start and end drawers */\n        open() {\n            this._drawers.forEach(drawer => drawer.open());\n        }\n        /** Calls `close` of both start and end drawers */\n        close() {\n            this._drawers.forEach(drawer => drawer.close());\n        }\n        /**\n         * Recalculates and updates the inline styles for the content. Note that this should be used\n         * sparingly, because it causes a reflow.\n         */\n        updateContentMargins() {\n            // 1. For drawers in `over` mode, they don't affect the content.\n            // 2. For drawers in `side` mode they should shrink the content. We do this by adding to the\n            //    left margin (for left drawer) or right margin (for right the drawer).\n            // 3. For drawers in `push` mode the should shift the content without resizing it. We do this by\n            //    adding to the left or right margin and simultaneously subtracting the same amount of\n            //    margin from the other side.\n            let left = 0;\n            let right = 0;\n            if (this._left && this._left.opened) {\n                if (this._left.mode == 'side') {\n                    left += this._left._getWidth();\n                }\n                else if (this._left.mode == 'push') {\n                    const width = this._left._getWidth();\n                    left += width;\n                    right -= width;\n                }\n            }\n            if (this._right && this._right.opened) {\n                if (this._right.mode == 'side') {\n                    right += this._right._getWidth();\n                }\n                else if (this._right.mode == 'push') {\n                    const width = this._right._getWidth();\n                    right += width;\n                    left -= width;\n                }\n            }\n            // If either `right` or `left` is zero, don't set a style to the element. This\n            // allows users to specify a custom size via CSS class in SSR scenarios where the\n            // measured widths will always be zero. Note that we reset to `null` here, rather\n            // than below, in order to ensure that the types in the `if` below are consistent.\n            left = left || null;\n            right = right || null;\n            if (left !== this._contentMargins.left || right !== this._contentMargins.right) {\n                this._contentMargins = { left, right };\n                // Pull back into the NgZone since in some cases we could be outside. We need to be careful\n                // to do it only when something changed, otherwise we can end up hitting the zone too often.\n                this._ngZone.run(() => this._contentMarginChanges.next(this._contentMargins));\n            }\n        }\n        ngDoCheck() {\n            // If users opted into autosizing, do a check every change detection cycle.\n            if (this._autosize && this._isPushed()) {\n                // Run outside the NgZone, otherwise the debouncer will throw us into an infinite loop.\n                this._ngZone.runOutsideAngular(() => this._doCheckSubject.next());\n            }\n        }\n        /**\n         * Subscribes to drawer events in order to set a class on the main container element when the\n         * drawer is open and the backdrop is visible. This ensures any overflow on the container element\n         * is properly hidden.\n         */\n        _watchDrawerToggle(drawer) {\n            drawer._animationStarted.pipe(Object(filter[\"a\" /* filter */])((event) => event.fromState !== event.toState), Object(takeUntil[\"a\" /* takeUntil */])(this._drawers.changes))\n                .subscribe((event) => {\n                // Set the transition class on the container so that the animations occur. This should not\n                // be set initially because animations should only be triggered via a change in state.\n                if (event.toState !== 'open-instant' && this._animationMode !== 'NoopAnimations') {\n                    this._element.nativeElement.classList.add('mat-drawer-transition');\n                }\n                this.updateContentMargins();\n                this._changeDetectorRef.markForCheck();\n            });\n            if (drawer.mode !== 'side') {\n                drawer.openedChange.pipe(Object(takeUntil[\"a\" /* takeUntil */])(this._drawers.changes)).subscribe(() => this._setContainerClass(drawer.opened));\n            }\n        }\n        /**\n         * Subscribes to drawer onPositionChanged event in order to\n         * re-validate drawers when the position changes.\n         */\n        _watchDrawerPosition(drawer) {\n            if (!drawer) {\n                return;\n            }\n            // NOTE: We need to wait for the microtask queue to be empty before validating,\n            // since both drawers may be swapping positions at the same time.\n            drawer.onPositionChanged.pipe(Object(takeUntil[\"a\" /* takeUntil */])(this._drawers.changes)).subscribe(() => {\n                this._ngZone.onMicrotaskEmpty.pipe(Object(take[\"a\" /* take */])(1)).subscribe(() => {\n                    this._validateDrawers();\n                });\n            });\n        }\n        /** Subscribes to changes in drawer mode so we can run change detection. */\n        _watchDrawerMode(drawer) {\n            if (drawer) {\n                drawer._modeChanged.pipe(Object(takeUntil[\"a\" /* takeUntil */])(Object(merge[\"a\" /* merge */])(this._drawers.changes, this._destroyed)))\n                    .subscribe(() => {\n                    this.updateContentMargins();\n                    this._changeDetectorRef.markForCheck();\n                });\n            }\n        }\n        /** Toggles the 'mat-drawer-opened' class on the main 'mat-drawer-container' element. */\n        _setContainerClass(isAdd) {\n            const classList = this._element.nativeElement.classList;\n            const className = 'mat-drawer-container-has-open';\n            if (isAdd) {\n                classList.add(className);\n            }\n            else {\n                classList.remove(className);\n            }\n        }\n        /** Validate the state of the drawer children components. */\n        _validateDrawers() {\n            this._start = this._end = null;\n            // Ensure that we have at most one start and one end drawer.\n            this._drawers.forEach(drawer => {\n                if (drawer.position == 'end') {\n                    if (this._end != null && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                        throwMatDuplicatedDrawerError('end');\n                    }\n                    this._end = drawer;\n                }\n                else {\n                    if (this._start != null && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                        throwMatDuplicatedDrawerError('start');\n                    }\n                    this._start = drawer;\n                }\n            });\n            this._right = this._left = null;\n            // Detect if we're LTR or RTL.\n            if (this._dir && this._dir.value === 'rtl') {\n                this._left = this._end;\n                this._right = this._start;\n            }\n            else {\n                this._left = this._start;\n                this._right = this._end;\n            }\n        }\n        /** Whether the container is being pushed to the side by one of the drawers. */\n        _isPushed() {\n            return (this._isDrawerOpen(this._start) && this._start.mode != 'over') ||\n                (this._isDrawerOpen(this._end) && this._end.mode != 'over');\n        }\n        _onBackdropClicked() {\n            this.backdropClick.emit();\n            this._closeModalDrawersViaBackdrop();\n        }\n        _closeModalDrawersViaBackdrop() {\n            // Close all open drawers where closing is not disabled and the mode is not `side`.\n            [this._start, this._end]\n                .filter(drawer => drawer && !drawer.disableClose && this._canHaveBackdrop(drawer))\n                .forEach(drawer => drawer._closeViaBackdropClick());\n        }\n        _isShowingBackdrop() {\n            return (this._isDrawerOpen(this._start) && this._canHaveBackdrop(this._start)) ||\n                (this._isDrawerOpen(this._end) && this._canHaveBackdrop(this._end));\n        }\n        _canHaveBackdrop(drawer) {\n            return drawer.mode !== 'side' || !!this._backdropOverride;\n        }\n        _isDrawerOpen(drawer) {\n            return drawer != null && drawer.opened;\n        }\n    }\n    MatDrawerContainer.ɵfac = function MatDrawerContainer_Factory(t) { return new (t || MatDrawerContainer)(core[\"Pb\" /* ɵɵdirectiveInject */](bidi[\"b\" /* Directionality */], 8), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"h\" /* ChangeDetectorRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](scrolling[\"e\" /* ViewportRuler */]), core[\"Pb\" /* ɵɵdirectiveInject */](MAT_DRAWER_DEFAULT_AUTOSIZE), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_animations[\"a\" /* ANIMATION_MODULE_TYPE */], 8)); };\n    MatDrawerContainer.ɵcmp = /*@__PURE__*/ core[\"Jb\" /* ɵɵdefineComponent */]({ type: MatDrawerContainer, selectors: [[\"mat-drawer-container\"]], contentQueries: function MatDrawerContainer_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                core[\"Ib\" /* ɵɵcontentQuery */](dirIndex, sidenav_MatDrawerContent, true);\n                core[\"Ib\" /* ɵɵcontentQuery */](dirIndex, sidenav_MatDrawer, true);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx._content = _t.first);\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx._allDrawers = _t);\n            }\n        }, viewQuery: function MatDrawerContainer_Query(rf, ctx) {\n            if (rf & 1) {\n                core[\"Rc\" /* ɵɵviewQuery */](sidenav_MatDrawerContent, true);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx._userContent = _t.first);\n            }\n        }, hostAttrs: [1, \"mat-drawer-container\"], hostVars: 2, hostBindings: function MatDrawerContainer_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Hb\" /* ɵɵclassProp */](\"mat-drawer-container-explicit-backdrop\", ctx._backdropOverride);\n            }\n        }, inputs: { autosize: \"autosize\", hasBackdrop: \"hasBackdrop\" }, outputs: { backdropClick: \"backdropClick\" }, exportAs: [\"matDrawerContainer\"], features: [/*@__PURE__*/ core[\"Bb\" /* ɵɵProvidersFeature */]([{\n                    provide: MAT_DRAWER_CONTAINER,\n                    useExisting: MatDrawerContainer\n                }])], ngContentSelectors: _c2, decls: 4, vars: 2, consts: [[\"class\", \"mat-drawer-backdrop\", 3, \"mat-drawer-shown\", \"click\", 4, \"ngIf\"], [4, \"ngIf\"], [1, \"mat-drawer-backdrop\", 3, \"click\"]], template: function MatDrawerContainer_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"oc\" /* ɵɵprojectionDef */](_c1);\n                core[\"Kc\" /* ɵɵtemplate */](0, MatDrawerContainer_div_0_Template, 1, 2, \"div\", 0);\n                core[\"nc\" /* ɵɵprojection */](1);\n                core[\"nc\" /* ɵɵprojection */](2, 1);\n                core[\"Kc\" /* ɵɵtemplate */](3, MatDrawerContainer_mat_drawer_content_3_Template, 2, 0, \"mat-drawer-content\", 1);\n            }\n            if (rf & 2) {\n                core[\"pc\" /* ɵɵproperty */](\"ngIf\", ctx.hasBackdrop);\n                core[\"Cb\" /* ɵɵadvance */](3);\n                core[\"pc\" /* ɵɵproperty */](\"ngIf\", !ctx._content);\n            }\n        }, directives: [common[\"l\" /* NgIf */], sidenav_MatDrawerContent], styles: [_c5], encapsulation: 2, changeDetection: 0 });\n    return MatDrawerContainer;\n})();\nlet sidenav_MatSidenavContent = /*@__PURE__*/ (() => {\n    class MatSidenavContent extends sidenav_MatDrawerContent {\n        constructor(changeDetectorRef, container, elementRef, scrollDispatcher, ngZone) {\n            super(changeDetectorRef, container, elementRef, scrollDispatcher, ngZone);\n        }\n    }\n    MatSidenavContent.ɵfac = function MatSidenavContent_Factory(t) { return new (t || MatSidenavContent)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"h\" /* ChangeDetectorRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](Object(core[\"W\" /* forwardRef */])(() => sidenav_MatSidenavContainer)), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](scrolling[\"c\" /* ScrollDispatcher */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */])); };\n    MatSidenavContent.ɵcmp = /*@__PURE__*/ core[\"Jb\" /* ɵɵdefineComponent */]({ type: MatSidenavContent, selectors: [[\"mat-sidenav-content\"]], hostAttrs: [1, \"mat-drawer-content\", \"mat-sidenav-content\"], hostVars: 4, hostBindings: function MatSidenavContent_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Hc\" /* ɵɵstyleProp */](\"margin-left\", ctx._container._contentMargins.left, \"px\")(\"margin-right\", ctx._container._contentMargins.right, \"px\");\n            }\n        }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], ngContentSelectors: _c0, decls: 1, vars: 0, template: function MatSidenavContent_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"oc\" /* ɵɵprojectionDef */]();\n                core[\"nc\" /* ɵɵprojection */](0);\n            }\n        }, encapsulation: 2, changeDetection: 0 });\n    return MatSidenavContent;\n})();\nlet sidenav_MatSidenav = /*@__PURE__*/ (() => {\n    class MatSidenav extends sidenav_MatDrawer {\n        constructor() {\n            super(...arguments);\n            this._fixedInViewport = false;\n            this._fixedTopGap = 0;\n            this._fixedBottomGap = 0;\n        }\n        /** Whether the sidenav is fixed in the viewport. */\n        get fixedInViewport() { return this._fixedInViewport; }\n        set fixedInViewport(value) { this._fixedInViewport = Object(coercion[\"c\" /* coerceBooleanProperty */])(value); }\n        /**\n         * The gap between the top of the sidenav and the top of the viewport when the sidenav is in fixed\n         * mode.\n         */\n        get fixedTopGap() { return this._fixedTopGap; }\n        set fixedTopGap(value) { this._fixedTopGap = Object(coercion[\"f\" /* coerceNumberProperty */])(value); }\n        /**\n         * The gap between the bottom of the sidenav and the bottom of the viewport when the sidenav is in\n         * fixed mode.\n         */\n        get fixedBottomGap() { return this._fixedBottomGap; }\n        set fixedBottomGap(value) { this._fixedBottomGap = Object(coercion[\"f\" /* coerceNumberProperty */])(value); }\n    }\n    MatSidenav.ɵfac = function MatSidenav_Factory(t) { return ɵMatSidenav_BaseFactory(t || MatSidenav); };\n    MatSidenav.ɵcmp = /*@__PURE__*/ core[\"Jb\" /* ɵɵdefineComponent */]({ type: MatSidenav, selectors: [[\"mat-sidenav\"]], hostAttrs: [\"tabIndex\", \"-1\", 1, \"mat-drawer\", \"mat-sidenav\"], hostVars: 17, hostBindings: function MatSidenav_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Db\" /* ɵɵattribute */](\"align\", null);\n                core[\"Hc\" /* ɵɵstyleProp */](\"top\", ctx.fixedInViewport ? ctx.fixedTopGap : null, \"px\")(\"bottom\", ctx.fixedInViewport ? ctx.fixedBottomGap : null, \"px\");\n                core[\"Hb\" /* ɵɵclassProp */](\"mat-drawer-end\", ctx.position === \"end\")(\"mat-drawer-over\", ctx.mode === \"over\")(\"mat-drawer-push\", ctx.mode === \"push\")(\"mat-drawer-side\", ctx.mode === \"side\")(\"mat-drawer-opened\", ctx.opened)(\"mat-sidenav-fixed\", ctx.fixedInViewport);\n            }\n        }, inputs: { fixedInViewport: \"fixedInViewport\", fixedTopGap: \"fixedTopGap\", fixedBottomGap: \"fixedBottomGap\" }, exportAs: [\"matSidenav\"], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], ngContentSelectors: _c0, decls: 2, vars: 0, consts: [[1, \"mat-drawer-inner-container\"]], template: function MatSidenav_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"oc\" /* ɵɵprojectionDef */]();\n                core[\"Vb\" /* ɵɵelementStart */](0, \"div\", 0);\n                core[\"nc\" /* ɵɵprojection */](1);\n                core[\"Ub\" /* ɵɵelementEnd */]();\n            }\n        }, encapsulation: 2, data: { animation: [matDrawerAnimations.transformDrawer] }, changeDetection: 0 });\n    return MatSidenav;\n})();\nconst ɵMatSidenav_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ core[\"Xb\" /* ɵɵgetInheritedFactory */](sidenav_MatSidenav);\nlet sidenav_MatSidenavContainer = /*@__PURE__*/ (() => {\n    class MatSidenavContainer extends sidenav_MatDrawerContainer {\n    }\n    MatSidenavContainer.ɵfac = function MatSidenavContainer_Factory(t) { return ɵMatSidenavContainer_BaseFactory(t || MatSidenavContainer); };\n    MatSidenavContainer.ɵcmp = /*@__PURE__*/ core[\"Jb\" /* ɵɵdefineComponent */]({ type: MatSidenavContainer, selectors: [[\"mat-sidenav-container\"]], contentQueries: function MatSidenavContainer_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                core[\"Ib\" /* ɵɵcontentQuery */](dirIndex, sidenav_MatSidenavContent, true);\n                core[\"Ib\" /* ɵɵcontentQuery */](dirIndex, sidenav_MatSidenav, true);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx._content = _t.first);\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx._allDrawers = _t);\n            }\n        }, hostAttrs: [1, \"mat-drawer-container\", \"mat-sidenav-container\"], hostVars: 2, hostBindings: function MatSidenavContainer_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Hb\" /* ɵɵclassProp */](\"mat-drawer-container-explicit-backdrop\", ctx._backdropOverride);\n            }\n        }, exportAs: [\"matSidenavContainer\"], features: [/*@__PURE__*/ core[\"Bb\" /* ɵɵProvidersFeature */]([{\n                    provide: MAT_DRAWER_CONTAINER,\n                    useExisting: MatSidenavContainer\n                }]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]], ngContentSelectors: _c4, decls: 4, vars: 2, consts: [[\"class\", \"mat-drawer-backdrop\", 3, \"mat-drawer-shown\", \"click\", 4, \"ngIf\"], [\"cdkScrollable\", \"\", 4, \"ngIf\"], [1, \"mat-drawer-backdrop\", 3, \"click\"], [\"cdkScrollable\", \"\"]], template: function MatSidenavContainer_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"oc\" /* ɵɵprojectionDef */](_c3);\n                core[\"Kc\" /* ɵɵtemplate */](0, MatSidenavContainer_div_0_Template, 1, 2, \"div\", 0);\n                core[\"nc\" /* ɵɵprojection */](1);\n                core[\"nc\" /* ɵɵprojection */](2, 1);\n                core[\"Kc\" /* ɵɵtemplate */](3, MatSidenavContainer_mat_sidenav_content_3_Template, 2, 0, \"mat-sidenav-content\", 1);\n            }\n            if (rf & 2) {\n                core[\"pc\" /* ɵɵproperty */](\"ngIf\", ctx.hasBackdrop);\n                core[\"Cb\" /* ɵɵadvance */](3);\n                core[\"pc\" /* ɵɵproperty */](\"ngIf\", !ctx._content);\n            }\n        }, directives: [common[\"l\" /* NgIf */], sidenav_MatSidenavContent, scrolling[\"a\" /* CdkScrollable */]], styles: [_c5], encapsulation: 2, changeDetection: 0 });\n    return MatSidenavContainer;\n})();\nconst ɵMatSidenavContainer_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ core[\"Xb\" /* ɵɵgetInheritedFactory */](sidenav_MatSidenavContainer);\nlet sidenav_MatSidenavModule = /*@__PURE__*/ (() => {\n    class MatSidenavModule {\n    }\n    MatSidenavModule.ɵmod = /*@__PURE__*/ core[\"Nb\" /* ɵɵdefineNgModule */]({ type: MatSidenavModule });\n    MatSidenavModule.ɵinj = /*@__PURE__*/ core[\"Mb\" /* ɵɵdefineInjector */]({ factory: function MatSidenavModule_Factory(t) { return new (t || MatSidenavModule)(); }, imports: [[\n                common[\"c\" /* CommonModule */],\n                fesm2015_core[\"i\" /* MatCommonModule */],\n                platform[\"b\" /* PlatformModule */],\n                scrolling[\"b\" /* CdkScrollableModule */],\n            ], scrolling[\"b\" /* CdkScrollableModule */],\n            fesm2015_core[\"i\" /* MatCommonModule */]] });\n    return MatSidenavModule;\n})();\n/*@__PURE__*/ (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ec\" /* ɵɵsetNgModuleScope */](sidenav_MatSidenavModule, { declarations: function () { return [sidenav_MatDrawer, sidenav_MatDrawerContainer, sidenav_MatDrawerContent, sidenav_MatSidenav, sidenav_MatSidenavContainer, sidenav_MatSidenavContent]; }, imports: function () {\n            return [common[\"c\" /* CommonModule */],\n                fesm2015_core[\"i\" /* MatCommonModule */],\n                platform[\"b\" /* PlatformModule */],\n                scrolling[\"b\" /* CdkScrollableModule */]];\n        }, exports: function () {\n            return [scrolling[\"b\" /* CdkScrollableModule */],\n                fesm2015_core[\"i\" /* MatCommonModule */], sidenav_MatDrawer, sidenav_MatDrawerContainer, sidenav_MatDrawerContent, sidenav_MatSidenav, sidenav_MatSidenavContainer, sidenav_MatSidenavContent];\n        } });\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=sidenav.js.map\n\n\n/***/ })\n\n}]);","inputSourceMap":null}