{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{Qu3c:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return MatTooltip}),__webpack_require__.d(__webpack_exports__,\"b\",function(){return MatTooltipModule});var _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"rDax\"),_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"u47x\"),_angular_common__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"ofXK\"),_angular_core__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(\"fXoL\"),_angular_material_core__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(\"FKr1\"),_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__(\"vxfF\"),_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_6__=__webpack_require__(\"8LU1\"),_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_7__=__webpack_require__(\"FtGj\"),_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_8__=__webpack_require__(\"0MNC\"),_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_9__=__webpack_require__(\"nLfN\"),_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_10__=__webpack_require__(\"+rOU\"),rxjs__WEBPACK_IMPORTED_MODULE_11__=__webpack_require__(\"XNiG\"),rxjs_operators__WEBPACK_IMPORTED_MODULE_12__=__webpack_require__(\"1G5W\"),rxjs_operators__WEBPACK_IMPORTED_MODULE_13__=__webpack_require__(\"IzEk\"),_angular_animations__WEBPACK_IMPORTED_MODULE_14__=__webpack_require__(\"R0Ic\"),_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_15__=__webpack_require__(\"cH1L\");const matTooltipAnimations={tooltipState:Object(_angular_animations__WEBPACK_IMPORTED_MODULE_14__.m)(\"state\",[Object(_angular_animations__WEBPACK_IMPORTED_MODULE_14__.j)(\"initial, void, hidden\",Object(_angular_animations__WEBPACK_IMPORTED_MODULE_14__.k)({opacity:0,transform:\"scale(0)\"})),Object(_angular_animations__WEBPACK_IMPORTED_MODULE_14__.j)(\"visible\",Object(_angular_animations__WEBPACK_IMPORTED_MODULE_14__.k)({transform:\"scale(1)\"})),Object(_angular_animations__WEBPACK_IMPORTED_MODULE_14__.l)(\"* => visible\",Object(_angular_animations__WEBPACK_IMPORTED_MODULE_14__.e)(\"200ms cubic-bezier(0, 0, 0.2, 1)\",Object(_angular_animations__WEBPACK_IMPORTED_MODULE_14__.g)([Object(_angular_animations__WEBPACK_IMPORTED_MODULE_14__.k)({opacity:0,transform:\"scale(0)\",offset:0}),Object(_angular_animations__WEBPACK_IMPORTED_MODULE_14__.k)({opacity:.5,transform:\"scale(0.99)\",offset:.5}),Object(_angular_animations__WEBPACK_IMPORTED_MODULE_14__.k)({opacity:1,transform:\"scale(1)\",offset:1})]))),Object(_angular_animations__WEBPACK_IMPORTED_MODULE_14__.l)(\"* => hidden\",Object(_angular_animations__WEBPACK_IMPORTED_MODULE_14__.e)(\"100ms cubic-bezier(0, 0, 0.2, 1)\",Object(_angular_animations__WEBPACK_IMPORTED_MODULE_14__.k)({opacity:0})))])},passiveListenerOptions=Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_9__.f)({passive:!0}),MAT_TOOLTIP_SCROLL_STRATEGY=new _angular_core__WEBPACK_IMPORTED_MODULE_3__.s(\"mat-tooltip-scroll-strategy\"),MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER={provide:MAT_TOOLTIP_SCROLL_STRATEGY,deps:[_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_0__.c],useFactory:function(overlay){return()=>overlay.scrollStrategies.reposition({scrollThrottle:20})}},MAT_TOOLTIP_DEFAULT_OPTIONS=new _angular_core__WEBPACK_IMPORTED_MODULE_3__.s(\"mat-tooltip-default-options\",{providedIn:\"root\",factory:function(){return{showDelay:0,hideDelay:0,touchendHideDelay:1500}}});let MatTooltip=(()=>{class MatTooltip{constructor(_overlay,_elementRef,_scrollDispatcher,_viewContainerRef,_ngZone,_platform,_ariaDescriber,_focusMonitor,scrollStrategy,_dir,_defaultOptions){this._overlay=_overlay,this._elementRef=_elementRef,this._scrollDispatcher=_scrollDispatcher,this._viewContainerRef=_viewContainerRef,this._ngZone=_ngZone,this._platform=_platform,this._ariaDescriber=_ariaDescriber,this._focusMonitor=_focusMonitor,this._dir=_dir,this._defaultOptions=_defaultOptions,this._position=\"below\",this._disabled=!1,this._viewInitialized=!1,this._pointerExitEventsInitialized=!1,this.showDelay=this._defaultOptions.showDelay,this.hideDelay=this._defaultOptions.hideDelay,this.touchGestures=\"auto\",this._message=\"\",this._passiveListeners=[],this._destroyed=new rxjs__WEBPACK_IMPORTED_MODULE_11__.a,this._handleKeydown=event=>{this._isTooltipVisible()&&event.keyCode===_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_7__.h&&!Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_7__.t)(event)&&(event.preventDefault(),event.stopPropagation(),this._ngZone.run(()=>this.hide(0)))},this._scrollStrategy=scrollStrategy,_defaultOptions&&(_defaultOptions.position&&(this.position=_defaultOptions.position),_defaultOptions.touchGestures&&(this.touchGestures=_defaultOptions.touchGestures)),_ngZone.runOutsideAngular(()=>{_elementRef.nativeElement.addEventListener(\"keydown\",this._handleKeydown)})}get position(){return this._position}set position(value){value!==this._position&&(this._position=value,this._overlayRef&&(this._updatePosition(),this._tooltipInstance&&this._tooltipInstance.show(0),this._overlayRef.updatePosition()))}get disabled(){return this._disabled}set disabled(value){this._disabled=Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_6__.c)(value),this._disabled?this.hide(0):this._setupPointerEnterEventsIfNeeded()}get message(){return this._message}set message(value){this._ariaDescriber.removeDescription(this._elementRef.nativeElement,this._message),this._message=null!=value?String(value).trim():\"\",!this._message&&this._isTooltipVisible()?this.hide(0):(this._setupPointerEnterEventsIfNeeded(),this._updateTooltipMessage(),this._ngZone.runOutsideAngular(()=>{Promise.resolve().then(()=>{this._ariaDescriber.describe(this._elementRef.nativeElement,this.message)})}))}get tooltipClass(){return this._tooltipClass}set tooltipClass(value){this._tooltipClass=value,this._tooltipInstance&&this._setTooltipClass(this._tooltipClass)}ngAfterViewInit(){this._viewInitialized=!0,this._setupPointerEnterEventsIfNeeded(),this._focusMonitor.monitor(this._elementRef).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_12__.a)(this._destroyed)).subscribe(origin=>{origin?\"keyboard\"===origin&&this._ngZone.run(()=>this.show()):this._ngZone.run(()=>this.hide(0))})}ngOnDestroy(){const nativeElement=this._elementRef.nativeElement;clearTimeout(this._touchstartTimeout),this._overlayRef&&(this._overlayRef.dispose(),this._tooltipInstance=null),nativeElement.removeEventListener(\"keydown\",this._handleKeydown),this._passiveListeners.forEach(([event,listener])=>{nativeElement.removeEventListener(event,listener,passiveListenerOptions)}),this._passiveListeners.length=0,this._destroyed.next(),this._destroyed.complete(),this._ariaDescriber.removeDescription(nativeElement,this.message),this._focusMonitor.stopMonitoring(nativeElement)}show(delay=this.showDelay){if(this.disabled||!this.message||this._isTooltipVisible()&&!this._tooltipInstance._showTimeoutId&&!this._tooltipInstance._hideTimeoutId)return;const overlayRef=this._createOverlay();this._detach(),this._portal=this._portal||new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_10__.d(TooltipComponent,this._viewContainerRef),this._tooltipInstance=overlayRef.attach(this._portal).instance,this._tooltipInstance.afterHidden().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_12__.a)(this._destroyed)).subscribe(()=>this._detach()),this._setTooltipClass(this._tooltipClass),this._updateTooltipMessage(),this._tooltipInstance.show(delay)}hide(delay=this.hideDelay){this._tooltipInstance&&this._tooltipInstance.hide(delay)}toggle(){this._isTooltipVisible()?this.hide():this.show()}_isTooltipVisible(){return!!this._tooltipInstance&&this._tooltipInstance.isVisible()}_createOverlay(){if(this._overlayRef)return this._overlayRef;const scrollableAncestors=this._scrollDispatcher.getAncestorScrollContainers(this._elementRef),strategy=this._overlay.position().flexibleConnectedTo(this._elementRef).withTransformOriginOn(\".mat-tooltip\").withFlexibleDimensions(!1).withViewportMargin(8).withScrollableContainers(scrollableAncestors);return strategy.positionChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_12__.a)(this._destroyed)).subscribe(change=>{this._tooltipInstance&&change.scrollableViewProperties.isOverlayClipped&&this._tooltipInstance.isVisible()&&this._ngZone.run(()=>this.hide(0))}),this._overlayRef=this._overlay.create({direction:this._dir,positionStrategy:strategy,panelClass:\"mat-tooltip-panel\",scrollStrategy:this._scrollStrategy()}),this._updatePosition(),this._overlayRef.detachments().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_12__.a)(this._destroyed)).subscribe(()=>this._detach()),this._overlayRef}_detach(){this._overlayRef&&this._overlayRef.hasAttached()&&this._overlayRef.detach(),this._tooltipInstance=null}_updatePosition(){const position=this._overlayRef.getConfig().positionStrategy,origin=this._getOrigin(),overlay=this._getOverlayPosition();position.withPositions([Object.assign(Object.assign({},origin.main),overlay.main),Object.assign(Object.assign({},origin.fallback),overlay.fallback)])}_getOrigin(){const isLtr=!this._dir||\"ltr\"==this._dir.value,position=this.position;let originPosition;\"above\"==position||\"below\"==position?originPosition={originX:\"center\",originY:\"above\"==position?\"top\":\"bottom\"}:\"before\"==position||\"left\"==position&&isLtr||\"right\"==position&&!isLtr?originPosition={originX:\"start\",originY:\"center\"}:(\"after\"==position||\"right\"==position&&isLtr||\"left\"==position&&!isLtr)&&(originPosition={originX:\"end\",originY:\"center\"});const{x:x,y:y}=this._invertPosition(originPosition.originX,originPosition.originY);return{main:originPosition,fallback:{originX:x,originY:y}}}_getOverlayPosition(){const isLtr=!this._dir||\"ltr\"==this._dir.value,position=this.position;let overlayPosition;\"above\"==position?overlayPosition={overlayX:\"center\",overlayY:\"bottom\"}:\"below\"==position?overlayPosition={overlayX:\"center\",overlayY:\"top\"}:\"before\"==position||\"left\"==position&&isLtr||\"right\"==position&&!isLtr?overlayPosition={overlayX:\"end\",overlayY:\"center\"}:(\"after\"==position||\"right\"==position&&isLtr||\"left\"==position&&!isLtr)&&(overlayPosition={overlayX:\"start\",overlayY:\"center\"});const{x:x,y:y}=this._invertPosition(overlayPosition.overlayX,overlayPosition.overlayY);return{main:overlayPosition,fallback:{overlayX:x,overlayY:y}}}_updateTooltipMessage(){this._tooltipInstance&&(this._tooltipInstance.message=this.message,this._tooltipInstance._markForCheck(),this._ngZone.onMicrotaskEmpty.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__.a)(1),Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_12__.a)(this._destroyed)).subscribe(()=>{this._tooltipInstance&&this._overlayRef.updatePosition()}))}_setTooltipClass(tooltipClass){this._tooltipInstance&&(this._tooltipInstance.tooltipClass=tooltipClass,this._tooltipInstance._markForCheck())}_invertPosition(x,y){return\"above\"===this.position||\"below\"===this.position?\"top\"===y?y=\"bottom\":\"bottom\"===y&&(y=\"top\"):\"end\"===x?x=\"start\":\"start\"===x&&(x=\"end\"),{x:x,y:y}}_setupPointerEnterEventsIfNeeded(){!this._disabled&&this.message&&this._viewInitialized&&!this._passiveListeners.length&&(this._platformSupportsMouseEvents()?this._passiveListeners.push([\"mouseenter\",()=>{this._setupPointerExitEventsIfNeeded(),this.show()}]):\"off\"!==this.touchGestures&&(this._disableNativeGesturesIfNecessary(),this._passiveListeners.push([\"touchstart\",()=>{this._setupPointerExitEventsIfNeeded(),clearTimeout(this._touchstartTimeout),this._touchstartTimeout=setTimeout(()=>this.show(),500)}])),this._addListeners(this._passiveListeners))}_setupPointerExitEventsIfNeeded(){if(this._pointerExitEventsInitialized)return;this._pointerExitEventsInitialized=!0;const exitListeners=[];if(this._platformSupportsMouseEvents())exitListeners.push([\"mouseleave\",()=>this.hide()]);else if(\"off\"!==this.touchGestures){this._disableNativeGesturesIfNecessary();const touchendListener=()=>{clearTimeout(this._touchstartTimeout),this.hide(this._defaultOptions.touchendHideDelay)};exitListeners.push([\"touchend\",touchendListener],[\"touchcancel\",touchendListener])}this._addListeners(exitListeners),this._passiveListeners.push(...exitListeners)}_addListeners(listeners){listeners.forEach(([event,listener])=>{this._elementRef.nativeElement.addEventListener(event,listener,passiveListenerOptions)})}_platformSupportsMouseEvents(){return!this._platform.IOS&&!this._platform.ANDROID}_disableNativeGesturesIfNecessary(){const gestures=this.touchGestures;if(\"off\"!==gestures){const element=this._elementRef.nativeElement,style=element.style;(\"on\"===gestures||\"INPUT\"!==element.nodeName&&\"TEXTAREA\"!==element.nodeName)&&(style.userSelect=style.msUserSelect=style.webkitUserSelect=style.MozUserSelect=\"none\"),\"on\"!==gestures&&element.draggable||(style.webkitUserDrag=\"none\"),style.touchAction=\"none\",style.webkitTapHighlightColor=\"transparent\"}}}return MatTooltip.ɵfac=function(t){return new(t||MatTooltip)(_angular_core__WEBPACK_IMPORTED_MODULE_3__.Pb(_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_0__.c),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Pb(_angular_core__WEBPACK_IMPORTED_MODULE_3__.l),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Pb(_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_5__.c),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Pb(_angular_core__WEBPACK_IMPORTED_MODULE_3__.S),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Pb(_angular_core__WEBPACK_IMPORTED_MODULE_3__.B),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Pb(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_9__.a),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Pb(_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__.c),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Pb(_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__.h),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Pb(MAT_TOOLTIP_SCROLL_STRATEGY),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Pb(_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_15__.b,8),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Pb(MAT_TOOLTIP_DEFAULT_OPTIONS,8))},MatTooltip.ɵdir=_angular_core__WEBPACK_IMPORTED_MODULE_3__.Kb({type:MatTooltip,selectors:[[\"\",\"matTooltip\",\"\"]],hostAttrs:[1,\"mat-tooltip-trigger\"],inputs:{showDelay:[\"matTooltipShowDelay\",\"showDelay\"],hideDelay:[\"matTooltipHideDelay\",\"hideDelay\"],touchGestures:[\"matTooltipTouchGestures\",\"touchGestures\"],position:[\"matTooltipPosition\",\"position\"],disabled:[\"matTooltipDisabled\",\"disabled\"],message:[\"matTooltip\",\"message\"],tooltipClass:[\"matTooltipClass\",\"tooltipClass\"]},exportAs:[\"matTooltip\"]}),MatTooltip})(),TooltipComponent=(()=>{class TooltipComponent{constructor(_changeDetectorRef,_breakpointObserver){this._changeDetectorRef=_changeDetectorRef,this._breakpointObserver=_breakpointObserver,this._visibility=\"initial\",this._closeOnInteraction=!1,this._onHide=new rxjs__WEBPACK_IMPORTED_MODULE_11__.a,this._isHandset=this._breakpointObserver.observe(_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_8__.b.Handset)}show(delay){this._hideTimeoutId&&(clearTimeout(this._hideTimeoutId),this._hideTimeoutId=null),this._closeOnInteraction=!0,this._showTimeoutId=setTimeout(()=>{this._visibility=\"visible\",this._showTimeoutId=null,this._markForCheck()},delay)}hide(delay){this._showTimeoutId&&(clearTimeout(this._showTimeoutId),this._showTimeoutId=null),this._hideTimeoutId=setTimeout(()=>{this._visibility=\"hidden\",this._hideTimeoutId=null,this._markForCheck()},delay)}afterHidden(){return this._onHide}isVisible(){return\"visible\"===this._visibility}ngOnDestroy(){this._onHide.complete()}_animationStart(){this._closeOnInteraction=!1}_animationDone(event){const toState=event.toState;\"hidden\"!==toState||this.isVisible()||this._onHide.next(),\"visible\"!==toState&&\"hidden\"!==toState||(this._closeOnInteraction=!0)}_handleBodyInteraction(){this._closeOnInteraction&&this.hide(0)}_markForCheck(){this._changeDetectorRef.markForCheck()}}return TooltipComponent.ɵfac=function(t){return new(t||TooltipComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_3__.Pb(_angular_core__WEBPACK_IMPORTED_MODULE_3__.h),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Pb(_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_8__.a))},TooltipComponent.ɵcmp=_angular_core__WEBPACK_IMPORTED_MODULE_3__.Jb({type:TooltipComponent,selectors:[[\"mat-tooltip-component\"]],hostAttrs:[\"aria-hidden\",\"true\"],hostVars:2,hostBindings:function(rf,ctx){1&rf&&_angular_core__WEBPACK_IMPORTED_MODULE_3__.gc(\"click\",function(){return ctx._handleBodyInteraction()},!1,_angular_core__WEBPACK_IMPORTED_MODULE_3__.yc),2&rf&&_angular_core__WEBPACK_IMPORTED_MODULE_3__.Hc(\"zoom\",\"visible\"===ctx._visibility?1:null)},decls:3,vars:7,consts:[[1,\"mat-tooltip\",3,\"ngClass\"]],template:function(rf,ctx){if(1&rf&&(_angular_core__WEBPACK_IMPORTED_MODULE_3__.Vb(0,\"div\",0),_angular_core__WEBPACK_IMPORTED_MODULE_3__.gc(\"@state.start\",function(){return ctx._animationStart()})(\"@state.done\",function($event){return ctx._animationDone($event)}),_angular_core__WEBPACK_IMPORTED_MODULE_3__.lc(1,\"async\"),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Mc(2),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Ub()),2&rf){let tmp_0_0=null;_angular_core__WEBPACK_IMPORTED_MODULE_3__.Hb(\"mat-tooltip-handset\",null==(tmp_0_0=_angular_core__WEBPACK_IMPORTED_MODULE_3__.mc(1,5,ctx._isHandset))?null:tmp_0_0.matches),_angular_core__WEBPACK_IMPORTED_MODULE_3__.pc(\"ngClass\",ctx.tooltipClass)(\"@state\",ctx._visibility),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Cb(2),_angular_core__WEBPACK_IMPORTED_MODULE_3__.Nc(ctx.message)}},directives:[_angular_common__WEBPACK_IMPORTED_MODULE_2__.j],pipes:[_angular_common__WEBPACK_IMPORTED_MODULE_2__.b],styles:[\".mat-tooltip-panel{pointer-events:none !important}.mat-tooltip{color:#fff;border-radius:4px;margin:14px;max-width:250px;padding-left:8px;padding-right:8px;overflow:hidden;text-overflow:ellipsis}.cdk-high-contrast-active .mat-tooltip{outline:solid 1px}.mat-tooltip-handset{margin:24px;padding-left:16px;padding-right:16px}\\n\"],encapsulation:2,data:{animation:[matTooltipAnimations.tooltipState]},changeDetection:0}),TooltipComponent})(),MatTooltipModule=(()=>{class MatTooltipModule{}return MatTooltipModule.ɵmod=_angular_core__WEBPACK_IMPORTED_MODULE_3__.Nb({type:MatTooltipModule}),MatTooltipModule.ɵinj=_angular_core__WEBPACK_IMPORTED_MODULE_3__.Mb({factory:function(t){return new(t||MatTooltipModule)},providers:[MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER],imports:[[_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__.a,_angular_common__WEBPACK_IMPORTED_MODULE_2__.c,_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_0__.f,_angular_material_core__WEBPACK_IMPORTED_MODULE_4__.i],_angular_material_core__WEBPACK_IMPORTED_MODULE_4__.i,_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_5__.b]}),MatTooltipModule})()}}]);","name":"0-es2015.909acba6cecb5a84f750.js","input":"(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[0],{\n\n/***/ \"Qu3c\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export MAT_TOOLTIP_DEFAULT_OPTIONS */\n/* unused harmony export MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY */\n/* unused harmony export MAT_TOOLTIP_SCROLL_STRATEGY */\n/* unused harmony export MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY */\n/* unused harmony export MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return MatTooltip; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return MatTooltipModule; });\n/* unused harmony export SCROLL_THROTTLE_MS */\n/* unused harmony export TOOLTIP_PANEL_CLASS */\n/* unused harmony export TooltipComponent */\n/* unused harmony export getMatTooltipInvalidPositionError */\n/* unused harmony export matTooltipAnimations */\n/* harmony import */ var _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"rDax\");\n/* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"u47x\");\n/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"ofXK\");\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"fXoL\");\n/* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"FKr1\");\n/* harmony import */ var _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"vxfF\");\n/* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(\"8LU1\");\n/* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(\"FtGj\");\n/* harmony import */ var _angular_cdk_layout__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(\"0MNC\");\n/* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(\"nLfN\");\n/* harmony import */ var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(\"+rOU\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(\"XNiG\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(\"1G5W\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(\"IzEk\");\n/* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(\"R0Ic\");\n/* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(\"cH1L\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Animations used by MatTooltip.\n * @docs-private\n */\n\n\n\n\n\n\n\n\nconst matTooltipAnimations = {\n    /** Animation that transitions a tooltip in and out. */\n    tooltipState: /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_14__[/* trigger */ \"m\"])('state', [\n        /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_14__[/* state */ \"j\"])('initial, void, hidden', /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_14__[/* style */ \"k\"])({ opacity: 0, transform: 'scale(0)' })),\n        /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_14__[/* state */ \"j\"])('visible', /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_14__[/* style */ \"k\"])({ transform: 'scale(1)' })),\n        /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_14__[/* transition */ \"l\"])('* => visible', /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_14__[/* animate */ \"e\"])('200ms cubic-bezier(0, 0, 0.2, 1)', /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_14__[/* keyframes */ \"g\"])([\n            /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_14__[/* style */ \"k\"])({ opacity: 0, transform: 'scale(0)', offset: 0 }),\n            /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_14__[/* style */ \"k\"])({ opacity: 0.5, transform: 'scale(0.99)', offset: 0.5 }),\n            /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_14__[/* style */ \"k\"])({ opacity: 1, transform: 'scale(1)', offset: 1 })\n        ]))),\n        /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_14__[/* transition */ \"l\"])('* => hidden', /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_14__[/* animate */ \"e\"])('100ms cubic-bezier(0, 0, 0.2, 1)', /*@__PURE__*/ Object(_angular_animations__WEBPACK_IMPORTED_MODULE_14__[/* style */ \"k\"])({ opacity: 0 }))),\n    ])\n};\n/** Time in ms to throttle repositioning after scroll events. */\nconst SCROLL_THROTTLE_MS = 20;\n/** CSS class that will be attached to the overlay panel. */\nconst TOOLTIP_PANEL_CLASS = 'mat-tooltip-panel';\n/** Options used to bind passive event listeners. */\nconst passiveListenerOptions = /*@__PURE__*/ Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_9__[/* normalizePassiveListenerOptions */ \"f\"])({ passive: true });\n/**\n * Time between the user putting the pointer on a tooltip\n * trigger and the long press event being fired.\n */\nconst LONGPRESS_DELAY = 500;\n/**\n * Creates an error to be thrown if the user supplied an invalid tooltip position.\n * @docs-private\n */\nfunction getMatTooltipInvalidPositionError(position) {\n    return Error(`Tooltip position \"${position}\" is invalid.`);\n}\n/** Injection token that determines the scroll handling while a tooltip is visible. */\nconst MAT_TOOLTIP_SCROLL_STRATEGY = /*@__PURE__*/ new _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* InjectionToken */ \"s\"]('mat-tooltip-scroll-strategy');\n/** @docs-private */\nfunction MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY(overlay) {\n    return () => overlay.scrollStrategies.reposition({ scrollThrottle: SCROLL_THROTTLE_MS });\n}\n/** @docs-private */\nconst MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n    provide: MAT_TOOLTIP_SCROLL_STRATEGY,\n    deps: [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_0__[/* Overlay */ \"c\"]],\n    useFactory: MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY,\n};\n/** Injection token to be used to override the default options for `matTooltip`. */\nconst MAT_TOOLTIP_DEFAULT_OPTIONS = /*@__PURE__*/ new _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* InjectionToken */ \"s\"]('mat-tooltip-default-options', {\n    providedIn: 'root',\n    factory: MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY\n});\n/** @docs-private */\nfunction MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY() {\n    return {\n        showDelay: 0,\n        hideDelay: 0,\n        touchendHideDelay: 1500,\n    };\n}\nlet MatTooltip = /*@__PURE__*/ (() => {\n    class MatTooltip {\n        constructor(_overlay, _elementRef, _scrollDispatcher, _viewContainerRef, _ngZone, _platform, _ariaDescriber, _focusMonitor, scrollStrategy, _dir, _defaultOptions) {\n            this._overlay = _overlay;\n            this._elementRef = _elementRef;\n            this._scrollDispatcher = _scrollDispatcher;\n            this._viewContainerRef = _viewContainerRef;\n            this._ngZone = _ngZone;\n            this._platform = _platform;\n            this._ariaDescriber = _ariaDescriber;\n            this._focusMonitor = _focusMonitor;\n            this._dir = _dir;\n            this._defaultOptions = _defaultOptions;\n            this._position = 'below';\n            this._disabled = false;\n            this._viewInitialized = false;\n            this._pointerExitEventsInitialized = false;\n            /** The default delay in ms before showing the tooltip after show is called */\n            this.showDelay = this._defaultOptions.showDelay;\n            /** The default delay in ms before hiding the tooltip after hide is called */\n            this.hideDelay = this._defaultOptions.hideDelay;\n            /**\n             * How touch gestures should be handled by the tooltip. On touch devices the tooltip directive\n             * uses a long press gesture to show and hide, however it can conflict with the native browser\n             * gestures. To work around the conflict, Angular Material disables native gestures on the\n             * trigger, but that might not be desirable on particular elements (e.g. inputs and draggable\n             * elements). The different values for this option configure the touch event handling as follows:\n             * - `auto` - Enables touch gestures for all elements, but tries to avoid conflicts with native\n             *   browser gestures on particular elements. In particular, it allows text selection on inputs\n             *   and textareas, and preserves the native browser dragging on elements marked as `draggable`.\n             * - `on` - Enables touch gestures for all elements and disables native\n             *   browser gestures with no exceptions.\n             * - `off` - Disables touch gestures. Note that this will prevent the tooltip from\n             *   showing on touch devices.\n             */\n            this.touchGestures = 'auto';\n            this._message = '';\n            /** Manually-bound passive event listeners. */\n            this._passiveListeners = [];\n            /** Emits when the component is destroyed. */\n            this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_11__[/* Subject */ \"a\"]();\n            /**\n             * Handles the keydown events on the host element.\n             * Needs to be an arrow function so that we can use it in addEventListener.\n             */\n            this._handleKeydown = (event) => {\n                if (this._isTooltipVisible() && event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_7__[/* ESCAPE */ \"h\"] && !Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_7__[/* hasModifierKey */ \"t\"])(event)) {\n                    event.preventDefault();\n                    event.stopPropagation();\n                    this._ngZone.run(() => this.hide(0));\n                }\n            };\n            this._scrollStrategy = scrollStrategy;\n            if (_defaultOptions) {\n                if (_defaultOptions.position) {\n                    this.position = _defaultOptions.position;\n                }\n                if (_defaultOptions.touchGestures) {\n                    this.touchGestures = _defaultOptions.touchGestures;\n                }\n            }\n            _ngZone.runOutsideAngular(() => {\n                _elementRef.nativeElement.addEventListener('keydown', this._handleKeydown);\n            });\n        }\n        /** Allows the user to define the position of the tooltip relative to the parent element */\n        get position() { return this._position; }\n        set position(value) {\n            if (value !== this._position) {\n                this._position = value;\n                if (this._overlayRef) {\n                    this._updatePosition();\n                    if (this._tooltipInstance) {\n                        this._tooltipInstance.show(0);\n                    }\n                    this._overlayRef.updatePosition();\n                }\n            }\n        }\n        /** Disables the display of the tooltip. */\n        get disabled() { return this._disabled; }\n        set disabled(value) {\n            this._disabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_6__[/* coerceBooleanProperty */ \"c\"])(value);\n            // If tooltip is disabled, hide immediately.\n            if (this._disabled) {\n                this.hide(0);\n            }\n            else {\n                this._setupPointerEnterEventsIfNeeded();\n            }\n        }\n        /** The message to be displayed in the tooltip */\n        get message() { return this._message; }\n        set message(value) {\n            this._ariaDescriber.removeDescription(this._elementRef.nativeElement, this._message);\n            // If the message is not a string (e.g. number), convert it to a string and trim it.\n            // Must convert with `String(value)`, not `${value}`, otherwise Closure Compiler optimises\n            // away the string-conversion: https://github.com/angular/components/issues/20684\n            this._message = value != null ? String(value).trim() : '';\n            if (!this._message && this._isTooltipVisible()) {\n                this.hide(0);\n            }\n            else {\n                this._setupPointerEnterEventsIfNeeded();\n                this._updateTooltipMessage();\n                this._ngZone.runOutsideAngular(() => {\n                    // The `AriaDescriber` has some functionality that avoids adding a description if it's the\n                    // same as the `aria-label` of an element, however we can't know whether the tooltip trigger\n                    // has a data-bound `aria-label` or when it'll be set for the first time. We can avoid the\n                    // issue by deferring the description by a tick so Angular has time to set the `aria-label`.\n                    Promise.resolve().then(() => {\n                        this._ariaDescriber.describe(this._elementRef.nativeElement, this.message);\n                    });\n                });\n            }\n        }\n        /** Classes to be passed to the tooltip. Supports the same syntax as `ngClass`. */\n        get tooltipClass() { return this._tooltipClass; }\n        set tooltipClass(value) {\n            this._tooltipClass = value;\n            if (this._tooltipInstance) {\n                this._setTooltipClass(this._tooltipClass);\n            }\n        }\n        ngAfterViewInit() {\n            // This needs to happen after view init so the initial values for all inputs have been set.\n            this._viewInitialized = true;\n            this._setupPointerEnterEventsIfNeeded();\n            this._focusMonitor.monitor(this._elementRef)\n                .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_12__[/* takeUntil */ \"a\"])(this._destroyed))\n                .subscribe(origin => {\n                // Note that the focus monitor runs outside the Angular zone.\n                if (!origin) {\n                    this._ngZone.run(() => this.hide(0));\n                }\n                else if (origin === 'keyboard') {\n                    this._ngZone.run(() => this.show());\n                }\n            });\n        }\n        /**\n         * Dispose the tooltip when destroyed.\n         */\n        ngOnDestroy() {\n            const nativeElement = this._elementRef.nativeElement;\n            clearTimeout(this._touchstartTimeout);\n            if (this._overlayRef) {\n                this._overlayRef.dispose();\n                this._tooltipInstance = null;\n            }\n            // Clean up the event listeners set in the constructor\n            nativeElement.removeEventListener('keydown', this._handleKeydown);\n            this._passiveListeners.forEach(([event, listener]) => {\n                nativeElement.removeEventListener(event, listener, passiveListenerOptions);\n            });\n            this._passiveListeners.length = 0;\n            this._destroyed.next();\n            this._destroyed.complete();\n            this._ariaDescriber.removeDescription(nativeElement, this.message);\n            this._focusMonitor.stopMonitoring(nativeElement);\n        }\n        /** Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input */\n        show(delay = this.showDelay) {\n            if (this.disabled || !this.message || (this._isTooltipVisible() &&\n                !this._tooltipInstance._showTimeoutId && !this._tooltipInstance._hideTimeoutId)) {\n                return;\n            }\n            const overlayRef = this._createOverlay();\n            this._detach();\n            this._portal = this._portal || new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_10__[/* ComponentPortal */ \"d\"](TooltipComponent, this._viewContainerRef);\n            this._tooltipInstance = overlayRef.attach(this._portal).instance;\n            this._tooltipInstance.afterHidden()\n                .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_12__[/* takeUntil */ \"a\"])(this._destroyed))\n                .subscribe(() => this._detach());\n            this._setTooltipClass(this._tooltipClass);\n            this._updateTooltipMessage();\n            this._tooltipInstance.show(delay);\n        }\n        /** Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input */\n        hide(delay = this.hideDelay) {\n            if (this._tooltipInstance) {\n                this._tooltipInstance.hide(delay);\n            }\n        }\n        /** Shows/hides the tooltip */\n        toggle() {\n            this._isTooltipVisible() ? this.hide() : this.show();\n        }\n        /** Returns true if the tooltip is currently visible to the user */\n        _isTooltipVisible() {\n            return !!this._tooltipInstance && this._tooltipInstance.isVisible();\n        }\n        /** Create the overlay config and position strategy */\n        _createOverlay() {\n            if (this._overlayRef) {\n                return this._overlayRef;\n            }\n            const scrollableAncestors = this._scrollDispatcher.getAncestorScrollContainers(this._elementRef);\n            // Create connected position strategy that listens for scroll events to reposition.\n            const strategy = this._overlay.position()\n                .flexibleConnectedTo(this._elementRef)\n                .withTransformOriginOn('.mat-tooltip')\n                .withFlexibleDimensions(false)\n                .withViewportMargin(8)\n                .withScrollableContainers(scrollableAncestors);\n            strategy.positionChanges.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_12__[/* takeUntil */ \"a\"])(this._destroyed)).subscribe(change => {\n                if (this._tooltipInstance) {\n                    if (change.scrollableViewProperties.isOverlayClipped && this._tooltipInstance.isVisible()) {\n                        // After position changes occur and the overlay is clipped by\n                        // a parent scrollable then close the tooltip.\n                        this._ngZone.run(() => this.hide(0));\n                    }\n                }\n            });\n            this._overlayRef = this._overlay.create({\n                direction: this._dir,\n                positionStrategy: strategy,\n                panelClass: TOOLTIP_PANEL_CLASS,\n                scrollStrategy: this._scrollStrategy()\n            });\n            this._updatePosition();\n            this._overlayRef.detachments()\n                .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_12__[/* takeUntil */ \"a\"])(this._destroyed))\n                .subscribe(() => this._detach());\n            return this._overlayRef;\n        }\n        /** Detaches the currently-attached tooltip. */\n        _detach() {\n            if (this._overlayRef && this._overlayRef.hasAttached()) {\n                this._overlayRef.detach();\n            }\n            this._tooltipInstance = null;\n        }\n        /** Updates the position of the current tooltip. */\n        _updatePosition() {\n            const position = this._overlayRef.getConfig().positionStrategy;\n            const origin = this._getOrigin();\n            const overlay = this._getOverlayPosition();\n            position.withPositions([\n                Object.assign(Object.assign({}, origin.main), overlay.main),\n                Object.assign(Object.assign({}, origin.fallback), overlay.fallback)\n            ]);\n        }\n        /**\n         * Returns the origin position and a fallback position based on the user's position preference.\n         * The fallback position is the inverse of the origin (e.g. `'below' -> 'above'`).\n         */\n        _getOrigin() {\n            const isLtr = !this._dir || this._dir.value == 'ltr';\n            const position = this.position;\n            let originPosition;\n            if (position == 'above' || position == 'below') {\n                originPosition = { originX: 'center', originY: position == 'above' ? 'top' : 'bottom' };\n            }\n            else if (position == 'before' ||\n                (position == 'left' && isLtr) ||\n                (position == 'right' && !isLtr)) {\n                originPosition = { originX: 'start', originY: 'center' };\n            }\n            else if (position == 'after' ||\n                (position == 'right' && isLtr) ||\n                (position == 'left' && !isLtr)) {\n                originPosition = { originX: 'end', originY: 'center' };\n            }\n            else if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                throw getMatTooltipInvalidPositionError(position);\n            }\n            const { x, y } = this._invertPosition(originPosition.originX, originPosition.originY);\n            return {\n                main: originPosition,\n                fallback: { originX: x, originY: y }\n            };\n        }\n        /** Returns the overlay position and a fallback position based on the user's preference */\n        _getOverlayPosition() {\n            const isLtr = !this._dir || this._dir.value == 'ltr';\n            const position = this.position;\n            let overlayPosition;\n            if (position == 'above') {\n                overlayPosition = { overlayX: 'center', overlayY: 'bottom' };\n            }\n            else if (position == 'below') {\n                overlayPosition = { overlayX: 'center', overlayY: 'top' };\n            }\n            else if (position == 'before' ||\n                (position == 'left' && isLtr) ||\n                (position == 'right' && !isLtr)) {\n                overlayPosition = { overlayX: 'end', overlayY: 'center' };\n            }\n            else if (position == 'after' ||\n                (position == 'right' && isLtr) ||\n                (position == 'left' && !isLtr)) {\n                overlayPosition = { overlayX: 'start', overlayY: 'center' };\n            }\n            else if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                throw getMatTooltipInvalidPositionError(position);\n            }\n            const { x, y } = this._invertPosition(overlayPosition.overlayX, overlayPosition.overlayY);\n            return {\n                main: overlayPosition,\n                fallback: { overlayX: x, overlayY: y }\n            };\n        }\n        /** Updates the tooltip message and repositions the overlay according to the new message length */\n        _updateTooltipMessage() {\n            // Must wait for the message to be painted to the tooltip so that the overlay can properly\n            // calculate the correct positioning based on the size of the text.\n            if (this._tooltipInstance) {\n                this._tooltipInstance.message = this.message;\n                this._tooltipInstance._markForCheck();\n                this._ngZone.onMicrotaskEmpty.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_13__[/* take */ \"a\"])(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_12__[/* takeUntil */ \"a\"])(this._destroyed)).subscribe(() => {\n                    if (this._tooltipInstance) {\n                        this._overlayRef.updatePosition();\n                    }\n                });\n            }\n        }\n        /** Updates the tooltip class */\n        _setTooltipClass(tooltipClass) {\n            if (this._tooltipInstance) {\n                this._tooltipInstance.tooltipClass = tooltipClass;\n                this._tooltipInstance._markForCheck();\n            }\n        }\n        /** Inverts an overlay position. */\n        _invertPosition(x, y) {\n            if (this.position === 'above' || this.position === 'below') {\n                if (y === 'top') {\n                    y = 'bottom';\n                }\n                else if (y === 'bottom') {\n                    y = 'top';\n                }\n            }\n            else {\n                if (x === 'end') {\n                    x = 'start';\n                }\n                else if (x === 'start') {\n                    x = 'end';\n                }\n            }\n            return { x, y };\n        }\n        /** Binds the pointer events to the tooltip trigger. */\n        _setupPointerEnterEventsIfNeeded() {\n            // Optimization: Defer hooking up events if there's no message or the tooltip is disabled.\n            if (this._disabled || !this.message || !this._viewInitialized ||\n                this._passiveListeners.length) {\n                return;\n            }\n            // The mouse events shouldn't be bound on mobile devices, because they can prevent the\n            // first tap from firing its click event or can cause the tooltip to open for clicks.\n            if (this._platformSupportsMouseEvents()) {\n                this._passiveListeners\n                    .push(['mouseenter', () => {\n                        this._setupPointerExitEventsIfNeeded();\n                        this.show();\n                    }]);\n            }\n            else if (this.touchGestures !== 'off') {\n                this._disableNativeGesturesIfNecessary();\n                this._passiveListeners\n                    .push(['touchstart', () => {\n                        // Note that it's important that we don't `preventDefault` here,\n                        // because it can prevent click events from firing on the element.\n                        this._setupPointerExitEventsIfNeeded();\n                        clearTimeout(this._touchstartTimeout);\n                        this._touchstartTimeout = setTimeout(() => this.show(), LONGPRESS_DELAY);\n                    }]);\n            }\n            this._addListeners(this._passiveListeners);\n        }\n        _setupPointerExitEventsIfNeeded() {\n            if (this._pointerExitEventsInitialized) {\n                return;\n            }\n            this._pointerExitEventsInitialized = true;\n            const exitListeners = [];\n            if (this._platformSupportsMouseEvents()) {\n                exitListeners.push(['mouseleave', () => this.hide()]);\n            }\n            else if (this.touchGestures !== 'off') {\n                this._disableNativeGesturesIfNecessary();\n                const touchendListener = () => {\n                    clearTimeout(this._touchstartTimeout);\n                    this.hide(this._defaultOptions.touchendHideDelay);\n                };\n                exitListeners.push(['touchend', touchendListener], ['touchcancel', touchendListener]);\n            }\n            this._addListeners(exitListeners);\n            this._passiveListeners.push(...exitListeners);\n        }\n        _addListeners(listeners) {\n            listeners.forEach(([event, listener]) => {\n                this._elementRef.nativeElement.addEventListener(event, listener, passiveListenerOptions);\n            });\n        }\n        _platformSupportsMouseEvents() {\n            return !this._platform.IOS && !this._platform.ANDROID;\n        }\n        /** Disables the native browser gestures, based on how the tooltip has been configured. */\n        _disableNativeGesturesIfNecessary() {\n            const gestures = this.touchGestures;\n            if (gestures !== 'off') {\n                const element = this._elementRef.nativeElement;\n                const style = element.style;\n                // If gestures are set to `auto`, we don't disable text selection on inputs and\n                // textareas, because it prevents the user from typing into them on iOS Safari.\n                if (gestures === 'on' || (element.nodeName !== 'INPUT' && element.nodeName !== 'TEXTAREA')) {\n                    style.userSelect = style.msUserSelect = style.webkitUserSelect =\n                        style.MozUserSelect = 'none';\n                }\n                // If we have `auto` gestures and the element uses native HTML dragging,\n                // we don't set `-webkit-user-drag` because it prevents the native behavior.\n                if (gestures === 'on' || !element.draggable) {\n                    style.webkitUserDrag = 'none';\n                }\n                style.touchAction = 'none';\n                style.webkitTapHighlightColor = 'transparent';\n            }\n        }\n    }\n    MatTooltip.ɵfac = function MatTooltip_Factory(t) { return new (t || MatTooltip)(_angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Pb\"](_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_0__[/* Overlay */ \"c\"]), _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Pb\"](_angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ElementRef */ \"l\"]), _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Pb\"](_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_5__[/* ScrollDispatcher */ \"c\"]), _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Pb\"](_angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ViewContainerRef */ \"S\"]), _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Pb\"](_angular_core__WEBPACK_IMPORTED_MODULE_3__[/* NgZone */ \"B\"]), _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Pb\"](_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_9__[/* Platform */ \"a\"]), _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Pb\"](_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__[/* AriaDescriber */ \"c\"]), _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Pb\"](_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__[/* FocusMonitor */ \"h\"]), _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Pb\"](MAT_TOOLTIP_SCROLL_STRATEGY), _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Pb\"](_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_15__[/* Directionality */ \"b\"], 8), _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Pb\"](MAT_TOOLTIP_DEFAULT_OPTIONS, 8)); };\n    MatTooltip.ɵdir = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdefineDirective */ \"Kb\"]({ type: MatTooltip, selectors: [[\"\", \"matTooltip\", \"\"]], hostAttrs: [1, \"mat-tooltip-trigger\"], inputs: { showDelay: [\"matTooltipShowDelay\", \"showDelay\"], hideDelay: [\"matTooltipHideDelay\", \"hideDelay\"], touchGestures: [\"matTooltipTouchGestures\", \"touchGestures\"], position: [\"matTooltipPosition\", \"position\"], disabled: [\"matTooltipDisabled\", \"disabled\"], message: [\"matTooltip\", \"message\"], tooltipClass: [\"matTooltipClass\", \"tooltipClass\"] }, exportAs: [\"matTooltip\"] });\n    return MatTooltip;\n})();\nlet TooltipComponent = /*@__PURE__*/ (() => {\n    class TooltipComponent {\n        constructor(_changeDetectorRef, _breakpointObserver) {\n            this._changeDetectorRef = _changeDetectorRef;\n            this._breakpointObserver = _breakpointObserver;\n            /** Property watched by the animation framework to show or hide the tooltip */\n            this._visibility = 'initial';\n            /** Whether interactions on the page should close the tooltip */\n            this._closeOnInteraction = false;\n            /** Subject for notifying that the tooltip has been hidden from the view */\n            this._onHide = new rxjs__WEBPACK_IMPORTED_MODULE_11__[/* Subject */ \"a\"]();\n            /** Stream that emits whether the user has a handset-sized display.  */\n            this._isHandset = this._breakpointObserver.observe(_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_8__[/* Breakpoints */ \"b\"].Handset);\n        }\n        /**\n         * Shows the tooltip with an animation originating from the provided origin\n         * @param delay Amount of milliseconds to the delay showing the tooltip.\n         */\n        show(delay) {\n            // Cancel the delayed hide if it is scheduled\n            if (this._hideTimeoutId) {\n                clearTimeout(this._hideTimeoutId);\n                this._hideTimeoutId = null;\n            }\n            // Body interactions should cancel the tooltip if there is a delay in showing.\n            this._closeOnInteraction = true;\n            this._showTimeoutId = setTimeout(() => {\n                this._visibility = 'visible';\n                this._showTimeoutId = null;\n                // Mark for check so if any parent component has set the\n                // ChangeDetectionStrategy to OnPush it will be checked anyways\n                this._markForCheck();\n            }, delay);\n        }\n        /**\n         * Begins the animation to hide the tooltip after the provided delay in ms.\n         * @param delay Amount of milliseconds to delay showing the tooltip.\n         */\n        hide(delay) {\n            // Cancel the delayed show if it is scheduled\n            if (this._showTimeoutId) {\n                clearTimeout(this._showTimeoutId);\n                this._showTimeoutId = null;\n            }\n            this._hideTimeoutId = setTimeout(() => {\n                this._visibility = 'hidden';\n                this._hideTimeoutId = null;\n                // Mark for check so if any parent component has set the\n                // ChangeDetectionStrategy to OnPush it will be checked anyways\n                this._markForCheck();\n            }, delay);\n        }\n        /** Returns an observable that notifies when the tooltip has been hidden from view. */\n        afterHidden() {\n            return this._onHide;\n        }\n        /** Whether the tooltip is being displayed. */\n        isVisible() {\n            return this._visibility === 'visible';\n        }\n        ngOnDestroy() {\n            this._onHide.complete();\n        }\n        _animationStart() {\n            this._closeOnInteraction = false;\n        }\n        _animationDone(event) {\n            const toState = event.toState;\n            if (toState === 'hidden' && !this.isVisible()) {\n                this._onHide.next();\n            }\n            if (toState === 'visible' || toState === 'hidden') {\n                this._closeOnInteraction = true;\n            }\n        }\n        /**\n         * Interactions on the HTML body should close the tooltip immediately as defined in the\n         * material design spec.\n         * https://material.io/design/components/tooltips.html#behavior\n         */\n        _handleBodyInteraction() {\n            if (this._closeOnInteraction) {\n                this.hide(0);\n            }\n        }\n        /**\n         * Marks that the tooltip needs to be checked in the next change detection run.\n         * Mainly used for rendering the initial text before positioning a tooltip, which\n         * can be problematic in components with OnPush change detection.\n         */\n        _markForCheck() {\n            this._changeDetectorRef.markForCheck();\n        }\n    }\n    TooltipComponent.ɵfac = function TooltipComponent_Factory(t) { return new (t || TooltipComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Pb\"](_angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ChangeDetectorRef */ \"h\"]), _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdirectiveInject */ \"Pb\"](_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_8__[/* BreakpointObserver */ \"a\"])); };\n    TooltipComponent.ɵcmp = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdefineComponent */ \"Jb\"]({ type: TooltipComponent, selectors: [[\"mat-tooltip-component\"]], hostAttrs: [\"aria-hidden\", \"true\"], hostVars: 2, hostBindings: function TooltipComponent_HostBindings(rf, ctx) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵlistener */ \"gc\"](\"click\", function TooltipComponent_click_HostBindingHandler() { return ctx._handleBodyInteraction(); }, false, _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵresolveBody */ \"yc\"]);\n            }\n            if (rf & 2) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵstyleProp */ \"Hc\"](\"zoom\", ctx._visibility === \"visible\" ? 1 : null);\n            }\n        }, decls: 3, vars: 7, consts: [[1, \"mat-tooltip\", 3, \"ngClass\"]], template: function TooltipComponent_Template(rf, ctx) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵelementStart */ \"Vb\"](0, \"div\", 0);\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵlistener */ \"gc\"](\"@state.start\", function TooltipComponent_Template_div_animation_state_start_0_listener() { return ctx._animationStart(); })(\"@state.done\", function TooltipComponent_Template_div_animation_state_done_0_listener($event) { return ctx._animationDone($event); });\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵpipe */ \"lc\"](1, \"async\");\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵtext */ \"Mc\"](2);\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵelementEnd */ \"Ub\"]();\n            }\n            if (rf & 2) {\n                let tmp_0_0 = null;\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵclassProp */ \"Hb\"](\"mat-tooltip-handset\", (tmp_0_0 = _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵpipeBind1 */ \"mc\"](1, 5, ctx._isHandset)) == null ? null : tmp_0_0.matches);\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵproperty */ \"pc\"](\"ngClass\", ctx.tooltipClass)(\"@state\", ctx._visibility);\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵadvance */ \"Cb\"](2);\n                _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵtextInterpolate */ \"Nc\"](ctx.message);\n            }\n        }, directives: [_angular_common__WEBPACK_IMPORTED_MODULE_2__[/* NgClass */ \"j\"]], pipes: [_angular_common__WEBPACK_IMPORTED_MODULE_2__[/* AsyncPipe */ \"b\"]], styles: [\".mat-tooltip-panel{pointer-events:none !important}.mat-tooltip{color:#fff;border-radius:4px;margin:14px;max-width:250px;padding-left:8px;padding-right:8px;overflow:hidden;text-overflow:ellipsis}.cdk-high-contrast-active .mat-tooltip{outline:solid 1px}.mat-tooltip-handset{margin:24px;padding-left:16px;padding-right:16px}\\n\"], encapsulation: 2, data: { animation: [matTooltipAnimations.tooltipState] }, changeDetection: 0 });\n    return TooltipComponent;\n})();\nlet MatTooltipModule = /*@__PURE__*/ (() => {\n    class MatTooltipModule {\n    }\n    MatTooltipModule.ɵmod = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdefineNgModule */ \"Nb\"]({ type: MatTooltipModule });\n    MatTooltipModule.ɵinj = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵdefineInjector */ \"Mb\"]({ factory: function MatTooltipModule_Factory(t) { return new (t || MatTooltipModule)(); }, providers: [MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER], imports: [[\n                _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__[/* A11yModule */ \"a\"],\n                _angular_common__WEBPACK_IMPORTED_MODULE_2__[/* CommonModule */ \"c\"],\n                _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_0__[/* OverlayModule */ \"f\"],\n                _angular_material_core__WEBPACK_IMPORTED_MODULE_4__[/* MatCommonModule */ \"i\"],\n            ], _angular_material_core__WEBPACK_IMPORTED_MODULE_4__[/* MatCommonModule */ \"i\"], _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_5__[/* CdkScrollableModule */ \"b\"]] });\n    return MatTooltipModule;\n})();\n/*@__PURE__*/ (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_3__[/* ɵɵsetNgModuleScope */ \"Ec\"](MatTooltipModule, { declarations: function () { return [MatTooltip, TooltipComponent]; }, imports: function () {\n            return [_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_1__[/* A11yModule */ \"a\"],\n                _angular_common__WEBPACK_IMPORTED_MODULE_2__[/* CommonModule */ \"c\"],\n                _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_0__[/* OverlayModule */ \"f\"],\n                _angular_material_core__WEBPACK_IMPORTED_MODULE_4__[/* MatCommonModule */ \"i\"]];\n        }, exports: function () { return [MatTooltip, TooltipComponent, _angular_material_core__WEBPACK_IMPORTED_MODULE_4__[/* MatCommonModule */ \"i\"], _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_5__[/* CdkScrollableModule */ \"b\"]]; } });\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=tooltip.js.map\n\n\n/***/ })\n\n}]);","inputSourceMap":null}