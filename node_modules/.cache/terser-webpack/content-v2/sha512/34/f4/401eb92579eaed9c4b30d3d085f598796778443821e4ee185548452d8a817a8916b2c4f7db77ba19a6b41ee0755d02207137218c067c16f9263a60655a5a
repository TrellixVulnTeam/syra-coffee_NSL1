{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{\"+0xr\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return table_MatCell}),__webpack_require__.d(__webpack_exports__,\"b\",function(){return table_MatCellDef}),__webpack_require__.d(__webpack_exports__,\"c\",function(){return table_MatColumnDef}),__webpack_require__.d(__webpack_exports__,\"d\",function(){return table_MatFooterCell}),__webpack_require__.d(__webpack_exports__,\"e\",function(){return table_MatFooterCellDef}),__webpack_require__.d(__webpack_exports__,\"f\",function(){return table_MatFooterRow}),__webpack_require__.d(__webpack_exports__,\"g\",function(){return table_MatFooterRowDef}),__webpack_require__.d(__webpack_exports__,\"h\",function(){return table_MatHeaderCell}),__webpack_require__.d(__webpack_exports__,\"i\",function(){return table_MatHeaderCellDef}),__webpack_require__.d(__webpack_exports__,\"j\",function(){return table_MatHeaderRow}),__webpack_require__.d(__webpack_exports__,\"k\",function(){return table_MatHeaderRowDef}),__webpack_require__.d(__webpack_exports__,\"l\",function(){return table_MatRow}),__webpack_require__.d(__webpack_exports__,\"m\",function(){return table_MatRowDef}),__webpack_require__.d(__webpack_exports__,\"n\",function(){return table_MatTable}),__webpack_require__.d(__webpack_exports__,\"o\",function(){return table_MatTableDataSource}),__webpack_require__.d(__webpack_exports__,\"p\",function(){return table_MatTableModule});var coercion=__webpack_require__(\"8LU1\"),collections=__webpack_require__(\"0EQZ\"),core=__webpack_require__(\"fXoL\"),bidi=__webpack_require__(\"cH1L\"),platform=__webpack_require__(\"nLfN\"),scrolling=__webpack_require__(\"vxfF\"),common=__webpack_require__(\"ofXK\"),Subject=__webpack_require__(\"XNiG\"),from=__webpack_require__(\"Cfvw\"),BehaviorSubject=__webpack_require__(\"2Vo4\"),isObservable=__webpack_require__(\"7+OI\"),of=__webpack_require__(\"LRne\"),takeUntil=__webpack_require__(\"1G5W\"),take=__webpack_require__(\"IzEk\");const _c0=[[[\"caption\"]],[[\"colgroup\"],[\"col\"]]],_c1=[\"caption\",\"colgroup, col\"];function mixinHasStickyInput(base){return class extends base{constructor(...args){super(...args),this._sticky=!1,this._hasStickyChanged=!1}get sticky(){return this._sticky}set sticky(v){const prevValue=this._sticky;this._sticky=Object(coercion.c)(v),this._hasStickyChanged=prevValue!==this._sticky}hasStickyChanged(){const hasStickyChanged=this._hasStickyChanged;return this._hasStickyChanged=!1,hasStickyChanged}resetStickyChanged(){this._hasStickyChanged=!1}}}const CDK_TABLE=new core.s(\"CDK_TABLE\");let table_CdkCellDef=(()=>{class CdkCellDef{constructor(template){this.template=template}}return CdkCellDef.ɵfac=function(t){return new(t||CdkCellDef)(core.Pb(core.O))},CdkCellDef.ɵdir=core.Kb({type:CdkCellDef,selectors:[[\"\",\"cdkCellDef\",\"\"]]}),CdkCellDef})(),table_CdkHeaderCellDef=(()=>{class CdkHeaderCellDef{constructor(template){this.template=template}}return CdkHeaderCellDef.ɵfac=function(t){return new(t||CdkHeaderCellDef)(core.Pb(core.O))},CdkHeaderCellDef.ɵdir=core.Kb({type:CdkHeaderCellDef,selectors:[[\"\",\"cdkHeaderCellDef\",\"\"]]}),CdkHeaderCellDef})(),table_CdkFooterCellDef=(()=>{class CdkFooterCellDef{constructor(template){this.template=template}}return CdkFooterCellDef.ɵfac=function(t){return new(t||CdkFooterCellDef)(core.Pb(core.O))},CdkFooterCellDef.ɵdir=core.Kb({type:CdkFooterCellDef,selectors:[[\"\",\"cdkFooterCellDef\",\"\"]]}),CdkFooterCellDef})();class CdkColumnDefBase{}const _CdkColumnDefBase=mixinHasStickyInput(CdkColumnDefBase);let table_CdkColumnDef=(()=>{class CdkColumnDef extends _CdkColumnDefBase{constructor(_table){super(),this._table=_table,this._stickyEnd=!1}get name(){return this._name}set name(name){this._setNameInput(name)}get stickyEnd(){return this._stickyEnd}set stickyEnd(v){const prevValue=this._stickyEnd;this._stickyEnd=Object(coercion.c)(v),this._hasStickyChanged=prevValue!==this._stickyEnd}_updateColumnCssClassName(){this._columnCssClassName=[\"cdk-column-\"+this.cssClassFriendlyName]}_setNameInput(value){value&&(this._name=value,this.cssClassFriendlyName=value.replace(/[^a-z0-9_-]/gi,\"-\"),this._updateColumnCssClassName())}}return CdkColumnDef.ɵfac=function(t){return new(t||CdkColumnDef)(core.Pb(CDK_TABLE,8))},CdkColumnDef.ɵdir=core.Kb({type:CdkColumnDef,selectors:[[\"\",\"cdkColumnDef\",\"\"]],contentQueries:function(rf,ctx,dirIndex){if(1&rf&&(core.Ib(dirIndex,table_CdkCellDef,!0),core.Ib(dirIndex,table_CdkHeaderCellDef,!0),core.Ib(dirIndex,table_CdkFooterCellDef,!0)),2&rf){let _t;core.wc(_t=core.hc())&&(ctx.cell=_t.first),core.wc(_t=core.hc())&&(ctx.headerCell=_t.first),core.wc(_t=core.hc())&&(ctx.footerCell=_t.first)}},inputs:{sticky:\"sticky\",name:[\"cdkColumnDef\",\"name\"],stickyEnd:\"stickyEnd\"},features:[core.Bb([{provide:\"MAT_SORT_HEADER_COLUMN_DEF\",useExisting:CdkColumnDef}]),core.zb]}),CdkColumnDef})();class BaseCdkCell{constructor(columnDef,elementRef){const classList=elementRef.nativeElement.classList;for(const className of columnDef._columnCssClassName)classList.add(className)}}let table_CdkHeaderCell=(()=>{class CdkHeaderCell extends BaseCdkCell{constructor(columnDef,elementRef){super(columnDef,elementRef)}}return CdkHeaderCell.ɵfac=function(t){return new(t||CdkHeaderCell)(core.Pb(table_CdkColumnDef),core.Pb(core.l))},CdkHeaderCell.ɵdir=core.Kb({type:CdkHeaderCell,selectors:[[\"cdk-header-cell\"],[\"th\",\"cdk-header-cell\",\"\"]],hostAttrs:[\"role\",\"columnheader\",1,\"cdk-header-cell\"],features:[core.zb]}),CdkHeaderCell})(),table_CdkFooterCell=(()=>{class CdkFooterCell extends BaseCdkCell{constructor(columnDef,elementRef){super(columnDef,elementRef)}}return CdkFooterCell.ɵfac=function(t){return new(t||CdkFooterCell)(core.Pb(table_CdkColumnDef),core.Pb(core.l))},CdkFooterCell.ɵdir=core.Kb({type:CdkFooterCell,selectors:[[\"cdk-footer-cell\"],[\"td\",\"cdk-footer-cell\",\"\"]],hostAttrs:[\"role\",\"gridcell\",1,\"cdk-footer-cell\"],features:[core.zb]}),CdkFooterCell})(),table_CdkCell=(()=>{class CdkCell extends BaseCdkCell{constructor(columnDef,elementRef){super(columnDef,elementRef)}}return CdkCell.ɵfac=function(t){return new(t||CdkCell)(core.Pb(table_CdkColumnDef),core.Pb(core.l))},CdkCell.ɵdir=core.Kb({type:CdkCell,selectors:[[\"cdk-cell\"],[\"td\",\"cdk-cell\",\"\"]],hostAttrs:[\"role\",\"gridcell\",1,\"cdk-cell\"],features:[core.zb]}),CdkCell})();class _Schedule{constructor(){this.tasks=[],this.endTasks=[]}}const _COALESCED_STYLE_SCHEDULER=new core.s(\"_COALESCED_STYLE_SCHEDULER\");let table_CoalescedStyleScheduler=(()=>{class _CoalescedStyleScheduler{constructor(_ngZone){this._ngZone=_ngZone,this._currentSchedule=null,this._destroyed=new Subject.a}schedule(task){this._createScheduleIfNeeded(),this._currentSchedule.tasks.push(task)}scheduleEnd(task){this._createScheduleIfNeeded(),this._currentSchedule.endTasks.push(task)}ngOnDestroy(){this._destroyed.next(),this._destroyed.complete()}_createScheduleIfNeeded(){this._currentSchedule||(this._currentSchedule=new _Schedule,this._getScheduleObservable().pipe(Object(takeUntil.a)(this._destroyed)).subscribe(()=>{for(;this._currentSchedule.tasks.length||this._currentSchedule.endTasks.length;){const schedule=this._currentSchedule;this._currentSchedule=new _Schedule;for(const task of schedule.tasks)task();for(const task of schedule.endTasks)task()}this._currentSchedule=null}))}_getScheduleObservable(){return this._ngZone.isStable?Object(from.a)(Promise.resolve(void 0)):this._ngZone.onStable.pipe(Object(take.a)(1))}}return _CoalescedStyleScheduler.ɵfac=function(t){return new(t||_CoalescedStyleScheduler)(core.cc(core.B))},_CoalescedStyleScheduler.ɵprov=core.Lb({token:_CoalescedStyleScheduler,factory:_CoalescedStyleScheduler.ɵfac}),_CoalescedStyleScheduler})(),table_BaseRowDef=(()=>{class BaseRowDef{constructor(template,_differs){this.template=template,this._differs=_differs}ngOnChanges(changes){if(!this._columnsDiffer){const columns=changes.columns&&changes.columns.currentValue||[];this._columnsDiffer=this._differs.find(columns).create(),this._columnsDiffer.diff(columns)}}getColumnsDiff(){return this._columnsDiffer.diff(this.columns)}extractCellTemplate(column){return this instanceof table_CdkHeaderRowDef?column.headerCell.template:this instanceof table_CdkFooterRowDef?column.footerCell.template:column.cell.template}}return BaseRowDef.ɵfac=function(t){return new(t||BaseRowDef)(core.Pb(core.O),core.Pb(core.u))},BaseRowDef.ɵdir=core.Kb({type:BaseRowDef,features:[core.Ab]}),BaseRowDef})();class CdkHeaderRowDefBase extends table_BaseRowDef{}const _CdkHeaderRowDefBase=mixinHasStickyInput(CdkHeaderRowDefBase);let table_CdkHeaderRowDef=(()=>{class CdkHeaderRowDef extends _CdkHeaderRowDefBase{constructor(template,_differs,_table){super(template,_differs),this._table=_table}ngOnChanges(changes){super.ngOnChanges(changes)}}return CdkHeaderRowDef.ɵfac=function(t){return new(t||CdkHeaderRowDef)(core.Pb(core.O),core.Pb(core.u),core.Pb(CDK_TABLE,8))},CdkHeaderRowDef.ɵdir=core.Kb({type:CdkHeaderRowDef,selectors:[[\"\",\"cdkHeaderRowDef\",\"\"]],inputs:{columns:[\"cdkHeaderRowDef\",\"columns\"],sticky:[\"cdkHeaderRowDefSticky\",\"sticky\"]},features:[core.zb,core.Ab]}),CdkHeaderRowDef})();class CdkFooterRowDefBase extends table_BaseRowDef{}const _CdkFooterRowDefBase=mixinHasStickyInput(CdkFooterRowDefBase);let table_CdkFooterRowDef=(()=>{class CdkFooterRowDef extends _CdkFooterRowDefBase{constructor(template,_differs,_table){super(template,_differs),this._table=_table}ngOnChanges(changes){super.ngOnChanges(changes)}}return CdkFooterRowDef.ɵfac=function(t){return new(t||CdkFooterRowDef)(core.Pb(core.O),core.Pb(core.u),core.Pb(CDK_TABLE,8))},CdkFooterRowDef.ɵdir=core.Kb({type:CdkFooterRowDef,selectors:[[\"\",\"cdkFooterRowDef\",\"\"]],inputs:{columns:[\"cdkFooterRowDef\",\"columns\"],sticky:[\"cdkFooterRowDefSticky\",\"sticky\"]},features:[core.zb,core.Ab]}),CdkFooterRowDef})(),table_CdkRowDef=(()=>{class CdkRowDef extends table_BaseRowDef{constructor(template,_differs,_table){super(template,_differs),this._table=_table}}return CdkRowDef.ɵfac=function(t){return new(t||CdkRowDef)(core.Pb(core.O),core.Pb(core.u),core.Pb(CDK_TABLE,8))},CdkRowDef.ɵdir=core.Kb({type:CdkRowDef,selectors:[[\"\",\"cdkRowDef\",\"\"]],inputs:{columns:[\"cdkRowDefColumns\",\"columns\"],when:[\"cdkRowDefWhen\",\"when\"]},features:[core.zb]}),CdkRowDef})(),table_CdkCellOutlet=(()=>{class CdkCellOutlet{constructor(_viewContainer){this._viewContainer=_viewContainer,CdkCellOutlet.mostRecentCellOutlet=this}ngOnDestroy(){CdkCellOutlet.mostRecentCellOutlet===this&&(CdkCellOutlet.mostRecentCellOutlet=null)}}return CdkCellOutlet.ɵfac=function(t){return new(t||CdkCellOutlet)(core.Pb(core.S))},CdkCellOutlet.ɵdir=core.Kb({type:CdkCellOutlet,selectors:[[\"\",\"cdkCellOutlet\",\"\"]]}),CdkCellOutlet.mostRecentCellOutlet=null,CdkCellOutlet})(),table_CdkHeaderRow=(()=>{class CdkHeaderRow{}return CdkHeaderRow.ɵfac=function(t){return new(t||CdkHeaderRow)},CdkHeaderRow.ɵcmp=core.Jb({type:CdkHeaderRow,selectors:[[\"cdk-header-row\"],[\"tr\",\"cdk-header-row\",\"\"]],hostAttrs:[\"role\",\"row\",1,\"cdk-header-row\"],decls:1,vars:0,consts:[[\"cdkCellOutlet\",\"\"]],template:function(rf,ctx){1&rf&&core.Rb(0,0)},directives:[table_CdkCellOutlet],encapsulation:2}),CdkHeaderRow})(),table_CdkFooterRow=(()=>{class CdkFooterRow{}return CdkFooterRow.ɵfac=function(t){return new(t||CdkFooterRow)},CdkFooterRow.ɵcmp=core.Jb({type:CdkFooterRow,selectors:[[\"cdk-footer-row\"],[\"tr\",\"cdk-footer-row\",\"\"]],hostAttrs:[\"role\",\"row\",1,\"cdk-footer-row\"],decls:1,vars:0,consts:[[\"cdkCellOutlet\",\"\"]],template:function(rf,ctx){1&rf&&core.Rb(0,0)},directives:[table_CdkCellOutlet],encapsulation:2}),CdkFooterRow})(),table_CdkRow=(()=>{class CdkRow{}return CdkRow.ɵfac=function(t){return new(t||CdkRow)},CdkRow.ɵcmp=core.Jb({type:CdkRow,selectors:[[\"cdk-row\"],[\"tr\",\"cdk-row\",\"\"]],hostAttrs:[\"role\",\"row\",1,\"cdk-row\"],decls:1,vars:0,consts:[[\"cdkCellOutlet\",\"\"]],template:function(rf,ctx){1&rf&&core.Rb(0,0)},directives:[table_CdkCellOutlet],encapsulation:2}),CdkRow})(),table_CdkNoDataRow=(()=>{class CdkNoDataRow{constructor(templateRef){this.templateRef=templateRef}}return CdkNoDataRow.ɵfac=function(t){return new(t||CdkNoDataRow)(core.Pb(core.O))},CdkNoDataRow.ɵdir=core.Kb({type:CdkNoDataRow,selectors:[[\"ng-template\",\"cdkNoDataRow\",\"\"]]}),CdkNoDataRow})();const STICKY_DIRECTIONS=[\"top\",\"bottom\",\"left\",\"right\"];class StickyStyler{constructor(_isNativeHtmlTable,_stickCellCss,direction,_coalescedStyleScheduler,_isBrowser=!0,_needsPositionStickyOnElement=!0){this._isNativeHtmlTable=_isNativeHtmlTable,this._stickCellCss=_stickCellCss,this.direction=direction,this._coalescedStyleScheduler=_coalescedStyleScheduler,this._isBrowser=_isBrowser,this._needsPositionStickyOnElement=_needsPositionStickyOnElement,this._cachedCellWidths=[]}clearStickyPositioning(rows,stickyDirections){const elementsToClear=[];for(const row of rows)if(row.nodeType===row.ELEMENT_NODE){elementsToClear.push(row);for(let i=0;i<row.children.length;i++)elementsToClear.push(row.children[i])}this._scheduleStyleChanges(()=>{for(const element of elementsToClear)this._removeStickyStyle(element,stickyDirections)})}updateStickyColumns(rows,stickyStartStates,stickyEndStates,recalculateCellWidths=!0){if(!rows.length||!this._isBrowser||!stickyStartStates.some(state=>state)&&!stickyEndStates.some(state=>state))return;const firstRow=rows[0],numCells=firstRow.children.length,cellWidths=this._getCellWidths(firstRow,recalculateCellWidths),startPositions=this._getStickyStartColumnPositions(cellWidths,stickyStartStates),endPositions=this._getStickyEndColumnPositions(cellWidths,stickyEndStates);this._scheduleStyleChanges(()=>{const isRtl=\"rtl\"===this.direction,start=isRtl?\"right\":\"left\",end=isRtl?\"left\":\"right\";for(const row of rows)for(let i=0;i<numCells;i++){const cell=row.children[i];stickyStartStates[i]&&this._addStickyStyle(cell,start,startPositions[i]),stickyEndStates[i]&&this._addStickyStyle(cell,end,endPositions[i])}})}stickRows(rowsToStick,stickyStates,position){if(!this._isBrowser)return;const rows=\"bottom\"===position?rowsToStick.slice().reverse():rowsToStick,states=\"bottom\"===position?stickyStates.slice().reverse():stickyStates,stickyHeights=[],elementsToStick=[];for(let rowIndex=0,stickyHeight=0;rowIndex<rows.length;rowIndex++){if(stickyHeights[rowIndex]=stickyHeight,!states[rowIndex])continue;const row=rows[rowIndex];elementsToStick[rowIndex]=this._isNativeHtmlTable?Array.from(row.children):[row],rowIndex!==rows.length-1&&(stickyHeight+=row.getBoundingClientRect().height)}this._scheduleStyleChanges(()=>{for(let rowIndex=0;rowIndex<rows.length;rowIndex++){if(!states[rowIndex])continue;const height=stickyHeights[rowIndex];for(const element of elementsToStick[rowIndex])this._addStickyStyle(element,position,height)}})}updateStickyFooterContainer(tableElement,stickyStates){if(!this._isNativeHtmlTable)return;const tfoot=tableElement.querySelector(\"tfoot\");this._scheduleStyleChanges(()=>{stickyStates.some(state=>!state)?this._removeStickyStyle(tfoot,[\"bottom\"]):this._addStickyStyle(tfoot,\"bottom\",0)})}_removeStickyStyle(element,stickyDirections){for(const dir of stickyDirections)element.style[dir]=\"\";STICKY_DIRECTIONS.some(dir=>-1===stickyDirections.indexOf(dir)&&element.style[dir])?element.style.zIndex=this._getCalculatedZIndex(element):(element.style.zIndex=\"\",this._needsPositionStickyOnElement&&(element.style.position=\"\"),element.classList.remove(this._stickCellCss))}_addStickyStyle(element,dir,dirValue){element.classList.add(this._stickCellCss),element.style[dir]=dirValue+\"px\",element.style.zIndex=this._getCalculatedZIndex(element),this._needsPositionStickyOnElement&&(element.style.cssText+=\"position: -webkit-sticky; position: sticky; \")}_getCalculatedZIndex(element){const zIndexIncrements={top:100,bottom:10,left:1,right:1};let zIndex=0;for(const dir of STICKY_DIRECTIONS)element.style[dir]&&(zIndex+=zIndexIncrements[dir]);return zIndex?\"\"+zIndex:\"\"}_getCellWidths(row,recalculateCellWidths=!0){if(!recalculateCellWidths&&this._cachedCellWidths.length)return this._cachedCellWidths;const cellWidths=[],firstRowCells=row.children;for(let i=0;i<firstRowCells.length;i++)cellWidths.push(firstRowCells[i].getBoundingClientRect().width);return this._cachedCellWidths=cellWidths,cellWidths}_getStickyStartColumnPositions(widths,stickyStates){const positions=[];let nextPosition=0;for(let i=0;i<widths.length;i++)stickyStates[i]&&(positions[i]=nextPosition,nextPosition+=widths[i]);return positions}_getStickyEndColumnPositions(widths,stickyStates){const positions=[];let nextPosition=0;for(let i=widths.length;i>0;i--)stickyStates[i]&&(positions[i]=nextPosition,nextPosition+=widths[i]);return positions}_scheduleStyleChanges(changes){this._coalescedStyleScheduler?this._coalescedStyleScheduler.schedule(changes):changes()}}let table_DataRowOutlet=(()=>{class DataRowOutlet{constructor(viewContainer,elementRef){this.viewContainer=viewContainer,this.elementRef=elementRef}}return DataRowOutlet.ɵfac=function(t){return new(t||DataRowOutlet)(core.Pb(core.S),core.Pb(core.l))},DataRowOutlet.ɵdir=core.Kb({type:DataRowOutlet,selectors:[[\"\",\"rowOutlet\",\"\"]]}),DataRowOutlet})(),table_HeaderRowOutlet=(()=>{class HeaderRowOutlet{constructor(viewContainer,elementRef){this.viewContainer=viewContainer,this.elementRef=elementRef}}return HeaderRowOutlet.ɵfac=function(t){return new(t||HeaderRowOutlet)(core.Pb(core.S),core.Pb(core.l))},HeaderRowOutlet.ɵdir=core.Kb({type:HeaderRowOutlet,selectors:[[\"\",\"headerRowOutlet\",\"\"]]}),HeaderRowOutlet})(),table_FooterRowOutlet=(()=>{class FooterRowOutlet{constructor(viewContainer,elementRef){this.viewContainer=viewContainer,this.elementRef=elementRef}}return FooterRowOutlet.ɵfac=function(t){return new(t||FooterRowOutlet)(core.Pb(core.S),core.Pb(core.l))},FooterRowOutlet.ɵdir=core.Kb({type:FooterRowOutlet,selectors:[[\"\",\"footerRowOutlet\",\"\"]]}),FooterRowOutlet})(),table_NoDataRowOutlet=(()=>{class NoDataRowOutlet{constructor(viewContainer,elementRef){this.viewContainer=viewContainer,this.elementRef=elementRef}}return NoDataRowOutlet.ɵfac=function(t){return new(t||NoDataRowOutlet)(core.Pb(core.S),core.Pb(core.l))},NoDataRowOutlet.ɵdir=core.Kb({type:NoDataRowOutlet,selectors:[[\"\",\"noDataRowOutlet\",\"\"]]}),NoDataRowOutlet})(),table_CdkTable=(()=>{class CdkTable{constructor(_differs,_changeDetectorRef,_elementRef,role,_dir,_document,_platform,_viewRepeater,_coalescedStyleScheduler,_viewportRuler){this._differs=_differs,this._changeDetectorRef=_changeDetectorRef,this._elementRef=_elementRef,this._dir=_dir,this._platform=_platform,this._viewRepeater=_viewRepeater,this._coalescedStyleScheduler=_coalescedStyleScheduler,this._viewportRuler=_viewportRuler,this._onDestroy=new Subject.a,this._columnDefsByName=new Map,this._customColumnDefs=new Set,this._customRowDefs=new Set,this._customHeaderRowDefs=new Set,this._customFooterRowDefs=new Set,this._headerRowDefChanged=!0,this._footerRowDefChanged=!0,this._stickyColumnStylesNeedReset=!0,this._forceRecalculateCellWidths=!0,this._cachedRenderRowsMap=new Map,this.stickyCssClass=\"cdk-table-sticky\",this.needsPositionStickyOnElement=!0,this._isShowingNoDataRow=!1,this._multiTemplateDataRows=!1,this._fixedLayout=!1,this.viewChange=new BehaviorSubject.a({start:0,end:Number.MAX_VALUE}),role||this._elementRef.nativeElement.setAttribute(\"role\",\"grid\"),this._document=_document,this._isNativeHtmlTable=\"TABLE\"===this._elementRef.nativeElement.nodeName}get trackBy(){return this._trackByFn}set trackBy(fn){this._trackByFn=fn}get dataSource(){return this._dataSource}set dataSource(dataSource){this._dataSource!==dataSource&&this._switchDataSource(dataSource)}get multiTemplateDataRows(){return this._multiTemplateDataRows}set multiTemplateDataRows(v){this._multiTemplateDataRows=Object(coercion.c)(v),this._rowOutlet&&this._rowOutlet.viewContainer.length&&(this._forceRenderDataRows(),this.updateStickyColumnStyles())}get fixedLayout(){return this._fixedLayout}set fixedLayout(v){this._fixedLayout=Object(coercion.c)(v),this._forceRecalculateCellWidths=!0,this._stickyColumnStylesNeedReset=!0}ngOnInit(){this._setupStickyStyler(),this._isNativeHtmlTable&&this._applyNativeTableSections(),this._dataDiffer=this._differs.find([]).create((_i,dataRow)=>this.trackBy?this.trackBy(dataRow.dataIndex,dataRow.data):dataRow),this._viewportRuler&&this._viewportRuler.change().pipe(Object(takeUntil.a)(this._onDestroy)).subscribe(()=>{this._forceRecalculateCellWidths=!0})}ngAfterContentChecked(){this._cacheRowDefs(),this._cacheColumnDefs();const rowDefsChanged=this._renderUpdatedColumns()||this._headerRowDefChanged||this._footerRowDefChanged;this._stickyColumnStylesNeedReset=this._stickyColumnStylesNeedReset||rowDefsChanged,this._forceRecalculateCellWidths=rowDefsChanged,this._headerRowDefChanged&&(this._forceRenderHeaderRows(),this._headerRowDefChanged=!1),this._footerRowDefChanged&&(this._forceRenderFooterRows(),this._footerRowDefChanged=!1),this.dataSource&&this._rowDefs.length>0&&!this._renderChangeSubscription?this._observeRenderChanges():this._stickyColumnStylesNeedReset&&this.updateStickyColumnStyles(),this._checkStickyStates()}ngOnDestroy(){this._rowOutlet.viewContainer.clear(),this._noDataRowOutlet.viewContainer.clear(),this._headerRowOutlet.viewContainer.clear(),this._footerRowOutlet.viewContainer.clear(),this._cachedRenderRowsMap.clear(),this._onDestroy.next(),this._onDestroy.complete(),Object(collections.g)(this.dataSource)&&this.dataSource.disconnect(this)}renderRows(){this._renderRows=this._getAllRenderRows();const changes=this._dataDiffer.diff(this._renderRows);if(!changes)return void this._updateNoDataRow();const viewContainer=this._rowOutlet.viewContainer;this._viewRepeater?this._viewRepeater.applyChanges(changes,viewContainer,(record,_adjustedPreviousIndex,currentIndex)=>this._getEmbeddedViewArgs(record.item,currentIndex),record=>record.item.data,change=>{1===change.operation&&change.context&&this._renderCellTemplateForItem(change.record.item.rowDef,change.context)}):changes.forEachOperation((record,prevIndex,currentIndex)=>{if(null==record.previousIndex){const renderRow=record.item;this._renderRow(this._rowOutlet,renderRow.rowDef,currentIndex,{$implicit:renderRow.data})}else if(null==currentIndex)viewContainer.remove(prevIndex);else{const view=viewContainer.get(prevIndex);viewContainer.move(view,currentIndex)}}),this._updateRowIndexContext(),changes.forEachIdentityChange(record=>{viewContainer.get(record.currentIndex).context.$implicit=record.item.data}),this._updateNoDataRow(),this.updateStickyColumnStyles()}addColumnDef(columnDef){this._customColumnDefs.add(columnDef)}removeColumnDef(columnDef){this._customColumnDefs.delete(columnDef)}addRowDef(rowDef){this._customRowDefs.add(rowDef)}removeRowDef(rowDef){this._customRowDefs.delete(rowDef)}addHeaderRowDef(headerRowDef){this._customHeaderRowDefs.add(headerRowDef),this._headerRowDefChanged=!0}removeHeaderRowDef(headerRowDef){this._customHeaderRowDefs.delete(headerRowDef),this._headerRowDefChanged=!0}addFooterRowDef(footerRowDef){this._customFooterRowDefs.add(footerRowDef),this._footerRowDefChanged=!0}removeFooterRowDef(footerRowDef){this._customFooterRowDefs.delete(footerRowDef),this._footerRowDefChanged=!0}setNoDataRow(noDataRow){this._customNoDataRow=noDataRow}updateStickyHeaderRowStyles(){const headerRows=this._getRenderedRows(this._headerRowOutlet),thead=this._elementRef.nativeElement.querySelector(\"thead\");thead&&(thead.style.display=headerRows.length?\"\":\"none\");const stickyStates=this._headerRowDefs.map(def=>def.sticky);this._stickyStyler.clearStickyPositioning(headerRows,[\"top\"]),this._stickyStyler.stickRows(headerRows,stickyStates,\"top\"),this._headerRowDefs.forEach(def=>def.resetStickyChanged())}updateStickyFooterRowStyles(){const footerRows=this._getRenderedRows(this._footerRowOutlet),tfoot=this._elementRef.nativeElement.querySelector(\"tfoot\");tfoot&&(tfoot.style.display=footerRows.length?\"\":\"none\");const stickyStates=this._footerRowDefs.map(def=>def.sticky);this._stickyStyler.clearStickyPositioning(footerRows,[\"bottom\"]),this._stickyStyler.stickRows(footerRows,stickyStates,\"bottom\"),this._stickyStyler.updateStickyFooterContainer(this._elementRef.nativeElement,stickyStates),this._footerRowDefs.forEach(def=>def.resetStickyChanged())}updateStickyColumnStyles(){const headerRows=this._getRenderedRows(this._headerRowOutlet),dataRows=this._getRenderedRows(this._rowOutlet),footerRows=this._getRenderedRows(this._footerRowOutlet);(this._isNativeHtmlTable&&!this._fixedLayout||this._stickyColumnStylesNeedReset)&&(this._stickyStyler.clearStickyPositioning([...headerRows,...dataRows,...footerRows],[\"left\",\"right\"]),this._stickyColumnStylesNeedReset=!1),headerRows.forEach((headerRow,i)=>{this._addStickyColumnStyles([headerRow],this._headerRowDefs[i])}),this._rowDefs.forEach(rowDef=>{const rows=[];for(let i=0;i<dataRows.length;i++)this._renderRows[i].rowDef===rowDef&&rows.push(dataRows[i]);this._addStickyColumnStyles(rows,rowDef)}),footerRows.forEach((footerRow,i)=>{this._addStickyColumnStyles([footerRow],this._footerRowDefs[i])}),Array.from(this._columnDefsByName.values()).forEach(def=>def.resetStickyChanged())}_getAllRenderRows(){const renderRows=[],prevCachedRenderRows=this._cachedRenderRowsMap;this._cachedRenderRowsMap=new Map;for(let i=0;i<this._data.length;i++){let data=this._data[i];const renderRowsForData=this._getRenderRowsForData(data,i,prevCachedRenderRows.get(data));this._cachedRenderRowsMap.has(data)||this._cachedRenderRowsMap.set(data,new WeakMap);for(let j=0;j<renderRowsForData.length;j++){let renderRow=renderRowsForData[j];const cache=this._cachedRenderRowsMap.get(renderRow.data);cache.has(renderRow.rowDef)?cache.get(renderRow.rowDef).push(renderRow):cache.set(renderRow.rowDef,[renderRow]),renderRows.push(renderRow)}}return renderRows}_getRenderRowsForData(data,dataIndex,cache){return this._getRowDefs(data,dataIndex).map(rowDef=>{const cachedRenderRows=cache&&cache.has(rowDef)?cache.get(rowDef):[];if(cachedRenderRows.length){const dataRow=cachedRenderRows.shift();return dataRow.dataIndex=dataIndex,dataRow}return{data:data,rowDef:rowDef,dataIndex:dataIndex}})}_cacheColumnDefs(){this._columnDefsByName.clear(),mergeArrayAndSet(this._getOwnDefs(this._contentColumnDefs),this._customColumnDefs).forEach(columnDef=>{this._columnDefsByName.has(columnDef.name),this._columnDefsByName.set(columnDef.name,columnDef)})}_cacheRowDefs(){this._headerRowDefs=mergeArrayAndSet(this._getOwnDefs(this._contentHeaderRowDefs),this._customHeaderRowDefs),this._footerRowDefs=mergeArrayAndSet(this._getOwnDefs(this._contentFooterRowDefs),this._customFooterRowDefs),this._rowDefs=mergeArrayAndSet(this._getOwnDefs(this._contentRowDefs),this._customRowDefs);const defaultRowDefs=this._rowDefs.filter(def=>!def.when);this._defaultRowDef=defaultRowDefs[0]}_renderUpdatedColumns(){const columnsDiffReducer=(acc,def)=>acc||!!def.getColumnsDiff(),dataColumnsChanged=this._rowDefs.reduce(columnsDiffReducer,!1);dataColumnsChanged&&this._forceRenderDataRows();const headerColumnsChanged=this._headerRowDefs.reduce(columnsDiffReducer,!1);headerColumnsChanged&&this._forceRenderHeaderRows();const footerColumnsChanged=this._footerRowDefs.reduce(columnsDiffReducer,!1);return footerColumnsChanged&&this._forceRenderFooterRows(),dataColumnsChanged||headerColumnsChanged||footerColumnsChanged}_switchDataSource(dataSource){this._data=[],Object(collections.g)(this.dataSource)&&this.dataSource.disconnect(this),this._renderChangeSubscription&&(this._renderChangeSubscription.unsubscribe(),this._renderChangeSubscription=null),dataSource||(this._dataDiffer&&this._dataDiffer.diff([]),this._rowOutlet.viewContainer.clear()),this._dataSource=dataSource}_observeRenderChanges(){if(!this.dataSource)return;let dataStream;Object(collections.g)(this.dataSource)?dataStream=this.dataSource.connect(this):Object(isObservable.a)(this.dataSource)?dataStream=this.dataSource:Array.isArray(this.dataSource)&&(dataStream=Object(of.a)(this.dataSource)),this._renderChangeSubscription=dataStream.pipe(Object(takeUntil.a)(this._onDestroy)).subscribe(data=>{this._data=data||[],this.renderRows()})}_forceRenderHeaderRows(){this._headerRowOutlet.viewContainer.length>0&&this._headerRowOutlet.viewContainer.clear(),this._headerRowDefs.forEach((def,i)=>this._renderRow(this._headerRowOutlet,def,i)),this.updateStickyHeaderRowStyles()}_forceRenderFooterRows(){this._footerRowOutlet.viewContainer.length>0&&this._footerRowOutlet.viewContainer.clear(),this._footerRowDefs.forEach((def,i)=>this._renderRow(this._footerRowOutlet,def,i)),this.updateStickyFooterRowStyles()}_addStickyColumnStyles(rows,rowDef){const columnDefs=Array.from(rowDef.columns||[]).map(columnName=>this._columnDefsByName.get(columnName)),stickyStartStates=columnDefs.map(columnDef=>columnDef.sticky),stickyEndStates=columnDefs.map(columnDef=>columnDef.stickyEnd);this._stickyStyler.updateStickyColumns(rows,stickyStartStates,stickyEndStates,!this._fixedLayout||this._forceRecalculateCellWidths)}_getRenderedRows(rowOutlet){const renderedRows=[];for(let i=0;i<rowOutlet.viewContainer.length;i++){const viewRef=rowOutlet.viewContainer.get(i);renderedRows.push(viewRef.rootNodes[0])}return renderedRows}_getRowDefs(data,dataIndex){if(1==this._rowDefs.length)return[this._rowDefs[0]];let rowDefs=[];if(this.multiTemplateDataRows)rowDefs=this._rowDefs.filter(def=>!def.when||def.when(dataIndex,data));else{let rowDef=this._rowDefs.find(def=>def.when&&def.when(dataIndex,data))||this._defaultRowDef;rowDef&&rowDefs.push(rowDef)}return rowDefs}_getEmbeddedViewArgs(renderRow,index){return{templateRef:renderRow.rowDef.template,context:{$implicit:renderRow.data},index:index}}_renderRow(outlet,rowDef,index,context={}){const view=outlet.viewContainer.createEmbeddedView(rowDef.template,context,index);return this._renderCellTemplateForItem(rowDef,context),view}_renderCellTemplateForItem(rowDef,context){for(let cellTemplate of this._getCellTemplates(rowDef))table_CdkCellOutlet.mostRecentCellOutlet&&table_CdkCellOutlet.mostRecentCellOutlet._viewContainer.createEmbeddedView(cellTemplate,context);this._changeDetectorRef.markForCheck()}_updateRowIndexContext(){const viewContainer=this._rowOutlet.viewContainer;for(let renderIndex=0,count=viewContainer.length;renderIndex<count;renderIndex++){const context=viewContainer.get(renderIndex).context;context.count=count,context.first=0===renderIndex,context.last=renderIndex===count-1,context.even=renderIndex%2==0,context.odd=!context.even,this.multiTemplateDataRows?(context.dataIndex=this._renderRows[renderIndex].dataIndex,context.renderIndex=renderIndex):context.index=this._renderRows[renderIndex].dataIndex}}_getCellTemplates(rowDef){return rowDef&&rowDef.columns?Array.from(rowDef.columns,columnId=>{const column=this._columnDefsByName.get(columnId);return rowDef.extractCellTemplate(column)}):[]}_applyNativeTableSections(){const documentFragment=this._document.createDocumentFragment(),sections=[{tag:\"thead\",outlets:[this._headerRowOutlet]},{tag:\"tbody\",outlets:[this._rowOutlet,this._noDataRowOutlet]},{tag:\"tfoot\",outlets:[this._footerRowOutlet]}];for(const section of sections){const element=this._document.createElement(section.tag);element.setAttribute(\"role\",\"rowgroup\");for(const outlet of section.outlets)element.appendChild(outlet.elementRef.nativeElement);documentFragment.appendChild(element)}this._elementRef.nativeElement.appendChild(documentFragment)}_forceRenderDataRows(){this._dataDiffer.diff([]),this._rowOutlet.viewContainer.clear(),this.renderRows()}_checkStickyStates(){const stickyCheckReducer=(acc,d)=>acc||d.hasStickyChanged();this._headerRowDefs.reduce(stickyCheckReducer,!1)&&this.updateStickyHeaderRowStyles(),this._footerRowDefs.reduce(stickyCheckReducer,!1)&&this.updateStickyFooterRowStyles(),Array.from(this._columnDefsByName.values()).reduce(stickyCheckReducer,!1)&&(this._stickyColumnStylesNeedReset=!0,this.updateStickyColumnStyles())}_setupStickyStyler(){this._stickyStyler=new StickyStyler(this._isNativeHtmlTable,this.stickyCssClass,this._dir?this._dir.value:\"ltr\",this._coalescedStyleScheduler,this._platform.isBrowser,this.needsPositionStickyOnElement),(this._dir?this._dir.change:Object(of.a)()).pipe(Object(takeUntil.a)(this._onDestroy)).subscribe(value=>{this._stickyStyler.direction=value,this.updateStickyColumnStyles()})}_getOwnDefs(items){return items.filter(item=>!item._table||item._table===this)}_updateNoDataRow(){const noDataRow=this._customNoDataRow||this._noDataRow;if(noDataRow){const shouldShow=0===this._rowOutlet.viewContainer.length;if(shouldShow!==this._isShowingNoDataRow){const container=this._noDataRowOutlet.viewContainer;shouldShow?container.createEmbeddedView(noDataRow.templateRef):container.clear(),this._isShowingNoDataRow=shouldShow}}}}return CdkTable.ɵfac=function(t){return new(t||CdkTable)(core.Pb(core.u),core.Pb(core.h),core.Pb(core.l),core.dc(\"role\"),core.Pb(bidi.b,8),core.Pb(common.d),core.Pb(platform.a),core.Pb(collections.f,8),core.Pb(_COALESCED_STYLE_SCHEDULER,8),core.Pb(scrolling.e,8))},CdkTable.ɵcmp=core.Jb({type:CdkTable,selectors:[[\"cdk-table\"],[\"table\",\"cdk-table\",\"\"]],contentQueries:function(rf,ctx,dirIndex){if(1&rf&&(core.Ib(dirIndex,table_CdkNoDataRow,!0),core.Ib(dirIndex,table_CdkColumnDef,!0),core.Ib(dirIndex,table_CdkRowDef,!0),core.Ib(dirIndex,table_CdkHeaderRowDef,!0),core.Ib(dirIndex,table_CdkFooterRowDef,!0)),2&rf){let _t;core.wc(_t=core.hc())&&(ctx._noDataRow=_t.first),core.wc(_t=core.hc())&&(ctx._contentColumnDefs=_t),core.wc(_t=core.hc())&&(ctx._contentRowDefs=_t),core.wc(_t=core.hc())&&(ctx._contentHeaderRowDefs=_t),core.wc(_t=core.hc())&&(ctx._contentFooterRowDefs=_t)}},viewQuery:function(rf,ctx){if(1&rf&&(core.Gc(table_DataRowOutlet,!0),core.Gc(table_HeaderRowOutlet,!0),core.Gc(table_FooterRowOutlet,!0),core.Gc(table_NoDataRowOutlet,!0)),2&rf){let _t;core.wc(_t=core.hc())&&(ctx._rowOutlet=_t.first),core.wc(_t=core.hc())&&(ctx._headerRowOutlet=_t.first),core.wc(_t=core.hc())&&(ctx._footerRowOutlet=_t.first),core.wc(_t=core.hc())&&(ctx._noDataRowOutlet=_t.first)}},hostAttrs:[1,\"cdk-table\"],hostVars:2,hostBindings:function(rf,ctx){2&rf&&core.Hb(\"cdk-table-fixed-layout\",ctx.fixedLayout)},inputs:{trackBy:\"trackBy\",dataSource:\"dataSource\",multiTemplateDataRows:\"multiTemplateDataRows\",fixedLayout:\"fixedLayout\"},exportAs:[\"cdkTable\"],features:[core.Bb([{provide:CDK_TABLE,useExisting:CdkTable},{provide:collections.f,useClass:collections.d},{provide:_COALESCED_STYLE_SCHEDULER,useClass:table_CoalescedStyleScheduler}])],ngContentSelectors:_c1,decls:6,vars:0,consts:[[\"headerRowOutlet\",\"\"],[\"rowOutlet\",\"\"],[\"noDataRowOutlet\",\"\"],[\"footerRowOutlet\",\"\"]],template:function(rf,ctx){1&rf&&(core.oc(_c0),core.nc(0),core.nc(1,1),core.Rb(2,0),core.Rb(3,1),core.Rb(4,2),core.Rb(5,3))},directives:[table_HeaderRowOutlet,table_DataRowOutlet,table_NoDataRowOutlet,table_FooterRowOutlet],styles:[\".cdk-table-fixed-layout{table-layout:fixed}\\n\"],encapsulation:2}),CdkTable})();function mergeArrayAndSet(array,set){return array.concat(Array.from(set))}let table_CdkTableModule=(()=>{class CdkTableModule{}return CdkTableModule.ɵmod=core.Nb({type:CdkTableModule}),CdkTableModule.ɵinj=core.Mb({factory:function(t){return new(t||CdkTableModule)},imports:[[scrolling.d]]}),CdkTableModule})();var fesm2015_core=__webpack_require__(\"FKr1\"),Subscription=__webpack_require__(\"quSY\"),merge=__webpack_require__(\"VRyK\"),combineLatest=__webpack_require__(\"itXk\"),map=__webpack_require__(\"lJxs\");const table_c0=[[[\"caption\"]],[[\"colgroup\"],[\"col\"]]],table_c1=[\"caption\",\"colgroup, col\"];let table_MatTable=(()=>{class MatTable extends table_CdkTable{constructor(){super(...arguments),this.stickyCssClass=\"mat-table-sticky\",this.needsPositionStickyOnElement=!1}}return MatTable.ɵfac=function(t){return ɵMatTable_BaseFactory(t||MatTable)},MatTable.ɵcmp=core.Jb({type:MatTable,selectors:[[\"mat-table\"],[\"table\",\"mat-table\",\"\"]],hostAttrs:[1,\"mat-table\"],hostVars:2,hostBindings:function(rf,ctx){2&rf&&core.Hb(\"mat-table-fixed-layout\",ctx.fixedLayout)},exportAs:[\"matTable\"],features:[core.Bb([{provide:collections.f,useClass:collections.d},{provide:table_CdkTable,useExisting:MatTable},{provide:CDK_TABLE,useExisting:MatTable},{provide:_COALESCED_STYLE_SCHEDULER,useClass:table_CoalescedStyleScheduler}]),core.zb],ngContentSelectors:table_c1,decls:6,vars:0,consts:[[\"headerRowOutlet\",\"\"],[\"rowOutlet\",\"\"],[\"noDataRowOutlet\",\"\"],[\"footerRowOutlet\",\"\"]],template:function(rf,ctx){1&rf&&(core.oc(table_c0),core.nc(0),core.nc(1,1),core.Rb(2,0),core.Rb(3,1),core.Rb(4,2),core.Rb(5,3))},directives:[table_HeaderRowOutlet,table_DataRowOutlet,table_NoDataRowOutlet,table_FooterRowOutlet],styles:['mat-table{display:block}mat-header-row{min-height:56px}mat-row,mat-footer-row{min-height:48px}mat-row,mat-header-row,mat-footer-row{display:flex;border-width:0;border-bottom-width:1px;border-style:solid;align-items:center;box-sizing:border-box}mat-row::after,mat-header-row::after,mat-footer-row::after{display:inline-block;min-height:inherit;content:\"\"}mat-cell:first-of-type,mat-header-cell:first-of-type,mat-footer-cell:first-of-type{padding-left:24px}[dir=rtl] mat-cell:first-of-type:not(:only-of-type),[dir=rtl] mat-header-cell:first-of-type:not(:only-of-type),[dir=rtl] mat-footer-cell:first-of-type:not(:only-of-type){padding-left:0;padding-right:24px}mat-cell:last-of-type,mat-header-cell:last-of-type,mat-footer-cell:last-of-type{padding-right:24px}[dir=rtl] mat-cell:last-of-type:not(:only-of-type),[dir=rtl] mat-header-cell:last-of-type:not(:only-of-type),[dir=rtl] mat-footer-cell:last-of-type:not(:only-of-type){padding-right:0;padding-left:24px}mat-cell,mat-header-cell,mat-footer-cell{flex:1;display:flex;align-items:center;overflow:hidden;word-wrap:break-word;min-height:inherit}table.mat-table{border-spacing:0}tr.mat-header-row{height:56px}tr.mat-row,tr.mat-footer-row{height:48px}th.mat-header-cell{text-align:left}[dir=rtl] th.mat-header-cell{text-align:right}th.mat-header-cell,td.mat-cell,td.mat-footer-cell{padding:0;border-bottom-width:1px;border-bottom-style:solid}th.mat-header-cell:first-of-type,td.mat-cell:first-of-type,td.mat-footer-cell:first-of-type{padding-left:24px}[dir=rtl] th.mat-header-cell:first-of-type:not(:only-of-type),[dir=rtl] td.mat-cell:first-of-type:not(:only-of-type),[dir=rtl] td.mat-footer-cell:first-of-type:not(:only-of-type){padding-left:0;padding-right:24px}th.mat-header-cell:last-of-type,td.mat-cell:last-of-type,td.mat-footer-cell:last-of-type{padding-right:24px}[dir=rtl] th.mat-header-cell:last-of-type:not(:only-of-type),[dir=rtl] td.mat-cell:last-of-type:not(:only-of-type),[dir=rtl] td.mat-footer-cell:last-of-type:not(:only-of-type){padding-right:0;padding-left:24px}.mat-table-sticky{position:-webkit-sticky;position:sticky}.mat-table-fixed-layout{table-layout:fixed}\\n'],encapsulation:2}),MatTable})();const ɵMatTable_BaseFactory=core.Xb(table_MatTable);let table_MatCellDef=(()=>{class MatCellDef extends table_CdkCellDef{}return MatCellDef.ɵfac=function(t){return ɵMatCellDef_BaseFactory(t||MatCellDef)},MatCellDef.ɵdir=core.Kb({type:MatCellDef,selectors:[[\"\",\"matCellDef\",\"\"]],features:[core.Bb([{provide:table_CdkCellDef,useExisting:MatCellDef}]),core.zb]}),MatCellDef})();const ɵMatCellDef_BaseFactory=core.Xb(table_MatCellDef);let table_MatHeaderCellDef=(()=>{class MatHeaderCellDef extends table_CdkHeaderCellDef{}return MatHeaderCellDef.ɵfac=function(t){return ɵMatHeaderCellDef_BaseFactory(t||MatHeaderCellDef)},MatHeaderCellDef.ɵdir=core.Kb({type:MatHeaderCellDef,selectors:[[\"\",\"matHeaderCellDef\",\"\"]],features:[core.Bb([{provide:table_CdkHeaderCellDef,useExisting:MatHeaderCellDef}]),core.zb]}),MatHeaderCellDef})();const ɵMatHeaderCellDef_BaseFactory=core.Xb(table_MatHeaderCellDef);let table_MatFooterCellDef=(()=>{class MatFooterCellDef extends table_CdkFooterCellDef{}return MatFooterCellDef.ɵfac=function(t){return ɵMatFooterCellDef_BaseFactory(t||MatFooterCellDef)},MatFooterCellDef.ɵdir=core.Kb({type:MatFooterCellDef,selectors:[[\"\",\"matFooterCellDef\",\"\"]],features:[core.Bb([{provide:table_CdkFooterCellDef,useExisting:MatFooterCellDef}]),core.zb]}),MatFooterCellDef})();const ɵMatFooterCellDef_BaseFactory=core.Xb(table_MatFooterCellDef);let table_MatColumnDef=(()=>{class MatColumnDef extends table_CdkColumnDef{get name(){return this._name}set name(name){this._setNameInput(name)}_updateColumnCssClassName(){super._updateColumnCssClassName(),this._columnCssClassName.push(\"mat-column-\"+this.cssClassFriendlyName)}}return MatColumnDef.ɵfac=function(t){return ɵMatColumnDef_BaseFactory(t||MatColumnDef)},MatColumnDef.ɵdir=core.Kb({type:MatColumnDef,selectors:[[\"\",\"matColumnDef\",\"\"]],inputs:{sticky:\"sticky\",name:[\"matColumnDef\",\"name\"]},features:[core.Bb([{provide:table_CdkColumnDef,useExisting:MatColumnDef},{provide:\"MAT_SORT_HEADER_COLUMN_DEF\",useExisting:MatColumnDef}]),core.zb]}),MatColumnDef})();const ɵMatColumnDef_BaseFactory=core.Xb(table_MatColumnDef);let table_MatHeaderCell=(()=>{class MatHeaderCell extends table_CdkHeaderCell{}return MatHeaderCell.ɵfac=function(t){return ɵMatHeaderCell_BaseFactory(t||MatHeaderCell)},MatHeaderCell.ɵdir=core.Kb({type:MatHeaderCell,selectors:[[\"mat-header-cell\"],[\"th\",\"mat-header-cell\",\"\"]],hostAttrs:[\"role\",\"columnheader\",1,\"mat-header-cell\"],features:[core.zb]}),MatHeaderCell})();const ɵMatHeaderCell_BaseFactory=core.Xb(table_MatHeaderCell);let table_MatFooterCell=(()=>{class MatFooterCell extends table_CdkFooterCell{}return MatFooterCell.ɵfac=function(t){return ɵMatFooterCell_BaseFactory(t||MatFooterCell)},MatFooterCell.ɵdir=core.Kb({type:MatFooterCell,selectors:[[\"mat-footer-cell\"],[\"td\",\"mat-footer-cell\",\"\"]],hostAttrs:[\"role\",\"gridcell\",1,\"mat-footer-cell\"],features:[core.zb]}),MatFooterCell})();const ɵMatFooterCell_BaseFactory=core.Xb(table_MatFooterCell);let table_MatCell=(()=>{class MatCell extends table_CdkCell{}return MatCell.ɵfac=function(t){return ɵMatCell_BaseFactory(t||MatCell)},MatCell.ɵdir=core.Kb({type:MatCell,selectors:[[\"mat-cell\"],[\"td\",\"mat-cell\",\"\"]],hostAttrs:[\"role\",\"gridcell\",1,\"mat-cell\"],features:[core.zb]}),MatCell})();const ɵMatCell_BaseFactory=core.Xb(table_MatCell);let table_MatHeaderRowDef=(()=>{class MatHeaderRowDef extends table_CdkHeaderRowDef{}return MatHeaderRowDef.ɵfac=function(t){return ɵMatHeaderRowDef_BaseFactory(t||MatHeaderRowDef)},MatHeaderRowDef.ɵdir=core.Kb({type:MatHeaderRowDef,selectors:[[\"\",\"matHeaderRowDef\",\"\"]],inputs:{columns:[\"matHeaderRowDef\",\"columns\"],sticky:[\"matHeaderRowDefSticky\",\"sticky\"]},features:[core.Bb([{provide:table_CdkHeaderRowDef,useExisting:MatHeaderRowDef}]),core.zb]}),MatHeaderRowDef})();const ɵMatHeaderRowDef_BaseFactory=core.Xb(table_MatHeaderRowDef);let table_MatFooterRowDef=(()=>{class MatFooterRowDef extends table_CdkFooterRowDef{}return MatFooterRowDef.ɵfac=function(t){return ɵMatFooterRowDef_BaseFactory(t||MatFooterRowDef)},MatFooterRowDef.ɵdir=core.Kb({type:MatFooterRowDef,selectors:[[\"\",\"matFooterRowDef\",\"\"]],inputs:{columns:[\"matFooterRowDef\",\"columns\"],sticky:[\"matFooterRowDefSticky\",\"sticky\"]},features:[core.Bb([{provide:table_CdkFooterRowDef,useExisting:MatFooterRowDef}]),core.zb]}),MatFooterRowDef})();const ɵMatFooterRowDef_BaseFactory=core.Xb(table_MatFooterRowDef);let table_MatRowDef=(()=>{class MatRowDef extends table_CdkRowDef{}return MatRowDef.ɵfac=function(t){return ɵMatRowDef_BaseFactory(t||MatRowDef)},MatRowDef.ɵdir=core.Kb({type:MatRowDef,selectors:[[\"\",\"matRowDef\",\"\"]],inputs:{columns:[\"matRowDefColumns\",\"columns\"],when:[\"matRowDefWhen\",\"when\"]},features:[core.Bb([{provide:table_CdkRowDef,useExisting:MatRowDef}]),core.zb]}),MatRowDef})();const ɵMatRowDef_BaseFactory=core.Xb(table_MatRowDef);let table_MatHeaderRow=(()=>{class MatHeaderRow extends table_CdkHeaderRow{}return MatHeaderRow.ɵfac=function(t){return ɵMatHeaderRow_BaseFactory(t||MatHeaderRow)},MatHeaderRow.ɵcmp=core.Jb({type:MatHeaderRow,selectors:[[\"mat-header-row\"],[\"tr\",\"mat-header-row\",\"\"]],hostAttrs:[\"role\",\"row\",1,\"mat-header-row\"],exportAs:[\"matHeaderRow\"],features:[core.Bb([{provide:table_CdkHeaderRow,useExisting:MatHeaderRow}]),core.zb],decls:1,vars:0,consts:[[\"cdkCellOutlet\",\"\"]],template:function(rf,ctx){1&rf&&core.Rb(0,0)},directives:[table_CdkCellOutlet],encapsulation:2}),MatHeaderRow})();const ɵMatHeaderRow_BaseFactory=core.Xb(table_MatHeaderRow);let table_MatFooterRow=(()=>{class MatFooterRow extends table_CdkFooterRow{}return MatFooterRow.ɵfac=function(t){return ɵMatFooterRow_BaseFactory(t||MatFooterRow)},MatFooterRow.ɵcmp=core.Jb({type:MatFooterRow,selectors:[[\"mat-footer-row\"],[\"tr\",\"mat-footer-row\",\"\"]],hostAttrs:[\"role\",\"row\",1,\"mat-footer-row\"],exportAs:[\"matFooterRow\"],features:[core.Bb([{provide:table_CdkFooterRow,useExisting:MatFooterRow}]),core.zb],decls:1,vars:0,consts:[[\"cdkCellOutlet\",\"\"]],template:function(rf,ctx){1&rf&&core.Rb(0,0)},directives:[table_CdkCellOutlet],encapsulation:2}),MatFooterRow})();const ɵMatFooterRow_BaseFactory=core.Xb(table_MatFooterRow);let table_MatRow=(()=>{class MatRow extends table_CdkRow{}return MatRow.ɵfac=function(t){return ɵMatRow_BaseFactory(t||MatRow)},MatRow.ɵcmp=core.Jb({type:MatRow,selectors:[[\"mat-row\"],[\"tr\",\"mat-row\",\"\"]],hostAttrs:[\"role\",\"row\",1,\"mat-row\"],exportAs:[\"matRow\"],features:[core.Bb([{provide:table_CdkRow,useExisting:MatRow}]),core.zb],decls:1,vars:0,consts:[[\"cdkCellOutlet\",\"\"]],template:function(rf,ctx){1&rf&&core.Rb(0,0)},directives:[table_CdkCellOutlet],encapsulation:2}),MatRow})();const ɵMatRow_BaseFactory=core.Xb(table_MatRow);let table_MatTableModule=(()=>{class MatTableModule{}return MatTableModule.ɵmod=core.Nb({type:MatTableModule}),MatTableModule.ɵinj=core.Mb({factory:function(t){return new(t||MatTableModule)},imports:[[table_CdkTableModule,fesm2015_core.i],fesm2015_core.i]}),MatTableModule})();class table_MatTableDataSource extends collections.b{constructor(initialData=[]){super(),this._renderData=new BehaviorSubject.a([]),this._filter=new BehaviorSubject.a(\"\"),this._internalPageChanges=new Subject.a,this._renderChangesSubscription=Subscription.a.EMPTY,this.sortingDataAccessor=(data,sortHeaderId)=>{const value=data[sortHeaderId];if(Object(coercion.a)(value)){const numberValue=Number(value);return numberValue<9007199254740991?numberValue:value}return value},this.sortData=(data,sort)=>{const active=sort.active,direction=sort.direction;return active&&\"\"!=direction?data.sort((a,b)=>{let valueA=this.sortingDataAccessor(a,active),valueB=this.sortingDataAccessor(b,active);const valueAType=typeof valueA,valueBType=typeof valueB;valueAType!==valueBType&&(\"number\"===valueAType&&(valueA+=\"\"),\"number\"===valueBType&&(valueB+=\"\"));let comparatorResult=0;return null!=valueA&&null!=valueB?valueA>valueB?comparatorResult=1:valueA<valueB&&(comparatorResult=-1):null!=valueA?comparatorResult=1:null!=valueB&&(comparatorResult=-1),comparatorResult*(\"asc\"==direction?1:-1)}):data},this.filterPredicate=(data,filter)=>{const dataStr=Object.keys(data).reduce((currentTerm,key)=>currentTerm+data[key]+\"◬\",\"\").toLowerCase(),transformedFilter=filter.trim().toLowerCase();return-1!=dataStr.indexOf(transformedFilter)},this._data=new BehaviorSubject.a(initialData),this._updateChangeSubscription()}get data(){return this._data.value}set data(data){this._data.next(data)}get filter(){return this._filter.value}set filter(filter){this._filter.next(filter)}get sort(){return this._sort}set sort(sort){this._sort=sort,this._updateChangeSubscription()}get paginator(){return this._paginator}set paginator(paginator){this._paginator=paginator,this._updateChangeSubscription()}_updateChangeSubscription(){const sortChange=this._sort?Object(merge.a)(this._sort.sortChange,this._sort.initialized):Object(of.a)(null),pageChange=this._paginator?Object(merge.a)(this._paginator.page,this._internalPageChanges,this._paginator.initialized):Object(of.a)(null),dataStream=this._data,filteredData=Object(combineLatest.b)([dataStream,this._filter]).pipe(Object(map.a)(([data])=>this._filterData(data))),orderedData=Object(combineLatest.b)([filteredData,sortChange]).pipe(Object(map.a)(([data])=>this._orderData(data))),paginatedData=Object(combineLatest.b)([orderedData,pageChange]).pipe(Object(map.a)(([data])=>this._pageData(data)));this._renderChangesSubscription.unsubscribe(),this._renderChangesSubscription=paginatedData.subscribe(data=>this._renderData.next(data))}_filterData(data){return this.filteredData=null==this.filter||\"\"===this.filter?data:data.filter(obj=>this.filterPredicate(obj,this.filter)),this.paginator&&this._updatePaginator(this.filteredData.length),this.filteredData}_orderData(data){return this.sort?this.sortData(data.slice(),this.sort):data}_pageData(data){if(!this.paginator)return data;const startIndex=this.paginator.pageIndex*this.paginator.pageSize;return data.slice(startIndex,startIndex+this.paginator.pageSize)}_updatePaginator(filteredDataLength){Promise.resolve().then(()=>{const paginator=this.paginator;if(paginator&&(paginator.length=filteredDataLength,paginator.pageIndex>0)){const lastPageIndex=Math.ceil(paginator.length/paginator.pageSize)-1||0,newPageIndex=Math.min(paginator.pageIndex,lastPageIndex);newPageIndex!==paginator.pageIndex&&(paginator.pageIndex=newPageIndex,this._internalPageChanges.next())}})}connect(){return this._renderData}disconnect(){}}}}]);","name":"1-es2015.af8816f364590b26510a.js","input":"(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[1],{\n\n/***/ \"+0xr\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ table_MatCell; });\n__webpack_require__.d(__webpack_exports__, \"b\", function() { return /* binding */ table_MatCellDef; });\n__webpack_require__.d(__webpack_exports__, \"c\", function() { return /* binding */ table_MatColumnDef; });\n__webpack_require__.d(__webpack_exports__, \"d\", function() { return /* binding */ table_MatFooterCell; });\n__webpack_require__.d(__webpack_exports__, \"e\", function() { return /* binding */ table_MatFooterCellDef; });\n__webpack_require__.d(__webpack_exports__, \"f\", function() { return /* binding */ table_MatFooterRow; });\n__webpack_require__.d(__webpack_exports__, \"g\", function() { return /* binding */ table_MatFooterRowDef; });\n__webpack_require__.d(__webpack_exports__, \"h\", function() { return /* binding */ table_MatHeaderCell; });\n__webpack_require__.d(__webpack_exports__, \"i\", function() { return /* binding */ table_MatHeaderCellDef; });\n__webpack_require__.d(__webpack_exports__, \"j\", function() { return /* binding */ table_MatHeaderRow; });\n__webpack_require__.d(__webpack_exports__, \"k\", function() { return /* binding */ table_MatHeaderRowDef; });\n__webpack_require__.d(__webpack_exports__, \"l\", function() { return /* binding */ table_MatRow; });\n__webpack_require__.d(__webpack_exports__, \"m\", function() { return /* binding */ table_MatRowDef; });\n__webpack_require__.d(__webpack_exports__, \"n\", function() { return /* binding */ table_MatTable; });\n__webpack_require__.d(__webpack_exports__, \"o\", function() { return /* binding */ table_MatTableDataSource; });\n__webpack_require__.d(__webpack_exports__, \"p\", function() { return /* binding */ table_MatTableModule; });\n\n// UNUSED EXPORTS: MatNoDataRow, MatTextColumn\n\n// EXTERNAL MODULE: ./node_modules/@angular/cdk/fesm2015/coercion.js\nvar coercion = __webpack_require__(\"8LU1\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/collections.js\nvar collections = __webpack_require__(\"0EQZ\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js\nvar core = __webpack_require__(\"fXoL\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/bidi.js\nvar bidi = __webpack_require__(\"cH1L\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/platform.js\nvar platform = __webpack_require__(\"nLfN\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/scrolling.js + 11 modules\nvar scrolling = __webpack_require__(\"vxfF\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/common/__ivy_ngcc__/fesm2015/common.js\nvar common = __webpack_require__(\"ofXK\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subject.js\nvar Subject = __webpack_require__(\"XNiG\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/from.js + 6 modules\nvar from = __webpack_require__(\"Cfvw\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/BehaviorSubject.js\nvar BehaviorSubject = __webpack_require__(\"2Vo4\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/isObservable.js\nvar isObservable = __webpack_require__(\"7+OI\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/of.js\nvar of = __webpack_require__(\"LRne\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/takeUntil.js\nvar takeUntil = __webpack_require__(\"1G5W\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/take.js\nvar take = __webpack_require__(\"IzEk\");\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/table.js\n\n\n\n\n\n\n\nconst _c0 = [[[\"caption\"]], [[\"colgroup\"], [\"col\"]]];\nconst _c1 = [\"caption\", \"colgroup, col\"];\nfunction CdkTextColumn_th_1_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Vb\" /* ɵɵelementStart */](0, \"th\", 3);\n        core[\"Mc\" /* ɵɵtext */](1);\n        core[\"Ub\" /* ɵɵelementEnd */]();\n    }\n    if (rf & 2) {\n        const ctx_r0 = core[\"kc\" /* ɵɵnextContext */]();\n        core[\"Hc\" /* ɵɵstyleProp */](\"text-align\", ctx_r0.justify);\n        core[\"Cb\" /* ɵɵadvance */](1);\n        core[\"Oc\" /* ɵɵtextInterpolate1 */](\" \", ctx_r0.headerText, \" \");\n    }\n}\nfunction CdkTextColumn_td_2_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Vb\" /* ɵɵelementStart */](0, \"td\", 4);\n        core[\"Mc\" /* ɵɵtext */](1);\n        core[\"Ub\" /* ɵɵelementEnd */]();\n    }\n    if (rf & 2) {\n        const data_r2 = ctx.$implicit;\n        const ctx_r1 = core[\"kc\" /* ɵɵnextContext */]();\n        core[\"Hc\" /* ɵɵstyleProp */](\"text-align\", ctx_r1.justify);\n        core[\"Cb\" /* ɵɵadvance */](1);\n        core[\"Oc\" /* ɵɵtextInterpolate1 */](\" \", ctx_r1.dataAccessor(data_r2, ctx_r1.name), \" \");\n    }\n}\n\n\n\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Mixin to provide a directive with a function that checks if the sticky input has been\n * changed since the last time the function was called. Essentially adds a dirty-check to the\n * sticky value.\n * @docs-private\n */\nfunction mixinHasStickyInput(base) {\n    return class extends base {\n        constructor(...args) {\n            super(...args);\n            this._sticky = false;\n            /** Whether the sticky input has changed since it was last checked. */\n            this._hasStickyChanged = false;\n        }\n        /** Whether sticky positioning should be applied. */\n        get sticky() { return this._sticky; }\n        set sticky(v) {\n            const prevValue = this._sticky;\n            this._sticky = Object(coercion[\"c\" /* coerceBooleanProperty */])(v);\n            this._hasStickyChanged = prevValue !== this._sticky;\n        }\n        /** Whether the sticky value has changed since this was last called. */\n        hasStickyChanged() {\n            const hasStickyChanged = this._hasStickyChanged;\n            this._hasStickyChanged = false;\n            return hasStickyChanged;\n        }\n        /** Resets the dirty check for cases where the sticky state has been used without checking. */\n        resetStickyChanged() {\n            this._hasStickyChanged = false;\n        }\n    };\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Used to provide a table to some of the sub-components without causing a circular dependency.\n * @docs-private\n */\nconst CDK_TABLE = /*@__PURE__*/ new core[\"s\" /* InjectionToken */]('CDK_TABLE');\n/** Injection token that can be used to specify the text column options. */\nconst TEXT_COLUMN_OPTIONS = /*@__PURE__*/ new core[\"s\" /* InjectionToken */]('text-column-options');\nlet table_CdkCellDef = /*@__PURE__*/ (() => {\n    class CdkCellDef {\n        constructor(/** @docs-private */ template) {\n            this.template = template;\n        }\n    }\n    CdkCellDef.ɵfac = function CdkCellDef_Factory(t) { return new (t || CdkCellDef)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"O\" /* TemplateRef */])); };\n    CdkCellDef.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: CdkCellDef, selectors: [[\"\", \"cdkCellDef\", \"\"]] });\n    return CdkCellDef;\n})();\nlet table_CdkHeaderCellDef = /*@__PURE__*/ (() => {\n    class CdkHeaderCellDef {\n        constructor(/** @docs-private */ template) {\n            this.template = template;\n        }\n    }\n    CdkHeaderCellDef.ɵfac = function CdkHeaderCellDef_Factory(t) { return new (t || CdkHeaderCellDef)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"O\" /* TemplateRef */])); };\n    CdkHeaderCellDef.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: CdkHeaderCellDef, selectors: [[\"\", \"cdkHeaderCellDef\", \"\"]] });\n    return CdkHeaderCellDef;\n})();\nlet table_CdkFooterCellDef = /*@__PURE__*/ (() => {\n    class CdkFooterCellDef {\n        constructor(/** @docs-private */ template) {\n            this.template = template;\n        }\n    }\n    CdkFooterCellDef.ɵfac = function CdkFooterCellDef_Factory(t) { return new (t || CdkFooterCellDef)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"O\" /* TemplateRef */])); };\n    CdkFooterCellDef.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: CdkFooterCellDef, selectors: [[\"\", \"cdkFooterCellDef\", \"\"]] });\n    return CdkFooterCellDef;\n})();\n// Boilerplate for applying mixins to CdkColumnDef.\n/** @docs-private */\nclass CdkColumnDefBase {\n}\nconst _CdkColumnDefBase = /*@__PURE__*/ mixinHasStickyInput(CdkColumnDefBase);\nlet table_CdkColumnDef = /*@__PURE__*/ (() => {\n    class CdkColumnDef extends _CdkColumnDefBase {\n        constructor(_table) {\n            super();\n            this._table = _table;\n            this._stickyEnd = false;\n        }\n        /** Unique name for this column. */\n        get name() { return this._name; }\n        set name(name) { this._setNameInput(name); }\n        /**\n         * Whether this column should be sticky positioned on the end of the row. Should make sure\n         * that it mimics the `CanStick` mixin such that `_hasStickyChanged` is set to true if the value\n         * has been changed.\n         */\n        get stickyEnd() {\n            return this._stickyEnd;\n        }\n        set stickyEnd(v) {\n            const prevValue = this._stickyEnd;\n            this._stickyEnd = Object(coercion[\"c\" /* coerceBooleanProperty */])(v);\n            this._hasStickyChanged = prevValue !== this._stickyEnd;\n        }\n        /**\n         * Overridable method that sets the css classes that will be added to every cell in this\n         * column.\n         * In the future, columnCssClassName will change from type string[] to string and this\n         * will set a single string value.\n         * @docs-private\n         */\n        _updateColumnCssClassName() {\n            this._columnCssClassName = [`cdk-column-${this.cssClassFriendlyName}`];\n        }\n        /**\n         * This has been extracted to a util because of TS 4 and VE.\n         * View Engine doesn't support property rename inheritance.\n         * TS 4.0 doesn't allow properties to override accessors or vice-versa.\n         * @docs-private\n         */\n        _setNameInput(value) {\n            // If the directive is set without a name (updated programatically), then this setter will\n            // trigger with an empty string and should not overwrite the programatically set value.\n            if (value) {\n                this._name = value;\n                this.cssClassFriendlyName = value.replace(/[^a-z0-9_-]/ig, '-');\n                this._updateColumnCssClassName();\n            }\n        }\n    }\n    CdkColumnDef.ɵfac = function CdkColumnDef_Factory(t) { return new (t || CdkColumnDef)(core[\"Pb\" /* ɵɵdirectiveInject */](CDK_TABLE, 8)); };\n    CdkColumnDef.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: CdkColumnDef, selectors: [[\"\", \"cdkColumnDef\", \"\"]], contentQueries: function CdkColumnDef_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                core[\"Ib\" /* ɵɵcontentQuery */](dirIndex, table_CdkCellDef, true);\n                core[\"Ib\" /* ɵɵcontentQuery */](dirIndex, table_CdkHeaderCellDef, true);\n                core[\"Ib\" /* ɵɵcontentQuery */](dirIndex, table_CdkFooterCellDef, true);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx.cell = _t.first);\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx.headerCell = _t.first);\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx.footerCell = _t.first);\n            }\n        }, inputs: { sticky: \"sticky\", name: [\"cdkColumnDef\", \"name\"], stickyEnd: \"stickyEnd\" }, features: [/*@__PURE__*/ core[\"Bb\" /* ɵɵProvidersFeature */]([{ provide: 'MAT_SORT_HEADER_COLUMN_DEF', useExisting: CdkColumnDef }]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return CdkColumnDef;\n})();\n/** Base class for the cells. Adds a CSS classname that identifies the column it renders in. */\nclass BaseCdkCell {\n    constructor(columnDef, elementRef) {\n        // If IE 11 is dropped before we switch to setting a single class name, change to multi param\n        // with destructuring.\n        const classList = elementRef.nativeElement.classList;\n        for (const className of columnDef._columnCssClassName) {\n            classList.add(className);\n        }\n    }\n}\nlet table_CdkHeaderCell = /*@__PURE__*/ (() => {\n    class CdkHeaderCell extends BaseCdkCell {\n        constructor(columnDef, elementRef) {\n            super(columnDef, elementRef);\n        }\n    }\n    CdkHeaderCell.ɵfac = function CdkHeaderCell_Factory(t) { return new (t || CdkHeaderCell)(core[\"Pb\" /* ɵɵdirectiveInject */](table_CdkColumnDef), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */])); };\n    CdkHeaderCell.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: CdkHeaderCell, selectors: [[\"cdk-header-cell\"], [\"th\", \"cdk-header-cell\", \"\"]], hostAttrs: [\"role\", \"columnheader\", 1, \"cdk-header-cell\"], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return CdkHeaderCell;\n})();\nlet table_CdkFooterCell = /*@__PURE__*/ (() => {\n    class CdkFooterCell extends BaseCdkCell {\n        constructor(columnDef, elementRef) {\n            super(columnDef, elementRef);\n        }\n    }\n    CdkFooterCell.ɵfac = function CdkFooterCell_Factory(t) { return new (t || CdkFooterCell)(core[\"Pb\" /* ɵɵdirectiveInject */](table_CdkColumnDef), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */])); };\n    CdkFooterCell.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: CdkFooterCell, selectors: [[\"cdk-footer-cell\"], [\"td\", \"cdk-footer-cell\", \"\"]], hostAttrs: [\"role\", \"gridcell\", 1, \"cdk-footer-cell\"], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return CdkFooterCell;\n})();\nlet table_CdkCell = /*@__PURE__*/ (() => {\n    class CdkCell extends BaseCdkCell {\n        constructor(columnDef, elementRef) {\n            super(columnDef, elementRef);\n        }\n    }\n    CdkCell.ɵfac = function CdkCell_Factory(t) { return new (t || CdkCell)(core[\"Pb\" /* ɵɵdirectiveInject */](table_CdkColumnDef), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */])); };\n    CdkCell.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: CdkCell, selectors: [[\"cdk-cell\"], [\"td\", \"cdk-cell\", \"\"]], hostAttrs: [\"role\", \"gridcell\", 1, \"cdk-cell\"], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return CdkCell;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @docs-private\n */\nclass _Schedule {\n    constructor() {\n        this.tasks = [];\n        this.endTasks = [];\n    }\n}\n/** Injection token used to provide a coalesced style scheduler. */\nconst _COALESCED_STYLE_SCHEDULER = /*@__PURE__*/ new core[\"s\" /* InjectionToken */]('_COALESCED_STYLE_SCHEDULER');\nlet table_CoalescedStyleScheduler = /*@__PURE__*/ (() => {\n    class _CoalescedStyleScheduler {\n        constructor(_ngZone) {\n            this._ngZone = _ngZone;\n            this._currentSchedule = null;\n            this._destroyed = new Subject[\"a\" /* Subject */]();\n        }\n        /**\n         * Schedules the specified task to run at the end of the current VM turn.\n         */\n        schedule(task) {\n            this._createScheduleIfNeeded();\n            this._currentSchedule.tasks.push(task);\n        }\n        /**\n         * Schedules the specified task to run after other scheduled tasks at the end of the current\n         * VM turn.\n         */\n        scheduleEnd(task) {\n            this._createScheduleIfNeeded();\n            this._currentSchedule.endTasks.push(task);\n        }\n        /** Prevent any further tasks from running. */\n        ngOnDestroy() {\n            this._destroyed.next();\n            this._destroyed.complete();\n        }\n        _createScheduleIfNeeded() {\n            if (this._currentSchedule) {\n                return;\n            }\n            this._currentSchedule = new _Schedule();\n            this._getScheduleObservable().pipe(Object(takeUntil[\"a\" /* takeUntil */])(this._destroyed)).subscribe(() => {\n                while (this._currentSchedule.tasks.length || this._currentSchedule.endTasks.length) {\n                    const schedule = this._currentSchedule;\n                    // Capture new tasks scheduled by the current set of tasks.\n                    this._currentSchedule = new _Schedule();\n                    for (const task of schedule.tasks) {\n                        task();\n                    }\n                    for (const task of schedule.endTasks) {\n                        task();\n                    }\n                }\n                this._currentSchedule = null;\n            });\n        }\n        _getScheduleObservable() {\n            // Use onStable when in the context of an ongoing change detection cycle so that we\n            // do not accidentally trigger additional cycles.\n            return this._ngZone.isStable ?\n                Object(from[\"a\" /* from */])(Promise.resolve(undefined)) :\n                this._ngZone.onStable.pipe(Object(take[\"a\" /* take */])(1));\n        }\n    }\n    _CoalescedStyleScheduler.ɵfac = function _CoalescedStyleScheduler_Factory(t) { return new (t || _CoalescedStyleScheduler)(core[\"cc\" /* ɵɵinject */](core[\"B\" /* NgZone */])); };\n    _CoalescedStyleScheduler.ɵprov = /*@__PURE__*/ core[\"Lb\" /* ɵɵdefineInjectable */]({ token: _CoalescedStyleScheduler, factory: _CoalescedStyleScheduler.ɵfac });\n    return _CoalescedStyleScheduler;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * The row template that can be used by the mat-table. Should not be used outside of the\n * material library.\n */\nconst CDK_ROW_TEMPLATE = `<ng-container cdkCellOutlet></ng-container>`;\nlet table_BaseRowDef = /*@__PURE__*/ (() => {\n    class BaseRowDef {\n        constructor(\n        /** @docs-private */ template, _differs) {\n            this.template = template;\n            this._differs = _differs;\n        }\n        ngOnChanges(changes) {\n            // Create a new columns differ if one does not yet exist. Initialize it based on initial value\n            // of the columns property or an empty array if none is provided.\n            if (!this._columnsDiffer) {\n                const columns = (changes['columns'] && changes['columns'].currentValue) || [];\n                this._columnsDiffer = this._differs.find(columns).create();\n                this._columnsDiffer.diff(columns);\n            }\n        }\n        /**\n         * Returns the difference between the current columns and the columns from the last diff, or null\n         * if there is no difference.\n         */\n        getColumnsDiff() {\n            return this._columnsDiffer.diff(this.columns);\n        }\n        /** Gets this row def's relevant cell template from the provided column def. */\n        extractCellTemplate(column) {\n            if (this instanceof table_CdkHeaderRowDef) {\n                return column.headerCell.template;\n            }\n            if (this instanceof table_CdkFooterRowDef) {\n                return column.footerCell.template;\n            }\n            else {\n                return column.cell.template;\n            }\n        }\n    }\n    BaseRowDef.ɵfac = function BaseRowDef_Factory(t) { return new (t || BaseRowDef)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"O\" /* TemplateRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"u\" /* IterableDiffers */])); };\n    BaseRowDef.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: BaseRowDef, features: [core[\"Ab\" /* ɵɵNgOnChangesFeature */]] });\n    return BaseRowDef;\n})();\n// Boilerplate for applying mixins to CdkHeaderRowDef.\n/** @docs-private */\nclass CdkHeaderRowDefBase extends table_BaseRowDef {\n}\nconst _CdkHeaderRowDefBase = /*@__PURE__*/ mixinHasStickyInput(CdkHeaderRowDefBase);\nlet table_CdkHeaderRowDef = /*@__PURE__*/ (() => {\n    class CdkHeaderRowDef extends _CdkHeaderRowDefBase {\n        constructor(template, _differs, _table) {\n            super(template, _differs);\n            this._table = _table;\n        }\n        // Prerender fails to recognize that ngOnChanges in a part of this class through inheritance.\n        // Explicitly define it so that the method is called as part of the Angular lifecycle.\n        ngOnChanges(changes) {\n            super.ngOnChanges(changes);\n        }\n    }\n    CdkHeaderRowDef.ɵfac = function CdkHeaderRowDef_Factory(t) { return new (t || CdkHeaderRowDef)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"O\" /* TemplateRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"u\" /* IterableDiffers */]), core[\"Pb\" /* ɵɵdirectiveInject */](CDK_TABLE, 8)); };\n    CdkHeaderRowDef.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: CdkHeaderRowDef, selectors: [[\"\", \"cdkHeaderRowDef\", \"\"]], inputs: { columns: [\"cdkHeaderRowDef\", \"columns\"], sticky: [\"cdkHeaderRowDefSticky\", \"sticky\"] }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */], core[\"Ab\" /* ɵɵNgOnChangesFeature */]] });\n    return CdkHeaderRowDef;\n})();\n// Boilerplate for applying mixins to CdkFooterRowDef.\n/** @docs-private */\nclass CdkFooterRowDefBase extends table_BaseRowDef {\n}\nconst _CdkFooterRowDefBase = /*@__PURE__*/ mixinHasStickyInput(CdkFooterRowDefBase);\nlet table_CdkFooterRowDef = /*@__PURE__*/ (() => {\n    class CdkFooterRowDef extends _CdkFooterRowDefBase {\n        constructor(template, _differs, _table) {\n            super(template, _differs);\n            this._table = _table;\n        }\n        // Prerender fails to recognize that ngOnChanges in a part of this class through inheritance.\n        // Explicitly define it so that the method is called as part of the Angular lifecycle.\n        ngOnChanges(changes) {\n            super.ngOnChanges(changes);\n        }\n    }\n    CdkFooterRowDef.ɵfac = function CdkFooterRowDef_Factory(t) { return new (t || CdkFooterRowDef)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"O\" /* TemplateRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"u\" /* IterableDiffers */]), core[\"Pb\" /* ɵɵdirectiveInject */](CDK_TABLE, 8)); };\n    CdkFooterRowDef.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: CdkFooterRowDef, selectors: [[\"\", \"cdkFooterRowDef\", \"\"]], inputs: { columns: [\"cdkFooterRowDef\", \"columns\"], sticky: [\"cdkFooterRowDefSticky\", \"sticky\"] }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */], core[\"Ab\" /* ɵɵNgOnChangesFeature */]] });\n    return CdkFooterRowDef;\n})();\nlet table_CdkRowDef = /*@__PURE__*/ (() => {\n    class CdkRowDef extends table_BaseRowDef {\n        // TODO(andrewseguin): Add an input for providing a switch function to determine\n        //   if this template should be used.\n        constructor(template, _differs, _table) {\n            super(template, _differs);\n            this._table = _table;\n        }\n    }\n    CdkRowDef.ɵfac = function CdkRowDef_Factory(t) { return new (t || CdkRowDef)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"O\" /* TemplateRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"u\" /* IterableDiffers */]), core[\"Pb\" /* ɵɵdirectiveInject */](CDK_TABLE, 8)); };\n    CdkRowDef.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: CdkRowDef, selectors: [[\"\", \"cdkRowDef\", \"\"]], inputs: { columns: [\"cdkRowDefColumns\", \"columns\"], when: [\"cdkRowDefWhen\", \"when\"] }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return CdkRowDef;\n})();\nlet table_CdkCellOutlet = /*@__PURE__*/ (() => {\n    class CdkCellOutlet {\n        constructor(_viewContainer) {\n            this._viewContainer = _viewContainer;\n            CdkCellOutlet.mostRecentCellOutlet = this;\n        }\n        ngOnDestroy() {\n            // If this was the last outlet being rendered in the view, remove the reference\n            // from the static property after it has been destroyed to avoid leaking memory.\n            if (CdkCellOutlet.mostRecentCellOutlet === this) {\n                CdkCellOutlet.mostRecentCellOutlet = null;\n            }\n        }\n    }\n    CdkCellOutlet.ɵfac = function CdkCellOutlet_Factory(t) { return new (t || CdkCellOutlet)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"S\" /* ViewContainerRef */])); };\n    CdkCellOutlet.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: CdkCellOutlet, selectors: [[\"\", \"cdkCellOutlet\", \"\"]] });\n    /**\n     * Static property containing the latest constructed instance of this class.\n     * Used by the CDK table when each CdkHeaderRow and CdkRow component is created using\n     * createEmbeddedView. After one of these components are created, this property will provide\n     * a handle to provide that component's cells and context. After init, the CdkCellOutlet will\n     * construct the cells with the provided context.\n     */\n    CdkCellOutlet.mostRecentCellOutlet = null;\n    return CdkCellOutlet;\n})();\nlet table_CdkHeaderRow = /*@__PURE__*/ (() => {\n    class CdkHeaderRow {\n    }\n    CdkHeaderRow.ɵfac = function CdkHeaderRow_Factory(t) { return new (t || CdkHeaderRow)(); };\n    CdkHeaderRow.ɵcmp = /*@__PURE__*/ core[\"Jb\" /* ɵɵdefineComponent */]({ type: CdkHeaderRow, selectors: [[\"cdk-header-row\"], [\"tr\", \"cdk-header-row\", \"\"]], hostAttrs: [\"role\", \"row\", 1, \"cdk-header-row\"], decls: 1, vars: 0, consts: [[\"cdkCellOutlet\", \"\"]], template: function CdkHeaderRow_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"Rb\" /* ɵɵelementContainer */](0, 0);\n            }\n        }, directives: [table_CdkCellOutlet], encapsulation: 2 });\n    return CdkHeaderRow;\n})();\nlet table_CdkFooterRow = /*@__PURE__*/ (() => {\n    class CdkFooterRow {\n    }\n    CdkFooterRow.ɵfac = function CdkFooterRow_Factory(t) { return new (t || CdkFooterRow)(); };\n    CdkFooterRow.ɵcmp = /*@__PURE__*/ core[\"Jb\" /* ɵɵdefineComponent */]({ type: CdkFooterRow, selectors: [[\"cdk-footer-row\"], [\"tr\", \"cdk-footer-row\", \"\"]], hostAttrs: [\"role\", \"row\", 1, \"cdk-footer-row\"], decls: 1, vars: 0, consts: [[\"cdkCellOutlet\", \"\"]], template: function CdkFooterRow_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"Rb\" /* ɵɵelementContainer */](0, 0);\n            }\n        }, directives: [table_CdkCellOutlet], encapsulation: 2 });\n    return CdkFooterRow;\n})();\nlet table_CdkRow = /*@__PURE__*/ (() => {\n    class CdkRow {\n    }\n    CdkRow.ɵfac = function CdkRow_Factory(t) { return new (t || CdkRow)(); };\n    CdkRow.ɵcmp = /*@__PURE__*/ core[\"Jb\" /* ɵɵdefineComponent */]({ type: CdkRow, selectors: [[\"cdk-row\"], [\"tr\", \"cdk-row\", \"\"]], hostAttrs: [\"role\", \"row\", 1, \"cdk-row\"], decls: 1, vars: 0, consts: [[\"cdkCellOutlet\", \"\"]], template: function CdkRow_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"Rb\" /* ɵɵelementContainer */](0, 0);\n            }\n        }, directives: [table_CdkCellOutlet], encapsulation: 2 });\n    return CdkRow;\n})();\nlet table_CdkNoDataRow = /*@__PURE__*/ (() => {\n    class CdkNoDataRow {\n        constructor(templateRef) {\n            this.templateRef = templateRef;\n        }\n    }\n    CdkNoDataRow.ɵfac = function CdkNoDataRow_Factory(t) { return new (t || CdkNoDataRow)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"O\" /* TemplateRef */])); };\n    CdkNoDataRow.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: CdkNoDataRow, selectors: [[\"ng-template\", \"cdkNoDataRow\", \"\"]] });\n    return CdkNoDataRow;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * List of all possible directions that can be used for sticky positioning.\n * @docs-private\n */\nconst STICKY_DIRECTIONS = ['top', 'bottom', 'left', 'right'];\n/**\n * Applies and removes sticky positioning styles to the `CdkTable` rows and columns cells.\n * @docs-private\n */\nclass StickyStyler {\n    /**\n     * @param _isNativeHtmlTable Whether the sticky logic should be based on a table\n     *     that uses the native `<table>` element.\n     * @param _stickCellCss The CSS class that will be applied to every row/cell that has\n     *     sticky positioning applied.\n     * @param direction The directionality context of the table (ltr/rtl); affects column positioning\n     *     by reversing left/right positions.\n     * @param _isBrowser Whether the table is currently being rendered on the server or the client.\n     * @param _needsPositionStickyOnElement Whether we need to specify position: sticky on cells\n     *     using inline styles. If false, it is assumed that position: sticky is included in\n     *     the component stylesheet for _stickCellCss.\n     */\n    constructor(_isNativeHtmlTable, _stickCellCss, direction, \n    /**\n     * @deprecated `_coalescedStyleScheduler` parameter to become required.\n     * @breaking-change 11.0.0\n     */\n    _coalescedStyleScheduler, _isBrowser = true, _needsPositionStickyOnElement = true) {\n        this._isNativeHtmlTable = _isNativeHtmlTable;\n        this._stickCellCss = _stickCellCss;\n        this.direction = direction;\n        this._coalescedStyleScheduler = _coalescedStyleScheduler;\n        this._isBrowser = _isBrowser;\n        this._needsPositionStickyOnElement = _needsPositionStickyOnElement;\n        this._cachedCellWidths = [];\n    }\n    /**\n     * Clears the sticky positioning styles from the row and its cells by resetting the `position`\n     * style, setting the zIndex to 0, and unsetting each provided sticky direction.\n     * @param rows The list of rows that should be cleared from sticking in the provided directions\n     * @param stickyDirections The directions that should no longer be set as sticky on the rows.\n     */\n    clearStickyPositioning(rows, stickyDirections) {\n        const elementsToClear = [];\n        for (const row of rows) {\n            // If the row isn't an element (e.g. if it's an `ng-container`),\n            // it won't have inline styles or `children` so we skip it.\n            if (row.nodeType !== row.ELEMENT_NODE) {\n                continue;\n            }\n            elementsToClear.push(row);\n            for (let i = 0; i < row.children.length; i++) {\n                elementsToClear.push(row.children[i]);\n            }\n        }\n        // Coalesce with sticky row/column updates (and potentially other changes like column resize).\n        this._scheduleStyleChanges(() => {\n            for (const element of elementsToClear) {\n                this._removeStickyStyle(element, stickyDirections);\n            }\n        });\n    }\n    /**\n     * Applies sticky left and right positions to the cells of each row according to the sticky\n     * states of the rendered column definitions.\n     * @param rows The rows that should have its set of cells stuck according to the sticky states.\n     * @param stickyStartStates A list of boolean states where each state represents whether the cell\n     *     in this index position should be stuck to the start of the row.\n     * @param stickyEndStates A list of boolean states where each state represents whether the cell\n     *     in this index position should be stuck to the end of the row.\n     * @param recalculateCellWidths Whether the sticky styler should recalculate the width of each\n     *     column cell. If `false` cached widths will be used instead.\n     */\n    updateStickyColumns(rows, stickyStartStates, stickyEndStates, recalculateCellWidths = true) {\n        if (!rows.length || !this._isBrowser || !(stickyStartStates.some(state => state) ||\n            stickyEndStates.some(state => state))) {\n            return;\n        }\n        const firstRow = rows[0];\n        const numCells = firstRow.children.length;\n        const cellWidths = this._getCellWidths(firstRow, recalculateCellWidths);\n        const startPositions = this._getStickyStartColumnPositions(cellWidths, stickyStartStates);\n        const endPositions = this._getStickyEndColumnPositions(cellWidths, stickyEndStates);\n        // Coalesce with sticky row updates (and potentially other changes like column resize).\n        this._scheduleStyleChanges(() => {\n            const isRtl = this.direction === 'rtl';\n            const start = isRtl ? 'right' : 'left';\n            const end = isRtl ? 'left' : 'right';\n            for (const row of rows) {\n                for (let i = 0; i < numCells; i++) {\n                    const cell = row.children[i];\n                    if (stickyStartStates[i]) {\n                        this._addStickyStyle(cell, start, startPositions[i]);\n                    }\n                    if (stickyEndStates[i]) {\n                        this._addStickyStyle(cell, end, endPositions[i]);\n                    }\n                }\n            }\n        });\n    }\n    /**\n     * Applies sticky positioning to the row's cells if using the native table layout, and to the\n     * row itself otherwise.\n     * @param rowsToStick The list of rows that should be stuck according to their corresponding\n     *     sticky state and to the provided top or bottom position.\n     * @param stickyStates A list of boolean states where each state represents whether the row\n     *     should be stuck in the particular top or bottom position.\n     * @param position The position direction in which the row should be stuck if that row should be\n     *     sticky.\n     *\n     */\n    stickRows(rowsToStick, stickyStates, position) {\n        // Since we can't measure the rows on the server, we can't stick the rows properly.\n        if (!this._isBrowser) {\n            return;\n        }\n        // If positioning the rows to the bottom, reverse their order when evaluating the sticky\n        // position such that the last row stuck will be \"bottom: 0px\" and so on. Note that the\n        // sticky states need to be reversed as well.\n        const rows = position === 'bottom' ? rowsToStick.slice().reverse() : rowsToStick;\n        const states = position === 'bottom' ? stickyStates.slice().reverse() : stickyStates;\n        // Measure row heights all at once before adding sticky styles to reduce layout thrashing.\n        const stickyHeights = [];\n        const elementsToStick = [];\n        for (let rowIndex = 0, stickyHeight = 0; rowIndex < rows.length; rowIndex++) {\n            stickyHeights[rowIndex] = stickyHeight;\n            if (!states[rowIndex]) {\n                continue;\n            }\n            const row = rows[rowIndex];\n            elementsToStick[rowIndex] = this._isNativeHtmlTable ?\n                Array.from(row.children) : [row];\n            if (rowIndex !== rows.length - 1) {\n                stickyHeight += row.getBoundingClientRect().height;\n            }\n        }\n        // Coalesce with other sticky row updates (top/bottom), sticky columns updates\n        // (and potentially other changes like column resize).\n        this._scheduleStyleChanges(() => {\n            for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {\n                if (!states[rowIndex]) {\n                    continue;\n                }\n                const height = stickyHeights[rowIndex];\n                for (const element of elementsToStick[rowIndex]) {\n                    this._addStickyStyle(element, position, height);\n                }\n            }\n        });\n    }\n    /**\n     * When using the native table in Safari, sticky footer cells do not stick. The only way to stick\n     * footer rows is to apply sticky styling to the tfoot container. This should only be done if\n     * all footer rows are sticky. If not all footer rows are sticky, remove sticky positioning from\n     * the tfoot element.\n     */\n    updateStickyFooterContainer(tableElement, stickyStates) {\n        if (!this._isNativeHtmlTable) {\n            return;\n        }\n        const tfoot = tableElement.querySelector('tfoot');\n        // Coalesce with other sticky updates (and potentially other changes like column resize).\n        this._scheduleStyleChanges(() => {\n            if (stickyStates.some(state => !state)) {\n                this._removeStickyStyle(tfoot, ['bottom']);\n            }\n            else {\n                this._addStickyStyle(tfoot, 'bottom', 0);\n            }\n        });\n    }\n    /**\n     * Removes the sticky style on the element by removing the sticky cell CSS class, re-evaluating\n     * the zIndex, removing each of the provided sticky directions, and removing the\n     * sticky position if there are no more directions.\n     */\n    _removeStickyStyle(element, stickyDirections) {\n        for (const dir of stickyDirections) {\n            element.style[dir] = '';\n        }\n        // If the element no longer has any more sticky directions, remove sticky positioning and\n        // the sticky CSS class.\n        // Short-circuit checking element.style[dir] for stickyDirections as they\n        // were already removed above.\n        const hasDirection = STICKY_DIRECTIONS.some(dir => stickyDirections.indexOf(dir) === -1 && element.style[dir]);\n        if (hasDirection) {\n            element.style.zIndex = this._getCalculatedZIndex(element);\n        }\n        else {\n            // When not hasDirection, _getCalculatedZIndex will always return ''.\n            element.style.zIndex = '';\n            if (this._needsPositionStickyOnElement) {\n                element.style.position = '';\n            }\n            element.classList.remove(this._stickCellCss);\n        }\n    }\n    /**\n     * Adds the sticky styling to the element by adding the sticky style class, changing position\n     * to be sticky (and -webkit-sticky), setting the appropriate zIndex, and adding a sticky\n     * direction and value.\n     */\n    _addStickyStyle(element, dir, dirValue) {\n        element.classList.add(this._stickCellCss);\n        element.style[dir] = `${dirValue}px`;\n        element.style.zIndex = this._getCalculatedZIndex(element);\n        if (this._needsPositionStickyOnElement) {\n            element.style.cssText += 'position: -webkit-sticky; position: sticky; ';\n        }\n    }\n    /**\n     * Calculate what the z-index should be for the element, depending on what directions (top,\n     * bottom, left, right) have been set. It should be true that elements with a top direction\n     * should have the highest index since these are elements like a table header. If any of those\n     * elements are also sticky in another direction, then they should appear above other elements\n     * that are only sticky top (e.g. a sticky column on a sticky header). Bottom-sticky elements\n     * (e.g. footer rows) should then be next in the ordering such that they are below the header\n     * but above any non-sticky elements. Finally, left/right sticky elements (e.g. sticky columns)\n     * should minimally increment so that they are above non-sticky elements but below top and bottom\n     * elements.\n     */\n    _getCalculatedZIndex(element) {\n        const zIndexIncrements = {\n            top: 100,\n            bottom: 10,\n            left: 1,\n            right: 1,\n        };\n        let zIndex = 0;\n        // Use `Iterable` instead of `Array` because TypeScript, as of 3.6.3,\n        // loses the array generic type in the `for of`. But we *also* have to use `Array` because\n        // typescript won't iterate over an `Iterable` unless you compile with `--downlevelIteration`\n        for (const dir of STICKY_DIRECTIONS) {\n            if (element.style[dir]) {\n                zIndex += zIndexIncrements[dir];\n            }\n        }\n        return zIndex ? `${zIndex}` : '';\n    }\n    /** Gets the widths for each cell in the provided row. */\n    _getCellWidths(row, recalculateCellWidths = true) {\n        if (!recalculateCellWidths && this._cachedCellWidths.length) {\n            return this._cachedCellWidths;\n        }\n        const cellWidths = [];\n        const firstRowCells = row.children;\n        for (let i = 0; i < firstRowCells.length; i++) {\n            let cell = firstRowCells[i];\n            cellWidths.push(cell.getBoundingClientRect().width);\n        }\n        this._cachedCellWidths = cellWidths;\n        return cellWidths;\n    }\n    /**\n     * Determines the left and right positions of each sticky column cell, which will be the\n     * accumulation of all sticky column cell widths to the left and right, respectively.\n     * Non-sticky cells do not need to have a value set since their positions will not be applied.\n     */\n    _getStickyStartColumnPositions(widths, stickyStates) {\n        const positions = [];\n        let nextPosition = 0;\n        for (let i = 0; i < widths.length; i++) {\n            if (stickyStates[i]) {\n                positions[i] = nextPosition;\n                nextPosition += widths[i];\n            }\n        }\n        return positions;\n    }\n    /**\n     * Determines the left and right positions of each sticky column cell, which will be the\n     * accumulation of all sticky column cell widths to the left and right, respectively.\n     * Non-sticky cells do not need to have a value set since their positions will not be applied.\n     */\n    _getStickyEndColumnPositions(widths, stickyStates) {\n        const positions = [];\n        let nextPosition = 0;\n        for (let i = widths.length; i > 0; i--) {\n            if (stickyStates[i]) {\n                positions[i] = nextPosition;\n                nextPosition += widths[i];\n            }\n        }\n        return positions;\n    }\n    /**\n     * Schedules styles to be applied when the style scheduler deems appropriate.\n     * @breaking-change 11.0.0 This method can be removed in favor of calling\n     * `CoalescedStyleScheduler.schedule` directly once the scheduler is a required parameter.\n     */\n    _scheduleStyleChanges(changes) {\n        if (this._coalescedStyleScheduler) {\n            this._coalescedStyleScheduler.schedule(changes);\n        }\n        else {\n            changes();\n        }\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Returns an error to be thrown when attempting to find an unexisting column.\n * @param id Id whose lookup failed.\n * @docs-private\n */\nfunction getTableUnknownColumnError(id) {\n    return Error(`Could not find column with id \"${id}\".`);\n}\n/**\n * Returns an error to be thrown when two column definitions have the same name.\n * @docs-private\n */\nfunction getTableDuplicateColumnNameError(name) {\n    return Error(`Duplicate column definition name provided: \"${name}\".`);\n}\n/**\n * Returns an error to be thrown when there are multiple rows that are missing a when function.\n * @docs-private\n */\nfunction getTableMultipleDefaultRowDefsError() {\n    return Error(`There can only be one default row without a when predicate function.`);\n}\n/**\n * Returns an error to be thrown when there are no matching row defs for a particular set of data.\n * @docs-private\n */\nfunction getTableMissingMatchingRowDefError(data) {\n    return Error(`Could not find a matching row definition for the` +\n        `provided row data: ${JSON.stringify(data)}`);\n}\n/**\n * Returns an error to be thrown when there is no row definitions present in the content.\n * @docs-private\n */\nfunction getTableMissingRowDefsError() {\n    return Error('Missing definitions for header, footer, and row; ' +\n        'cannot determine which columns should be rendered.');\n}\n/**\n * Returns an error to be thrown when the data source does not match the compatible types.\n * @docs-private\n */\nfunction getTableUnknownDataSourceError() {\n    return Error(`Provided data source did not match an array, Observable, or DataSource`);\n}\n/**\n * Returns an error to be thrown when the text column cannot find a parent table to inject.\n * @docs-private\n */\nfunction getTableTextColumnMissingParentTableError() {\n    return Error(`Text column could not find a parent table for registration.`);\n}\n/**\n * Returns an error to be thrown when a table text column doesn't have a name.\n * @docs-private\n */\nfunction getTableTextColumnMissingNameError() {\n    return Error(`Table text column must have a name.`);\n}\nlet table_DataRowOutlet = /*@__PURE__*/ (() => {\n    class DataRowOutlet {\n        constructor(viewContainer, elementRef) {\n            this.viewContainer = viewContainer;\n            this.elementRef = elementRef;\n        }\n    }\n    DataRowOutlet.ɵfac = function DataRowOutlet_Factory(t) { return new (t || DataRowOutlet)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"S\" /* ViewContainerRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */])); };\n    DataRowOutlet.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: DataRowOutlet, selectors: [[\"\", \"rowOutlet\", \"\"]] });\n    return DataRowOutlet;\n})();\nlet table_HeaderRowOutlet = /*@__PURE__*/ (() => {\n    class HeaderRowOutlet {\n        constructor(viewContainer, elementRef) {\n            this.viewContainer = viewContainer;\n            this.elementRef = elementRef;\n        }\n    }\n    HeaderRowOutlet.ɵfac = function HeaderRowOutlet_Factory(t) { return new (t || HeaderRowOutlet)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"S\" /* ViewContainerRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */])); };\n    HeaderRowOutlet.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: HeaderRowOutlet, selectors: [[\"\", \"headerRowOutlet\", \"\"]] });\n    return HeaderRowOutlet;\n})();\nlet table_FooterRowOutlet = /*@__PURE__*/ (() => {\n    class FooterRowOutlet {\n        constructor(viewContainer, elementRef) {\n            this.viewContainer = viewContainer;\n            this.elementRef = elementRef;\n        }\n    }\n    FooterRowOutlet.ɵfac = function FooterRowOutlet_Factory(t) { return new (t || FooterRowOutlet)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"S\" /* ViewContainerRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */])); };\n    FooterRowOutlet.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: FooterRowOutlet, selectors: [[\"\", \"footerRowOutlet\", \"\"]] });\n    return FooterRowOutlet;\n})();\nlet table_NoDataRowOutlet = /*@__PURE__*/ (() => {\n    class NoDataRowOutlet {\n        constructor(viewContainer, elementRef) {\n            this.viewContainer = viewContainer;\n            this.elementRef = elementRef;\n        }\n    }\n    NoDataRowOutlet.ɵfac = function NoDataRowOutlet_Factory(t) { return new (t || NoDataRowOutlet)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"S\" /* ViewContainerRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */])); };\n    NoDataRowOutlet.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: NoDataRowOutlet, selectors: [[\"\", \"noDataRowOutlet\", \"\"]] });\n    return NoDataRowOutlet;\n})();\n/**\n * The table template that can be used by the mat-table. Should not be used outside of the\n * material library.\n * @docs-private\n */\nconst CDK_TABLE_TEMPLATE = \n// Note that according to MDN, the `caption` element has to be projected as the **first**\n// element in the table. See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/caption\n`\n  <ng-content select=\"caption\"></ng-content>\n  <ng-content select=\"colgroup, col\"></ng-content>\n  <ng-container headerRowOutlet></ng-container>\n  <ng-container rowOutlet></ng-container>\n  <ng-container noDataRowOutlet></ng-container>\n  <ng-container footerRowOutlet></ng-container>\n`;\n/**\n * Class used to conveniently type the embedded view ref for rows with a context.\n * @docs-private\n */\nclass table_RowViewRef extends core[\"m\" /* EmbeddedViewRef */] {\n}\nlet table_CdkTable = /*@__PURE__*/ (() => {\n    class CdkTable {\n        constructor(_differs, _changeDetectorRef, _elementRef, role, _dir, _document, _platform, \n        /**\n         * @deprecated `_coalescedStyleScheduler`, `_viewRepeater` and `_viewportRuler`\n         *    parameters to become required.\n         * @breaking-change 11.0.0\n         */\n        _viewRepeater, _coalescedStyleScheduler, \n        // Optional for backwards compatibility. The viewport ruler is provided in root. Therefore,\n        // this property will never be null.\n        // tslint:disable-next-line: lightweight-tokens\n        _viewportRuler) {\n            this._differs = _differs;\n            this._changeDetectorRef = _changeDetectorRef;\n            this._elementRef = _elementRef;\n            this._dir = _dir;\n            this._platform = _platform;\n            this._viewRepeater = _viewRepeater;\n            this._coalescedStyleScheduler = _coalescedStyleScheduler;\n            this._viewportRuler = _viewportRuler;\n            /** Subject that emits when the component has been destroyed. */\n            this._onDestroy = new Subject[\"a\" /* Subject */]();\n            /**\n             * Map of all the user's defined columns (header, data, and footer cell template) identified by\n             * name. Collection populated by the column definitions gathered by `ContentChildren` as well as\n             * any custom column definitions added to `_customColumnDefs`.\n             */\n            this._columnDefsByName = new Map();\n            /**\n             * Column definitions that were defined outside of the direct content children of the table.\n             * These will be defined when, e.g., creating a wrapper around the cdkTable that has\n             * column definitions as *its* content child.\n             */\n            this._customColumnDefs = new Set();\n            /**\n             * Data row definitions that were defined outside of the direct content children of the table.\n             * These will be defined when, e.g., creating a wrapper around the cdkTable that has\n             * built-in data rows as *its* content child.\n             */\n            this._customRowDefs = new Set();\n            /**\n             * Header row definitions that were defined outside of the direct content children of the table.\n             * These will be defined when, e.g., creating a wrapper around the cdkTable that has\n             * built-in header rows as *its* content child.\n             */\n            this._customHeaderRowDefs = new Set();\n            /**\n             * Footer row definitions that were defined outside of the direct content children of the table.\n             * These will be defined when, e.g., creating a wrapper around the cdkTable that has a\n             * built-in footer row as *its* content child.\n             */\n            this._customFooterRowDefs = new Set();\n            /**\n             * Whether the header row definition has been changed. Triggers an update to the header row after\n             * content is checked. Initialized as true so that the table renders the initial set of rows.\n             */\n            this._headerRowDefChanged = true;\n            /**\n             * Whether the footer row definition has been changed. Triggers an update to the footer row after\n             * content is checked. Initialized as true so that the table renders the initial set of rows.\n             */\n            this._footerRowDefChanged = true;\n            /**\n             * Whether the sticky column styles need to be updated. Set to `true` when the visible columns\n             * change.\n             */\n            this._stickyColumnStylesNeedReset = true;\n            /**\n             * Whether the sticky styler should recalculate cell widths when applying sticky styles. If\n             * `false`, cached values will be used instead. This is only applicable to tables with\n             * {@link fixedLayout} enabled. For other tables, cell widths will always be recalculated.\n             */\n            this._forceRecalculateCellWidths = true;\n            /**\n             * Cache of the latest rendered `RenderRow` objects as a map for easy retrieval when constructing\n             * a new list of `RenderRow` objects for rendering rows. Since the new list is constructed with\n             * the cached `RenderRow` objects when possible, the row identity is preserved when the data\n             * and row template matches, which allows the `IterableDiffer` to check rows by reference\n             * and understand which rows are added/moved/removed.\n             *\n             * Implemented as a map of maps where the first key is the `data: T` object and the second is the\n             * `CdkRowDef<T>` object. With the two keys, the cache points to a `RenderRow<T>` object that\n             * contains an array of created pairs. The array is necessary to handle cases where the data\n             * array contains multiple duplicate data objects and each instantiated `RenderRow` must be\n             * stored.\n             */\n            this._cachedRenderRowsMap = new Map();\n            /**\n             * CSS class added to any row or cell that has sticky positioning applied. May be overriden by\n             * table subclasses.\n             */\n            this.stickyCssClass = 'cdk-table-sticky';\n            /**\n             * Whether to manually add positon: sticky to all sticky cell elements. Not needed if\n             * the position is set in a selector associated with the value of stickyCssClass. May be\n             * overridden by table subclasses\n             */\n            this.needsPositionStickyOnElement = true;\n            /** Whether the no data row is currently showing anything. */\n            this._isShowingNoDataRow = false;\n            this._multiTemplateDataRows = false;\n            this._fixedLayout = false;\n            // TODO(andrewseguin): Remove max value as the end index\n            //   and instead calculate the view on init and scroll.\n            /**\n             * Stream containing the latest information on what rows are being displayed on screen.\n             * Can be used by the data source to as a heuristic of what data should be provided.\n             *\n             * @docs-private\n             */\n            this.viewChange = new BehaviorSubject[\"a\" /* BehaviorSubject */]({ start: 0, end: Number.MAX_VALUE });\n            if (!role) {\n                this._elementRef.nativeElement.setAttribute('role', 'grid');\n            }\n            this._document = _document;\n            this._isNativeHtmlTable = this._elementRef.nativeElement.nodeName === 'TABLE';\n        }\n        /**\n         * Tracking function that will be used to check the differences in data changes. Used similarly\n         * to `ngFor` `trackBy` function. Optimize row operations by identifying a row based on its data\n         * relative to the function to know if a row should be added/removed/moved.\n         * Accepts a function that takes two parameters, `index` and `item`.\n         */\n        get trackBy() {\n            return this._trackByFn;\n        }\n        set trackBy(fn) {\n            if ((typeof ngDevMode === 'undefined' || ngDevMode) && fn != null && typeof fn !== 'function') {\n                console.warn(`trackBy must be a function, but received ${JSON.stringify(fn)}.`);\n            }\n            this._trackByFn = fn;\n        }\n        /**\n         * The table's source of data, which can be provided in three ways (in order of complexity):\n         *   - Simple data array (each object represents one table row)\n         *   - Stream that emits a data array each time the array changes\n         *   - `DataSource` object that implements the connect/disconnect interface.\n         *\n         * If a data array is provided, the table must be notified when the array's objects are\n         * added, removed, or moved. This can be done by calling the `renderRows()` function which will\n         * render the diff since the last table render. If the data array reference is changed, the table\n         * will automatically trigger an update to the rows.\n         *\n         * When providing an Observable stream, the table will trigger an update automatically when the\n         * stream emits a new array of data.\n         *\n         * Finally, when providing a `DataSource` object, the table will use the Observable stream\n         * provided by the connect function and trigger updates when that stream emits new data array\n         * values. During the table's ngOnDestroy or when the data source is removed from the table, the\n         * table will call the DataSource's `disconnect` function (may be useful for cleaning up any\n         * subscriptions registered during the connect process).\n         */\n        get dataSource() {\n            return this._dataSource;\n        }\n        set dataSource(dataSource) {\n            if (this._dataSource !== dataSource) {\n                this._switchDataSource(dataSource);\n            }\n        }\n        /**\n         * Whether to allow multiple rows per data object by evaluating which rows evaluate their 'when'\n         * predicate to true. If `multiTemplateDataRows` is false, which is the default value, then each\n         * dataobject will render the first row that evaluates its when predicate to true, in the order\n         * defined in the table, or otherwise the default row which does not have a when predicate.\n         */\n        get multiTemplateDataRows() {\n            return this._multiTemplateDataRows;\n        }\n        set multiTemplateDataRows(v) {\n            this._multiTemplateDataRows = Object(coercion[\"c\" /* coerceBooleanProperty */])(v);\n            // In Ivy if this value is set via a static attribute (e.g. <table multiTemplateDataRows>),\n            // this setter will be invoked before the row outlet has been defined hence the null check.\n            if (this._rowOutlet && this._rowOutlet.viewContainer.length) {\n                this._forceRenderDataRows();\n                this.updateStickyColumnStyles();\n            }\n        }\n        /**\n         * Whether to use a fixed table layout. Enabling this option will enforce consistent column widths\n         * and optimize rendering sticky styles for native tables. No-op for flex tables.\n         */\n        get fixedLayout() {\n            return this._fixedLayout;\n        }\n        set fixedLayout(v) {\n            this._fixedLayout = Object(coercion[\"c\" /* coerceBooleanProperty */])(v);\n            // Toggling `fixedLayout` may change column widths. Sticky column styles should be recalculated.\n            this._forceRecalculateCellWidths = true;\n            this._stickyColumnStylesNeedReset = true;\n        }\n        ngOnInit() {\n            this._setupStickyStyler();\n            if (this._isNativeHtmlTable) {\n                this._applyNativeTableSections();\n            }\n            // Set up the trackBy function so that it uses the `RenderRow` as its identity by default. If\n            // the user has provided a custom trackBy, return the result of that function as evaluated\n            // with the values of the `RenderRow`'s data and index.\n            this._dataDiffer = this._differs.find([]).create((_i, dataRow) => {\n                return this.trackBy ? this.trackBy(dataRow.dataIndex, dataRow.data) : dataRow;\n            });\n            // Table cell dimensions may change after resizing the window. Signal the sticky styler to\n            // refresh its cache of cell widths the next time sticky styles are updated.\n            // @breaking-change 11.0.0 Remove null check for _viewportRuler once it's a required parameter.\n            if (this._viewportRuler) {\n                this._viewportRuler.change().pipe(Object(takeUntil[\"a\" /* takeUntil */])(this._onDestroy)).subscribe(() => {\n                    this._forceRecalculateCellWidths = true;\n                });\n            }\n        }\n        ngAfterContentChecked() {\n            // Cache the row and column definitions gathered by ContentChildren and programmatic injection.\n            this._cacheRowDefs();\n            this._cacheColumnDefs();\n            // Make sure that the user has at least added header, footer, or data row def.\n            if (!this._headerRowDefs.length && !this._footerRowDefs.length && !this._rowDefs.length &&\n                (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw getTableMissingRowDefsError();\n            }\n            // Render updates if the list of columns have been changed for the header, row, or footer defs.\n            const columnsChanged = this._renderUpdatedColumns();\n            const rowDefsChanged = columnsChanged || this._headerRowDefChanged || this._footerRowDefChanged;\n            // Ensure sticky column styles are reset if set to `true` elsewhere.\n            this._stickyColumnStylesNeedReset = this._stickyColumnStylesNeedReset || rowDefsChanged;\n            this._forceRecalculateCellWidths = rowDefsChanged;\n            // If the header row definition has been changed, trigger a render to the header row.\n            if (this._headerRowDefChanged) {\n                this._forceRenderHeaderRows();\n                this._headerRowDefChanged = false;\n            }\n            // If the footer row definition has been changed, trigger a render to the footer row.\n            if (this._footerRowDefChanged) {\n                this._forceRenderFooterRows();\n                this._footerRowDefChanged = false;\n            }\n            // If there is a data source and row definitions, connect to the data source unless a\n            // connection has already been made.\n            if (this.dataSource && this._rowDefs.length > 0 && !this._renderChangeSubscription) {\n                this._observeRenderChanges();\n            }\n            else if (this._stickyColumnStylesNeedReset) {\n                // In the above case, _observeRenderChanges will result in updateStickyColumnStyles being\n                // called when it row data arrives. Otherwise, we need to call it proactively.\n                this.updateStickyColumnStyles();\n            }\n            this._checkStickyStates();\n        }\n        ngOnDestroy() {\n            this._rowOutlet.viewContainer.clear();\n            this._noDataRowOutlet.viewContainer.clear();\n            this._headerRowOutlet.viewContainer.clear();\n            this._footerRowOutlet.viewContainer.clear();\n            this._cachedRenderRowsMap.clear();\n            this._onDestroy.next();\n            this._onDestroy.complete();\n            if (Object(collections[\"g\" /* isDataSource */])(this.dataSource)) {\n                this.dataSource.disconnect(this);\n            }\n        }\n        /**\n         * Renders rows based on the table's latest set of data, which was either provided directly as an\n         * input or retrieved through an Observable stream (directly or from a DataSource).\n         * Checks for differences in the data since the last diff to perform only the necessary\n         * changes (add/remove/move rows).\n         *\n         * If the table's data source is a DataSource or Observable, this will be invoked automatically\n         * each time the provided Observable stream emits a new data array. Otherwise if your data is\n         * an array, this function will need to be called to render any changes.\n         */\n        renderRows() {\n            this._renderRows = this._getAllRenderRows();\n            const changes = this._dataDiffer.diff(this._renderRows);\n            if (!changes) {\n                this._updateNoDataRow();\n                return;\n            }\n            const viewContainer = this._rowOutlet.viewContainer;\n            // @breaking-change 11.0.0 Remove null check for `_viewRepeater` and the\n            // `else` clause once `_viewRepeater` is turned into a required parameter.\n            if (this._viewRepeater) {\n                this._viewRepeater.applyChanges(changes, viewContainer, (record, _adjustedPreviousIndex, currentIndex) => this._getEmbeddedViewArgs(record.item, currentIndex), (record) => record.item.data, (change) => {\n                    if (change.operation === 1 /* INSERTED */ && change.context) {\n                        this._renderCellTemplateForItem(change.record.item.rowDef, change.context);\n                    }\n                });\n            }\n            else {\n                changes.forEachOperation((record, prevIndex, currentIndex) => {\n                    if (record.previousIndex == null) {\n                        const renderRow = record.item;\n                        const rowDef = renderRow.rowDef;\n                        const context = { $implicit: renderRow.data };\n                        this._renderRow(this._rowOutlet, rowDef, currentIndex, context);\n                    }\n                    else if (currentIndex == null) {\n                        viewContainer.remove(prevIndex);\n                    }\n                    else {\n                        const view = viewContainer.get(prevIndex);\n                        viewContainer.move(view, currentIndex);\n                    }\n                });\n            }\n            // Update the meta context of a row's context data (index, count, first, last, ...)\n            this._updateRowIndexContext();\n            // Update rows that did not get added/removed/moved but may have had their identity changed,\n            // e.g. if trackBy matched data on some property but the actual data reference changed.\n            changes.forEachIdentityChange((record) => {\n                const rowView = viewContainer.get(record.currentIndex);\n                rowView.context.$implicit = record.item.data;\n            });\n            this._updateNoDataRow();\n            this.updateStickyColumnStyles();\n        }\n        /** Adds a column definition that was not included as part of the content children. */\n        addColumnDef(columnDef) {\n            this._customColumnDefs.add(columnDef);\n        }\n        /** Removes a column definition that was not included as part of the content children. */\n        removeColumnDef(columnDef) {\n            this._customColumnDefs.delete(columnDef);\n        }\n        /** Adds a row definition that was not included as part of the content children. */\n        addRowDef(rowDef) {\n            this._customRowDefs.add(rowDef);\n        }\n        /** Removes a row definition that was not included as part of the content children. */\n        removeRowDef(rowDef) {\n            this._customRowDefs.delete(rowDef);\n        }\n        /** Adds a header row definition that was not included as part of the content children. */\n        addHeaderRowDef(headerRowDef) {\n            this._customHeaderRowDefs.add(headerRowDef);\n            this._headerRowDefChanged = true;\n        }\n        /** Removes a header row definition that was not included as part of the content children. */\n        removeHeaderRowDef(headerRowDef) {\n            this._customHeaderRowDefs.delete(headerRowDef);\n            this._headerRowDefChanged = true;\n        }\n        /** Adds a footer row definition that was not included as part of the content children. */\n        addFooterRowDef(footerRowDef) {\n            this._customFooterRowDefs.add(footerRowDef);\n            this._footerRowDefChanged = true;\n        }\n        /** Removes a footer row definition that was not included as part of the content children. */\n        removeFooterRowDef(footerRowDef) {\n            this._customFooterRowDefs.delete(footerRowDef);\n            this._footerRowDefChanged = true;\n        }\n        /** Sets a no data row definition that was not included as a part of the content children. */\n        setNoDataRow(noDataRow) {\n            this._customNoDataRow = noDataRow;\n        }\n        /**\n         * Updates the header sticky styles. First resets all applied styles with respect to the cells\n         * sticking to the top. Then, evaluating which cells need to be stuck to the top. This is\n         * automatically called when the header row changes its displayed set of columns, or if its\n         * sticky input changes. May be called manually for cases where the cell content changes outside\n         * of these events.\n         */\n        updateStickyHeaderRowStyles() {\n            const headerRows = this._getRenderedRows(this._headerRowOutlet);\n            const tableElement = this._elementRef.nativeElement;\n            // Hide the thead element if there are no header rows. This is necessary to satisfy\n            // overzealous a11y checkers that fail because the `rowgroup` element does not contain\n            // required child `row`.\n            const thead = tableElement.querySelector('thead');\n            if (thead) {\n                thead.style.display = headerRows.length ? '' : 'none';\n            }\n            const stickyStates = this._headerRowDefs.map(def => def.sticky);\n            this._stickyStyler.clearStickyPositioning(headerRows, ['top']);\n            this._stickyStyler.stickRows(headerRows, stickyStates, 'top');\n            // Reset the dirty state of the sticky input change since it has been used.\n            this._headerRowDefs.forEach(def => def.resetStickyChanged());\n        }\n        /**\n         * Updates the footer sticky styles. First resets all applied styles with respect to the cells\n         * sticking to the bottom. Then, evaluating which cells need to be stuck to the bottom. This is\n         * automatically called when the footer row changes its displayed set of columns, or if its\n         * sticky input changes. May be called manually for cases where the cell content changes outside\n         * of these events.\n         */\n        updateStickyFooterRowStyles() {\n            const footerRows = this._getRenderedRows(this._footerRowOutlet);\n            const tableElement = this._elementRef.nativeElement;\n            // Hide the tfoot element if there are no footer rows. This is necessary to satisfy\n            // overzealous a11y checkers that fail because the `rowgroup` element does not contain\n            // required child `row`.\n            const tfoot = tableElement.querySelector('tfoot');\n            if (tfoot) {\n                tfoot.style.display = footerRows.length ? '' : 'none';\n            }\n            const stickyStates = this._footerRowDefs.map(def => def.sticky);\n            this._stickyStyler.clearStickyPositioning(footerRows, ['bottom']);\n            this._stickyStyler.stickRows(footerRows, stickyStates, 'bottom');\n            this._stickyStyler.updateStickyFooterContainer(this._elementRef.nativeElement, stickyStates);\n            // Reset the dirty state of the sticky input change since it has been used.\n            this._footerRowDefs.forEach(def => def.resetStickyChanged());\n        }\n        /**\n         * Updates the column sticky styles. First resets all applied styles with respect to the cells\n         * sticking to the left and right. Then sticky styles are added for the left and right according\n         * to the column definitions for each cell in each row. This is automatically called when\n         * the data source provides a new set of data or when a column definition changes its sticky\n         * input. May be called manually for cases where the cell content changes outside of these events.\n         */\n        updateStickyColumnStyles() {\n            const headerRows = this._getRenderedRows(this._headerRowOutlet);\n            const dataRows = this._getRenderedRows(this._rowOutlet);\n            const footerRows = this._getRenderedRows(this._footerRowOutlet);\n            // For tables not using a fixed layout, the column widths may change when new rows are rendered.\n            // In a table using a fixed layout, row content won't affect column width, so sticky styles\n            // don't need to be cleared unless either the sticky column config changes or one of the row\n            // defs change.\n            if ((this._isNativeHtmlTable && !this._fixedLayout)\n                || this._stickyColumnStylesNeedReset) {\n                // Clear the left and right positioning from all columns in the table across all rows since\n                // sticky columns span across all table sections (header, data, footer)\n                this._stickyStyler.clearStickyPositioning([...headerRows, ...dataRows, ...footerRows], ['left', 'right']);\n                this._stickyColumnStylesNeedReset = false;\n            }\n            // Update the sticky styles for each header row depending on the def's sticky state\n            headerRows.forEach((headerRow, i) => {\n                this._addStickyColumnStyles([headerRow], this._headerRowDefs[i]);\n            });\n            // Update the sticky styles for each data row depending on its def's sticky state\n            this._rowDefs.forEach(rowDef => {\n                // Collect all the rows rendered with this row definition.\n                const rows = [];\n                for (let i = 0; i < dataRows.length; i++) {\n                    if (this._renderRows[i].rowDef === rowDef) {\n                        rows.push(dataRows[i]);\n                    }\n                }\n                this._addStickyColumnStyles(rows, rowDef);\n            });\n            // Update the sticky styles for each footer row depending on the def's sticky state\n            footerRows.forEach((footerRow, i) => {\n                this._addStickyColumnStyles([footerRow], this._footerRowDefs[i]);\n            });\n            // Reset the dirty state of the sticky input change since it has been used.\n            Array.from(this._columnDefsByName.values()).forEach(def => def.resetStickyChanged());\n        }\n        /**\n         * Get the list of RenderRow objects to render according to the current list of data and defined\n         * row definitions. If the previous list already contained a particular pair, it should be reused\n         * so that the differ equates their references.\n         */\n        _getAllRenderRows() {\n            const renderRows = [];\n            // Store the cache and create a new one. Any re-used RenderRow objects will be moved into the\n            // new cache while unused ones can be picked up by garbage collection.\n            const prevCachedRenderRows = this._cachedRenderRowsMap;\n            this._cachedRenderRowsMap = new Map();\n            // For each data object, get the list of rows that should be rendered, represented by the\n            // respective `RenderRow` object which is the pair of `data` and `CdkRowDef`.\n            for (let i = 0; i < this._data.length; i++) {\n                let data = this._data[i];\n                const renderRowsForData = this._getRenderRowsForData(data, i, prevCachedRenderRows.get(data));\n                if (!this._cachedRenderRowsMap.has(data)) {\n                    this._cachedRenderRowsMap.set(data, new WeakMap());\n                }\n                for (let j = 0; j < renderRowsForData.length; j++) {\n                    let renderRow = renderRowsForData[j];\n                    const cache = this._cachedRenderRowsMap.get(renderRow.data);\n                    if (cache.has(renderRow.rowDef)) {\n                        cache.get(renderRow.rowDef).push(renderRow);\n                    }\n                    else {\n                        cache.set(renderRow.rowDef, [renderRow]);\n                    }\n                    renderRows.push(renderRow);\n                }\n            }\n            return renderRows;\n        }\n        /**\n         * Gets a list of `RenderRow<T>` for the provided data object and any `CdkRowDef` objects that\n         * should be rendered for this data. Reuses the cached RenderRow objects if they match the same\n         * `(T, CdkRowDef)` pair.\n         */\n        _getRenderRowsForData(data, dataIndex, cache) {\n            const rowDefs = this._getRowDefs(data, dataIndex);\n            return rowDefs.map(rowDef => {\n                const cachedRenderRows = (cache && cache.has(rowDef)) ? cache.get(rowDef) : [];\n                if (cachedRenderRows.length) {\n                    const dataRow = cachedRenderRows.shift();\n                    dataRow.dataIndex = dataIndex;\n                    return dataRow;\n                }\n                else {\n                    return { data, rowDef, dataIndex };\n                }\n            });\n        }\n        /** Update the map containing the content's column definitions. */\n        _cacheColumnDefs() {\n            this._columnDefsByName.clear();\n            const columnDefs = mergeArrayAndSet(this._getOwnDefs(this._contentColumnDefs), this._customColumnDefs);\n            columnDefs.forEach(columnDef => {\n                if (this._columnDefsByName.has(columnDef.name) &&\n                    (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                    throw getTableDuplicateColumnNameError(columnDef.name);\n                }\n                this._columnDefsByName.set(columnDef.name, columnDef);\n            });\n        }\n        /** Update the list of all available row definitions that can be used. */\n        _cacheRowDefs() {\n            this._headerRowDefs = mergeArrayAndSet(this._getOwnDefs(this._contentHeaderRowDefs), this._customHeaderRowDefs);\n            this._footerRowDefs = mergeArrayAndSet(this._getOwnDefs(this._contentFooterRowDefs), this._customFooterRowDefs);\n            this._rowDefs = mergeArrayAndSet(this._getOwnDefs(this._contentRowDefs), this._customRowDefs);\n            // After all row definitions are determined, find the row definition to be considered default.\n            const defaultRowDefs = this._rowDefs.filter(def => !def.when);\n            if (!this.multiTemplateDataRows && defaultRowDefs.length > 1 &&\n                (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw getTableMultipleDefaultRowDefsError();\n            }\n            this._defaultRowDef = defaultRowDefs[0];\n        }\n        /**\n         * Check if the header, data, or footer rows have changed what columns they want to display or\n         * whether the sticky states have changed for the header or footer. If there is a diff, then\n         * re-render that section.\n         */\n        _renderUpdatedColumns() {\n            const columnsDiffReducer = (acc, def) => acc || !!def.getColumnsDiff();\n            // Force re-render data rows if the list of column definitions have changed.\n            const dataColumnsChanged = this._rowDefs.reduce(columnsDiffReducer, false);\n            if (dataColumnsChanged) {\n                this._forceRenderDataRows();\n            }\n            // Force re-render header/footer rows if the list of column definitions have changed.\n            const headerColumnsChanged = this._headerRowDefs.reduce(columnsDiffReducer, false);\n            if (headerColumnsChanged) {\n                this._forceRenderHeaderRows();\n            }\n            const footerColumnsChanged = this._footerRowDefs.reduce(columnsDiffReducer, false);\n            if (footerColumnsChanged) {\n                this._forceRenderFooterRows();\n            }\n            return dataColumnsChanged || headerColumnsChanged || footerColumnsChanged;\n        }\n        /**\n         * Switch to the provided data source by resetting the data and unsubscribing from the current\n         * render change subscription if one exists. If the data source is null, interpret this by\n         * clearing the row outlet. Otherwise start listening for new data.\n         */\n        _switchDataSource(dataSource) {\n            this._data = [];\n            if (Object(collections[\"g\" /* isDataSource */])(this.dataSource)) {\n                this.dataSource.disconnect(this);\n            }\n            // Stop listening for data from the previous data source.\n            if (this._renderChangeSubscription) {\n                this._renderChangeSubscription.unsubscribe();\n                this._renderChangeSubscription = null;\n            }\n            if (!dataSource) {\n                if (this._dataDiffer) {\n                    this._dataDiffer.diff([]);\n                }\n                this._rowOutlet.viewContainer.clear();\n            }\n            this._dataSource = dataSource;\n        }\n        /** Set up a subscription for the data provided by the data source. */\n        _observeRenderChanges() {\n            // If no data source has been set, there is nothing to observe for changes.\n            if (!this.dataSource) {\n                return;\n            }\n            let dataStream;\n            if (Object(collections[\"g\" /* isDataSource */])(this.dataSource)) {\n                dataStream = this.dataSource.connect(this);\n            }\n            else if (Object(isObservable[\"a\" /* isObservable */])(this.dataSource)) {\n                dataStream = this.dataSource;\n            }\n            else if (Array.isArray(this.dataSource)) {\n                dataStream = Object(of[\"a\" /* of */])(this.dataSource);\n            }\n            if (dataStream === undefined && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw getTableUnknownDataSourceError();\n            }\n            this._renderChangeSubscription = dataStream.pipe(Object(takeUntil[\"a\" /* takeUntil */])(this._onDestroy))\n                .subscribe(data => {\n                this._data = data || [];\n                this.renderRows();\n            });\n        }\n        /**\n         * Clears any existing content in the header row outlet and creates a new embedded view\n         * in the outlet using the header row definition.\n         */\n        _forceRenderHeaderRows() {\n            // Clear the header row outlet if any content exists.\n            if (this._headerRowOutlet.viewContainer.length > 0) {\n                this._headerRowOutlet.viewContainer.clear();\n            }\n            this._headerRowDefs.forEach((def, i) => this._renderRow(this._headerRowOutlet, def, i));\n            this.updateStickyHeaderRowStyles();\n        }\n        /**\n         * Clears any existing content in the footer row outlet and creates a new embedded view\n         * in the outlet using the footer row definition.\n         */\n        _forceRenderFooterRows() {\n            // Clear the footer row outlet if any content exists.\n            if (this._footerRowOutlet.viewContainer.length > 0) {\n                this._footerRowOutlet.viewContainer.clear();\n            }\n            this._footerRowDefs.forEach((def, i) => this._renderRow(this._footerRowOutlet, def, i));\n            this.updateStickyFooterRowStyles();\n        }\n        /** Adds the sticky column styles for the rows according to the columns' stick states. */\n        _addStickyColumnStyles(rows, rowDef) {\n            const columnDefs = Array.from(rowDef.columns || []).map(columnName => {\n                const columnDef = this._columnDefsByName.get(columnName);\n                if (!columnDef && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                    throw getTableUnknownColumnError(columnName);\n                }\n                return columnDef;\n            });\n            const stickyStartStates = columnDefs.map(columnDef => columnDef.sticky);\n            const stickyEndStates = columnDefs.map(columnDef => columnDef.stickyEnd);\n            this._stickyStyler.updateStickyColumns(rows, stickyStartStates, stickyEndStates, !this._fixedLayout || this._forceRecalculateCellWidths);\n        }\n        /** Gets the list of rows that have been rendered in the row outlet. */\n        _getRenderedRows(rowOutlet) {\n            const renderedRows = [];\n            for (let i = 0; i < rowOutlet.viewContainer.length; i++) {\n                const viewRef = rowOutlet.viewContainer.get(i);\n                renderedRows.push(viewRef.rootNodes[0]);\n            }\n            return renderedRows;\n        }\n        /**\n         * Get the matching row definitions that should be used for this row data. If there is only\n         * one row definition, it is returned. Otherwise, find the row definitions that has a when\n         * predicate that returns true with the data. If none return true, return the default row\n         * definition.\n         */\n        _getRowDefs(data, dataIndex) {\n            if (this._rowDefs.length == 1) {\n                return [this._rowDefs[0]];\n            }\n            let rowDefs = [];\n            if (this.multiTemplateDataRows) {\n                rowDefs = this._rowDefs.filter(def => !def.when || def.when(dataIndex, data));\n            }\n            else {\n                let rowDef = this._rowDefs.find(def => def.when && def.when(dataIndex, data)) || this._defaultRowDef;\n                if (rowDef) {\n                    rowDefs.push(rowDef);\n                }\n            }\n            if (!rowDefs.length && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw getTableMissingMatchingRowDefError(data);\n            }\n            return rowDefs;\n        }\n        _getEmbeddedViewArgs(renderRow, index) {\n            const rowDef = renderRow.rowDef;\n            const context = { $implicit: renderRow.data };\n            return {\n                templateRef: rowDef.template,\n                context,\n                index,\n            };\n        }\n        /**\n         * Creates a new row template in the outlet and fills it with the set of cell templates.\n         * Optionally takes a context to provide to the row and cells, as well as an optional index\n         * of where to place the new row template in the outlet.\n         */\n        _renderRow(outlet, rowDef, index, context = {}) {\n            // TODO(andrewseguin): enforce that one outlet was instantiated from createEmbeddedView\n            const view = outlet.viewContainer.createEmbeddedView(rowDef.template, context, index);\n            this._renderCellTemplateForItem(rowDef, context);\n            return view;\n        }\n        _renderCellTemplateForItem(rowDef, context) {\n            for (let cellTemplate of this._getCellTemplates(rowDef)) {\n                if (table_CdkCellOutlet.mostRecentCellOutlet) {\n                    table_CdkCellOutlet.mostRecentCellOutlet._viewContainer.createEmbeddedView(cellTemplate, context);\n                }\n            }\n            this._changeDetectorRef.markForCheck();\n        }\n        /**\n         * Updates the index-related context for each row to reflect any changes in the index of the rows,\n         * e.g. first/last/even/odd.\n         */\n        _updateRowIndexContext() {\n            const viewContainer = this._rowOutlet.viewContainer;\n            for (let renderIndex = 0, count = viewContainer.length; renderIndex < count; renderIndex++) {\n                const viewRef = viewContainer.get(renderIndex);\n                const context = viewRef.context;\n                context.count = count;\n                context.first = renderIndex === 0;\n                context.last = renderIndex === count - 1;\n                context.even = renderIndex % 2 === 0;\n                context.odd = !context.even;\n                if (this.multiTemplateDataRows) {\n                    context.dataIndex = this._renderRows[renderIndex].dataIndex;\n                    context.renderIndex = renderIndex;\n                }\n                else {\n                    context.index = this._renderRows[renderIndex].dataIndex;\n                }\n            }\n        }\n        /** Gets the column definitions for the provided row def. */\n        _getCellTemplates(rowDef) {\n            if (!rowDef || !rowDef.columns) {\n                return [];\n            }\n            return Array.from(rowDef.columns, columnId => {\n                const column = this._columnDefsByName.get(columnId);\n                if (!column && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                    throw getTableUnknownColumnError(columnId);\n                }\n                return rowDef.extractCellTemplate(column);\n            });\n        }\n        /** Adds native table sections (e.g. tbody) and moves the row outlets into them. */\n        _applyNativeTableSections() {\n            const documentFragment = this._document.createDocumentFragment();\n            const sections = [\n                { tag: 'thead', outlets: [this._headerRowOutlet] },\n                { tag: 'tbody', outlets: [this._rowOutlet, this._noDataRowOutlet] },\n                { tag: 'tfoot', outlets: [this._footerRowOutlet] },\n            ];\n            for (const section of sections) {\n                const element = this._document.createElement(section.tag);\n                element.setAttribute('role', 'rowgroup');\n                for (const outlet of section.outlets) {\n                    element.appendChild(outlet.elementRef.nativeElement);\n                }\n                documentFragment.appendChild(element);\n            }\n            // Use a DocumentFragment so we don't hit the DOM on each iteration.\n            this._elementRef.nativeElement.appendChild(documentFragment);\n        }\n        /**\n         * Forces a re-render of the data rows. Should be called in cases where there has been an input\n         * change that affects the evaluation of which rows should be rendered, e.g. toggling\n         * `multiTemplateDataRows` or adding/removing row definitions.\n         */\n        _forceRenderDataRows() {\n            this._dataDiffer.diff([]);\n            this._rowOutlet.viewContainer.clear();\n            this.renderRows();\n        }\n        /**\n         * Checks if there has been a change in sticky states since last check and applies the correct\n         * sticky styles. Since checking resets the \"dirty\" state, this should only be performed once\n         * during a change detection and after the inputs are settled (after content check).\n         */\n        _checkStickyStates() {\n            const stickyCheckReducer = (acc, d) => {\n                return acc || d.hasStickyChanged();\n            };\n            // Note that the check needs to occur for every definition since it notifies the definition\n            // that it can reset its dirty state. Using another operator like `some` may short-circuit\n            // remaining definitions and leave them in an unchecked state.\n            if (this._headerRowDefs.reduce(stickyCheckReducer, false)) {\n                this.updateStickyHeaderRowStyles();\n            }\n            if (this._footerRowDefs.reduce(stickyCheckReducer, false)) {\n                this.updateStickyFooterRowStyles();\n            }\n            if (Array.from(this._columnDefsByName.values()).reduce(stickyCheckReducer, false)) {\n                this._stickyColumnStylesNeedReset = true;\n                this.updateStickyColumnStyles();\n            }\n        }\n        /**\n         * Creates the sticky styler that will be used for sticky rows and columns. Listens\n         * for directionality changes and provides the latest direction to the styler. Re-applies column\n         * stickiness when directionality changes.\n         */\n        _setupStickyStyler() {\n            const direction = this._dir ? this._dir.value : 'ltr';\n            this._stickyStyler = new StickyStyler(this._isNativeHtmlTable, this.stickyCssClass, direction, this._coalescedStyleScheduler, this._platform.isBrowser, this.needsPositionStickyOnElement);\n            (this._dir ? this._dir.change : Object(of[\"a\" /* of */])())\n                .pipe(Object(takeUntil[\"a\" /* takeUntil */])(this._onDestroy))\n                .subscribe(value => {\n                this._stickyStyler.direction = value;\n                this.updateStickyColumnStyles();\n            });\n        }\n        /** Filters definitions that belong to this table from a QueryList. */\n        _getOwnDefs(items) {\n            return items.filter(item => !item._table || item._table === this);\n        }\n        /** Creates or removes the no data row, depending on whether any data is being shown. */\n        _updateNoDataRow() {\n            const noDataRow = this._customNoDataRow || this._noDataRow;\n            if (noDataRow) {\n                const shouldShow = this._rowOutlet.viewContainer.length === 0;\n                if (shouldShow !== this._isShowingNoDataRow) {\n                    const container = this._noDataRowOutlet.viewContainer;\n                    shouldShow ? container.createEmbeddedView(noDataRow.templateRef) : container.clear();\n                    this._isShowingNoDataRow = shouldShow;\n                }\n            }\n        }\n    }\n    CdkTable.ɵfac = function CdkTable_Factory(t) { return new (t || CdkTable)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"u\" /* IterableDiffers */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"h\" /* ChangeDetectorRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"dc\" /* ɵɵinjectAttribute */]('role'), core[\"Pb\" /* ɵɵdirectiveInject */](bidi[\"b\" /* Directionality */], 8), core[\"Pb\" /* ɵɵdirectiveInject */](common[\"d\" /* DOCUMENT */]), core[\"Pb\" /* ɵɵdirectiveInject */](platform[\"a\" /* Platform */]), core[\"Pb\" /* ɵɵdirectiveInject */](collections[\"f\" /* _VIEW_REPEATER_STRATEGY */], 8), core[\"Pb\" /* ɵɵdirectiveInject */](_COALESCED_STYLE_SCHEDULER, 8), core[\"Pb\" /* ɵɵdirectiveInject */](scrolling[\"e\" /* ViewportRuler */], 8)); };\n    CdkTable.ɵcmp = /*@__PURE__*/ core[\"Jb\" /* ɵɵdefineComponent */]({ type: CdkTable, selectors: [[\"cdk-table\"], [\"table\", \"cdk-table\", \"\"]], contentQueries: function CdkTable_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                core[\"Ib\" /* ɵɵcontentQuery */](dirIndex, table_CdkNoDataRow, true);\n                core[\"Ib\" /* ɵɵcontentQuery */](dirIndex, table_CdkColumnDef, true);\n                core[\"Ib\" /* ɵɵcontentQuery */](dirIndex, table_CdkRowDef, true);\n                core[\"Ib\" /* ɵɵcontentQuery */](dirIndex, table_CdkHeaderRowDef, true);\n                core[\"Ib\" /* ɵɵcontentQuery */](dirIndex, table_CdkFooterRowDef, true);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx._noDataRow = _t.first);\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx._contentColumnDefs = _t);\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx._contentRowDefs = _t);\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx._contentHeaderRowDefs = _t);\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx._contentFooterRowDefs = _t);\n            }\n        }, viewQuery: function CdkTable_Query(rf, ctx) {\n            if (rf & 1) {\n                core[\"Gc\" /* ɵɵstaticViewQuery */](table_DataRowOutlet, true);\n                core[\"Gc\" /* ɵɵstaticViewQuery */](table_HeaderRowOutlet, true);\n                core[\"Gc\" /* ɵɵstaticViewQuery */](table_FooterRowOutlet, true);\n                core[\"Gc\" /* ɵɵstaticViewQuery */](table_NoDataRowOutlet, true);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx._rowOutlet = _t.first);\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx._headerRowOutlet = _t.first);\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx._footerRowOutlet = _t.first);\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx._noDataRowOutlet = _t.first);\n            }\n        }, hostAttrs: [1, \"cdk-table\"], hostVars: 2, hostBindings: function CdkTable_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Hb\" /* ɵɵclassProp */](\"cdk-table-fixed-layout\", ctx.fixedLayout);\n            }\n        }, inputs: { trackBy: \"trackBy\", dataSource: \"dataSource\", multiTemplateDataRows: \"multiTemplateDataRows\", fixedLayout: \"fixedLayout\" }, exportAs: [\"cdkTable\"], features: [/*@__PURE__*/ core[\"Bb\" /* ɵɵProvidersFeature */]([\n                { provide: CDK_TABLE, useExisting: CdkTable },\n                { provide: collections[\"f\" /* _VIEW_REPEATER_STRATEGY */], useClass: collections[\"d\" /* _DisposeViewRepeaterStrategy */] },\n                { provide: _COALESCED_STYLE_SCHEDULER, useClass: table_CoalescedStyleScheduler },\n            ])], ngContentSelectors: _c1, decls: 6, vars: 0, consts: [[\"headerRowOutlet\", \"\"], [\"rowOutlet\", \"\"], [\"noDataRowOutlet\", \"\"], [\"footerRowOutlet\", \"\"]], template: function CdkTable_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"oc\" /* ɵɵprojectionDef */](_c0);\n                core[\"nc\" /* ɵɵprojection */](0);\n                core[\"nc\" /* ɵɵprojection */](1, 1);\n                core[\"Rb\" /* ɵɵelementContainer */](2, 0);\n                core[\"Rb\" /* ɵɵelementContainer */](3, 1);\n                core[\"Rb\" /* ɵɵelementContainer */](4, 2);\n                core[\"Rb\" /* ɵɵelementContainer */](5, 3);\n            }\n        }, directives: [table_HeaderRowOutlet, table_DataRowOutlet, table_NoDataRowOutlet, table_FooterRowOutlet], styles: [\".cdk-table-fixed-layout{table-layout:fixed}\\n\"], encapsulation: 2 });\n    return CdkTable;\n})();\n/** Utility function that gets a merged list of the entries in an array and values of a Set. */\nfunction mergeArrayAndSet(array, set) {\n    return array.concat(Array.from(set));\n}\nlet table_CdkTextColumn = /*@__PURE__*/ (() => {\n    class CdkTextColumn {\n        constructor(\n        // `CdkTextColumn` is always requiring a table, but we just assert it manually\n        // for better error reporting.\n        // tslint:disable-next-line: lightweight-tokens\n        _table, _options) {\n            this._table = _table;\n            this._options = _options;\n            /** Alignment of the cell values. */\n            this.justify = 'start';\n            this._options = _options || {};\n        }\n        /** Column name that should be used to reference this column. */\n        get name() {\n            return this._name;\n        }\n        set name(name) {\n            this._name = name;\n            // With Ivy, inputs can be initialized before static query results are\n            // available. In that case, we defer the synchronization until \"ngOnInit\" fires.\n            this._syncColumnDefName();\n        }\n        ngOnInit() {\n            this._syncColumnDefName();\n            if (this.headerText === undefined) {\n                this.headerText = this._createDefaultHeaderText();\n            }\n            if (!this.dataAccessor) {\n                this.dataAccessor =\n                    this._options.defaultDataAccessor || ((data, name) => data[name]);\n            }\n            if (this._table) {\n                // Provide the cell and headerCell directly to the table with the static `ViewChild` query,\n                // since the columnDef will not pick up its content by the time the table finishes checking\n                // its content and initializing the rows.\n                this.columnDef.cell = this.cell;\n                this.columnDef.headerCell = this.headerCell;\n                this._table.addColumnDef(this.columnDef);\n            }\n            else if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                throw getTableTextColumnMissingParentTableError();\n            }\n        }\n        ngOnDestroy() {\n            if (this._table) {\n                this._table.removeColumnDef(this.columnDef);\n            }\n        }\n        /**\n         * Creates a default header text. Use the options' header text transformation function if one\n         * has been provided. Otherwise simply capitalize the column name.\n         */\n        _createDefaultHeaderText() {\n            const name = this.name;\n            if (!name && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw getTableTextColumnMissingNameError();\n            }\n            if (this._options && this._options.defaultHeaderTextTransform) {\n                return this._options.defaultHeaderTextTransform(name);\n            }\n            return name[0].toUpperCase() + name.slice(1);\n        }\n        /** Synchronizes the column definition name with the text column name. */\n        _syncColumnDefName() {\n            if (this.columnDef) {\n                this.columnDef.name = this.name;\n            }\n        }\n    }\n    CdkTextColumn.ɵfac = function CdkTextColumn_Factory(t) { return new (t || CdkTextColumn)(core[\"Pb\" /* ɵɵdirectiveInject */](table_CdkTable, 8), core[\"Pb\" /* ɵɵdirectiveInject */](TEXT_COLUMN_OPTIONS, 8)); };\n    CdkTextColumn.ɵcmp = /*@__PURE__*/ core[\"Jb\" /* ɵɵdefineComponent */]({ type: CdkTextColumn, selectors: [[\"cdk-text-column\"]], viewQuery: function CdkTextColumn_Query(rf, ctx) {\n            if (rf & 1) {\n                core[\"Gc\" /* ɵɵstaticViewQuery */](table_CdkColumnDef, true);\n                core[\"Gc\" /* ɵɵstaticViewQuery */](table_CdkCellDef, true);\n                core[\"Gc\" /* ɵɵstaticViewQuery */](table_CdkHeaderCellDef, true);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx.columnDef = _t.first);\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx.cell = _t.first);\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx.headerCell = _t.first);\n            }\n        }, inputs: { justify: \"justify\", name: \"name\", headerText: \"headerText\", dataAccessor: \"dataAccessor\" }, decls: 3, vars: 0, consts: [[\"cdkColumnDef\", \"\"], [\"cdk-header-cell\", \"\", 3, \"text-align\", 4, \"cdkHeaderCellDef\"], [\"cdk-cell\", \"\", 3, \"text-align\", 4, \"cdkCellDef\"], [\"cdk-header-cell\", \"\"], [\"cdk-cell\", \"\"]], template: function CdkTextColumn_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"Tb\" /* ɵɵelementContainerStart */](0, 0);\n                core[\"Kc\" /* ɵɵtemplate */](1, CdkTextColumn_th_1_Template, 2, 3, \"th\", 1);\n                core[\"Kc\" /* ɵɵtemplate */](2, CdkTextColumn_td_2_Template, 2, 3, \"td\", 2);\n                core[\"Sb\" /* ɵɵelementContainerEnd */]();\n            }\n        }, directives: [table_CdkColumnDef, table_CdkHeaderCellDef, table_CdkCellDef, table_CdkHeaderCell, table_CdkCell], encapsulation: 2 });\n    return CdkTextColumn;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst EXPORTED_DECLARATIONS = [\n    table_CdkTable,\n    table_CdkRowDef,\n    table_CdkCellDef,\n    table_CdkCellOutlet,\n    table_CdkHeaderCellDef,\n    table_CdkFooterCellDef,\n    table_CdkColumnDef,\n    table_CdkCell,\n    table_CdkRow,\n    table_CdkHeaderCell,\n    table_CdkFooterCell,\n    table_CdkHeaderRow,\n    table_CdkHeaderRowDef,\n    table_CdkFooterRow,\n    table_CdkFooterRowDef,\n    table_DataRowOutlet,\n    table_HeaderRowOutlet,\n    table_FooterRowOutlet,\n    table_CdkTextColumn,\n    table_CdkNoDataRow,\n    table_NoDataRowOutlet,\n];\nlet table_CdkTableModule = /*@__PURE__*/ (() => {\n    class CdkTableModule {\n    }\n    CdkTableModule.ɵmod = /*@__PURE__*/ core[\"Nb\" /* ɵɵdefineNgModule */]({ type: CdkTableModule });\n    CdkTableModule.ɵinj = /*@__PURE__*/ core[\"Mb\" /* ɵɵdefineInjector */]({ factory: function CdkTableModule_Factory(t) { return new (t || CdkTableModule)(); }, imports: [[scrolling[\"d\" /* ScrollingModule */]]] });\n    return CdkTableModule;\n})();\n/*@__PURE__*/ (function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ec\" /* ɵɵsetNgModuleScope */](table_CdkTableModule, { declarations: function () { return [table_CdkTable, table_CdkRowDef, table_CdkCellDef, table_CdkCellOutlet, table_CdkHeaderCellDef, table_CdkFooterCellDef, table_CdkColumnDef, table_CdkCell, table_CdkRow, table_CdkHeaderCell, table_CdkFooterCell, table_CdkHeaderRow, table_CdkHeaderRowDef, table_CdkFooterRow, table_CdkFooterRowDef, table_DataRowOutlet, table_HeaderRowOutlet, table_FooterRowOutlet, table_CdkTextColumn, table_CdkNoDataRow, table_NoDataRowOutlet]; }, imports: function () { return [scrolling[\"d\" /* ScrollingModule */]]; }, exports: function () { return [table_CdkTable, table_CdkRowDef, table_CdkCellDef, table_CdkCellOutlet, table_CdkHeaderCellDef, table_CdkFooterCellDef, table_CdkColumnDef, table_CdkCell, table_CdkRow, table_CdkHeaderCell, table_CdkFooterCell, table_CdkHeaderRow, table_CdkHeaderRowDef, table_CdkFooterRow, table_CdkFooterRowDef, table_DataRowOutlet, table_HeaderRowOutlet, table_FooterRowOutlet, table_CdkTextColumn, table_CdkNoDataRow, table_NoDataRowOutlet]; } }); })();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=table.js.map\n\n// EXTERNAL MODULE: ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/core.js + 1 modules\nvar fesm2015_core = __webpack_require__(\"FKr1\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subscription.js + 1 modules\nvar Subscription = __webpack_require__(\"quSY\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/merge.js\nvar merge = __webpack_require__(\"VRyK\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/combineLatest.js\nvar combineLatest = __webpack_require__(\"itXk\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/map.js\nvar map = __webpack_require__(\"lJxs\");\n\n// CONCATENATED MODULE: ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/table.js\n\n\n\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Wrapper for the CdkTable with Material design styles.\n */\n\n\nconst table_c0 = [[[\"caption\"]], [[\"colgroup\"], [\"col\"]]];\nconst table_c1 = [\"caption\", \"colgroup, col\"];\nfunction MatTextColumn_th_1_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Vb\" /* ɵɵelementStart */](0, \"th\", 3);\n        core[\"Mc\" /* ɵɵtext */](1);\n        core[\"Ub\" /* ɵɵelementEnd */]();\n    }\n    if (rf & 2) {\n        const ctx_r0 = core[\"kc\" /* ɵɵnextContext */]();\n        core[\"Hc\" /* ɵɵstyleProp */](\"text-align\", ctx_r0.justify);\n        core[\"Cb\" /* ɵɵadvance */](1);\n        core[\"Oc\" /* ɵɵtextInterpolate1 */](\" \", ctx_r0.headerText, \" \");\n    }\n}\nfunction MatTextColumn_td_2_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Vb\" /* ɵɵelementStart */](0, \"td\", 4);\n        core[\"Mc\" /* ɵɵtext */](1);\n        core[\"Ub\" /* ɵɵelementEnd */]();\n    }\n    if (rf & 2) {\n        const data_r2 = ctx.$implicit;\n        const ctx_r1 = core[\"kc\" /* ɵɵnextContext */]();\n        core[\"Hc\" /* ɵɵstyleProp */](\"text-align\", ctx_r1.justify);\n        core[\"Cb\" /* ɵɵadvance */](1);\n        core[\"Oc\" /* ɵɵtextInterpolate1 */](\" \", ctx_r1.dataAccessor(data_r2, ctx_r1.name), \" \");\n    }\n}\nlet table_MatTable = /*@__PURE__*/ (() => {\n    class MatTable extends table_CdkTable {\n        constructor() {\n            super(...arguments);\n            /** Overrides the sticky CSS class set by the `CdkTable`. */\n            this.stickyCssClass = 'mat-table-sticky';\n            /** Overrides the need to add position: sticky on every sticky cell element in `CdkTable`. */\n            this.needsPositionStickyOnElement = false;\n        }\n    }\n    MatTable.ɵfac = function MatTable_Factory(t) { return ɵMatTable_BaseFactory(t || MatTable); };\n    MatTable.ɵcmp = /*@__PURE__*/ core[\"Jb\" /* ɵɵdefineComponent */]({ type: MatTable, selectors: [[\"mat-table\"], [\"table\", \"mat-table\", \"\"]], hostAttrs: [1, \"mat-table\"], hostVars: 2, hostBindings: function MatTable_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Hb\" /* ɵɵclassProp */](\"mat-table-fixed-layout\", ctx.fixedLayout);\n            }\n        }, exportAs: [\"matTable\"], features: [/*@__PURE__*/ core[\"Bb\" /* ɵɵProvidersFeature */]([\n                // TODO(michaeljamesparsons) Abstract the view repeater strategy to a directive API so this code\n                //  is only included in the build if used.\n                { provide: collections[\"f\" /* _VIEW_REPEATER_STRATEGY */], useClass: collections[\"d\" /* _DisposeViewRepeaterStrategy */] },\n                { provide: table_CdkTable, useExisting: MatTable },\n                { provide: CDK_TABLE, useExisting: MatTable },\n                { provide: _COALESCED_STYLE_SCHEDULER, useClass: table_CoalescedStyleScheduler },\n            ]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]], ngContentSelectors: table_c1, decls: 6, vars: 0, consts: [[\"headerRowOutlet\", \"\"], [\"rowOutlet\", \"\"], [\"noDataRowOutlet\", \"\"], [\"footerRowOutlet\", \"\"]], template: function MatTable_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"oc\" /* ɵɵprojectionDef */](table_c0);\n                core[\"nc\" /* ɵɵprojection */](0);\n                core[\"nc\" /* ɵɵprojection */](1, 1);\n                core[\"Rb\" /* ɵɵelementContainer */](2, 0);\n                core[\"Rb\" /* ɵɵelementContainer */](3, 1);\n                core[\"Rb\" /* ɵɵelementContainer */](4, 2);\n                core[\"Rb\" /* ɵɵelementContainer */](5, 3);\n            }\n        }, directives: [table_HeaderRowOutlet, table_DataRowOutlet, table_NoDataRowOutlet, table_FooterRowOutlet], styles: [\"mat-table{display:block}mat-header-row{min-height:56px}mat-row,mat-footer-row{min-height:48px}mat-row,mat-header-row,mat-footer-row{display:flex;border-width:0;border-bottom-width:1px;border-style:solid;align-items:center;box-sizing:border-box}mat-row::after,mat-header-row::after,mat-footer-row::after{display:inline-block;min-height:inherit;content:\\\"\\\"}mat-cell:first-of-type,mat-header-cell:first-of-type,mat-footer-cell:first-of-type{padding-left:24px}[dir=rtl] mat-cell:first-of-type:not(:only-of-type),[dir=rtl] mat-header-cell:first-of-type:not(:only-of-type),[dir=rtl] mat-footer-cell:first-of-type:not(:only-of-type){padding-left:0;padding-right:24px}mat-cell:last-of-type,mat-header-cell:last-of-type,mat-footer-cell:last-of-type{padding-right:24px}[dir=rtl] mat-cell:last-of-type:not(:only-of-type),[dir=rtl] mat-header-cell:last-of-type:not(:only-of-type),[dir=rtl] mat-footer-cell:last-of-type:not(:only-of-type){padding-right:0;padding-left:24px}mat-cell,mat-header-cell,mat-footer-cell{flex:1;display:flex;align-items:center;overflow:hidden;word-wrap:break-word;min-height:inherit}table.mat-table{border-spacing:0}tr.mat-header-row{height:56px}tr.mat-row,tr.mat-footer-row{height:48px}th.mat-header-cell{text-align:left}[dir=rtl] th.mat-header-cell{text-align:right}th.mat-header-cell,td.mat-cell,td.mat-footer-cell{padding:0;border-bottom-width:1px;border-bottom-style:solid}th.mat-header-cell:first-of-type,td.mat-cell:first-of-type,td.mat-footer-cell:first-of-type{padding-left:24px}[dir=rtl] th.mat-header-cell:first-of-type:not(:only-of-type),[dir=rtl] td.mat-cell:first-of-type:not(:only-of-type),[dir=rtl] td.mat-footer-cell:first-of-type:not(:only-of-type){padding-left:0;padding-right:24px}th.mat-header-cell:last-of-type,td.mat-cell:last-of-type,td.mat-footer-cell:last-of-type{padding-right:24px}[dir=rtl] th.mat-header-cell:last-of-type:not(:only-of-type),[dir=rtl] td.mat-cell:last-of-type:not(:only-of-type),[dir=rtl] td.mat-footer-cell:last-of-type:not(:only-of-type){padding-right:0;padding-left:24px}.mat-table-sticky{position:-webkit-sticky;position:sticky}.mat-table-fixed-layout{table-layout:fixed}\\n\"], encapsulation: 2 });\n    return MatTable;\n})();\nconst ɵMatTable_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ core[\"Xb\" /* ɵɵgetInheritedFactory */](table_MatTable);\nlet table_MatCellDef = /*@__PURE__*/ (() => {\n    class MatCellDef extends table_CdkCellDef {\n    }\n    MatCellDef.ɵfac = function MatCellDef_Factory(t) { return ɵMatCellDef_BaseFactory(t || MatCellDef); };\n    MatCellDef.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: MatCellDef, selectors: [[\"\", \"matCellDef\", \"\"]], features: [/*@__PURE__*/ core[\"Bb\" /* ɵɵProvidersFeature */]([{ provide: table_CdkCellDef, useExisting: MatCellDef }]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return MatCellDef;\n})();\nconst ɵMatCellDef_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ core[\"Xb\" /* ɵɵgetInheritedFactory */](table_MatCellDef);\nlet table_MatHeaderCellDef = /*@__PURE__*/ (() => {\n    class MatHeaderCellDef extends table_CdkHeaderCellDef {\n    }\n    MatHeaderCellDef.ɵfac = function MatHeaderCellDef_Factory(t) { return ɵMatHeaderCellDef_BaseFactory(t || MatHeaderCellDef); };\n    MatHeaderCellDef.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: MatHeaderCellDef, selectors: [[\"\", \"matHeaderCellDef\", \"\"]], features: [/*@__PURE__*/ core[\"Bb\" /* ɵɵProvidersFeature */]([{ provide: table_CdkHeaderCellDef, useExisting: MatHeaderCellDef }]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return MatHeaderCellDef;\n})();\nconst ɵMatHeaderCellDef_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ core[\"Xb\" /* ɵɵgetInheritedFactory */](table_MatHeaderCellDef);\nlet table_MatFooterCellDef = /*@__PURE__*/ (() => {\n    class MatFooterCellDef extends table_CdkFooterCellDef {\n    }\n    MatFooterCellDef.ɵfac = function MatFooterCellDef_Factory(t) { return ɵMatFooterCellDef_BaseFactory(t || MatFooterCellDef); };\n    MatFooterCellDef.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: MatFooterCellDef, selectors: [[\"\", \"matFooterCellDef\", \"\"]], features: [/*@__PURE__*/ core[\"Bb\" /* ɵɵProvidersFeature */]([{ provide: table_CdkFooterCellDef, useExisting: MatFooterCellDef }]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return MatFooterCellDef;\n})();\nconst ɵMatFooterCellDef_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ core[\"Xb\" /* ɵɵgetInheritedFactory */](table_MatFooterCellDef);\nlet table_MatColumnDef = /*@__PURE__*/ (() => {\n    class MatColumnDef extends table_CdkColumnDef {\n        /** Unique name for this column. */\n        get name() { return this._name; }\n        set name(name) { this._setNameInput(name); }\n        /**\n         * Add \"mat-column-\" prefix in addition to \"cdk-column-\" prefix.\n         * In the future, this will only add \"mat-column-\" and columnCssClassName\n         * will change from type string[] to string.\n         * @docs-private\n         */\n        _updateColumnCssClassName() {\n            super._updateColumnCssClassName();\n            this._columnCssClassName.push(`mat-column-${this.cssClassFriendlyName}`);\n        }\n    }\n    MatColumnDef.ɵfac = function MatColumnDef_Factory(t) { return ɵMatColumnDef_BaseFactory(t || MatColumnDef); };\n    MatColumnDef.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: MatColumnDef, selectors: [[\"\", \"matColumnDef\", \"\"]], inputs: { sticky: \"sticky\", name: [\"matColumnDef\", \"name\"] }, features: [/*@__PURE__*/ core[\"Bb\" /* ɵɵProvidersFeature */]([\n                { provide: table_CdkColumnDef, useExisting: MatColumnDef },\n                { provide: 'MAT_SORT_HEADER_COLUMN_DEF', useExisting: MatColumnDef }\n            ]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return MatColumnDef;\n})();\nconst ɵMatColumnDef_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ core[\"Xb\" /* ɵɵgetInheritedFactory */](table_MatColumnDef);\nlet table_MatHeaderCell = /*@__PURE__*/ (() => {\n    class MatHeaderCell extends table_CdkHeaderCell {\n    }\n    MatHeaderCell.ɵfac = function MatHeaderCell_Factory(t) { return ɵMatHeaderCell_BaseFactory(t || MatHeaderCell); };\n    MatHeaderCell.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: MatHeaderCell, selectors: [[\"mat-header-cell\"], [\"th\", \"mat-header-cell\", \"\"]], hostAttrs: [\"role\", \"columnheader\", 1, \"mat-header-cell\"], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return MatHeaderCell;\n})();\nconst ɵMatHeaderCell_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ core[\"Xb\" /* ɵɵgetInheritedFactory */](table_MatHeaderCell);\nlet table_MatFooterCell = /*@__PURE__*/ (() => {\n    class MatFooterCell extends table_CdkFooterCell {\n    }\n    MatFooterCell.ɵfac = function MatFooterCell_Factory(t) { return ɵMatFooterCell_BaseFactory(t || MatFooterCell); };\n    MatFooterCell.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: MatFooterCell, selectors: [[\"mat-footer-cell\"], [\"td\", \"mat-footer-cell\", \"\"]], hostAttrs: [\"role\", \"gridcell\", 1, \"mat-footer-cell\"], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return MatFooterCell;\n})();\nconst ɵMatFooterCell_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ core[\"Xb\" /* ɵɵgetInheritedFactory */](table_MatFooterCell);\nlet table_MatCell = /*@__PURE__*/ (() => {\n    class MatCell extends table_CdkCell {\n    }\n    MatCell.ɵfac = function MatCell_Factory(t) { return ɵMatCell_BaseFactory(t || MatCell); };\n    MatCell.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: MatCell, selectors: [[\"mat-cell\"], [\"td\", \"mat-cell\", \"\"]], hostAttrs: [\"role\", \"gridcell\", 1, \"mat-cell\"], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return MatCell;\n})();\nconst ɵMatCell_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ core[\"Xb\" /* ɵɵgetInheritedFactory */](table_MatCell);\nlet table_MatHeaderRowDef = /*@__PURE__*/ (() => {\n    class MatHeaderRowDef extends table_CdkHeaderRowDef {\n    }\n    MatHeaderRowDef.ɵfac = function MatHeaderRowDef_Factory(t) { return ɵMatHeaderRowDef_BaseFactory(t || MatHeaderRowDef); };\n    MatHeaderRowDef.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: MatHeaderRowDef, selectors: [[\"\", \"matHeaderRowDef\", \"\"]], inputs: { columns: [\"matHeaderRowDef\", \"columns\"], sticky: [\"matHeaderRowDefSticky\", \"sticky\"] }, features: [/*@__PURE__*/ core[\"Bb\" /* ɵɵProvidersFeature */]([{ provide: table_CdkHeaderRowDef, useExisting: MatHeaderRowDef }]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return MatHeaderRowDef;\n})();\nconst ɵMatHeaderRowDef_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ core[\"Xb\" /* ɵɵgetInheritedFactory */](table_MatHeaderRowDef);\nlet table_MatFooterRowDef = /*@__PURE__*/ (() => {\n    class MatFooterRowDef extends table_CdkFooterRowDef {\n    }\n    MatFooterRowDef.ɵfac = function MatFooterRowDef_Factory(t) { return ɵMatFooterRowDef_BaseFactory(t || MatFooterRowDef); };\n    MatFooterRowDef.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: MatFooterRowDef, selectors: [[\"\", \"matFooterRowDef\", \"\"]], inputs: { columns: [\"matFooterRowDef\", \"columns\"], sticky: [\"matFooterRowDefSticky\", \"sticky\"] }, features: [/*@__PURE__*/ core[\"Bb\" /* ɵɵProvidersFeature */]([{ provide: table_CdkFooterRowDef, useExisting: MatFooterRowDef }]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return MatFooterRowDef;\n})();\nconst ɵMatFooterRowDef_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ core[\"Xb\" /* ɵɵgetInheritedFactory */](table_MatFooterRowDef);\nlet table_MatRowDef = /*@__PURE__*/ (() => {\n    class MatRowDef extends table_CdkRowDef {\n    }\n    MatRowDef.ɵfac = function MatRowDef_Factory(t) { return ɵMatRowDef_BaseFactory(t || MatRowDef); };\n    MatRowDef.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: MatRowDef, selectors: [[\"\", \"matRowDef\", \"\"]], inputs: { columns: [\"matRowDefColumns\", \"columns\"], when: [\"matRowDefWhen\", \"when\"] }, features: [/*@__PURE__*/ core[\"Bb\" /* ɵɵProvidersFeature */]([{ provide: table_CdkRowDef, useExisting: MatRowDef }]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return MatRowDef;\n})();\nconst ɵMatRowDef_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ core[\"Xb\" /* ɵɵgetInheritedFactory */](table_MatRowDef);\nlet table_MatHeaderRow = /*@__PURE__*/ (() => {\n    class MatHeaderRow extends table_CdkHeaderRow {\n    }\n    MatHeaderRow.ɵfac = function MatHeaderRow_Factory(t) { return ɵMatHeaderRow_BaseFactory(t || MatHeaderRow); };\n    MatHeaderRow.ɵcmp = /*@__PURE__*/ core[\"Jb\" /* ɵɵdefineComponent */]({ type: MatHeaderRow, selectors: [[\"mat-header-row\"], [\"tr\", \"mat-header-row\", \"\"]], hostAttrs: [\"role\", \"row\", 1, \"mat-header-row\"], exportAs: [\"matHeaderRow\"], features: [/*@__PURE__*/ core[\"Bb\" /* ɵɵProvidersFeature */]([{ provide: table_CdkHeaderRow, useExisting: MatHeaderRow }]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 1, vars: 0, consts: [[\"cdkCellOutlet\", \"\"]], template: function MatHeaderRow_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"Rb\" /* ɵɵelementContainer */](0, 0);\n            }\n        }, directives: [table_CdkCellOutlet], encapsulation: 2 });\n    return MatHeaderRow;\n})();\nconst ɵMatHeaderRow_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ core[\"Xb\" /* ɵɵgetInheritedFactory */](table_MatHeaderRow);\nlet table_MatFooterRow = /*@__PURE__*/ (() => {\n    class MatFooterRow extends table_CdkFooterRow {\n    }\n    MatFooterRow.ɵfac = function MatFooterRow_Factory(t) { return ɵMatFooterRow_BaseFactory(t || MatFooterRow); };\n    MatFooterRow.ɵcmp = /*@__PURE__*/ core[\"Jb\" /* ɵɵdefineComponent */]({ type: MatFooterRow, selectors: [[\"mat-footer-row\"], [\"tr\", \"mat-footer-row\", \"\"]], hostAttrs: [\"role\", \"row\", 1, \"mat-footer-row\"], exportAs: [\"matFooterRow\"], features: [/*@__PURE__*/ core[\"Bb\" /* ɵɵProvidersFeature */]([{ provide: table_CdkFooterRow, useExisting: MatFooterRow }]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 1, vars: 0, consts: [[\"cdkCellOutlet\", \"\"]], template: function MatFooterRow_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"Rb\" /* ɵɵelementContainer */](0, 0);\n            }\n        }, directives: [table_CdkCellOutlet], encapsulation: 2 });\n    return MatFooterRow;\n})();\nconst ɵMatFooterRow_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ core[\"Xb\" /* ɵɵgetInheritedFactory */](table_MatFooterRow);\nlet table_MatRow = /*@__PURE__*/ (() => {\n    class MatRow extends table_CdkRow {\n    }\n    MatRow.ɵfac = function MatRow_Factory(t) { return ɵMatRow_BaseFactory(t || MatRow); };\n    MatRow.ɵcmp = /*@__PURE__*/ core[\"Jb\" /* ɵɵdefineComponent */]({ type: MatRow, selectors: [[\"mat-row\"], [\"tr\", \"mat-row\", \"\"]], hostAttrs: [\"role\", \"row\", 1, \"mat-row\"], exportAs: [\"matRow\"], features: [/*@__PURE__*/ core[\"Bb\" /* ɵɵProvidersFeature */]([{ provide: table_CdkRow, useExisting: MatRow }]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 1, vars: 0, consts: [[\"cdkCellOutlet\", \"\"]], template: function MatRow_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"Rb\" /* ɵɵelementContainer */](0, 0);\n            }\n        }, directives: [table_CdkCellOutlet], encapsulation: 2 });\n    return MatRow;\n})();\nconst ɵMatRow_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ core[\"Xb\" /* ɵɵgetInheritedFactory */](table_MatRow);\nlet table_MatNoDataRow = /*@__PURE__*/ (() => {\n    class MatNoDataRow extends table_CdkNoDataRow {\n    }\n    MatNoDataRow.ɵfac = function MatNoDataRow_Factory(t) { return ɵMatNoDataRow_BaseFactory(t || MatNoDataRow); };\n    MatNoDataRow.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: MatNoDataRow, selectors: [[\"ng-template\", \"matNoDataRow\", \"\"]], features: [/*@__PURE__*/ core[\"Bb\" /* ɵɵProvidersFeature */]([{ provide: table_CdkNoDataRow, useExisting: MatNoDataRow }]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return MatNoDataRow;\n})();\nconst ɵMatNoDataRow_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ core[\"Xb\" /* ɵɵgetInheritedFactory */](table_MatNoDataRow);\nlet table_MatTextColumn = /*@__PURE__*/ (() => {\n    class MatTextColumn extends table_CdkTextColumn {\n    }\n    MatTextColumn.ɵfac = function MatTextColumn_Factory(t) { return ɵMatTextColumn_BaseFactory(t || MatTextColumn); };\n    MatTextColumn.ɵcmp = /*@__PURE__*/ core[\"Jb\" /* ɵɵdefineComponent */]({ type: MatTextColumn, selectors: [[\"mat-text-column\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 3, vars: 0, consts: [[\"matColumnDef\", \"\"], [\"mat-header-cell\", \"\", 3, \"text-align\", 4, \"matHeaderCellDef\"], [\"mat-cell\", \"\", 3, \"text-align\", 4, \"matCellDef\"], [\"mat-header-cell\", \"\"], [\"mat-cell\", \"\"]], template: function MatTextColumn_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"Tb\" /* ɵɵelementContainerStart */](0, 0);\n                core[\"Kc\" /* ɵɵtemplate */](1, MatTextColumn_th_1_Template, 2, 3, \"th\", 1);\n                core[\"Kc\" /* ɵɵtemplate */](2, MatTextColumn_td_2_Template, 2, 3, \"td\", 2);\n                core[\"Sb\" /* ɵɵelementContainerEnd */]();\n            }\n        }, directives: [table_MatColumnDef, table_MatHeaderCellDef, table_MatCellDef, table_MatHeaderCell, table_MatCell], encapsulation: 2 });\n    return MatTextColumn;\n})();\nconst ɵMatTextColumn_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ core[\"Xb\" /* ɵɵgetInheritedFactory */](table_MatTextColumn);\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst table_EXPORTED_DECLARATIONS = [\n    // Table\n    table_MatTable,\n    // Template defs\n    table_MatHeaderCellDef,\n    table_MatHeaderRowDef,\n    table_MatColumnDef,\n    table_MatCellDef,\n    table_MatRowDef,\n    table_MatFooterCellDef,\n    table_MatFooterRowDef,\n    // Cell directives\n    table_MatHeaderCell,\n    table_MatCell,\n    table_MatFooterCell,\n    // Row directives\n    table_MatHeaderRow,\n    table_MatRow,\n    table_MatFooterRow,\n    table_MatNoDataRow,\n    table_MatTextColumn,\n];\nlet table_MatTableModule = /*@__PURE__*/ (() => {\n    class MatTableModule {\n    }\n    MatTableModule.ɵmod = /*@__PURE__*/ core[\"Nb\" /* ɵɵdefineNgModule */]({ type: MatTableModule });\n    MatTableModule.ɵinj = /*@__PURE__*/ core[\"Mb\" /* ɵɵdefineInjector */]({ factory: function MatTableModule_Factory(t) { return new (t || MatTableModule)(); }, imports: [[\n                table_CdkTableModule,\n                fesm2015_core[\"i\" /* MatCommonModule */],\n            ], fesm2015_core[\"i\" /* MatCommonModule */]] });\n    return MatTableModule;\n})();\n/*@__PURE__*/ (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ec\" /* ɵɵsetNgModuleScope */](table_MatTableModule, { declarations: function () { return [table_MatTable, table_MatHeaderCellDef, table_MatHeaderRowDef, table_MatColumnDef, table_MatCellDef, table_MatRowDef, table_MatFooterCellDef, table_MatFooterRowDef, table_MatHeaderCell, table_MatCell, table_MatFooterCell, table_MatHeaderRow, table_MatRow, table_MatFooterRow, table_MatNoDataRow, table_MatTextColumn]; }, imports: function () {\n            return [table_CdkTableModule,\n                fesm2015_core[\"i\" /* MatCommonModule */]];\n        }, exports: function () { return [fesm2015_core[\"i\" /* MatCommonModule */], table_MatTable, table_MatHeaderCellDef, table_MatHeaderRowDef, table_MatColumnDef, table_MatCellDef, table_MatRowDef, table_MatFooterCellDef, table_MatFooterRowDef, table_MatHeaderCell, table_MatCell, table_MatFooterCell, table_MatHeaderRow, table_MatRow, table_MatFooterRow, table_MatNoDataRow, table_MatTextColumn]; } });\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Corresponds to `Number.MAX_SAFE_INTEGER`. Moved out into a variable here due to\n * flaky browser support and the value not being defined in Closure's typings.\n */\nconst MAX_SAFE_INTEGER = 9007199254740991;\n/**\n * Data source that accepts a client-side data array and includes native support of filtering,\n * sorting (using MatSort), and pagination (using MatPaginator).\n *\n * Allows for sort customization by overriding sortingDataAccessor, which defines how data\n * properties are accessed. Also allows for filter customization by overriding filterTermAccessor,\n * which defines how row data is converted to a string for filter matching.\n *\n * **Note:** This class is meant to be a simple data source to help you get started. As such\n * it isn't equipped to handle some more advanced cases like robust i18n support or server-side\n * interactions. If your app needs to support more advanced use cases, consider implementing your\n * own `DataSource`.\n */\nclass table_MatTableDataSource extends collections[\"b\" /* DataSource */] {\n    constructor(initialData = []) {\n        super();\n        /** Stream emitting render data to the table (depends on ordered data changes). */\n        this._renderData = new BehaviorSubject[\"a\" /* BehaviorSubject */]([]);\n        /** Stream that emits when a new filter string is set on the data source. */\n        this._filter = new BehaviorSubject[\"a\" /* BehaviorSubject */]('');\n        /** Used to react to internal changes of the paginator that are made by the data source itself. */\n        this._internalPageChanges = new Subject[\"a\" /* Subject */]();\n        /**\n         * Subscription to the changes that should trigger an update to the table's rendered rows, such\n         * as filtering, sorting, pagination, or base data changes.\n         */\n        this._renderChangesSubscription = Subscription[\"a\" /* Subscription */].EMPTY;\n        /**\n         * Data accessor function that is used for accessing data properties for sorting through\n         * the default sortData function.\n         * This default function assumes that the sort header IDs (which defaults to the column name)\n         * matches the data's properties (e.g. column Xyz represents data['Xyz']).\n         * May be set to a custom function for different behavior.\n         * @param data Data object that is being accessed.\n         * @param sortHeaderId The name of the column that represents the data.\n         */\n        this.sortingDataAccessor = (data, sortHeaderId) => {\n            const value = data[sortHeaderId];\n            if (Object(coercion[\"a\" /* _isNumberValue */])(value)) {\n                const numberValue = Number(value);\n                // Numbers beyond `MAX_SAFE_INTEGER` can't be compared reliably so we\n                // leave them as strings. For more info: https://goo.gl/y5vbSg\n                return numberValue < MAX_SAFE_INTEGER ? numberValue : value;\n            }\n            return value;\n        };\n        /**\n         * Gets a sorted copy of the data array based on the state of the MatSort. Called\n         * after changes are made to the filtered data or when sort changes are emitted from MatSort.\n         * By default, the function retrieves the active sort and its direction and compares data\n         * by retrieving data using the sortingDataAccessor. May be overridden for a custom implementation\n         * of data ordering.\n         * @param data The array of data that should be sorted.\n         * @param sort The connected MatSort that holds the current sort state.\n         */\n        this.sortData = (data, sort) => {\n            const active = sort.active;\n            const direction = sort.direction;\n            if (!active || direction == '') {\n                return data;\n            }\n            return data.sort((a, b) => {\n                let valueA = this.sortingDataAccessor(a, active);\n                let valueB = this.sortingDataAccessor(b, active);\n                // If there are data in the column that can be converted to a number,\n                // it must be ensured that the rest of the data\n                // is of the same type so as not to order incorrectly.\n                const valueAType = typeof valueA;\n                const valueBType = typeof valueB;\n                if (valueAType !== valueBType) {\n                    if (valueAType === 'number') {\n                        valueA += '';\n                    }\n                    if (valueBType === 'number') {\n                        valueB += '';\n                    }\n                }\n                // If both valueA and valueB exist (truthy), then compare the two. Otherwise, check if\n                // one value exists while the other doesn't. In this case, existing value should come last.\n                // This avoids inconsistent results when comparing values to undefined/null.\n                // If neither value exists, return 0 (equal).\n                let comparatorResult = 0;\n                if (valueA != null && valueB != null) {\n                    // Check if one value is greater than the other; if equal, comparatorResult should remain 0.\n                    if (valueA > valueB) {\n                        comparatorResult = 1;\n                    }\n                    else if (valueA < valueB) {\n                        comparatorResult = -1;\n                    }\n                }\n                else if (valueA != null) {\n                    comparatorResult = 1;\n                }\n                else if (valueB != null) {\n                    comparatorResult = -1;\n                }\n                return comparatorResult * (direction == 'asc' ? 1 : -1);\n            });\n        };\n        /**\n         * Checks if a data object matches the data source's filter string. By default, each data object\n         * is converted to a string of its properties and returns true if the filter has\n         * at least one occurrence in that string. By default, the filter string has its whitespace\n         * trimmed and the match is case-insensitive. May be overridden for a custom implementation of\n         * filter matching.\n         * @param data Data object used to check against the filter.\n         * @param filter Filter string that has been set on the data source.\n         * @returns Whether the filter matches against the data\n         */\n        this.filterPredicate = (data, filter) => {\n            // Transform the data into a lowercase string of all property values.\n            const dataStr = Object.keys(data).reduce((currentTerm, key) => {\n                // Use an obscure Unicode character to delimit the words in the concatenated string.\n                // This avoids matches where the values of two columns combined will match the user's query\n                // (e.g. `Flute` and `Stop` will match `Test`). The character is intended to be something\n                // that has a very low chance of being typed in by somebody in a text field. This one in\n                // particular is \"White up-pointing triangle with dot\" from\n                // https://en.wikipedia.org/wiki/List_of_Unicode_characters\n                return currentTerm + data[key] + '◬';\n            }, '').toLowerCase();\n            // Transform the filter by converting it to lowercase and removing whitespace.\n            const transformedFilter = filter.trim().toLowerCase();\n            return dataStr.indexOf(transformedFilter) != -1;\n        };\n        this._data = new BehaviorSubject[\"a\" /* BehaviorSubject */](initialData);\n        this._updateChangeSubscription();\n    }\n    /** Array of data that should be rendered by the table, where each object represents one row. */\n    get data() { return this._data.value; }\n    set data(data) { this._data.next(data); }\n    /**\n     * Filter term that should be used to filter out objects from the data array. To override how\n     * data objects match to this filter string, provide a custom function for filterPredicate.\n     */\n    get filter() { return this._filter.value; }\n    set filter(filter) { this._filter.next(filter); }\n    /**\n     * Instance of the MatSort directive used by the table to control its sorting. Sort changes\n     * emitted by the MatSort will trigger an update to the table's rendered data.\n     */\n    get sort() { return this._sort; }\n    set sort(sort) {\n        this._sort = sort;\n        this._updateChangeSubscription();\n    }\n    /**\n     * Instance of the MatPaginator component used by the table to control what page of the data is\n     * displayed. Page changes emitted by the MatPaginator will trigger an update to the\n     * table's rendered data.\n     *\n     * Note that the data source uses the paginator's properties to calculate which page of data\n     * should be displayed. If the paginator receives its properties as template inputs,\n     * e.g. `[pageLength]=100` or `[pageIndex]=1`, then be sure that the paginator's view has been\n     * initialized before assigning it to this data source.\n     */\n    get paginator() { return this._paginator; }\n    set paginator(paginator) {\n        this._paginator = paginator;\n        this._updateChangeSubscription();\n    }\n    /**\n     * Subscribe to changes that should trigger an update to the table's rendered rows. When the\n     * changes occur, process the current state of the filter, sort, and pagination along with\n     * the provided base data and send it to the table for rendering.\n     */\n    _updateChangeSubscription() {\n        // Sorting and/or pagination should be watched if MatSort and/or MatPaginator are provided.\n        // The events should emit whenever the component emits a change or initializes, or if no\n        // component is provided, a stream with just a null event should be provided.\n        // The `sortChange` and `pageChange` acts as a signal to the combineLatests below so that the\n        // pipeline can progress to the next step. Note that the value from these streams are not used,\n        // they purely act as a signal to progress in the pipeline.\n        const sortChange = this._sort ?\n            Object(merge[\"a\" /* merge */])(this._sort.sortChange, this._sort.initialized) :\n            Object(of[\"a\" /* of */])(null);\n        const pageChange = this._paginator ?\n            Object(merge[\"a\" /* merge */])(this._paginator.page, this._internalPageChanges, this._paginator.initialized) :\n            Object(of[\"a\" /* of */])(null);\n        const dataStream = this._data;\n        // Watch for base data or filter changes to provide a filtered set of data.\n        const filteredData = Object(combineLatest[\"b\" /* combineLatest */])([dataStream, this._filter])\n            .pipe(Object(map[\"a\" /* map */])(([data]) => this._filterData(data)));\n        // Watch for filtered data or sort changes to provide an ordered set of data.\n        const orderedData = Object(combineLatest[\"b\" /* combineLatest */])([filteredData, sortChange])\n            .pipe(Object(map[\"a\" /* map */])(([data]) => this._orderData(data)));\n        // Watch for ordered data or page changes to provide a paged set of data.\n        const paginatedData = Object(combineLatest[\"b\" /* combineLatest */])([orderedData, pageChange])\n            .pipe(Object(map[\"a\" /* map */])(([data]) => this._pageData(data)));\n        // Watched for paged data changes and send the result to the table to render.\n        this._renderChangesSubscription.unsubscribe();\n        this._renderChangesSubscription = paginatedData.subscribe(data => this._renderData.next(data));\n    }\n    /**\n     * Returns a filtered data array where each filter object contains the filter string within\n     * the result of the filterTermAccessor function. If no filter is set, returns the data array\n     * as provided.\n     */\n    _filterData(data) {\n        // If there is a filter string, filter out data that does not contain it.\n        // Each data object is converted to a string using the function defined by filterTermAccessor.\n        // May be overridden for customization.\n        this.filteredData = (this.filter == null || this.filter === '') ? data :\n            data.filter(obj => this.filterPredicate(obj, this.filter));\n        if (this.paginator) {\n            this._updatePaginator(this.filteredData.length);\n        }\n        return this.filteredData;\n    }\n    /**\n     * Returns a sorted copy of the data if MatSort has a sort applied, otherwise just returns the\n     * data array as provided. Uses the default data accessor for data lookup, unless a\n     * sortDataAccessor function is defined.\n     */\n    _orderData(data) {\n        // If there is no active sort or direction, return the data without trying to sort.\n        if (!this.sort) {\n            return data;\n        }\n        return this.sortData(data.slice(), this.sort);\n    }\n    /**\n     * Returns a paged slice of the provided data array according to the provided MatPaginator's page\n     * index and length. If there is no paginator provided, returns the data array as provided.\n     */\n    _pageData(data) {\n        if (!this.paginator) {\n            return data;\n        }\n        const startIndex = this.paginator.pageIndex * this.paginator.pageSize;\n        return data.slice(startIndex, startIndex + this.paginator.pageSize);\n    }\n    /**\n     * Updates the paginator to reflect the length of the filtered data, and makes sure that the page\n     * index does not exceed the paginator's last page. Values are changed in a resolved promise to\n     * guard against making property changes within a round of change detection.\n     */\n    _updatePaginator(filteredDataLength) {\n        Promise.resolve().then(() => {\n            const paginator = this.paginator;\n            if (!paginator) {\n                return;\n            }\n            paginator.length = filteredDataLength;\n            // If the page index is set beyond the page, reduce it to the last page.\n            if (paginator.pageIndex > 0) {\n                const lastPageIndex = Math.ceil(paginator.length / paginator.pageSize) - 1 || 0;\n                const newPageIndex = Math.min(paginator.pageIndex, lastPageIndex);\n                if (newPageIndex !== paginator.pageIndex) {\n                    paginator.pageIndex = newPageIndex;\n                    // Since the paginator only emits after user-generated changes,\n                    // we need our own stream so we know to should re-render the data.\n                    this._internalPageChanges.next();\n                }\n            }\n        });\n    }\n    /**\n     * Used by the MatTable. Called when it connects to the data source.\n     * @docs-private\n     */\n    connect() { return this._renderData; }\n    /**\n     * Used by the MatTable. Called when it is destroyed. No-op.\n     * @docs-private\n     */\n    disconnect() { }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=table.js.map\n\n\n/***/ })\n\n}]);","inputSourceMap":null}