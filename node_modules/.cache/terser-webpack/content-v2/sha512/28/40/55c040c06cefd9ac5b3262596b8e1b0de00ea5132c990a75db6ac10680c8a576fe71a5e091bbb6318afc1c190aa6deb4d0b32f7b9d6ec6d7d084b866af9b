{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{\"+8QG\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,\"append\",function(){return append.a}),__webpack_require__.d(__webpack_exports__,\"arabicToRoman\",function(){return arabicToRoman}),__webpack_require__.d(__webpack_exports__,\"createPromise\",function(){return create_promise.a}),__webpack_require__.d(__webpack_exports__,\"defined\",function(){return defined.a}),__webpack_require__.d(__webpack_exports__,\"definitionId\",function(){return definition_id.a}),__webpack_require__.d(__webpack_exports__,\"deg\",function(){return deg.a}),__webpack_require__.d(__webpack_exports__,\"encodeBase64\",function(){return encode_base64.a}),__webpack_require__.d(__webpack_exports__,\"eventCoordinates\",function(){return event_coordinates.a}),__webpack_require__.d(__webpack_exports__,\"eventElement\",function(){return event_element.a}),__webpack_require__.d(__webpack_exports__,\"isTransparent\",function(){return is_transparent.a}),__webpack_require__.d(__webpack_exports__,\"last\",function(){return last.a}),__webpack_require__.d(__webpack_exports__,\"limitValue\",function(){return limit_value.a}),__webpack_require__.d(__webpack_exports__,\"mergeSort\",function(){return mergeSort}),__webpack_require__.d(__webpack_exports__,\"now\",function(){return now.a}),__webpack_require__.d(__webpack_exports__,\"promiseAll\",function(){return promise_all.a}),__webpack_require__.d(__webpack_exports__,\"rad\",function(){return rad.a}),__webpack_require__.d(__webpack_exports__,\"round\",function(){return round.a}),__webpack_require__.d(__webpack_exports__,\"valueOrDefault\",function(){return value_or_default.a}),__webpack_require__.d(__webpack_exports__,\"bindEvents\",function(){return bind_events.a}),__webpack_require__.d(__webpack_exports__,\"elementOffset\",function(){return element_offset.a}),__webpack_require__.d(__webpack_exports__,\"elementSize\",function(){return element_size.a}),__webpack_require__.d(__webpack_exports__,\"elementStyles\",function(){return element_styles.a}),__webpack_require__.d(__webpack_exports__,\"unbindEvents\",function(){return unbind_events.a}),__webpack_require__.d(__webpack_exports__,\"elementPadding\",function(){return element_padding.a}),__webpack_require__.d(__webpack_exports__,\"elementScale\",function(){return element_scale.a}),__webpack_require__.d(__webpack_exports__,\"DEG_TO_RAD\",function(){return constants.a}),__webpack_require__.d(__webpack_exports__,\"MAX_NUM\",function(){return constants.b}),__webpack_require__.d(__webpack_exports__,\"MIN_NUM\",function(){return constants.c}),__webpack_require__.d(__webpack_exports__,\"LRUCache\",function(){return text_metrics.a}),__webpack_require__.d(__webpack_exports__,\"TextMetrics\",function(){return text_metrics.b}),__webpack_require__.d(__webpack_exports__,\"measureText\",function(){return text_metrics.d}),__webpack_require__.d(__webpack_exports__,\"objectKey\",function(){return text_metrics.f}),__webpack_require__.d(__webpack_exports__,\"hashKey\",function(){return text_metrics.c}),__webpack_require__.d(__webpack_exports__,\"normalizeText\",function(){return text_metrics.e});var append=__webpack_require__(\"i9ZU\");const literals={1:\"i\",10:\"x\",100:\"c\",2:\"ii\",20:\"xx\",200:\"cc\",3:\"iii\",30:\"xxx\",300:\"ccc\",4:\"iv\",40:\"xl\",400:\"cd\",5:\"v\",50:\"l\",500:\"d\",6:\"vi\",60:\"lx\",600:\"dc\",7:\"vii\",70:\"lxx\",700:\"dcc\",8:\"viii\",80:\"lxxx\",800:\"dccc\",9:\"ix\",90:\"xc\",900:\"cm\",1e3:\"m\"};function arabicToRoman(n){const values=[1e3,900,800,700,600,500,400,300,200,100,90,80,70,60,50,40,30,20,10,9,8,7,6,5,4,3,2,1];let roman=\"\";for(;n>0;)n<values[0]?values.shift():(roman+=literals[values[0]],n-=values[0]);return roman}var create_promise=__webpack_require__(\"dsTk\"),defined=__webpack_require__(\"VqL+\"),definition_id=__webpack_require__(\"E7ME\"),deg=__webpack_require__(\"9rnm\"),encode_base64=__webpack_require__(\"iYt6\"),event_coordinates=__webpack_require__(\"dH2W\"),event_element=__webpack_require__(\"IU+O\"),is_transparent=__webpack_require__(\"3Quq\"),last=__webpack_require__(\"Eu+R\"),limit_value=__webpack_require__(\"1UyF\");function mergeSort(a,cmp){return a.length<2?a.slice():function sort(a){if(a.length<=1)return a;var m=Math.floor(a.length/2),left=a.slice(0,m),right=a.slice(m);return function(a,b){for(var r=[],ai=0,bi=0,i=0;ai<a.length&&bi<b.length;)cmp(a[ai],b[bi])<=0?r[i++]=a[ai++]:r[i++]=b[bi++];return ai<a.length&&r.push.apply(r,a.slice(ai)),bi<b.length&&r.push.apply(r,b.slice(bi)),r}(left=sort(left),right=sort(right))}(a)}var now=__webpack_require__(\"hSuW\"),promise_all=__webpack_require__(\"Z3TV\"),rad=__webpack_require__(\"6USk\"),round=__webpack_require__(\"RlWg\"),value_or_default=__webpack_require__(\"9uUv\"),bind_events=__webpack_require__(\"APnZ\"),element_offset=__webpack_require__(\"IsCa\"),element_size=__webpack_require__(\"wd4i\"),element_styles=__webpack_require__(\"oY8A\"),unbind_events=__webpack_require__(\"Aie7\"),element_padding=__webpack_require__(\"DPs4\"),element_scale=__webpack_require__(\"JZGi\"),constants=__webpack_require__(\"2Ic7\"),text_metrics=__webpack_require__(\"wBpk\")},\"/EQf\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";let browser={};__webpack_exports__.a={get browser(){return\"undefined\"==typeof window||browser||(browser=function(userAgent){const browserRxs={edge:/(edge)[ \\/]([\\w.]+)/i,webkit:/(chrome)[ \\/]([\\w.]+)/i,safari:/(webkit)[ \\/]([\\w.]+)/i,opera:/(opera)(?:.*version|)[ \\/]([\\w.]+)/i,msie:/(msie\\s|trident.*? rv:)([\\w.]+)/i,mozilla:/(mozilla)(?:.*? rv:([\\w.]+)|)/i};let browser;for(let agent in browserRxs)if(browserRxs.hasOwnProperty(agent)){const match=userAgent.match(browserRxs[agent]);if(match){browser={},browser[agent]=!0,browser[match[1].toLowerCase().split(\" \")[0].split(\"/\")[0]]=!0,browser.version=parseInt(document.documentMode||match[2],10);break}}return browser}(window.navigator.userAgent)),browser}}},\"08A6\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return renderAttr});var _util__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"VqL+\");function renderAttr(name,value){return Object(_util__WEBPACK_IMPORTED_MODULE_0__.a)(value)&&null!==value?` ${name}=\"${value}\" `:\"\"}},\"16KE\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return drawing_namespaceObject}),__webpack_require__.d(__webpack_exports__,\"b\",function(){return geometry});var easing_functions_namespaceObject={};__webpack_require__.r(easing_functions_namespaceObject),__webpack_require__.d(easing_functions_namespaceObject,\"swing\",function(){return swing}),__webpack_require__.d(easing_functions_namespaceObject,\"linear\",function(){return linear}),__webpack_require__.d(easing_functions_namespaceObject,\"easeOutElastic\",function(){return easeOutElastic});var svg_namespaceObject={};__webpack_require__.r(svg_namespaceObject),__webpack_require__.d(svg_namespaceObject,\"Surface\",function(){return svg_surface}),__webpack_require__.d(svg_namespaceObject,\"RootNode\",function(){return root_node.a}),__webpack_require__.d(svg_namespaceObject,\"Node\",function(){return node.a}),__webpack_require__.d(svg_namespaceObject,\"GroupNode\",function(){return group_node}),__webpack_require__.d(svg_namespaceObject,\"ArcNode\",function(){return arc_node}),__webpack_require__.d(svg_namespaceObject,\"CircleNode\",function(){return circle_node}),__webpack_require__.d(svg_namespaceObject,\"RectNode\",function(){return rect_node}),__webpack_require__.d(svg_namespaceObject,\"ImageNode\",function(){return image_node}),__webpack_require__.d(svg_namespaceObject,\"TextNode\",function(){return text_node}),__webpack_require__.d(svg_namespaceObject,\"PathNode\",function(){return path_node}),__webpack_require__.d(svg_namespaceObject,\"MultiPathNode\",function(){return multi_path_node}),__webpack_require__.d(svg_namespaceObject,\"DefinitionNode\",function(){return definition_node.a}),__webpack_require__.d(svg_namespaceObject,\"ClipNode\",function(){return clip_node.a}),__webpack_require__.d(svg_namespaceObject,\"GradientStopNode\",function(){return gradient_stop_node.a}),__webpack_require__.d(svg_namespaceObject,\"LinearGradientNode\",function(){return linear_gradient_node.a}),__webpack_require__.d(svg_namespaceObject,\"RadialGradientNode\",function(){return radial_gradient_node.a}),__webpack_require__.d(svg_namespaceObject,\"exportGroup\",function(){return export_group.a});var canvas_namespaceObject={};__webpack_require__.r(canvas_namespaceObject),__webpack_require__.d(canvas_namespaceObject,\"Surface\",function(){return canvas_surface.a}),__webpack_require__.d(canvas_namespaceObject,\"RootNode\",function(){return canvas_root_node.a}),__webpack_require__.d(canvas_namespaceObject,\"Node\",function(){return canvas_node.a}),__webpack_require__.d(canvas_namespaceObject,\"GroupNode\",function(){return canvas_group_node.a}),__webpack_require__.d(canvas_namespaceObject,\"ArcNode\",function(){return canvas_arc_node.a}),__webpack_require__.d(canvas_namespaceObject,\"CircleNode\",function(){return canvas_circle_node.a}),__webpack_require__.d(canvas_namespaceObject,\"RectNode\",function(){return canvas_rect_node.a}),__webpack_require__.d(canvas_namespaceObject,\"ImageNode\",function(){return canvas_image_node.a}),__webpack_require__.d(canvas_namespaceObject,\"TextNode\",function(){return canvas_text_node.a}),__webpack_require__.d(canvas_namespaceObject,\"PathNode\",function(){return canvas_path_node.a}),__webpack_require__.d(canvas_namespaceObject,\"MultiPathNode\",function(){return canvas_multi_path_node.a});var drawing_namespaceObject={};__webpack_require__.r(drawing_namespaceObject),__webpack_require__.d(drawing_namespaceObject,\"HasObservers\",function(){return has_observers.a}),__webpack_require__.d(drawing_namespaceObject,\"Element\",function(){return shapes.c}),__webpack_require__.d(drawing_namespaceObject,\"Circle\",function(){return shapes.b}),__webpack_require__.d(drawing_namespaceObject,\"Arc\",function(){return shapes.a}),__webpack_require__.d(drawing_namespaceObject,\"Path\",function(){return shapes.h}),__webpack_require__.d(drawing_namespaceObject,\"MultiPath\",function(){return shapes.g}),__webpack_require__.d(drawing_namespaceObject,\"Text\",function(){return shapes.j}),__webpack_require__.d(drawing_namespaceObject,\"Image\",function(){return shapes.e}),__webpack_require__.d(drawing_namespaceObject,\"Group\",function(){return shapes.d}),__webpack_require__.d(drawing_namespaceObject,\"Layout\",function(){return shapes.f}),__webpack_require__.d(drawing_namespaceObject,\"Rect\",function(){return shapes.i}),__webpack_require__.d(drawing_namespaceObject,\"align\",function(){return align}),__webpack_require__.d(drawing_namespaceObject,\"vAlign\",function(){return vAlign}),__webpack_require__.d(drawing_namespaceObject,\"stack\",function(){return stack_stack}),__webpack_require__.d(drawing_namespaceObject,\"vStack\",function(){return vStack}),__webpack_require__.d(drawing_namespaceObject,\"wrap\",function(){return wrap_wrap}),__webpack_require__.d(drawing_namespaceObject,\"vWrap\",function(){return vWrap}),__webpack_require__.d(drawing_namespaceObject,\"fit\",function(){return fit}),__webpack_require__.d(drawing_namespaceObject,\"LinearGradient\",function(){return linear_gradient.a}),__webpack_require__.d(drawing_namespaceObject,\"RadialGradient\",function(){return radial_gradient.a}),__webpack_require__.d(drawing_namespaceObject,\"GradientStop\",function(){return gradient_stop.a}),__webpack_require__.d(drawing_namespaceObject,\"Gradient\",function(){return gradient.a}),__webpack_require__.d(drawing_namespaceObject,\"Animation\",function(){return animation}),__webpack_require__.d(drawing_namespaceObject,\"AnimationFactory\",function(){return animation_factory}),__webpack_require__.d(drawing_namespaceObject,\"PathParser\",function(){return path_parser}),__webpack_require__.d(drawing_namespaceObject,\"parsePath\",function(){return parse_path.a}),__webpack_require__.d(drawing_namespaceObject,\"BaseNode\",function(){return base_node.a}),__webpack_require__.d(drawing_namespaceObject,\"OptionsStore\",function(){return options_store.a}),__webpack_require__.d(drawing_namespaceObject,\"Surface\",function(){return es2015_surface}),__webpack_require__.d(drawing_namespaceObject,\"SurfaceFactory\",function(){return surface_factory}),__webpack_require__.d(drawing_namespaceObject,\"exportImage\",function(){return export_image.a}),__webpack_require__.d(drawing_namespaceObject,\"exportSVG\",function(){return export_svg.a}),__webpack_require__.d(drawing_namespaceObject,\"QuadNode\",function(){return quad_node.a}),__webpack_require__.d(drawing_namespaceObject,\"ShapesQuadTree\",function(){return shapes_quad_tree.a}),__webpack_require__.d(drawing_namespaceObject,\"svg\",function(){return svg_namespaceObject}),__webpack_require__.d(drawing_namespaceObject,\"canvas\",function(){return canvas_namespaceObject}),__webpack_require__.d(drawing_namespaceObject,\"util\",function(){return es2015_util});var has_observers=__webpack_require__(\"7joe\"),shapes=__webpack_require__(\"wm+B\"),translate_to_point=__webpack_require__(\"pVqk\"),align_start=__webpack_require__(\"5Jba\");function alignElements(elements,rect,alignment,axis,sizeField){for(let idx=0;idx<elements.length;idx++){const bbox=elements[idx].clippedBBox();if(bbox){const point=bbox.origin.clone();point[axis]=Object(align_start.a)(bbox.size[sizeField],rect,alignment||\"start\",axis,sizeField),Object(translate_to_point.a)(point,bbox,elements[idx])}}}function align(elements,rect,alignment){alignElements(elements,rect,alignment,\"x\",\"width\")}function vAlign(elements,rect,alignment){alignElements(elements,rect,alignment,\"y\",\"height\")}var geometry_point=__webpack_require__(\"lRJa\");function stackElements(elements,stackAxis,otherAxis,sizeField){if(elements.length>1){const origin=new geometry_point.a;let previousBBox=elements[0].bbox;for(let idx=1;idx<elements.length;idx++){let element=elements[idx].element,bbox=elements[idx].bbox;origin[stackAxis]=previousBBox.origin[stackAxis]+previousBBox.size[sizeField],origin[otherAxis]=bbox.origin[otherAxis],Object(translate_to_point.a)(origin,bbox,element),bbox.origin[stackAxis]=origin[stackAxis],previousBBox=bbox}}}function createStackElements(elements){const stackElements=[];for(let idx=0;idx<elements.length;idx++){let element=elements[idx],bbox=element.clippedBBox();bbox&&stackElements.push({element:element,bbox:bbox})}return stackElements}function stack_stack(elements){stackElements(createStackElements(elements),\"x\",\"y\",\"width\")}function vStack(elements){stackElements(createStackElements(elements),\"y\",\"x\",\"height\")}function wrapElements(elements,rect,axis,otherAxis,sizeField){const stacks=function(elements,rect,sizeField){const maxSize=rect.size[sizeField],stacks=[];let element,bbox,stack=[],stackSize=0;const addElementToStack=function(){stack.push({element:element,bbox:bbox})};for(let idx=0;idx<elements.length;idx++)if(element=elements[idx],bbox=element.clippedBBox(),bbox){let size=bbox.size[sizeField];stackSize+size>maxSize?stack.length?(stacks.push(stack),stack=[],addElementToStack(),stackSize=size):(addElementToStack(),stacks.push(stack),stack=[],stackSize=0):(addElementToStack(),stackSize+=size)}return stack.length&&stacks.push(stack),stacks}(elements,rect,sizeField),origin=rect.origin.clone(),result=[];for(let idx=0;idx<stacks.length;idx++){let stack=stacks[idx],startElement=stack[0];origin[otherAxis]=startElement.bbox.origin[otherAxis],Object(translate_to_point.a)(origin,startElement.bbox,startElement.element),startElement.bbox.origin[axis]=origin[axis],stackElements(stack,axis,otherAxis,sizeField),result.push([]);for(let elementIdx=0;elementIdx<stack.length;elementIdx++)result[idx].push(stack[elementIdx].element)}return result}function wrap_wrap(elements,rect){return wrapElements(elements,rect,\"x\",\"y\",\"width\")}function vWrap(elements,rect){return wrapElements(elements,rect,\"y\",\"x\",\"height\")}var geometry_transform=__webpack_require__(\"uBxF\");function fit(element,rect){const bbox=element.clippedBBox();if(bbox){const elementSize=bbox.size,rectSize=rect.size;if(rectSize.width<elementSize.width||rectSize.height<elementSize.height){const scale=Math.min(rectSize.width/elementSize.width,rectSize.height/elementSize.height),transform=element.transform()||Object(geometry_transform.a)();transform.scale(scale,scale),element.transform(transform)}}}var linear_gradient=__webpack_require__(\"7Jhm\"),radial_gradient=__webpack_require__(\"yhXd\"),gradient_stop=__webpack_require__(\"QPDK\"),gradient=__webpack_require__(\"4DQW\");function swing(position){return.5-Math.cos(position*Math.PI)/2}function linear(position){return position}function easeOutElastic(position,time,start,diff){let s=1.70158,p=0,a=diff;return 0===position?start:1===position?start+diff:(p||(p=.5),a<Math.abs(diff)?(a=diff,s=p/4):s=p/(2*Math.PI)*Math.asin(diff/a),a*Math.pow(2,-10*position)*Math.sin((Number(position)-s)*(1.1*Math.PI)/p)+diff+start)}var now=__webpack_require__(\"hSuW\"),limit_value=__webpack_require__(\"1UyF\"),common_class=__webpack_require__(\"LHUb\"),animation_frame=__webpack_require__(\"FRnV\");let instance;class animation_factory_AnimationFactory extends common_class.a{static get current(){return instance||(instance=new animation_factory_AnimationFactory),instance}constructor(){super(),this._items=[]}register(name,type){this._items.push({name:name,type:type})}create(element,options){const items=this._items;let match;if(options&&options.type){const type=options.type.toLowerCase();for(let i=0;i<items.length;i++)if(items[i].name.toLowerCase()===type){match=items[i];break}}if(match)return new match.type(element,options)}}var animation_factory=animation_factory_AnimationFactory,animation=class extends common_class.a{static create(type,element,options){return animation_factory.current.create(type,element,options)}get options(){return this._options||{duration:500,easing:\"swing\"}}set options(value){this._options=value}constructor(element,options){super(),this.options=Object.assign({},this.options,options),this.element=element}setup(){}step(){}play(){const options=this.options,{duration:duration,delay:delay=0}=options,easing=easing_functions_namespaceObject[options.easing],start=Object(now.a)()+delay,finish=start+duration;0===duration?(this.step(1),this.abort()):setTimeout(()=>{const loop=()=>{if(this._stopped)return;const wallTime=Object(now.a)(),time=Object(limit_value.a)(wallTime-start,0,duration),easingPosition=easing(time/duration,time,0,1,duration);this.step(easingPosition),wallTime<finish?Object(animation_frame.a)(loop):this.abort()};loop()},delay)}abort(){this._stopped=!0}destroy(){this.abort()}},path=__webpack_require__(\"Ah4p\"),parse_path=__webpack_require__(\"sK2o\");let path_parser_instance;class path_parser_PathParser extends common_class.a{static get current(){return path_parser_instance||(path_parser_instance=new path_parser_PathParser),path_parser_instance}parse(str,options){const multiPath=new path.a(options);return Object(parse_path.a)(multiPath,str)}}var path_parser=path_parser_PathParser,base_node=__webpack_require__(\"ztN+\"),options_store=__webpack_require__(\"Ptn1\"),surface=__webpack_require__(\"mcME\"),log_to_console=__webpack_require__(\"l/PP\"),root_node=__webpack_require__(\"wJcK\"),group=__webpack_require__(\"qUqW\"),render_svg=__webpack_require__(\"tZVE\"),constants=__webpack_require__(\"V34t\"),element_styles=__webpack_require__(\"oY8A\"),bind_events=__webpack_require__(\"APnZ\"),unbind_events=__webpack_require__(\"Aie7\"),node=__webpack_require__(\"7Prh\"),is_transparent=__webpack_require__(\"3Quq\"),defined=__webpack_require__(\"VqL+\"),core_constants=__webpack_require__(\"OOjv\"),render_all_attributes=__webpack_require__(\"YDM/\"),render_attribute=__webpack_require__(\"08A6\");const ATTRIBUTE_MAP={\"fill.opacity\":\"fill-opacity\",\"stroke.color\":\"stroke\",\"stroke.width\":\"stroke-width\",\"stroke.opacity\":\"stroke-opacity\"};var path_node=class extends node.a{geometryChange(){this.attr(\"d\",this.renderData()),this.invalidate()}optionsChange(e){switch(e.field){case\"fill\":e.value?this.allAttr(this.mapFill(e.value)):this.removeAttr(\"fill\");break;case\"fill.color\":this.allAttr(this.mapFill({color:e.value}));break;case\"stroke\":e.value?this.allAttr(this.mapStroke(e.value)):this.removeAttr(\"stroke\");break;case\"transform\":this.transformChange(e.value);break;default:const name=ATTRIBUTE_MAP[e.field];name&&this.attr(name,e.value)}super.optionsChange(e)}content(){this.element&&(this.element.textContent=this.srcElement.content())}renderData(){return this.printPath(this.srcElement)}printPath(path){const segments=path.segments,length=segments.length;if(length>0){const parts=[];let output,currentType;for(let i=1;i<length;i++){let segmentType=this.segmentType(segments[i-1],segments[i]);segmentType!==currentType&&(currentType=segmentType,parts.push(segmentType)),parts.push(\"L\"===segmentType?this.printPoints(segments[i].anchor()):this.printPoints(segments[i-1].controlOut(),segments[i].controlIn(),segments[i].anchor()))}return output=\"M\"+this.printPoints(segments[0].anchor())+\" \"+parts.join(\" \"),path.options.closed&&(output+=\"Z\"),output}}printPoints(){const points=arguments,length=points.length,result=[];for(let i=0;i<length;i++)result.push(points[i].toString(3));return result.join(\" \")}segmentType(segmentStart,segmentEnd){return segmentStart.controlOut()&&segmentEnd.controlIn()?\"C\":\"L\"}mapStroke(stroke){const attrs=[];return stroke&&!Object(is_transparent.a)(stroke.color)?(attrs.push([\"stroke\",stroke.color]),attrs.push([\"stroke-width\",stroke.width]),attrs.push([\"stroke-linecap\",this.renderLinecap(stroke)]),attrs.push([\"stroke-linejoin\",stroke.lineJoin]),Object(defined.a)(stroke.opacity)&&attrs.push([\"stroke-opacity\",stroke.opacity]),Object(defined.a)(stroke.dashType)&&attrs.push([\"stroke-dasharray\",this.renderDashType(stroke)])):attrs.push([\"stroke\",constants.a]),attrs}renderStroke(){return Object(render_all_attributes.a)(this.mapStroke(this.srcElement.options.stroke))}renderDashType(stroke){const{dashType:dashType,width:width=1}=stroke;if(dashType&&dashType!==core_constants.c){const dashArray=core_constants.b[dashType.toLowerCase()],result=[];for(let i=0;i<dashArray.length;i++)result.push(dashArray[i]*width);return result.join(\" \")}}renderLinecap(stroke){const{dashType:dashType,lineCap:lineCap}=stroke;return dashType&&\"solid\"!==dashType?core_constants.a:lineCap}mapFill(fill){const attrs=[];return fill&&\"Gradient\"===fill.nodeType||(fill&&!Object(is_transparent.a)(fill.color)?(attrs.push([\"fill\",fill.color]),Object(defined.a)(fill.opacity)&&attrs.push([\"fill-opacity\",fill.opacity])):attrs.push([\"fill\",constants.a])),attrs}renderFill(){return Object(render_all_attributes.a)(this.mapFill(this.srcElement.options.fill))}template(){return`<path ${this.renderId()} ${this.renderStyle()} ${this.renderOpacity()} ${Object(render_attribute.a)(\"d\",this.renderData())}${this.renderStroke()}${this.renderFill()}${this.renderDefinitions()}${this.renderTransform()}></path>`}},arc_node=class extends path_node{renderData(){return this.printPath(this.srcElement.toPath())}},circle_node=class extends path_node{geometryChange(){const center=this.center();this.attr(\"cx\",center.x),this.attr(\"cy\",center.y),this.attr(\"r\",this.radius()),this.invalidate()}center(){return this.srcElement.geometry().center}radius(){return this.srcElement.geometry().radius}template(){return`<circle ${this.renderId()} ${this.renderStyle()} ${this.renderOpacity()}cx='${this.center().x}' cy='${this.center().y}' r='${this.radius()}'${this.renderStroke()} ${this.renderFill()} ${this.renderDefinitions()}`+this.renderTransform()+\" ></circle>\"}},group_node=class extends node.a{template(){return`<g${this.renderId()+this.renderTransform()+this.renderStyle()+this.renderOpacity()+this.renderDefinitions()}>${this.renderChildren()}</g>`}optionsChange(e){\"transform\"===e.field&&this.transformChange(e.value),super.optionsChange(e)}};const ampRegExp=/&/g,ltRegExp=/</g,quoteRegExp=/\"/g,aposRegExp=/'/g,gtRegExp=/>/g;function htmlEncode(value){return String(value).replace(ampRegExp,\"&amp;\").replace(ltRegExp,\"&lt;\").replace(gtRegExp,\"&gt;\").replace(quoteRegExp,\"&quot;\").replace(aposRegExp,\"&#39;\")}var image_node=class extends path_node{geometryChange(){this.allAttr(this.mapPosition()),this.invalidate()}optionsChange(e){\"src\"===e.field&&this.allAttr(this.mapSource()),super.optionsChange(e)}mapPosition(){const rect=this.srcElement.rect(),tl=rect.topLeft();return[[\"x\",tl.x],[\"y\",tl.y],[\"width\",rect.width()+\"px\"],[\"height\",rect.height()+\"px\"]]}renderPosition(){return Object(render_all_attributes.a)(this.mapPosition())}mapSource(encode){let src=this.srcElement.src();return encode&&(src=htmlEncode(src)),[[\"xlink:href\",src]]}renderSource(){return Object(render_all_attributes.a)(this.mapSource(!0))}template(){return`<image preserveAspectRatio='none' ${this.renderId()} ${this.renderStyle()} ${this.renderTransform()} ${this.renderOpacity()}${this.renderPosition()} ${this.renderSource()} ${this.renderDefinitions()}></image>`}},multi_path_node=class extends path_node{renderData(){const paths=this.srcElement.paths;if(paths.length>0){const result=[];for(let i=0;i<paths.length;i++)result.push(this.printPath(paths[i]));return result.join(\" \")}}},rect_node=class extends path_node{geometryChange(){const geometry=this.srcElement.geometry();this.attr(\"x\",geometry.origin.x),this.attr(\"y\",geometry.origin.y),this.attr(\"width\",geometry.size.width),this.attr(\"height\",geometry.size.height),this.invalidate()}size(){return this.srcElement.geometry().size}origin(){return this.srcElement.geometry().origin}template(){return`<rect ${this.renderId()} ${this.renderStyle()} ${this.renderOpacity()} x='${this.origin().x}' y='${this.origin().y}' width='${this.size().width}' height='${this.size().height}' ${this.renderStroke()} ${this.renderFill()} ${this.renderDefinitions()} ${this.renderTransform()} />`}},render_style=__webpack_require__(\"8tN3\"),support=__webpack_require__(\"/EQf\"),util=__webpack_require__(\"C91f\");const ENTITY_REGEX=/&(?:[a-zA-Z]+|#\\d+);/g;function decodeEntities(text){if(!text||\"string\"!=typeof text||!ENTITY_REGEX.test(text))return text;const element=decodeEntities._element;return ENTITY_REGEX.lastIndex=0,text.replace(ENTITY_REGEX,match=>(element.innerHTML=match,element.textContent||element.innerText))}\"undefined\"!=typeof document&&(decodeEntities._element=document.createElement(\"span\"));var text_node=class extends path_node{geometryChange(){const pos=this.pos();this.attr(\"x\",pos.x),this.attr(\"y\",pos.y),this.invalidate()}optionsChange(e){\"font\"===e.field?(this.attr(\"style\",Object(render_style.a)(this.mapStyle())),this.geometryChange()):\"content\"===e.field&&super.content(this.srcElement.content()),super.optionsChange(e)}mapStyle(encode){const style=super.mapStyle(encode);let font=this.srcElement.options.font;return encode&&(font=htmlEncode(font)),style.push([\"font\",font],[\"white-space\",\"pre\"]),style}pos(){const pos=this.srcElement.position(),size=this.srcElement.measure();return pos.clone().setY(pos.y+size.baseline)}renderContent(){let content=this.srcElement.content();return content=decodeEntities(content),content=htmlEncode(content),Object(util.b)(content)}renderTextAnchor(){let anchor;return!(this.options||{}).rtl||support.a.browser.msie||support.a.browser.edge||(anchor=\"end\"),Object(render_attribute.a)(\"text-anchor\",anchor)}template(){return`<text ${this.renderId()} ${this.renderTextAnchor()} ${this.renderStyle()} ${this.renderOpacity()}x='${this.pos().x}' y='${this.pos().y}' ${this.renderStroke()} ${this.renderTransform()} ${this.renderDefinitions()}${this.renderFill()}>${this.renderContent()}</text>`}},node_map=__webpack_require__(\"uNz1\");node_map.a.Arc=arc_node,node_map.a.Circle=circle_node,node_map.a.Group=group_node,node_map.a.Image=image_node,node_map.a.MultiPath=multi_path_node,node_map.a.Path=path_node,node_map.a.Rect=rect_node,node_map.a.Text=text_node;var svg_surface=class extends surface.a{get type(){return\"svg\"}constructor(element,options){super(element,options),this._root=new root_node.a(Object.assign({rtl:\"rtl\"===Object(element_styles.a)(element,\"direction\").direction},this.options)),Object(render_svg.a)(this.element,this._template()),this._rootElement=this.element.firstElementChild,function(element){let ctm;try{ctm=element.getScreenCTM?element.getScreenCTM():null}catch(e){}if(ctm){const left=-ctm.e%1,top=-ctm.f%1,style=element.style;0===left&&0===top||(style.left=left+\"px\",style.top=top+\"px\")}}(this._rootElement),this._root.attachTo(this._rootElement),Object(bind_events.a)(this.element,{click:this._click,mouseover:this._mouseenter,mouseout:this._mouseleave,mousemove:this._mousemove}),this.resize()}destroy(){this._root&&(this._root.destroy(),this._root=null,this._rootElement=null,Object(unbind_events.a)(this.element,{click:this._click,mouseover:this._mouseenter,mouseout:this._mouseleave,mousemove:this._mousemove})),super.destroy()}translate(offset){const viewBox=`${Math.round(offset.x)} ${Math.round(offset.y)} ${this._size.width} ${this._size.height}`;this._offset=offset,this._rootElement.setAttribute(\"viewBox\",viewBox)}draw(element){super.draw(element),this._root.load([element])}clear(){super.clear(),this._root.clear()}svg(){return\"<?xml version='1.0' ?>\"+this._template()}exportVisual(){let{_visual:visual,_offset:offset}=this;if(offset){const wrap=new group.a;wrap.children.push(visual),wrap.transform(Object(geometry_transform.a)().translate(-offset.x,-offset.y)),visual=wrap}return visual}_resize(){this._offset&&this.translate(this._offset)}_template(){return`<svg style='width: 100%; height: 100%; overflow: hidden;' xmlns='${constants.b}' xmlns:xlink='http://www.w3.org/1999/xlink' version='1.1'>${this._root.render()}</svg>`}},canvas_surface=__webpack_require__(\"kGoT\");let surface_factory_instance,surface_factory_support;const hasDocument=()=>\"undefined\"!=typeof document;class surface_factory_SurfaceFactory extends common_class.a{static get support(){return surface_factory_support||(surface_factory_support={canvas:hasDocument()&&document.createElement(\"canvas\").getContext,svg:hasDocument()&&document.implementation.hasFeature(\"http://www.w3.org/TR/SVG11/feature#BasicStructure\",\"1.1\")}),surface_factory_support}static get current(){return surface_factory_instance||(surface_factory_instance=new surface_factory_SurfaceFactory),surface_factory_instance}constructor(){super(),this._items=[{name:\"svg\",type:svg_surface},{name:\"canvas\",type:canvas_surface.a}]}create(element,options){const items=this._items;let match=items[0];if(options&&options.type){const preferred=options.type.toLowerCase();for(let i=0;i<items.length;i++)if(items[i].name===preferred){match=items[i];break}}if(match)return new match.type(element,options);Object(log_to_console.a)(\"Warning: Unable to create Kendo UI Drawing Surface. Possible causes:\\n- The browser does not support SVG and Canvas. User agent: \"+navigator.userAgent)}}var surface_factory=surface_factory_SurfaceFactory,es2015_surface=class extends surface.a{static get support(){return surface_factory.support}static create(element,options){return surface_factory.current.create(element,options)}},definition_node=__webpack_require__(\"7WKN\"),clip_node=__webpack_require__(\"gNPy\"),gradient_stop_node=__webpack_require__(\"Fs4b\"),linear_gradient_node=__webpack_require__(\"4U2A\"),radial_gradient_node=__webpack_require__(\"inPS\"),export_group=__webpack_require__(\"eMc0\"),canvas_root_node=__webpack_require__(\"Ytya\"),canvas_node=__webpack_require__(\"o+K8\"),canvas_group_node=__webpack_require__(\"xYjD\"),canvas_arc_node=__webpack_require__(\"bRfn\"),canvas_circle_node=__webpack_require__(\"FSED\"),canvas_rect_node=__webpack_require__(\"SMq3\"),canvas_image_node=__webpack_require__(\"ijzS\"),canvas_text_node=__webpack_require__(\"G/KS\"),canvas_path_node=__webpack_require__(\"UzJa\"),canvas_multi_path_node=__webpack_require__(\"5HPa\"),es2015_util=__webpack_require__(\"+8QG\"),export_image=__webpack_require__(\"uekK\"),export_svg=__webpack_require__(\"eO0B\"),quad_node=__webpack_require__(\"R/Fs\"),shapes_quad_tree=__webpack_require__(\"5FN0\"),geometry=__webpack_require__(\"mjA8\")},\"1UyF\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";function limitValue(value,min,max){return Math.max(Math.min(value,max),min)}__webpack_require__.d(__webpack_exports__,\"a\",function(){return limitValue})},\"2Ic7\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return DEG_TO_RAD}),__webpack_require__.d(__webpack_exports__,\"b\",function(){return MAX_NUM}),__webpack_require__.d(__webpack_exports__,\"c\",function(){return MIN_NUM});const DEG_TO_RAD=Math.PI/180,MAX_NUM=Number.MAX_VALUE,MIN_NUM=-Number.MAX_VALUE},\"2smt\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _common__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"LHUb\");__webpack_exports__.a=class extends _common__WEBPACK_IMPORTED_MODULE_0__.a{constructor(){super(),this.shapes=[]}_add(shape,bbox){this.shapes.push({bbox:bbox,shape:shape}),shape._quadNode=this}pointShapes(point){const shapes=this.shapes,length=shapes.length,result=[];for(let idx=0;idx<length;idx++)shapes[idx].bbox.containsPoint(point)&&result.push(shapes[idx].shape);return result}insert(shape,bbox){this._add(shape,bbox)}remove(shape){const shapes=this.shapes,length=shapes.length;for(let idx=0;idx<length;idx++)if(shapes[idx].shape===shape){shapes.splice(idx,1);break}}}},\"3Quq\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return isTransparent});var _defined__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"VqL+\");function isTransparent(color){return\"\"===color||null===color||\"none\"===color||\"transparent\"===color||!Object(_defined__WEBPACK_IMPORTED_MODULE_0__.a)(color)}},\"4DQW\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";var elements_array=__webpack_require__(\"Vvtp\"),stops_array=class extends elements_array.a{_change(){this.optionsChange({field:\"stops\"})}},gradient_stop=__webpack_require__(\"QPDK\"),has_observers=__webpack_require__(\"7joe\"),definition_id=__webpack_require__(\"E7ME\"),defined=__webpack_require__(\"VqL+\");__webpack_exports__.a=class extends has_observers.a{get nodeType(){return\"Gradient\"}constructor(options={}){super(),this.stops=new stops_array(this._createStops(options.stops)),this.stops.addObserver(this),this._userSpace=options.userSpace,this.id=Object(definition_id.a)()}userSpace(value){return Object(defined.a)(value)?(this._userSpace=value,this.optionsChange(),this):this._userSpace}_createStops(stops=[]){const result=[];for(let idx=0;idx<stops.length;idx++)result.push(gradient_stop.a.create(stops[idx]));return result}addStop(offset,color,opacity){this.stops.push(new gradient_stop.a(offset,color,opacity))}removeStop(stop){const index=this.stops.indexOf(stop);index>=0&&this.stops.splice(index,1)}optionsChange(e){this.trigger(\"optionsChange\",{field:\"gradient\"+(e?\".\"+e.field:\"\"),value:this})}geometryChange(){this.optionsChange()}}},\"4U2A\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _gradient_node__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"7PhV\");__webpack_exports__.a=class extends _gradient_node__WEBPACK_IMPORTED_MODULE_0__.a{template(){return`<linearGradient id='${this.id}' ${this.renderCoordinates()}>${this.renderChildren()}</linearGradient>`}mapCoordinates(){const srcElement=this.srcElement,start=srcElement.start(),end=srcElement.end();return[[\"x1\",start.x],[\"y1\",start.y],[\"x2\",end.x],[\"y2\",end.y],this.mapSpace()]}}},\"4rzP\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";function lineIntersectionsCount(a,b,point){let intersects;if(a.x!==b.x){const minX=Math.min(a.x,b.x),maxX=Math.max(a.x,b.x),minY=Math.min(a.y,b.y),maxY=Math.max(a.y,b.y),inRange=minX<=point.x&&point.x<maxX;intersects=minY===maxY?point.y<=minY&&inRange:inRange&&(maxY-minY)*((a.x-b.x)*(a.y-b.y)>0?point.x-minX:maxX-point.x)/(maxX-minX)+minY-point.y>=0}return intersects?1:0}__webpack_require__.d(__webpack_exports__,\"a\",function(){return lineIntersectionsCount})},\"5FN0\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _quad_root__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"2smt\"),_quad_node__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"R/Fs\"),_geometry__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"XJRY\"),_common__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(\"LHUb\"),_util__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(\"i9ZU\");function zIndexComparer(x1,x2){return x1._zIndex<x2._zIndex?1:x1._zIndex>x2._zIndex?-1:0}__webpack_exports__.a=class extends _common__WEBPACK_IMPORTED_MODULE_3__.a{constructor(){super(),this.initRoots()}initRoots(){this.rootMap={},this.root=new _quad_root__WEBPACK_IMPORTED_MODULE_0__.a,this.rootElements=[]}clear(){const rootElements=this.rootElements;for(let idx=0;idx<rootElements.length;idx++)this.remove(rootElements[idx]);this.initRoots()}pointShape(point){const sectorRoot=(this.rootMap[Math.floor(point.x/3e3)]||{})[Math.floor(point.y/3e3)];let result=this.root.pointShapes(point);sectorRoot&&(result=result.concat(sectorRoot.pointShapes(point))),this.assignZindex(result),result.sort(zIndexComparer);for(let idx=0;idx<result.length;idx++)if(result[idx].containsPoint(point))return result[idx]}assignZindex(elements){for(let idx=0;idx<elements.length;idx++){let element=elements[idx],zIndex=0,levelWeight=Math.pow(1e4,75),parents=[];for(;element;)parents.push(element),element=element.parent;for(;parents.length;)element=parents.pop(),zIndex+=((element.parent?element.parent.children:this.rootElements).indexOf(element)+1)*levelWeight,levelWeight/=1e4;elements[idx]._zIndex=zIndex}}optionsChange(e){\"transform\"!==e.field&&\"stroke.width\"!==e.field||this.bboxChange(e.element)}geometryChange(e){this.bboxChange(e.element)}bboxChange(element){if(\"Group\"===element.nodeType)for(let idx=0;idx<element.children.length;idx++)this.bboxChange(element.children[idx]);else element._quadNode&&element._quadNode.remove(element),this._insertShape(element)}add(elements){const elementsArray=Array.isArray(elements)?elements.slice(0):[elements];Object(_util__WEBPACK_IMPORTED_MODULE_4__.a)(this.rootElements,elementsArray),this._insert(elementsArray)}childrenChange(e){if(\"remove\"===e.action)for(let idx=0;idx<e.items.length;idx++)this.remove(e.items[idx]);else this._insert(Array.prototype.slice.call(e.items,0))}_insert(elements){let element;for(;elements.length>0;)element=elements.pop(),element.addObserver(this),\"Group\"===element.nodeType?Object(_util__WEBPACK_IMPORTED_MODULE_4__.a)(elements,element.children):this._insertShape(element)}_insertShape(shape){const bbox=shape.bbox();if(bbox){const sectors=this.getSectors(bbox),x=sectors[0][0],y=sectors[1][0];if(this.inRoot(sectors))this.root.insert(shape,bbox);else{const rootMap=this.rootMap;rootMap[x]||(rootMap[x]={}),rootMap[x][y]||(rootMap[x][y]=new _quad_node__WEBPACK_IMPORTED_MODULE_1__.a(new _geometry__WEBPACK_IMPORTED_MODULE_2__.a([3e3*x,3e3*y],[3e3,3e3]))),rootMap[x][y].insert(shape,bbox)}}}remove(element){if(element.removeObserver(this),\"Group\"===element.nodeType){const children=element.children;for(let idx=0;idx<children.length;idx++)this.remove(children[idx])}else element._quadNode&&(element._quadNode.remove(element),delete element._quadNode)}inRoot(sectors){return sectors[0].length>1||sectors[1].length>1}getSectors(rect){const bottomRight=rect.bottomRight(),bottomX=Math.floor(bottomRight.x/3e3),bottomY=Math.floor(bottomRight.y/3e3),sectors=[[],[]];for(let x=Math.floor(rect.origin.x/3e3);x<=bottomX;x++)sectors[0].push(x);for(let y=Math.floor(rect.origin.y/3e3);y<=bottomY;y++)sectors[1].push(y);return sectors}}},\"5HPa\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _path_node__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"UzJa\"),_utils_render_path__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"hype\");__webpack_exports__.a=class extends _path_node__WEBPACK_IMPORTED_MODULE_0__.a{renderPoints(ctx){const paths=this.srcElement.paths;for(let i=0;i<paths.length;i++)Object(_utils_render_path__WEBPACK_IMPORTED_MODULE_1__.a)(ctx,paths[i])}}},\"5Jba\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";function alignStart(size,rect,align,axis,sizeField){let start;return start=\"start\"===align?rect.origin[axis]:\"end\"===align?rect.origin[axis]+rect.size[sizeField]-size:rect.origin[axis]+(rect.size[sizeField]-size)/2,start}__webpack_require__.d(__webpack_exports__,\"a\",function(){return alignStart})},\"63qr\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";var has_observers=__webpack_require__(\"7joe\"),geometry_rect=__webpack_require__(\"XJRY\"),geometry_point=__webpack_require__(\"lRJa\"),transform=__webpack_require__(\"uBxF\"),deg=__webpack_require__(\"9rnm\"),constants=__webpack_require__(\"2Ic7\");function isOutOfEndPoint(endPoint,controlPoint,point){const angle=Object(deg.a)(Math.atan2(controlPoint.y-endPoint.y,controlPoint.x-endPoint.x));return point.transformCopy(Object(transform.a)().rotate(-angle,endPoint)).x<endPoint.x}function calculateCurveAt(t,field,points){const t1=1-t;return Math.pow(t1,3)*points[0][field]+3*Math.pow(t1,2)*t*points[1][field]+3*Math.pow(t,2)*t1*points[2][field]+Math.pow(t,3)*points[3][field]}function toCubicPolynomial(points,field){return[3*points[1][field]-points[0][field]-3*points[2][field]+points[3][field],3*(points[0][field]-2*points[1][field]+points[2][field]),3*(-points[0][field]+points[1][field]),points[0][field]]}var geometry_constants=__webpack_require__(\"TD7o\"),common_class=__webpack_require__(\"LHUb\"),round=__webpack_require__(\"RlWg\");class complex_number_ComplexNumber extends common_class.a{constructor(real=0,img=0){super(),this.real=real,this.img=img}add(cNumber){return new complex_number_ComplexNumber(Object(round.a)(this.real+cNumber.real,geometry_constants.a),Object(round.a)(this.img+cNumber.img,geometry_constants.a))}addConstant(value){return new complex_number_ComplexNumber(this.real+value,this.img)}negate(){return new complex_number_ComplexNumber(-this.real,-this.img)}multiply(cNumber){return new complex_number_ComplexNumber(this.real*cNumber.real-this.img*cNumber.img,this.real*cNumber.img+this.img*cNumber.real)}multiplyConstant(value){return new complex_number_ComplexNumber(this.real*value,this.img*value)}nthRoot(n){const rad=Math.atan2(this.img,this.real),r=Math.sqrt(Math.pow(this.img,2)+Math.pow(this.real,2)),nthR=Math.pow(r,1/n);return new complex_number_ComplexNumber(nthR*Math.cos(rad/n),nthR*Math.sin(rad/n))}equals(cNumber){return this.real===cNumber.real&&this.img===cNumber.img}isReal(){return 0===this.img}}var complex_number=complex_number_ComplexNumber;function numberSign(x){return x<0?-1:1}function solveCubicEquation(a,b,c,d){if(0===a)return function(a,b,c){const squareRoot=Math.sqrt(Math.pow(b,2)-4*a*c);return[(-b+squareRoot)/(2*a),(-b-squareRoot)/(2*a)]}(b,c,d);const p=(3*a*c-Math.pow(b,2))/(3*Math.pow(a,2)),q=(2*Math.pow(b,3)-9*a*b*c+27*Math.pow(a,2)*d)/(27*Math.pow(a,3)),Q=Math.pow(p/3,3)+Math.pow(q/2,2),i=new complex_number(0,1),b3a=-b/(3*a);let x1,x2,y1,y2,y3,z1,z2;Q<0?(x1=new complex_number(-q/2,Math.sqrt(-Q)).nthRoot(3),x2=new complex_number(-q/2,-Math.sqrt(-Q)).nthRoot(3)):(x1=-q/2+Math.sqrt(Q),x1=new complex_number(numberSign(x1)*Math.pow(Math.abs(x1),1/3)),x2=-q/2-Math.sqrt(Q),x2=new complex_number(numberSign(x2)*Math.pow(Math.abs(x2),1/3))),y1=x1.add(x2),z1=x1.add(x2).multiplyConstant(-.5),z2=x1.add(x2.negate()).multiplyConstant(Math.sqrt(3)/2),y2=z1.add(i.multiply(z2)),y3=z1.add(i.negate().multiply(z2));const result=[];return y1.isReal()&&result.push(Object(round.a)(y1.real+b3a,geometry_constants.a)),y2.isReal()&&result.push(Object(round.a)(y2.real+b3a,geometry_constants.a)),y3.isReal()&&result.push(Object(round.a)(y3.real+b3a,geometry_constants.a)),result}function hasRootsInRange(points,point,field,rootField,range){const polynomial=toCubicPolynomial(points,rootField),roots=solveCubicEquation(polynomial[0],polynomial[1],polynomial[2],polynomial[3]-point[rootField]);let intersection;for(let idx=0;idx<roots.length;idx++)if(0<=roots[idx]&&roots[idx]<=1&&(intersection=calculateCurveAt(roots[idx],field,points),Math.abs(intersection-point[field])<=range))return!0}var math_close=__webpack_require__(\"f4aR\"),line_intersections_count=__webpack_require__(\"4rzP\"),with_points=__webpack_require__(\"zZ53\");const segment_points=[\"anchor\",\"controlIn\",\"controlOut\"];class segment_Segment extends(Object(with_points.a)(has_observers.a,segment_points)){constructor(anchor,controlIn,controlOut){super(),this.anchor(anchor||new geometry_point.a),this.controlIn(controlIn),this.controlOut(controlOut)}bboxTo(toSegment,matrix){const segmentAnchor=this.anchor().transformCopy(matrix),toSegmentAnchor=toSegment.anchor().transformCopy(matrix);let rect;return rect=this.controlOut()&&toSegment.controlIn()?this._curveBoundingBox(segmentAnchor,this.controlOut().transformCopy(matrix),toSegment.controlIn().transformCopy(matrix),toSegmentAnchor):this._lineBoundingBox(segmentAnchor,toSegmentAnchor),rect}_lineBoundingBox(p1,p2){return geometry_rect.a.fromPoints(p1,p2)}_curveBoundingBox(p1,cp1,cp2,p2){const points=[p1,cp1,cp2,p2],extremesX=this._curveExtremesFor(points,\"x\"),extremesY=this._curveExtremesFor(points,\"y\"),xLimits=arrayLimits([extremesX.min,extremesX.max,p1.x,p2.x]),yLimits=arrayLimits([extremesY.min,extremesY.max,p1.y,p2.y]);return geometry_rect.a.fromPoints(new geometry_point.a(xLimits.min,yLimits.min),new geometry_point.a(xLimits.max,yLimits.max))}_curveExtremesFor(points,field){const extremes=this._curveExtremes(points[0][field],points[1][field],points[2][field],points[3][field]);return{min:calculateCurveAt(extremes.min,field,points),max:calculateCurveAt(extremes.max,field,points)}}_curveExtremes(x1,x2,x3,x4){const a=x1-3*x2+3*x3-x4,b=-2*(x1-2*x2+x3),c=x1-x2,sqrt=Math.sqrt(b*b-4*a*c);let t1=0,t2=1;0===a?0!==b&&(t1=t2=-c/b):isNaN(sqrt)||(t1=(-b+sqrt)/(2*a),t2=(-b-sqrt)/(2*a));let min=Math.max(Math.min(t1,t2),0);(min<0||min>1)&&(min=0);let max=Math.min(Math.max(t1,t2),1);return(max>1||max<0)&&(max=1),{min:min,max:max}}_intersectionsTo(segment,point){let intersectionsCount;return intersectionsCount=this.controlOut()&&segment.controlIn()?function(points,point,bbox){const polynomial=toCubicPolynomial(points,\"x\"),roots=solveCubicEquation(polynomial[0],polynomial[1],polynomial[2],polynomial[3]-point.x);let rayIntersection,intersectsRay,count=0;for(let i=0;i<roots.length;i++)rayIntersection=calculateCurveAt(roots[i],\"y\",points),intersectsRay=Object(math_close.a)(rayIntersection,point.y)||rayIntersection>point.y,intersectsRay&&((0===roots[i]||1===roots[i])&&bbox.bottomRight().x>point.x||0<roots[i]&&roots[i]<1)&&count++;return count}([this.anchor(),this.controlOut(),segment.controlIn(),segment.anchor()],point,this.bboxTo(segment)):Object(line_intersections_count.a)(this.anchor(),segment.anchor(),point),intersectionsCount}_isOnCurveTo(segment,point,width,endSegment){if(this.bboxTo(segment).expand(width,width).containsPoint(point)){const p1=this.anchor(),p2=this.controlOut(),p3=segment.controlIn(),p4=segment.anchor();if(\"start\"===endSegment&&p1.distanceTo(point)<=width)return!isOutOfEndPoint(p1,p2,point);if(\"end\"===endSegment&&p4.distanceTo(point)<=width)return!isOutOfEndPoint(p4,p3,point);const points=[p1,p2,p3,p4];if(hasRootsInRange(points,point,\"x\",\"y\",width)||hasRootsInRange(points,point,\"y\",\"x\",width))return!0;const rotation=Object(transform.a)().rotate(45,point),rotatedPoints=[p1.transformCopy(rotation),p2.transformCopy(rotation),p3.transformCopy(rotation),p4.transformCopy(rotation)];return hasRootsInRange(rotatedPoints,point,\"x\",\"y\",width)||hasRootsInRange(rotatedPoints,point,\"y\",\"x\",width)}}_isOnLineTo(segment,point,width){const p1=this.anchor(),p2=segment.anchor(),angle=Object(deg.a)(Math.atan2(p2.y-p1.y,p2.x-p1.x));return new geometry_rect.a([p1.x,p1.y-width/2],[p1.distanceTo(p2),width]).containsPoint(point.transformCopy(Object(transform.a)().rotate(-angle,p1)))}_isOnPathTo(segment,point,width,endSegment){let isOnPath;return isOnPath=this.controlOut()&&segment.controlIn()?this._isOnCurveTo(segment,point,width/2,endSegment):this._isOnLineTo(segment,point,width),isOnPath}}function arrayLimits(arr){let length=arr.length,min=constants.b,max=constants.c;for(let i=0;i<length;i++)max=Math.max(max,arr[i]),min=Math.min(min,arr[i]);return{min:min,max:max}}__webpack_exports__.a=segment_Segment},\"6BXq\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return throttle});var _util_now__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"hSuW\");function throttle(fn,delay){let timeout,lastExecTime=0;if(!delay||delay<=0)return fn;const throttled=function(){const elapsed=Object(_util_now__WEBPACK_IMPORTED_MODULE_0__.a)()-lastExecTime,args=arguments,exec=function(){fn.apply(null,args),lastExecTime=Object(_util_now__WEBPACK_IMPORTED_MODULE_0__.a)()};if(!lastExecTime)return exec();timeout&&clearTimeout(timeout),elapsed>delay?exec():timeout=setTimeout(exec,delay-elapsed)};return throttled.cancel=function(){clearTimeout(timeout)},throttled}},\"6USk\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return rad});var _constants__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"2Ic7\");function rad(degrees){return degrees*_constants__WEBPACK_IMPORTED_MODULE_0__.a}},\"7Jhm\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _mixins_with_points__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"zZ53\"),_geometry_point__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"lRJa\"),_gradient__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"4DQW\");const points=[\"start\",\"end\"];class LinearGradient extends(Object(_mixins_with_points__WEBPACK_IMPORTED_MODULE_0__.a)(_gradient__WEBPACK_IMPORTED_MODULE_2__.a,points)){constructor(options={}){super(options),this.start(options.start||new _geometry_point__WEBPACK_IMPORTED_MODULE_1__.a),this.end(options.end||new _geometry_point__WEBPACK_IMPORTED_MODULE_1__.a(1,0))}}__webpack_exports__.a=LinearGradient},\"7PhV\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _gradient_stop_node__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"Fs4b\"),_core_base_node__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"ztN+\"),_node__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"7Prh\"),_utils_render_all_attributes__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(\"YDM/\");__webpack_exports__.a=class extends _node__WEBPACK_IMPORTED_MODULE_2__.a{constructor(srcElement){super(srcElement),this.id=srcElement.id,this.loadStops()}loadStops(){const stops=this.srcElement.stops,element=this.element;for(let idx=0;idx<stops.length;idx++){let stopNode=new _gradient_stop_node__WEBPACK_IMPORTED_MODULE_0__.a(stops[idx]);this.append(stopNode),element&&stopNode.attachTo(element)}}optionsChange(e){\"gradient.stops\"===e.field?(_core_base_node__WEBPACK_IMPORTED_MODULE_1__.a.prototype.clear.call(this),this.loadStops()):\"gradient\"===e.field&&this.allAttr(this.mapCoordinates())}renderCoordinates(){return Object(_utils_render_all_attributes__WEBPACK_IMPORTED_MODULE_3__.a)(this.mapCoordinates())}mapSpace(){return[\"gradientUnits\",this.srcElement.userSpace()?\"userSpaceOnUse\":\"objectBoundingBox\"]}}},\"7Prh\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _core_base_node__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"ztN+\"),_utils_render_all_attributes__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"YDM/\"),_utils_render_attribute__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"08A6\"),_utils_render_style__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(\"8tN3\"),_node_map__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(\"uNz1\"),_utils_render_svg__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__(\"tZVE\"),_constants__WEBPACK_IMPORTED_MODULE_6__=__webpack_require__(\"V34t\"),_common__WEBPACK_IMPORTED_MODULE_7__=__webpack_require__(\"/EQf\"),_util__WEBPACK_IMPORTED_MODULE_8__=__webpack_require__(\"VqL+\");const DefinitionMap={clip:\"clip-path\",fill:\"fill\"};function isDefinition(type,value){return\"clip\"===type||\"fill\"===type&&(!value||\"Gradient\"===value.nodeType)}__webpack_exports__.a=class extends _core_base_node__WEBPACK_IMPORTED_MODULE_0__.a{constructor(srcElement,options){super(srcElement),this.definitions={},this.options=options}destroy(){this.element&&(this.element._kendoNode=null,this.element=null),this.clearDefinitions(),super.destroy()}load(elements,pos){for(let i=0;i<elements.length;i++){const srcElement=elements[i],children=srcElement.children,childNode=new _node_map__WEBPACK_IMPORTED_MODULE_4__.a[srcElement.nodeType](srcElement,this.options);Object(_util__WEBPACK_IMPORTED_MODULE_8__.a)(pos)?this.insertAt(childNode,pos):this.append(childNode),childNode.createDefinitions(),children&&children.length>0&&childNode.load(children);const element=this.element;element&&childNode.attachTo(element,pos)}}root(){let root=this;for(;root.parent;)root=root.parent;return root}attachTo(domElement,pos){const container=document.createElement(\"div\");Object(_utils_render_svg__WEBPACK_IMPORTED_MODULE_5__.a)(container,\"<svg xmlns='\"+_constants__WEBPACK_IMPORTED_MODULE_6__.b+\"' version='1.1'>\"+this.render()+\"</svg>\");const element=container.firstChild.firstChild;element&&(Object(_util__WEBPACK_IMPORTED_MODULE_8__.a)(pos)?domElement.insertBefore(element,domElement.childNodes[pos]||null):domElement.appendChild(element),this.setElement(element))}setElement(element){this.element&&(this.element._kendoNode=null),this.element=element,this.element._kendoNode=this;const nodes=this.childNodes;for(let i=0;i<nodes.length;i++)nodes[i].setElement(element.childNodes[i])}clear(){this.clearDefinitions(),this.element&&(this.element.innerHTML=\"\");const children=this.childNodes;for(let i=0;i<children.length;i++)children[i].destroy();this.childNodes=[]}removeSelf(){if(this.element){const parentNode=this.element.parentNode;parentNode&&parentNode.removeChild(this.element),this.element=null}super.removeSelf()}template(){return this.renderChildren()}render(){return this.template()}renderChildren(){const nodes=this.childNodes;let output=\"\";for(let i=0;i<nodes.length;i++)output+=nodes[i].render();return output}optionsChange(e){const{field:field,value:value}=e;\"visible\"===field?this.css(\"display\",value?\"\":_constants__WEBPACK_IMPORTED_MODULE_6__.a):DefinitionMap[field]&&isDefinition(field,value)?this.updateDefinition(field,value):\"opacity\"===field?this.attr(\"opacity\",value):\"cursor\"===field?this.css(\"cursor\",value):\"id\"===field&&(value?this.attr(\"id\",value):this.removeAttr(\"id\")),super.optionsChange(e)}attr(name,value){this.element&&this.element.setAttribute(name,value)}allAttr(attrs){for(let i=0;i<attrs.length;i++)this.attr(attrs[i][0],attrs[i][1])}css(name,value){this.element&&(this.element.style[name]=value)}allCss(styles){for(let i=0;i<styles.length;i++)this.css(styles[i][0],styles[i][1])}removeAttr(name){this.element&&this.element.removeAttribute(name)}mapTransform(transform){const attrs=[];return transform&&attrs.push([\"transform\",\"matrix(\"+transform.matrix().toString(6)+\")\"]),attrs}renderTransform(){return Object(_utils_render_all_attributes__WEBPACK_IMPORTED_MODULE_1__.a)(this.mapTransform(this.srcElement.transform()))}transformChange(value){value?this.allAttr(this.mapTransform(value)):this.removeAttr(\"transform\")}mapStyle(){const options=this.srcElement.options,style=[[\"cursor\",options.cursor]];return!1===options.visible&&style.push([\"display\",_constants__WEBPACK_IMPORTED_MODULE_6__.a]),style}renderStyle(){return Object(_utils_render_attribute__WEBPACK_IMPORTED_MODULE_2__.a)(\"style\",Object(_utils_render_style__WEBPACK_IMPORTED_MODULE_3__.a)(this.mapStyle(!0)))}renderOpacity(){return Object(_utils_render_attribute__WEBPACK_IMPORTED_MODULE_2__.a)(\"opacity\",this.srcElement.options.opacity)}renderId(){return Object(_utils_render_attribute__WEBPACK_IMPORTED_MODULE_2__.a)(\"id\",this.srcElement.options.id)}createDefinitions(){const srcElement=this.srcElement,definitions=this.definitions;if(srcElement){const options=srcElement.options;let hasDefinitions;for(let field in DefinitionMap){let definition=options.get(field);definition&&isDefinition(field,definition)&&(definitions[field]=definition,hasDefinitions=!0)}hasDefinitions&&this.definitionChange({action:\"add\",definitions:definitions})}}definitionChange(e){this.parent&&this.parent.definitionChange(e)}updateDefinition(type,value){const definitions=this.definitions,current=definitions[type],attr=DefinitionMap[type],definition={};current&&(definition[type]=current,this.definitionChange({action:\"remove\",definitions:definition}),delete definitions[type]),value?(definition[type]=value,this.definitionChange({action:\"add\",definitions:definition}),definitions[type]=value,this.attr(attr,this.refUrl(value.id))):current&&this.removeAttr(attr)}clearDefinitions(){this.definitionChange({action:\"remove\",definitions:this.definitions}),this.definitions={}}renderDefinitions(){return Object(_utils_render_all_attributes__WEBPACK_IMPORTED_MODULE_1__.a)(this.mapDefinitions())}mapDefinitions(){const definitions=this.definitions,attrs=[];for(let field in definitions)attrs.push([DefinitionMap[field],this.refUrl(definitions[field].id)]);return attrs}refUrl(id){const skipBaseHref=(this.options||{}).skipBaseHref,baseHref=this.baseUrl().replace(/'/g,\"\\\\'\");return`url(${skipBaseHref?\"\":baseHref}#${id})`}baseUrl(){return function(){const base=document.getElementsByTagName(\"base\")[0];let href=document.location.href,url=\"\";if(base&&!(_common__WEBPACK_IMPORTED_MODULE_7__.a.browser||{}).msie){const hashIndex=href.indexOf(\"#\");-1!==hashIndex&&(href=href.substring(0,hashIndex)),url=href}return url}()}}},\"7WKN\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _gradients_linear_gradient__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"7Jhm\"),_gradients_radial_gradient__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"yhXd\"),_linear_gradient_node__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"4U2A\"),_radial_gradient_node__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(\"inPS\"),_node__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(\"7Prh\"),_clip_node__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__(\"gNPy\");__webpack_exports__.a=class extends _node__WEBPACK_IMPORTED_MODULE_4__.a{constructor(){super(),this.definitionMap={}}attachTo(domElement){this.element=domElement}template(){return`<defs>${this.renderChildren()}</defs>`}definitionChange(e){const{definitions:definitions,action:action}=e;\"add\"===action?this.addDefinitions(definitions):\"remove\"===action&&this.removeDefinitions(definitions)}createDefinition(type,item){let nodeType;return\"clip\"===type?nodeType=_clip_node__WEBPACK_IMPORTED_MODULE_5__.a:\"fill\"===type&&(item instanceof _gradients_linear_gradient__WEBPACK_IMPORTED_MODULE_0__.a?nodeType=_linear_gradient_node__WEBPACK_IMPORTED_MODULE_2__.a:item instanceof _gradients_radial_gradient__WEBPACK_IMPORTED_MODULE_1__.a&&(nodeType=_radial_gradient_node__WEBPACK_IMPORTED_MODULE_3__.a)),new nodeType(item)}addDefinitions(definitions){for(let field in definitions)this.addDefinition(field,definitions[field])}addDefinition(type,srcElement){const{element:element,definitionMap:definitionMap}=this,id=srcElement.id,mapItem=definitionMap[id];if(mapItem)mapItem.count++;else{const node=this.createDefinition(type,srcElement);definitionMap[id]={element:node,count:1},this.append(node),element&&node.attachTo(this.element)}}removeDefinitions(definitions){for(let field in definitions)this.removeDefinition(definitions[field])}removeDefinition(srcElement){const definitionMap=this.definitionMap,id=srcElement.id,mapItem=definitionMap[id];mapItem&&(mapItem.count--,0===mapItem.count&&(this.remove(this.childNodes.indexOf(mapItem.element),1),delete definitionMap[id]))}}},\"7joe\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _common__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"LHUb\");__webpack_exports__.a=class extends _common__WEBPACK_IMPORTED_MODULE_0__.a{observers(){return this._observers=this._observers||[],this._observers}addObserver(element){return this._observers?this._observers.push(element):this._observers=[element],this}removeObserver(element){const observers=this.observers(),index=observers.indexOf(element);return-1!==index&&observers.splice(index,1),this}trigger(methodName,event){const observers=this._observers;if(observers&&!this._suspended)for(let idx=0;idx<observers.length;idx++){let observer=observers[idx];observer[methodName]&&observer[methodName](event)}return this}optionsChange(e={}){e.element=this,this.trigger(\"optionsChange\",e)}geometryChange(){this.trigger(\"geometryChange\",{element:this})}suspend(){return this._suspended=(this._suspended||0)+1,this}resume(){return this._suspended=Math.max((this._suspended||0)-1,0),this}_observerField(field,value){this[field]&&this[field].removeObserver(this),this[field]=value,value.addObserver(this)}}},\"8tN3\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return renderStyle});var _util__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"VqL+\");function renderStyle(attrs){let output=\"\";for(let i=0;i<attrs.length;i++){let value=attrs[i][1];Object(_util__WEBPACK_IMPORTED_MODULE_0__.a)(value)&&(output+=attrs[i][0]+\":\"+value+\";\")}if(\"\"!==output)return output}},\"9rnm\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return deg});var _constants__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"2Ic7\");function deg(radians){return radians/_constants__WEBPACK_IMPORTED_MODULE_0__.a}},\"9uUv\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return valueOrDefault});var _defined__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"VqL+\");function valueOrDefault(value,defaultValue){return Object(_defined__WEBPACK_IMPORTED_MODULE_0__.a)(value)?value:defaultValue}},APnZ:function(module,__webpack_exports__,__webpack_require__){\"use strict\";function bindEvents(element,events){for(let eventName in events){const eventNames=eventName.trim().split(\" \");for(let idx=0;idx<eventNames.length;idx++)element.addEventListener(eventNames[idx],events[eventName],!1)}}__webpack_require__.d(__webpack_exports__,\"a\",function(){return bindEvents})},Ah4p:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"b\",function(){return path_Path}),__webpack_require__.d(__webpack_exports__,\"a\",function(){return path_MultiPath});var elements_array=__webpack_require__(\"Vvtp\"),geometry_elements_array=class extends elements_array.a{_change(){this.geometryChange()}},shapes_element=__webpack_require__(\"XdXH\"),paintable=__webpack_require__(\"T3aN\"),measurable=__webpack_require__(\"qNx/\"),geometry_arc=__webpack_require__(\"HKF7\"),rect=__webpack_require__(\"XJRY\"),geometry_segment=__webpack_require__(\"63qr\"),geometry_point=__webpack_require__(\"lRJa\"),size=__webpack_require__(\"ZfP6\"),line_intersections_count=__webpack_require__(\"4rzP\"),defined=__webpack_require__(\"VqL+\"),last=__webpack_require__(\"Eu+R\"),rad=__webpack_require__(\"6USk\"),parse_path=__webpack_require__(\"sK2o\"),elements_bounding_box=__webpack_require__(\"x/aw\"),elements_clippend_bounding_box=__webpack_require__(\"wbRH\");class path_Path extends(Object(paintable.a)(Object(measurable.a)(shapes_element.a))){static parse(str,options){return path_MultiPath.parse(str,options)}get nodeType(){return\"Path\"}constructor(options){super(options),this.segments=new geometry_elements_array,this.segments.addObserver(this),Object(defined.a)(this.options.stroke)||(this.stroke(\"#000\"),Object(defined.a)(this.options.stroke.lineJoin)||this.options.set(\"stroke.lineJoin\",\"miter\"))}moveTo(x,y){return this.suspend(),this.segments.elements([]),this.resume(),this.lineTo(x,y),this}lineTo(x,y){const point=Object(defined.a)(y)?new geometry_point.a(x,y):x,segment=new geometry_segment.a(point);return this.segments.push(segment),this}curveTo(controlOut,controlIn,point){if(this.segments.length>0){const lastSegment=Object(last.a)(this.segments),segment=new geometry_segment.a(point,controlIn);this.suspend(),lastSegment.controlOut(controlOut),this.resume(),this.segments.push(segment)}return this}arc(startAngle,endAngle,radiusX,radiusY,anticlockwise){if(this.segments.length>0){const anchor=Object(last.a)(this.segments).anchor(),start=Object(rad.a)(startAngle),center=new geometry_point.a(anchor.x-radiusX*Math.cos(start),anchor.y-radiusY*Math.sin(start)),arc=new geometry_arc.a(center,{startAngle:startAngle,endAngle:endAngle,radiusX:radiusX,radiusY:radiusY,anticlockwise:anticlockwise});this._addArcSegments(arc)}return this}arcTo(end,rx,ry,largeArc,swipe,rotation){if(this.segments.length>0){const anchor=Object(last.a)(this.segments).anchor(),arc=geometry_arc.a.fromPoints(anchor,end,rx,ry,largeArc,swipe,rotation);this._addArcSegments(arc)}return this}_addArcSegments(arc){this.suspend();const curvePoints=arc.curvePoints();for(let i=1;i<curvePoints.length;i+=3)this.curveTo(curvePoints[i],curvePoints[i+1],curvePoints[i+2]);this.resume(),this.geometryChange()}close(){return this.options.closed=!0,this.geometryChange(),this}rawBBox(){return this._bbox()}_containsPoint(point){const segments=this.segments,length=segments.length;let previous,current,intersectionsCount=0;for(let idx=1;idx<length;idx++)previous=segments[idx-1],current=segments[idx],intersectionsCount+=previous._intersectionsTo(current,point);return!this.options.closed&&segments[0].anchor().equals(segments[length-1].anchor())||(intersectionsCount+=Object(line_intersections_count.a)(segments[0].anchor(),segments[length-1].anchor(),point)),intersectionsCount%2!=0}_isOnPath(point,width){const segments=this.segments,length=segments.length,pathWidth=width||this.options.stroke.width;if(length>1){if(segments[0]._isOnPathTo(segments[1],point,pathWidth,\"start\"))return!0;for(let idx=2;idx<=length-2;idx++)if(segments[idx-1]._isOnPathTo(segments[idx],point,pathWidth))return!0;if(segments[length-2]._isOnPathTo(segments[length-1],point,pathWidth,\"end\"))return!0}return!1}_bbox(matrix){const segments=this.segments,length=segments.length;let boundingBox;if(1===length){let anchor=segments[0].anchor().transformCopy(matrix);boundingBox=new rect.a(anchor,size.a.ZERO)}else if(length>0)for(let i=1;i<length;i++){let segmentBox=segments[i-1].bboxTo(segments[i],matrix);boundingBox=boundingBox?rect.a.union(boundingBox,segmentBox):segmentBox}return boundingBox}static fromRect(rect,options){return new path_Path(options).moveTo(rect.topLeft()).lineTo(rect.topRight()).lineTo(rect.bottomRight()).lineTo(rect.bottomLeft()).close()}static fromPoints(points,options){if(points){const path=new path_Path(options);for(let i=0;i<points.length;i++){let point=geometry_point.a.create(points[i]);point&&(0===i?path.moveTo(point):path.lineTo(point))}return path}}static fromArc(arc,options){const path=new path_Path(options),startAngle=arc.startAngle,start=arc.pointAt(startAngle);return path.moveTo(start.x,start.y),path.arc(startAngle,arc.endAngle,arc.radiusX,arc.radiusY,arc.anticlockwise),path}}class path_MultiPath extends(Object(paintable.a)(Object(measurable.a)(shapes_element.a))){static parse(str,options){const instance=new path_MultiPath(options);return Object(parse_path.a)(instance,str)}get nodeType(){return\"MultiPath\"}constructor(options){super(options),this.paths=new geometry_elements_array,this.paths.addObserver(this),Object(defined.a)(this.options.stroke)||this.stroke(\"#000\")}moveTo(x,y){const path=new path_Path;return path.moveTo(x,y),this.paths.push(path),this}lineTo(x,y){return this.paths.length>0&&Object(last.a)(this.paths).lineTo(x,y),this}curveTo(controlOut,controlIn,point){return this.paths.length>0&&Object(last.a)(this.paths).curveTo(controlOut,controlIn,point),this}arc(startAngle,endAngle,radiusX,radiusY,anticlockwise){return this.paths.length>0&&Object(last.a)(this.paths).arc(startAngle,endAngle,radiusX,radiusY,anticlockwise),this}arcTo(end,rx,ry,largeArc,swipe,rotation){return this.paths.length>0&&Object(last.a)(this.paths).arcTo(end,rx,ry,largeArc,swipe,rotation),this}close(){return this.paths.length>0&&Object(last.a)(this.paths).close(),this}_bbox(matrix){return Object(elements_bounding_box.a)(this.paths,!0,matrix)}rawBBox(){return Object(elements_bounding_box.a)(this.paths,!1)}_containsPoint(point){const paths=this.paths;for(let idx=0;idx<paths.length;idx++)if(paths[idx]._containsPoint(point))return!0;return!1}_isOnPath(point){const paths=this.paths,width=this.options.stroke.width;for(let idx=0;idx<paths.length;idx++)if(paths[idx]._isOnPath(point,width))return!0;return!1}_clippedBBox(transformation){return Object(elements_clippend_bounding_box.a)(this.paths,this.currentTransform(transformation))}}},Aie7:function(module,__webpack_exports__,__webpack_require__){\"use strict\";function unbindEvents(element,events={}){for(let name in events){const eventNames=name.trim().split(\" \");for(let idx=0;idx<eventNames.length;idx++)element.removeEventListener(eventNames[idx],events[name],!1)}}__webpack_require__.d(__webpack_exports__,\"a\",function(){return unbindEvents})},BIVv:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _mixins_with_accessors__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"bp4U\"),_point__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"lRJa\"),_rect__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"XJRY\"),_math_ellipse_extreme_angles__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(\"Ll3z\"),_core_has_observers__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(\"7joe\"),_util__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__(\"6USk\");const PI_DIV_2=Math.PI/2;class Circle extends(Object(_mixins_with_accessors__WEBPACK_IMPORTED_MODULE_0__.a)(_core_has_observers__WEBPACK_IMPORTED_MODULE_4__.a,[\"radius\"])){constructor(center=new _point__WEBPACK_IMPORTED_MODULE_1__.a,radius=0){super(),this.setCenter(center),this.setRadius(radius)}setCenter(value){return this._observerField(\"center\",_point__WEBPACK_IMPORTED_MODULE_1__.a.create(value)),this.geometryChange(),this}getCenter(){return this.center}equals(other){return other&&other.center.equals(this.center)&&other.radius===this.radius}clone(){return new Circle(this.center.clone(),this.radius)}pointAt(angle){return this._pointAt(Object(_util__WEBPACK_IMPORTED_MODULE_5__.a)(angle))}bbox(matrix){const extremeAngles=Object(_math_ellipse_extreme_angles__WEBPACK_IMPORTED_MODULE_3__.a)(this.center,this.radius,this.radius,matrix);let minPoint=_point__WEBPACK_IMPORTED_MODULE_1__.a.maxPoint(),maxPoint=_point__WEBPACK_IMPORTED_MODULE_1__.a.minPoint();for(let i=0;i<4;i++){let currentPointX=this._pointAt(extremeAngles.x+i*PI_DIV_2).transformCopy(matrix),currentPointY=this._pointAt(extremeAngles.y+i*PI_DIV_2).transformCopy(matrix),currentPoint=new _point__WEBPACK_IMPORTED_MODULE_1__.a(currentPointX.x,currentPointY.y);minPoint=_point__WEBPACK_IMPORTED_MODULE_1__.a.min(minPoint,currentPoint),maxPoint=_point__WEBPACK_IMPORTED_MODULE_1__.a.max(maxPoint,currentPoint)}return _rect__WEBPACK_IMPORTED_MODULE_2__.a.fromPoints(minPoint,maxPoint)}_pointAt(angle){const{center:center,radius:radius}=this;return new _point__WEBPACK_IMPORTED_MODULE_1__.a(center.x+radius*Math.cos(angle),center.y+radius*Math.sin(angle))}containsPoint(point){const{center:center,radius:radius}=this;return Math.pow(point.x-center.x,2)+Math.pow(point.y-center.y,2)<=Math.pow(radius,2)}_isOnPath(point,width){const{center:center,radius:radius}=this,pointDistance=center.distanceTo(point);return radius-width<=pointDistance&&pointDistance<=radius+width}}__webpack_exports__.a=Circle},\"BK/f\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _mixins_with_geometry__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"O6F+\"),_element__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"XdXH\"),_geometry_rect__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"XJRY\"),_geometry_to_matrix__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(\"x/GK\"),_util__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(\"VqL+\");class Image extends(Object(_mixins_with_geometry__WEBPACK_IMPORTED_MODULE_0__.a)(_element__WEBPACK_IMPORTED_MODULE_1__.a,[\"rect\"])){get nodeType(){return\"Image\"}constructor(src,rect=new _geometry_rect__WEBPACK_IMPORTED_MODULE_2__.a,options={}){super(options),this.src(src),this.rect(rect)}src(value){return Object(_util__WEBPACK_IMPORTED_MODULE_4__.a)(value)?(this.options.set(\"src\",value),this):this.options.get(\"src\")}bbox(transformation){const combinedMatrix=Object(_geometry_to_matrix__WEBPACK_IMPORTED_MODULE_3__.a)(this.currentTransform(transformation));return this._rect.bbox(combinedMatrix)}rawBBox(){return this._rect.bbox()}_containsPoint(point){return this._rect.containsPoint(point)}_hasFill(){return this.src()}}__webpack_exports__.a=Image},C91f:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"c\",function(){return objectKey}),__webpack_require__.d(__webpack_exports__,\"a\",function(){return hashKey}),__webpack_require__.d(__webpack_exports__,\"b\",function(){return normalizeText});const REPLACE_REGEX=/\\r?\\n|\\r|\\t/g;function normalizeText(text){return String(text).replace(REPLACE_REGEX,\" \")}function objectKey(object){const parts=[];for(let key in object)parts.push(key+object[key]);return parts.sort().join(\"\")}function hashKey(str){let hash=2166136261;for(let i=0;i<str.length;++i)hash+=(hash<<1)+(hash<<4)+(hash<<7)+(hash<<8)+(hash<<24),hash^=str.charCodeAt(i);return hash>>>0}},DPs4:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return elementPadding});var _element_styles__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"oY8A\");function elementPadding(element){const{paddingLeft:paddingLeft,paddingTop:paddingTop}=Object(_element_styles__WEBPACK_IMPORTED_MODULE_0__.a)(element,[\"paddingLeft\",\"paddingTop\"]);return{top:parseFloat(paddingTop),left:parseFloat(paddingLeft)}}},E7ME:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return definitionId});let defId=1;function definitionId(){return\"kdef\"+defId++}},\"Eu+R\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";function last(array){if(array)return array[array.length-1]}__webpack_require__.d(__webpack_exports__,\"a\",function(){return last})},FRnV:function(module,__webpack_exports__,__webpack_require__){\"use strict\";let animationFrameProxy=callback=>{const wnd=\"undefined\"!=typeof window?window:{},animationFrame=wnd.requestAnimationFrame||wnd.webkitRequestAnimationFrame||wnd.mozRequestAnimationFrame||wnd.oRequestAnimationFrame||wnd.msRequestAnimationFrame||function(callback){setTimeout(callback,1e3/60)};animationFrameProxy=callback=>animationFrame.call(wnd,callback),animationFrameProxy(callback)};__webpack_exports__.a=animationFrameProxy},FSED:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _path_node__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"UzJa\");__webpack_exports__.a=class extends _path_node__WEBPACK_IMPORTED_MODULE_0__.a{renderPoints(ctx){const{center:center,radius:radius}=this.srcElement.geometry();ctx.arc(center.x,center.y,radius,0,2*Math.PI)}}},Fs4b:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _node__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"7Prh\"),_utils_render_attribute__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"08A6\");__webpack_exports__.a=class extends _node__WEBPACK_IMPORTED_MODULE_0__.a{template(){return`<stop ${this.renderOffset()} ${this.renderStyle()} />`}renderOffset(){return Object(_utils_render_attribute__WEBPACK_IMPORTED_MODULE_1__.a)(\"offset\",this.srcElement.offset())}mapStyle(){const srcElement=this.srcElement;return[[\"stop-color\",srcElement.color()],[\"stop-opacity\",srcElement.opacity()]]}optionsChange(e){\"offset\"===e.field?this.attr(e.field,e.value):\"color\"!==e.field&&\"opacity\"!==e.field||this.css(\"stop-\"+e.field,e.value)}}},\"G/KS\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _path_node__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"UzJa\");__webpack_exports__.a=class extends _path_node__WEBPACK_IMPORTED_MODULE_0__.a{renderTo(ctx){const text=this.srcElement,pos=text.position(),size=text.measure();ctx.save(),this.setTransform(ctx),this.setClip(ctx),this.setOpacity(ctx),ctx.beginPath(),ctx.font=text.options.font,ctx.textAlign=\"left\",this.setFill(ctx)&&ctx.fillText(text.content(),pos.x,pos.y+size.baseline),this.setStroke(ctx)&&(this.setLineDash(ctx),ctx.strokeText(text.content(),pos.x,pos.y+size.baseline)),ctx.restore()}}},HKF7:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var has_observers=__webpack_require__(\"7joe\"),rad=__webpack_require__(\"6USk\"),deg=__webpack_require__(\"9rnm\"),round=__webpack_require__(\"RlWg\"),with_accessors=__webpack_require__(\"bp4U\"),math_close=__webpack_require__(\"f4aR\");function closeOrLess(a,b,tolerance){return a<b||Object(math_close.a)(a,b,tolerance)}var geometry_point=__webpack_require__(\"lRJa\"),ellipse_extreme_angles=__webpack_require__(\"Ll3z\"),constants=__webpack_require__(\"TD7o\"),rect=__webpack_require__(\"XJRY\"),transform=__webpack_require__(\"uBxF\");const pow=Math.pow,accessors=[\"radiusX\",\"radiusY\",\"startAngle\",\"endAngle\",\"anticlockwise\"];class arc_Arc extends(Object(with_accessors.a)(has_observers.a,accessors)){constructor(center=new geometry_point.a,options={}){super(),this.setCenter(center),this.radiusX=options.radiusX,this.radiusY=options.radiusY||options.radiusX,this.startAngle=options.startAngle,this.endAngle=options.endAngle,this.anticlockwise=options.anticlockwise||!1,this.xRotation=options.xRotation}clone(){return new arc_Arc(this.center,{radiusX:this.radiusX,radiusY:this.radiusY,startAngle:this.startAngle,endAngle:this.endAngle,anticlockwise:this.anticlockwise})}setCenter(value){return this._observerField(\"center\",geometry_point.a.create(value)),this.geometryChange(),this}getCenter(){return this.center}pointAt(angle){const center=this.center,radian=Object(rad.a)(angle);return new geometry_point.a(center.x+this.radiusX*Math.cos(radian),center.y+this.radiusY*Math.sin(radian))}curvePoints(){const startAngle=this.startAngle,dir=this.anticlockwise?-1:1,curvePoints=[this.pointAt(startAngle)],interval=this._arcInterval(),intervalAngle=interval.endAngle-interval.startAngle,subIntervalsCount=Math.ceil(intervalAngle/45),subIntervalAngle=intervalAngle/subIntervalsCount;let transformation,currentAngle=startAngle;this.xRotation&&(transformation=Object(transform.a)().rotate(this.xRotation,this.center));for(let i=1;i<=subIntervalsCount;i++){const nextAngle=currentAngle+dir*subIntervalAngle,points=this._intervalCurvePoints(currentAngle,nextAngle,transformation);curvePoints.push(points.cp1,points.cp2,points.p2),currentAngle=nextAngle}return curvePoints}bbox(matrix){const interval=this._arcInterval(),startAngle=interval.startAngle,endAngle=interval.endAngle,extremeAngles=Object(ellipse_extreme_angles.a)(this.center,this.radiusX,this.radiusY,matrix),extremeX=Object(deg.a)(extremeAngles.x),extremeY=Object(deg.a)(extremeAngles.y),endPoint=this.pointAt(endAngle).transformCopy(matrix);let currentAngleX=bboxStartAngle(extremeX,startAngle),currentAngleY=bboxStartAngle(extremeY,startAngle),currentPoint=this.pointAt(startAngle).transformCopy(matrix),minPoint=geometry_point.a.min(currentPoint,endPoint),maxPoint=geometry_point.a.max(currentPoint,endPoint);for(;currentAngleX<endAngle||currentAngleY<endAngle;){let currentPointX,currentPointY;currentAngleX<endAngle&&(currentPointX=this.pointAt(currentAngleX).transformCopy(matrix),currentAngleX+=90),currentAngleY<endAngle&&(currentPointY=this.pointAt(currentAngleY).transformCopy(matrix),currentAngleY+=90),currentPoint=new geometry_point.a(currentPointX.x,currentPointY.y),minPoint=geometry_point.a.min(minPoint,currentPoint),maxPoint=geometry_point.a.max(maxPoint,currentPoint)}return rect.a.fromPoints(minPoint,maxPoint)}_arcInterval(){let{startAngle:startAngle,endAngle:endAngle,anticlockwise:anticlockwise}=this;if(anticlockwise){let oldStart=startAngle;startAngle=endAngle,endAngle=oldStart}return(startAngle>endAngle||anticlockwise&&startAngle===endAngle)&&(endAngle+=360),{startAngle:startAngle,endAngle:endAngle}}_intervalCurvePoints(startAngle,endAngle,transformation){const p1=this.pointAt(startAngle),p2=this.pointAt(endAngle),p1Derivative=this._derivativeAt(startAngle),p2Derivative=this._derivativeAt(endAngle),t=(Object(rad.a)(endAngle)-Object(rad.a)(startAngle))/3,cp1=new geometry_point.a(p1.x+t*p1Derivative.x,p1.y+t*p1Derivative.y),cp2=new geometry_point.a(p2.x-t*p2Derivative.x,p2.y-t*p2Derivative.y);return transformation&&(p1.transform(transformation),p2.transform(transformation),cp1.transform(transformation),cp2.transform(transformation)),{p1:p1,cp1:cp1,cp2:cp2,p2:p2}}_derivativeAt(angle){const radian=Object(rad.a)(angle);return new geometry_point.a(-this.radiusX*Math.sin(radian),this.radiusY*Math.cos(radian))}containsPoint(point){const interval=this._arcInterval(),intervalAngle=interval.endAngle-interval.startAngle,{center:center,radiusX:radiusX,radiusY:radiusY}=this,distance=center.distanceTo(point),angleRad=Math.atan2(point.y-center.y,point.x-center.x),pointRadius=radiusX*radiusY/Math.sqrt(pow(radiusX,2)*pow(Math.sin(angleRad),2)+pow(radiusY,2)*pow(Math.cos(angleRad),2)),startPoint=this.pointAt(this.startAngle).round(constants.a),endPoint=this.pointAt(this.endAngle).round(constants.a),intersection=function(p0,p1,p2,p3){const s1x=p1.x-p0.x,s2x=p3.x-p2.x,s1y=p1.y-p0.y,s2y=p3.y-p2.y,nx=p0.x-p2.x,ny=p0.y-p2.y,d=s1x*s2y-s2x*s1y,s=(s1x*ny-s1y*nx)/d,t=(s2x*ny-s2y*nx)/d;if(s>=0&&s<=1&&t>=0&&t<=1)return new geometry_point.a(p0.x+t*s1x,p0.y+t*s1y)}(center,point.round(constants.a),startPoint,endPoint);let containsPoint;if(intervalAngle<180)containsPoint=intersection&&closeOrLess(center.distanceTo(intersection),distance)&&closeOrLess(distance,pointRadius);else{let angle=calculateAngle(center.x,center.y,radiusX,radiusY,point.x,point.y);360!==angle&&(angle=(360+angle)%360);let inAngleRange=interval.startAngle<=angle&&angle<=interval.endAngle;containsPoint=inAngleRange&&closeOrLess(distance,pointRadius)||!inAngleRange&&(!intersection||intersection.equals(point))}return containsPoint}_isOnPath(point,width){const interval=this._arcInterval(),center=this.center;let angle=calculateAngle(center.x,center.y,this.radiusX,this.radiusY,point.x,point.y);return 360!==angle&&(angle=(360+angle)%360),interval.startAngle<=angle&&angle<=interval.endAngle&&this.pointAt(angle).distanceTo(point)<=width}static fromPoints(start,end,rx,ry,largeArc,swipe,rotation){const arcParameters=function(parameters){let{x1:x1,y1:y1,x2:x2,y2:y2,rx:rx,ry:ry,largeArc:largeArc,swipe:swipe,rotation:rotation=0}=parameters;const radians=Object(rad.a)(rotation),cosine=Math.cos(radians),sine=Math.sin(radians),xT=cosine*(x1-x2)/2+sine*(y1-y2)/2,yT=-sine*(x1-x2)/2+cosine*(y1-y2)/2,sign=largeArc!==swipe?1:-1,xt2=Math.pow(xT,2),yt2=Math.pow(yT,2);let rx2=Math.pow(rx,2),ry2=Math.pow(ry,2),delta=xt2/rx2+yt2/ry2;delta>1&&(delta=Math.sqrt(xt2/rx2+yt2/ry2),rx*=delta,rx2=Math.pow(rx,2),ry*=delta,ry2=Math.pow(ry,2));let constT=sign*Math.sqrt((rx2*ry2-rx2*yt2-ry2*xt2)/(rx2*yt2+ry2*xt2));isNaN(constT)&&(constT=0);const cxT=constT*(rx*yT)/ry,cyT=ry*xT*-constT/rx,cx=cosine*cxT-sine*cyT+(x1+x2)/2,cy=sine*cxT+cosine*cyT+(y1+y2)/2,uX=(xT-cxT)/rx,uY=(yT-cyT)/ry,vX=-(xT+cxT)/rx,vY=-(yT+cyT)/ry,startAngle=(uY>=0?1:-1)*Object(deg.a)(Math.acos(uX/Math.sqrt(uX*uX+uY*uY))),angleCosine=Object(round.a)((uX*vX+uY*vY)/(Math.sqrt(uX*uX+uY*uY)*Math.sqrt(vX*vX+vY*vY)),10);let angle=(uX*vY-uY*vX>=0?1:-1)*Object(deg.a)(Math.acos(angleCosine));!swipe&&angle>0&&(angle-=360),swipe&&angle<0&&(angle+=360);let endAngle=startAngle+angle;const signEndAngle=endAngle>=0?1:-1;return endAngle=Math.abs(endAngle)%360*signEndAngle,{center:new geometry_point.a(cx,cy),startAngle:startAngle,endAngle:endAngle,radiusX:rx,radiusY:ry,xRotation:rotation}}({x1:start.x,y1:start.y,x2:end.x,y2:end.y,rx:rx,ry:ry,largeArc:largeArc,swipe:swipe,rotation:rotation});return new arc_Arc(arcParameters.center,{startAngle:arcParameters.startAngle,endAngle:arcParameters.endAngle,radiusX:arcParameters.radiusX,radiusY:arcParameters.radiusY,xRotation:arcParameters.xRotation,anticlockwise:0===swipe})}}function calculateAngle(cx,cy,rx,ry,x,y){const cos=Object(round.a)((x-cx)/rx,3),sin=Object(round.a)((y-cy)/ry,3);return Object(round.a)(Object(deg.a)(Math.atan2(sin,cos)))}function bboxStartAngle(angle,start){let startAngle=angle;for(;startAngle<start;)startAngle+=90;return startAngle}__webpack_exports__.a=arc_Arc},\"IU+O\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";function eventElement(e={}){return e.touch?e.touch.initialTouch:e.target}__webpack_require__.d(__webpack_exports__,\"a\",function(){return eventElement})},IsCa:function(module,__webpack_exports__,__webpack_require__){\"use strict\";function elementOffset(element){const box=element.getBoundingClientRect(),documentElement=document.documentElement;return{top:box.top+(window.pageYOffset||documentElement.scrollTop)-(documentElement.clientTop||0),left:box.left+(window.pageXOffset||documentElement.scrollLeft)-(documentElement.clientLeft||0)}}__webpack_require__.d(__webpack_exports__,\"a\",function(){return elementOffset})},JZGi:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return elementScale});var _geometry_matrix__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"hL34\");const matrixRegexp=/matrix\\((.*)\\)/;function transformMatrix(element){const transform=getComputedStyle(element).transform;return\"none\"===transform?_geometry_matrix__WEBPACK_IMPORTED_MODULE_0__.a.unit():function(matrixString){const match=matrixString.match(matrixRegexp);if(null===match||2!==match.length)return _geometry_matrix__WEBPACK_IMPORTED_MODULE_0__.a.unit();const members=match[1].split(\",\").map(x=>parseFloat(x));return new _geometry_matrix__WEBPACK_IMPORTED_MODULE_0__.a(...members)}(transform)}function elementScale(element){if(!element)return _geometry_matrix__WEBPACK_IMPORTED_MODULE_0__.a.unit();let matrix=transformMatrix(element),parent=element.parentElement;for(;parent;){const parentMatrix=transformMatrix(parent);matrix=matrix.multiplyCopy(parentMatrix),parent=parent.parentElement}return matrix.b=matrix.c=matrix.e=matrix.f=0,matrix}},K3Ik:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _mixins_with_geometry__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"O6F+\"),_element__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"XdXH\"),_mixins_paintable__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"T3aN\"),_mixins_measurable__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(\"qNx/\"),_geometry_rect__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(\"XJRY\"),_util__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__(\"VqL+\");class Rect extends(Object(_mixins_paintable__WEBPACK_IMPORTED_MODULE_2__.a)(Object(_mixins_measurable__WEBPACK_IMPORTED_MODULE_3__.a)(Object(_mixins_with_geometry__WEBPACK_IMPORTED_MODULE_0__.a)(_element__WEBPACK_IMPORTED_MODULE_1__.a)))){get nodeType(){return\"Rect\"}constructor(geometry=new _geometry_rect__WEBPACK_IMPORTED_MODULE_4__.a,options={}){super(options),this.geometry(geometry),Object(_util__WEBPACK_IMPORTED_MODULE_5__.a)(this.options.stroke)||this.stroke(\"#000\")}_bbox(matrix){return this._geometry.bbox(matrix)}rawBBox(){return this._geometry.bbox()}_containsPoint(point){return this._geometry.containsPoint(point)}_isOnPath(point){return this.geometry()._isOnPath(point,this.options.stroke.width/2)}}__webpack_exports__.a=Rect},LHUb:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return Class});class Class{}},Ll3z:function(module,__webpack_exports__,__webpack_require__){\"use strict\";function ellipseExtremeAngles(center,rx,ry,matrix){let extremeX=0,extremeY=0;return matrix&&(extremeX=Math.atan2(matrix.c*ry,matrix.a*rx),0!==matrix.b&&(extremeY=Math.atan2(matrix.d*ry,matrix.b*rx))),{x:extremeX,y:extremeY}}__webpack_require__.d(__webpack_exports__,\"a\",function(){return ellipseExtremeAngles})},\"O6F+\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _util__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"VqL+\");function geometryAccessor(name){const fieldName=\"_\"+name;return function(value){return Object(_util__WEBPACK_IMPORTED_MODULE_0__.a)(value)?(this._observerField(fieldName,value),this.geometryChange(),this):this[fieldName]}}__webpack_exports__.a=(TBase,names=[\"geometry\"])=>{const result=class extends TBase{};return function(fn,names){for(let i=0;i<names.length;i++)fn[names[i]]=geometryAccessor(names[i])}(result.prototype,names),result}},OOjv:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"b\",function(){return DASH_ARRAYS}),__webpack_require__.d(__webpack_exports__,\"c\",function(){return SOLID}),__webpack_require__.d(__webpack_exports__,\"a\",function(){return BUTT});const DASH_ARRAYS={dot:[1.5,3.5],dash:[4,3.5],longdash:[8,3.5],dashdot:[3.5,3.5,1.5,3.5],longdashdot:[8,3.5,1.5,3.5],longdashdotdot:[8,3.5,1.5,3.5,1.5,3.5]},SOLID=\"solid\",BUTT=\"butt\"},Ptn1:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _common__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"LHUb\"),_has_observers__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"7joe\"),_util__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"VqL+\");const toString={}.toString;class OptionsStore extends _has_observers__WEBPACK_IMPORTED_MODULE_1__.a{constructor(options,prefix=\"\"){super(),this.prefix=prefix;for(let field in options){let member=options[field];member=this._wrap(member,field),this[field]=member}}get(field){const parts=field.split(\".\");let result=this;for(;parts.length&&result;)result=result[parts.shift()];return result}set(field,value){this.get(field)!==value&&(this._set(field,this._wrap(value,field)),this.optionsChange({field:this.prefix+field,value:value}))}_set(field,value){const composite=field.indexOf(\".\")>=0;let parentObj=this,fieldName=field;if(composite){const parts=fieldName.split(\".\");let prefix=this.prefix;for(;parts.length>1;){fieldName=parts.shift(),prefix+=fieldName+\".\";let obj=parentObj[fieldName];obj||(obj=new OptionsStore({},prefix),obj.addObserver(this),parentObj[fieldName]=obj),parentObj=obj}fieldName=parts[0]}parentObj._clear(fieldName),parentObj[fieldName]=value}_clear(field){const current=this[field];current&&current.removeObserver&&current.removeObserver(this)}_wrap(object,field){const type=toString.call(object);let wrapped=object;return null!==wrapped&&Object(_util__WEBPACK_IMPORTED_MODULE_2__.a)(wrapped)&&\"[object Object]\"===type&&(object instanceof OptionsStore||object instanceof _common__WEBPACK_IMPORTED_MODULE_0__.a||(wrapped=new OptionsStore(wrapped,this.prefix+field+\".\")),wrapped.addObserver(this)),wrapped}}__webpack_exports__.a=OptionsStore},QPDK:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var options_store=__webpack_require__(\"Ptn1\"),defined=__webpack_require__(\"VqL+\");function optionsAccessor(name){return function(value){return Object(defined.a)(value)?(this.options.set(name,value),this):this.options.get(name)}}var has_observers=__webpack_require__(\"7joe\");const options=[\"offset\",\"color\",\"opacity\"];class gradient_stop_GradientStop extends(((TBase,names)=>{const result=class extends TBase{};return function(fn,names){for(let i=0;i<names.length;i++)fn[names[i]]=optionsAccessor(names[i])}(result.prototype,names),result})(has_observers.a,options)){constructor(offset,color,opacity){super(),this.options=new options_store.a({offset:offset,color:color,opacity:Object(defined.a)(opacity)?opacity:1}),this.options.addObserver(this)}static create(arg){if(Object(defined.a)(arg)){let stop;return stop=arg instanceof gradient_stop_GradientStop?arg:arg.length>1?new gradient_stop_GradientStop(arg[0],arg[1],arg[2]):new gradient_stop_GradientStop(arg.offset,arg.color,arg.opacity),stop}}}__webpack_exports__.a=gradient_stop_GradientStop},QUbS:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _class__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"LHUb\"),_named_colors__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"T8t9\"),_parse_color__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"om2P\");__webpack_exports__.a=(()=>{class Color extends _class__WEBPACK_IMPORTED_MODULE_0__.a{constructor(value){if(super(),1===arguments.length){const formats=Color.formats,resolvedColor=this.resolveColor(value);for(let idx=0;idx<formats.length;idx++){const processor=formats[idx].process,parts=formats[idx].re.exec(resolvedColor);if(parts){const channels=processor(parts);this.r=channels[0],this.g=channels[1],this.b=channels[2]}}}else this.r=arguments[0],this.g=arguments[1],this.b=arguments[2];this.r=this.normalizeByte(this.r),this.g=this.normalizeByte(this.g),this.b=this.normalizeByte(this.b)}toHex(){const pad=this.padDigit,r=this.r.toString(16),g=this.g.toString(16),b=this.b.toString(16);return\"#\"+pad(r)+pad(g)+pad(b)}resolveColor(value){let color=value||\"black\";return\"#\"===color.charAt(0)&&(color=color.substr(1,6)),color=color.replace(/ /g,\"\"),color=color.toLowerCase(),color=Color.namedColors[color]||color,color}normalizeByte(value){return value<0||isNaN(value)?0:value>255?255:value}padDigit(value){return 1===value.length?\"0\"+value:value}brightness(value){const round=Math.round;return this.r=round(this.normalizeByte(this.r*value)),this.g=round(this.normalizeByte(this.g*value)),this.b=round(this.normalizeByte(this.b*value)),this}percBrightness(){return Math.sqrt(.241*this.r*this.r+.691*this.g*this.g+.068*this.b*this.b)}isDark(){return this.percBrightness()<180}static fromBytes(r,g,b,a){return new _parse_color__WEBPACK_IMPORTED_MODULE_2__.a(r,g,b,null!=a?a:1)}static fromRGB(r,g,b,a){return new _parse_color__WEBPACK_IMPORTED_MODULE_2__.d(r,g,b,null!=a?a:1)}static fromHSV(h,s,v,a){return new _parse_color__WEBPACK_IMPORTED_MODULE_2__.c(h,s,v,null!=a?a:1)}static fromHSL(h,s,l,a){return new _parse_color__WEBPACK_IMPORTED_MODULE_2__.b(h,s,l,null!=a?a:1)}}return Color.formats=[{re:/^rgb\\((\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3})\\)$/,process:function(parts){return[parseInt(parts[1],10),parseInt(parts[2],10),parseInt(parts[3],10)]}},{re:/^(\\w{2})(\\w{2})(\\w{2})$/,process:function(parts){return[parseInt(parts[1],16),parseInt(parts[2],16),parseInt(parts[3],16)]}},{re:/^(\\w{1})(\\w{1})(\\w{1})$/,process:function(parts){return[parseInt(parts[1]+parts[1],16),parseInt(parts[2]+parts[2],16),parseInt(parts[3]+parts[3],16)]}}],Color.namedColors=_named_colors__WEBPACK_IMPORTED_MODULE_1__.a,Color})()},\"R/Fs\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _quad_root__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"2smt\"),_geometry__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"XJRY\"),_util__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"i9ZU\");class QuadNode extends _quad_root__WEBPACK_IMPORTED_MODULE_0__.a{constructor(rect){super(),this.children=[],this.rect=rect}inBounds(rect){const nodeRect=this.rect,nodeBottomRight=nodeRect.bottomRight(),bottomRight=rect.bottomRight();return nodeRect.origin.x<=rect.origin.x&&nodeRect.origin.y<=rect.origin.y&&bottomRight.x<=nodeBottomRight.x&&bottomRight.y<=nodeBottomRight.y}pointShapes(point){const children=this.children,length=children.length,result=super.pointShapes(point);for(let idx=0;idx<length;idx++)Object(_util__WEBPACK_IMPORTED_MODULE_2__.a)(result,children[idx].pointShapes(point));return result}insert(shape,bbox){const children=this.children;let inserted=!1;if(this.inBounds(bbox)){if(this.shapes.length<4)this._add(shape,bbox);else{children.length||this._initChildren();for(let idx=0;idx<children.length;idx++)if(children[idx].insert(shape,bbox)){inserted=!0;break}inserted||this._add(shape,bbox)}inserted=!0}return inserted}_initChildren(){const{rect:rect,children:children}=this,center=rect.center(),halfWidth=rect.width()/2,halfHeight=rect.height()/2;children.push(new QuadNode(new _geometry__WEBPACK_IMPORTED_MODULE_1__.a([rect.origin.x,rect.origin.y],[halfWidth,halfHeight])),new QuadNode(new _geometry__WEBPACK_IMPORTED_MODULE_1__.a([center.x,rect.origin.y],[halfWidth,halfHeight])),new QuadNode(new _geometry__WEBPACK_IMPORTED_MODULE_1__.a([rect.origin.x,center.y],[halfWidth,halfHeight])),new QuadNode(new _geometry__WEBPACK_IMPORTED_MODULE_1__.a([center.x,center.y],[halfWidth,halfHeight])))}}__webpack_exports__.a=QuadNode},RlWg:function(module,__webpack_exports__,__webpack_require__){\"use strict\";function round(value,precision){const power=(p=precision)?Math.pow(10,p):1;var p;return Math.round(value*power)/power}__webpack_require__.d(__webpack_exports__,\"a\",function(){return round})},SMq3:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _path_node__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"UzJa\");__webpack_exports__.a=class extends _path_node__WEBPACK_IMPORTED_MODULE_0__.a{renderPoints(ctx){const{origin:origin,size:size}=this.srcElement.geometry();ctx.rect(origin.x,origin.y,size.width,size.height)}}},T3aN:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _util__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"VqL+\");__webpack_exports__.a=TBase=>class extends TBase{fill(color,opacity){const options=this.options;if(Object(_util__WEBPACK_IMPORTED_MODULE_0__.a)(color)){if(color&&\"Gradient\"!==color.nodeType){const newFill={color:color};Object(_util__WEBPACK_IMPORTED_MODULE_0__.a)(opacity)&&(newFill.opacity=opacity),options.set(\"fill\",newFill)}else options.set(\"fill\",color);return this}return options.get(\"fill\")}stroke(color,width,opacity){return Object(_util__WEBPACK_IMPORTED_MODULE_0__.a)(color)?(this.options.set(\"stroke.color\",color),Object(_util__WEBPACK_IMPORTED_MODULE_0__.a)(width)&&this.options.set(\"stroke.width\",width),Object(_util__WEBPACK_IMPORTED_MODULE_0__.a)(opacity)&&this.options.set(\"stroke.opacity\",opacity),this):this.options.get(\"stroke\")}}},T8t9:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_exports__.a={aliceblue:\"f0f8ff\",antiquewhite:\"faebd7\",aqua:\"00ffff\",aquamarine:\"7fffd4\",azure:\"f0ffff\",beige:\"f5f5dc\",bisque:\"ffe4c4\",black:\"000000\",blanchedalmond:\"ffebcd\",blue:\"0000ff\",blueviolet:\"8a2be2\",brown:\"a52a2a\",burlywood:\"deb887\",cadetblue:\"5f9ea0\",chartreuse:\"7fff00\",chocolate:\"d2691e\",coral:\"ff7f50\",cornflowerblue:\"6495ed\",cornsilk:\"fff8dc\",crimson:\"dc143c\",cyan:\"00ffff\",darkblue:\"00008b\",darkcyan:\"008b8b\",darkgoldenrod:\"b8860b\",darkgray:\"a9a9a9\",darkgrey:\"a9a9a9\",darkgreen:\"006400\",darkkhaki:\"bdb76b\",darkmagenta:\"8b008b\",darkolivegreen:\"556b2f\",darkorange:\"ff8c00\",darkorchid:\"9932cc\",darkred:\"8b0000\",darksalmon:\"e9967a\",darkseagreen:\"8fbc8f\",darkslateblue:\"483d8b\",darkslategray:\"2f4f4f\",darkslategrey:\"2f4f4f\",darkturquoise:\"00ced1\",darkviolet:\"9400d3\",deeppink:\"ff1493\",deepskyblue:\"00bfff\",dimgray:\"696969\",dimgrey:\"696969\",dodgerblue:\"1e90ff\",firebrick:\"b22222\",floralwhite:\"fffaf0\",forestgreen:\"228b22\",fuchsia:\"ff00ff\",gainsboro:\"dcdcdc\",ghostwhite:\"f8f8ff\",gold:\"ffd700\",goldenrod:\"daa520\",gray:\"808080\",grey:\"808080\",green:\"008000\",greenyellow:\"adff2f\",honeydew:\"f0fff0\",hotpink:\"ff69b4\",indianred:\"cd5c5c\",indigo:\"4b0082\",ivory:\"fffff0\",khaki:\"f0e68c\",lavender:\"e6e6fa\",lavenderblush:\"fff0f5\",lawngreen:\"7cfc00\",lemonchiffon:\"fffacd\",lightblue:\"add8e6\",lightcoral:\"f08080\",lightcyan:\"e0ffff\",lightgoldenrodyellow:\"fafad2\",lightgray:\"d3d3d3\",lightgrey:\"d3d3d3\",lightgreen:\"90ee90\",lightpink:\"ffb6c1\",lightsalmon:\"ffa07a\",lightseagreen:\"20b2aa\",lightskyblue:\"87cefa\",lightslategray:\"778899\",lightslategrey:\"778899\",lightsteelblue:\"b0c4de\",lightyellow:\"ffffe0\",lime:\"00ff00\",limegreen:\"32cd32\",linen:\"faf0e6\",magenta:\"ff00ff\",maroon:\"800000\",mediumaquamarine:\"66cdaa\",mediumblue:\"0000cd\",mediumorchid:\"ba55d3\",mediumpurple:\"9370d8\",mediumseagreen:\"3cb371\",mediumslateblue:\"7b68ee\",mediumspringgreen:\"00fa9a\",mediumturquoise:\"48d1cc\",mediumvioletred:\"c71585\",midnightblue:\"191970\",mintcream:\"f5fffa\",mistyrose:\"ffe4e1\",moccasin:\"ffe4b5\",navajowhite:\"ffdead\",navy:\"000080\",oldlace:\"fdf5e6\",olive:\"808000\",olivedrab:\"6b8e23\",orange:\"ffa500\",orangered:\"ff4500\",orchid:\"da70d6\",palegoldenrod:\"eee8aa\",palegreen:\"98fb98\",paleturquoise:\"afeeee\",palevioletred:\"d87093\",papayawhip:\"ffefd5\",peachpuff:\"ffdab9\",peru:\"cd853f\",pink:\"ffc0cb\",plum:\"dda0dd\",powderblue:\"b0e0e6\",purple:\"800080\",red:\"ff0000\",rosybrown:\"bc8f8f\",royalblue:\"4169e1\",saddlebrown:\"8b4513\",salmon:\"fa8072\",sandybrown:\"f4a460\",seagreen:\"2e8b57\",seashell:\"fff5ee\",sienna:\"a0522d\",silver:\"c0c0c0\",skyblue:\"87ceeb\",slateblue:\"6a5acd\",slategray:\"708090\",slategrey:\"708090\",snow:\"fffafa\",springgreen:\"00ff7f\",steelblue:\"4682b4\",tan:\"d2b48c\",teal:\"008080\",thistle:\"d8bfd8\",tomato:\"ff6347\",turquoise:\"40e0d0\",violet:\"ee82ee\",wheat:\"f5deb3\",white:\"ffffff\",whitesmoke:\"f5f5f5\",yellow:\"ffff00\",yellowgreen:\"9acd32\"}},TD7o:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return PRECISION});const PRECISION=10},Ual8:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _geometry_circle__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"BIVv\"),_mixins_paintable__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"T3aN\"),_mixins_measurable__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"qNx/\"),_mixins_with_geometry__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(\"O6F+\"),_element__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(\"XdXH\"),_util__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__(\"VqL+\");class Circle extends(Object(_mixins_paintable__WEBPACK_IMPORTED_MODULE_1__.a)(Object(_mixins_measurable__WEBPACK_IMPORTED_MODULE_2__.a)(Object(_mixins_with_geometry__WEBPACK_IMPORTED_MODULE_3__.a)(_element__WEBPACK_IMPORTED_MODULE_4__.a)))){get nodeType(){return\"Circle\"}constructor(geometry=new _geometry_circle__WEBPACK_IMPORTED_MODULE_0__.a,options={}){super(options),this.geometry(geometry),Object(_util__WEBPACK_IMPORTED_MODULE_5__.a)(this.options.stroke)||this.stroke(\"#000\")}rawBBox(){return this._geometry.bbox()}_bbox(matrix){return this._geometry.bbox(matrix)}_containsPoint(point){return this.geometry().containsPoint(point)}_isOnPath(point){return this.geometry()._isOnPath(point,this.options.stroke.width/2)}}__webpack_exports__.a=Circle},UzJa:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _node__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"o+K8\"),_common__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"om2P\"),_util__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"3Quq\"),_util__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(\"9uUv\"),_gradients_linear_gradient__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(\"7Jhm\"),_gradients_radial_gradient__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__(\"yhXd\"),_core_constants__WEBPACK_IMPORTED_MODULE_6__=__webpack_require__(\"OOjv\"),_utils_render_path__WEBPACK_IMPORTED_MODULE_7__=__webpack_require__(\"hype\");__webpack_exports__.a=class extends _node__WEBPACK_IMPORTED_MODULE_0__.a{renderTo(ctx){ctx.save(),this.setTransform(ctx),this.setClip(ctx),this.setOpacity(ctx),ctx.beginPath(),this.renderPoints(ctx,this.srcElement),this.setLineDash(ctx),this.setLineCap(ctx),this.setLineJoin(ctx),this.setFill(ctx),this.setStroke(ctx),ctx.restore()}setFill(ctx){const fill=this.srcElement.options.fill;let hasFill=!1;return fill&&(\"Gradient\"===fill.nodeType?(this.setGradientFill(ctx,fill),hasFill=!0):Object(_util__WEBPACK_IMPORTED_MODULE_2__.a)(fill.color)||(ctx.fillStyle=fill.color,ctx.save(),this.globalAlpha(ctx,fill.opacity),ctx.fill(),ctx.restore(),hasFill=!0)),hasFill}setGradientFill(ctx,fill){const bbox=this.srcElement.rawBBox();let gradient;if(fill instanceof _gradients_linear_gradient__WEBPACK_IMPORTED_MODULE_4__.a){let start=fill.start(),end=fill.end();gradient=ctx.createLinearGradient(start.x,start.y,end.x,end.y)}else if(fill instanceof _gradients_radial_gradient__WEBPACK_IMPORTED_MODULE_5__.a){let center=fill.center();gradient=ctx.createRadialGradient(center.x,center.y,0,center.x,center.y,fill.radius())}!function(gradient,stops){for(let idx=0;idx<stops.length;idx++){let stop=stops[idx],color=Object(_common__WEBPACK_IMPORTED_MODULE_1__.e)(stop.color());color.a*=stop.opacity(),gradient.addColorStop(stop.offset(),color.toCssRgba())}}(gradient,fill.stops),ctx.save(),fill.userSpace()||ctx.transform(bbox.width(),0,0,bbox.height(),bbox.origin.x,bbox.origin.y),ctx.fillStyle=gradient,ctx.fill(),ctx.restore()}setStroke(ctx){const stroke=this.srcElement.options.stroke;if(stroke&&!Object(_util__WEBPACK_IMPORTED_MODULE_2__.a)(stroke.color)&&stroke.width>0)return ctx.strokeStyle=stroke.color,ctx.lineWidth=Object(_util__WEBPACK_IMPORTED_MODULE_3__.a)(stroke.width,1),ctx.save(),this.globalAlpha(ctx,stroke.opacity),ctx.stroke(),ctx.restore(),!0}dashType(){const stroke=this.srcElement.options.stroke;if(stroke&&stroke.dashType)return stroke.dashType.toLowerCase()}setLineDash(ctx){const dashType=this.dashType();if(dashType&&dashType!==_core_constants__WEBPACK_IMPORTED_MODULE_6__.c){const dashArray=_core_constants__WEBPACK_IMPORTED_MODULE_6__.b[dashType];ctx.setLineDash?ctx.setLineDash(dashArray):(ctx.mozDash=dashArray,ctx.webkitLineDash=dashArray)}}setLineCap(ctx){const dashType=this.dashType(),stroke=this.srcElement.options.stroke;dashType&&dashType!==_core_constants__WEBPACK_IMPORTED_MODULE_6__.c?ctx.lineCap=_core_constants__WEBPACK_IMPORTED_MODULE_6__.a:stroke&&stroke.lineCap&&(ctx.lineCap=stroke.lineCap)}setLineJoin(ctx){const stroke=this.srcElement.options.stroke;stroke&&stroke.lineJoin&&(ctx.lineJoin=stroke.lineJoin)}renderPoints(ctx,path){Object(_utils_render_path__WEBPACK_IMPORTED_MODULE_7__.a)(ctx,path)}}},V34t:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"b\",function(){return SVG_NS}),__webpack_require__.d(__webpack_exports__,\"a\",function(){return NONE});const SVG_NS=\"http://www.w3.org/2000/svg\",NONE=\"none\"},\"VqL+\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";function defined(value){return void 0!==value}__webpack_require__.d(__webpack_exports__,\"a\",function(){return defined})},Vvtp:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _core_has_observers__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"7joe\");const push=[].push,pop=[].pop,splice=[].splice,shift=[].shift,slice=[].slice,unshift=[].unshift;__webpack_exports__.a=class extends _core_has_observers__WEBPACK_IMPORTED_MODULE_0__.a{constructor(array=[]){super(),this.length=0,this._splice(0,array.length,array)}elements(value){return value?(this._splice(0,this.length,value),this._change(),this):this.slice(0)}push(){const elements=arguments,result=push.apply(this,elements);return this._add(elements),result}slice(){return slice.call(this)}pop(){const length=this.length,result=pop.apply(this);return length&&this._remove([result]),result}splice(index,howMany){const elements=slice.call(arguments,2),result=this._splice(index,howMany,elements);return this._change(),result}shift(){const length=this.length,result=shift.apply(this);return length&&this._remove([result]),result}unshift(){const elements=arguments,result=unshift.apply(this,elements);return this._add(elements),result}indexOf(element){const length=this.length;for(let idx=0;idx<length;idx++)if(this[idx]===element)return idx;return-1}_splice(index,howMany,elements){const result=splice.apply(this,[index,howMany].concat(elements));return this._clearObserver(result),this._setObserver(elements),result}_add(elements){this._setObserver(elements),this._change()}_remove(elements){this._clearObserver(elements),this._change()}_setObserver(elements){for(let idx=0;idx<elements.length;idx++)elements[idx].addObserver(this)}_clearObserver(elements){for(let idx=0;idx<elements.length;idx++)elements[idx].removeObserver(this)}_change(){}}},XJRY:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _core_has_observers__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"7joe\"),_point__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"lRJa\"),_size__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"ZfP6\");class Rect extends _core_has_observers__WEBPACK_IMPORTED_MODULE_0__.a{constructor(origin=new _point__WEBPACK_IMPORTED_MODULE_1__.a,size=new _size__WEBPACK_IMPORTED_MODULE_2__.a){super(),this.setOrigin(origin),this.setSize(size)}clone(){return new Rect(this.origin.clone(),this.size.clone())}equals(other){return other&&other.origin.equals(this.origin)&&other.size.equals(this.size)}setOrigin(value){return this._observerField(\"origin\",_point__WEBPACK_IMPORTED_MODULE_1__.a.create(value)),this.geometryChange(),this}getOrigin(){return this.origin}setSize(value){return this._observerField(\"size\",_size__WEBPACK_IMPORTED_MODULE_2__.a.create(value)),this.geometryChange(),this}getSize(){return this.size}width(){return this.size.width}height(){return this.size.height}topLeft(){return this.origin.clone()}bottomRight(){return this.origin.clone().translate(this.width(),this.height())}topRight(){return this.origin.clone().translate(this.width(),0)}bottomLeft(){return this.origin.clone().translate(0,this.height())}center(){return this.origin.clone().translate(this.width()/2,this.height()/2)}bbox(matrix){const tl=this.topLeft().transformCopy(matrix),tr=this.topRight().transformCopy(matrix),br=this.bottomRight().transformCopy(matrix),bl=this.bottomLeft().transformCopy(matrix);return Rect.fromPoints(tl,tr,br,bl)}transformCopy(m){return Rect.fromPoints(this.topLeft().transform(m),this.bottomRight().transform(m))}expand(x,y=x){return this.size.width+=2*x,this.size.height+=2*y,this.origin.translate(-x,-y),this}expandCopy(x,y){return this.clone().expand(x,y)}containsPoint(point){const origin=this.origin,bottomRight=this.bottomRight();return!(point.x<origin.x||point.y<origin.y||bottomRight.x<point.x||bottomRight.y<point.y)}_isOnPath(point,width){const rectOuter=this.expandCopy(width,width),rectInner=this.expandCopy(-width,-width);return rectOuter.containsPoint(point)&&!rectInner.containsPoint(point)}static fromPoints(){const topLeft=_point__WEBPACK_IMPORTED_MODULE_1__.a.min.apply(null,arguments),bottomRight=_point__WEBPACK_IMPORTED_MODULE_1__.a.max.apply(null,arguments),size=new _size__WEBPACK_IMPORTED_MODULE_2__.a(bottomRight.x-topLeft.x,bottomRight.y-topLeft.y);return new Rect(topLeft,size)}static union(a,b){return Rect.fromPoints(_point__WEBPACK_IMPORTED_MODULE_1__.a.min(a.topLeft(),b.topLeft()),_point__WEBPACK_IMPORTED_MODULE_1__.a.max(a.bottomRight(),b.bottomRight()))}static intersect(a,b){const rect1={left:a.topLeft().x,top:a.topLeft().y,right:a.bottomRight().x,bottom:a.bottomRight().y},rect2={left:b.topLeft().x,top:b.topLeft().y,right:b.bottomRight().x,bottom:b.bottomRight().y};if(rect1.left<=rect2.right&&rect2.left<=rect1.right&&rect1.top<=rect2.bottom&&rect2.top<=rect1.bottom)return Rect.fromPoints(new _point__WEBPACK_IMPORTED_MODULE_1__.a(Math.max(rect1.left,rect2.left),Math.max(rect1.top,rect2.top)),new _point__WEBPACK_IMPORTED_MODULE_1__.a(Math.min(rect1.right,rect2.right),Math.min(rect1.bottom,rect2.bottom)))}}__webpack_exports__.a=Rect},XdXH:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _core_options_store__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"Ptn1\"),_geometry_rect__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"XJRY\"),_geometry_matrix__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"hL34\"),_geometry_transform__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(\"uBxF\"),_geometry_to_matrix__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(\"x/GK\"),_core_has_observers__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__(\"7joe\"),_util__WEBPACK_IMPORTED_MODULE_6__=__webpack_require__(\"E7ME\"),_util__WEBPACK_IMPORTED_MODULE_7__=__webpack_require__(\"VqL+\"),_util__WEBPACK_IMPORTED_MODULE_8__=__webpack_require__(\"9uUv\"),_util__WEBPACK_IMPORTED_MODULE_9__=__webpack_require__(\"3Quq\");__webpack_exports__.a=class extends _core_has_observers__WEBPACK_IMPORTED_MODULE_5__.a{get nodeType(){return\"Rect\"}constructor(options){super(),this._initOptions(options)}_initOptions(options={}){const{clip:clip,transform:transform}=options;transform&&(options.transform=Object(_geometry_transform__WEBPACK_IMPORTED_MODULE_3__.a)(transform)),clip&&!clip.id&&(clip.id=Object(_util__WEBPACK_IMPORTED_MODULE_6__.a)()),this.options=new _core_options_store__WEBPACK_IMPORTED_MODULE_0__.a(options),this.options.addObserver(this)}transform(value){if(!Object(_util__WEBPACK_IMPORTED_MODULE_7__.a)(value))return this.options.get(\"transform\");this.options.set(\"transform\",Object(_geometry_transform__WEBPACK_IMPORTED_MODULE_3__.a)(value))}parentTransform(){let parentMatrix,element=this;for(;element.parent;){element=element.parent;let transformation=element.transform();transformation&&(parentMatrix=transformation.matrix().multiplyCopy(parentMatrix||_geometry_matrix__WEBPACK_IMPORTED_MODULE_2__.a.unit()))}if(parentMatrix)return Object(_geometry_transform__WEBPACK_IMPORTED_MODULE_3__.a)(parentMatrix)}currentTransform(parentTransform=this.parentTransform()){const elementTransform=this.transform(),elementMatrix=Object(_geometry_to_matrix__WEBPACK_IMPORTED_MODULE_4__.a)(elementTransform);let combinedMatrix,parentMatrix=Object(_geometry_to_matrix__WEBPACK_IMPORTED_MODULE_4__.a)(parentTransform);if(combinedMatrix=elementMatrix&&parentMatrix?parentMatrix.multiplyCopy(elementMatrix):elementMatrix||parentMatrix,combinedMatrix)return Object(_geometry_transform__WEBPACK_IMPORTED_MODULE_3__.a)(combinedMatrix)}visible(value){return Object(_util__WEBPACK_IMPORTED_MODULE_7__.a)(value)?(this.options.set(\"visible\",value),this):!1!==this.options.get(\"visible\")}clip(value){const options=this.options;return Object(_util__WEBPACK_IMPORTED_MODULE_7__.a)(value)?(value&&!value.id&&(value.id=Object(_util__WEBPACK_IMPORTED_MODULE_6__.a)()),options.set(\"clip\",value),this):options.get(\"clip\")}opacity(value){return Object(_util__WEBPACK_IMPORTED_MODULE_7__.a)(value)?(this.options.set(\"opacity\",value),this):Object(_util__WEBPACK_IMPORTED_MODULE_8__.a)(this.options.get(\"opacity\"),1)}clippedBBox(transformation){const bbox=this._clippedBBox(transformation);if(bbox){const clip=this.clip();return clip?_geometry_rect__WEBPACK_IMPORTED_MODULE_1__.a.intersect(bbox,clip.bbox(transformation)):bbox}}containsPoint(point,parentTransform){if(this.visible()){const transform=this.currentTransform(parentTransform);let transformedPoint=point;return transform&&(transformedPoint=point.transformCopy(transform.matrix().invert())),this._hasFill()&&this._containsPoint(transformedPoint)||this._isOnPath&&this._hasStroke()&&this._isOnPath(transformedPoint)}return!1}_hasFill(){const fill=this.options.fill;return fill&&!Object(_util__WEBPACK_IMPORTED_MODULE_9__.a)(fill.color)}_hasStroke(){const stroke=this.options.stroke;return stroke&&stroke.width>0&&!Object(_util__WEBPACK_IMPORTED_MODULE_9__.a)(stroke.color)}_clippedBBox(transformation){return this.bbox(transformation)}}},\"YDM/\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return renderAllAttr});var _render_attribute__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"08A6\");function renderAllAttr(attrs){let output=\"\";for(let i=0;i<attrs.length;i++)output+=Object(_render_attribute__WEBPACK_IMPORTED_MODULE_0__.a)(attrs[i][0],attrs[i][1]);return output}},Ytya:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _group_node__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"xYjD\"),_mixins_traversable__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"fdcc\"),_common__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"6BXq\"),_common__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(\"FRnV\");class RootNode extends(Object(_mixins_traversable__WEBPACK_IMPORTED_MODULE_1__.a)(_group_node__WEBPACK_IMPORTED_MODULE_0__.a,\"childNodes\")){constructor(canvas,size){super(),this.canvas=canvas,this.size=size,this.ctx=canvas.getContext(\"2d\");const invalidateHandler=this._invalidate.bind(this);this.invalidate=Object(_common__WEBPACK_IMPORTED_MODULE_2__.a)(()=>{Object(_common__WEBPACK_IMPORTED_MODULE_3__.a)(invalidateHandler)},16.666666666666668)}destroy(){super.destroy(),this.canvas=null,this.ctx=null}load(elements,pos,cors){this.loadElements(elements,pos,cors),this._invalidate()}_rescale(scale){const{canvas:canvas,size:size}=this;canvas.width=size.width*scale,canvas.height=size.height*scale,this.ctx.scale(scale,scale)}_devicePixelRatio(){return\"number\"==typeof window.devicePixelRatio?window.devicePixelRatio:1}_invalidate(options){if(!this.ctx)return;const scale=options&&options.fixedScale?1:this._devicePixelRatio();this._rescale(scale),this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height),this.renderTo(this.ctx)}}__webpack_exports__.a=RootNode},Z3TV:function(module,__webpack_exports__,__webpack_require__){\"use strict\";function promiseAll(promises){return Promise.all(promises)}__webpack_require__.d(__webpack_exports__,\"a\",function(){return promiseAll})},ZfP6:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _core_has_observers__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"7joe\"),_mixins_with_accessors__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"bp4U\"),_util__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"VqL+\"),_util__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(\"RlWg\");class Size extends(Object(_mixins_with_accessors__WEBPACK_IMPORTED_MODULE_1__.a)(_core_has_observers__WEBPACK_IMPORTED_MODULE_0__.a,[\"width\",\"height\"])){constructor(width,height){super(),this.width=width||0,this.height=height||0}equals(other){return other&&other.width===this.width&&other.height===this.height}clone(){return new Size(this.width,this.height)}toArray(digits){const doRound=Object(_util__WEBPACK_IMPORTED_MODULE_2__.a)(digits);return[doRound?Object(_util__WEBPACK_IMPORTED_MODULE_3__.a)(this.width,digits):this.width,doRound?Object(_util__WEBPACK_IMPORTED_MODULE_3__.a)(this.height,digits):this.height]}static create(arg0,arg1){if(Object(_util__WEBPACK_IMPORTED_MODULE_2__.a)(arg0))return arg0 instanceof Size?arg0:1===arguments.length&&2===arg0.length?new Size(arg0[0],arg0[1]):new Size(arg0,arg1)}static get ZERO(){return new Size(0,0)}}__webpack_exports__.a=Size},bRfn:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _path_node__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"UzJa\"),_utils_render_path__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"hype\");__webpack_exports__.a=class extends _path_node__WEBPACK_IMPORTED_MODULE_0__.a{renderPoints(ctx){const path=this.srcElement.toPath();Object(_utils_render_path__WEBPACK_IMPORTED_MODULE_1__.a)(ctx,path)}}},bSS5:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _class__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"LHUb\");function isFunction(value){return\"function\"==typeof value}function getArray(value){return\"string\"==typeof value?[value]:value}function preventDefault(){this._defaultPrevented=!0}function isDefaultPrevented(){return!0===this._defaultPrevented}__webpack_exports__.a=class extends _class__WEBPACK_IMPORTED_MODULE_0__.a{constructor(){super(),this._events={}}bind(eventName,handlers,one){const eventNames=getArray(eventName),handlersIsFunction=isFunction(handlers),length=eventNames.length;if(void 0===handlers){for(let field in eventName)this.bind(field,eventName[field]);return this}for(let idx=0;idx<length;idx++){const eventName=eventNames[idx];let handler=handlersIsFunction?handlers:handlers[eventName];if(handler){if(one){const original=handler;handler=()=>{this.unbind(eventName,handler),original.apply(this,arguments)},handler.original=original}(this._events[eventName]=this._events[eventName]||[]).push(handler)}}return this}one(eventNames,handlers){return this.bind(eventNames,handlers,!0)}first(eventName,handlers){const eventNames=getArray(eventName),handlersIsFunction=isFunction(handlers);for(let idx=0,length=eventNames.length;idx<length;idx++){const eventName=eventNames[idx],handler=handlersIsFunction?handlers:handlers[eventName];handler&&(this._events[eventName]=this._events[eventName]||[]).unshift(handler)}return this}trigger(eventName,e={}){let events=this._events[eventName];if(events){const length=events.length;e.sender=this,e._defaultPrevented=!1,e.preventDefault=preventDefault,e.isDefaultPrevented=isDefaultPrevented,events=events.slice();for(let idx=0;idx<length;idx++)events[idx].call(this,e);return!0===e._defaultPrevented}return!1}unbind(eventName,handler){const events=this._events[eventName];if(void 0===eventName)this._events={};else if(events)if(handler)for(let idx=events.length-1;idx>=0;idx--)events[idx]!==handler&&events[idx].original!==handler||events.splice(idx,1);else this._events[eventName]=[];return this}}},bp4U:function(module,__webpack_exports__,__webpack_require__){\"use strict\";function setAccessor(field){return function(value){return this[field]!==value&&(this[field]=value,this.geometryChange()),this}}function getAccessor(field){return function(){return this[field]}}__webpack_exports__.a=(TBase,names)=>{const result=class extends TBase{};return function(fn,fields){for(let i=0;i<fields.length;i++){let name=fields[i],capitalized=name.charAt(0).toUpperCase()+name.substring(1,name.length);fn[\"set\"+capitalized]=setAccessor(name),fn[\"get\"+capitalized]=getAccessor(name)}}(result.prototype,names),result}},dH2W:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return eventCoordinates});var _defined__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"VqL+\");function eventCoordinates(e){return Object(_defined__WEBPACK_IMPORTED_MODULE_0__.a)((e.x||{}).location)?{x:e.x.location,y:e.y.location}:{x:e.pageX||e.clientX||0,y:e.pageY||e.clientY||0}}},dsTk:function(module,__webpack_exports__,__webpack_require__){\"use strict\";function createPromise(){let resolveFn,rejectFn;const promise=new Promise((resolve,reject)=>{resolveFn=data=>(promise._state=\"resolved\",resolve(data),promise),rejectFn=data=>(promise._state=\"rejected\",reject(data),promise)});return promise._state=\"pending\",promise.resolve=resolveFn,promise.reject=rejectFn,promise.state=()=>promise._state,promise}__webpack_require__.d(__webpack_exports__,\"a\",function(){return createPromise})},e5dn:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var shapes_group=__webpack_require__(\"qUqW\"),geometry_size=__webpack_require__(\"ZfP6\"),geometry_rect=__webpack_require__(\"XJRY\"),point=__webpack_require__(\"lRJa\"),geometry_transform=__webpack_require__(\"uBxF\"),translate_to_point=__webpack_require__(\"pVqk\"),align_start=__webpack_require__(\"5Jba\");function alignStartReverse(size,rect,align,axis,sizeField){let start;return start=\"start\"===align?rect.origin[axis]+rect.size[sizeField]-size:\"end\"===align?rect.origin[axis]:rect.origin[axis]+(rect.size[sizeField]-size)/2,start}const DEFAULT_OPTIONS={alignContent:\"start\",justifyContent:\"start\",alignItems:\"start\",spacing:0,orientation:\"horizontal\",lineSpacing:0,wrap:!0,revers:!1},forEach=(elements,callback)=>{elements.forEach(callback)},forEachReverse=(elements,callback)=>{for(let idx=elements.length-1;idx>=0;idx--)callback(elements[idx],idx)};__webpack_exports__.a=class extends shapes_group.a{constructor(rect,options){super(Object.assign({},DEFAULT_OPTIONS,options)),this._rect=rect,this._fieldMap={}}rect(value){return value?(this._rect=value,this):this._rect}_initMap(){const options=this.options,fieldMap=this._fieldMap;\"horizontal\"===options.orientation?(fieldMap.sizeField=\"width\",fieldMap.groupsSizeField=\"height\",fieldMap.groupAxis=\"x\",fieldMap.groupsAxis=\"y\"):(fieldMap.sizeField=\"height\",fieldMap.groupsSizeField=\"width\",fieldMap.groupAxis=\"y\",fieldMap.groupsAxis=\"x\"),options.reverse?(this.forEach=forEachReverse,this.justifyAlign=alignStartReverse):(this.forEach=forEach,this.justifyAlign=align_start.a)}reflow(){if(!this._rect||0===this.children.length)return;this._initMap(),this.options.transform&&this.transform(null);const options=this.options,rect=this._rect,{groups:groups,groupsSize:groupsSize}=this._initGroups(),{sizeField:sizeField,groupsSizeField:groupsSizeField,groupAxis:groupAxis,groupsAxis:groupsAxis}=this._fieldMap,groupOrigin=new point.a,elementOrigin=new point.a,size=new geometry_size.a;let elementStart,group,groupBox,groupStart=Object(align_start.a)(groupsSize,rect,options.alignContent,groupsAxis,groupsSizeField);const arrangeElements=(bbox,idx)=>{const element=group.elements[idx];elementOrigin[groupAxis]=elementStart,elementOrigin[groupsAxis]=Object(align_start.a)(bbox.size[groupsSizeField],groupBox,options.alignItems,groupsAxis,groupsSizeField),Object(translate_to_point.a)(elementOrigin,bbox,element),elementStart+=bbox.size[sizeField]+options.spacing};for(let groupIdx=0;groupIdx<groups.length;groupIdx++)group=groups[groupIdx],groupOrigin[groupAxis]=elementStart=this.justifyAlign(group.size,rect,options.justifyContent,groupAxis,sizeField),groupOrigin[groupsAxis]=groupStart,size[sizeField]=group.size,size[groupsSizeField]=group.lineSize,groupBox=new geometry_rect.a(groupOrigin,size),this.forEach(group.bboxes,arrangeElements),groupStart+=group.lineSize+options.lineSpacing;if(!options.wrap&&group.size>rect.size[sizeField]){const scale=rect.size[sizeField]/groupBox.size[sizeField],scaledStart=groupBox.topLeft().scale(scale,scale),scaledSize=groupBox.size[groupsSizeField]*scale,newStart=Object(align_start.a)(scaledSize,rect,options.alignContent,groupsAxis,groupsSizeField),transform=Object(geometry_transform.a)();\"x\"===groupAxis?transform.translate(rect.origin.x-scaledStart.x,newStart-scaledStart.y):transform.translate(newStart-scaledStart.x,rect.origin.y-scaledStart.y),transform.scale(scale,scale),this.transform(transform)}}_initGroups(){const{options:options,children:children}=this,{lineSpacing:lineSpacing,wrap:wrap,spacing:spacing}=options,sizeField=this._fieldMap.sizeField;let group=this._newGroup();const groups=[],addGroup=function(){groups.push(group),groupsSize+=group.lineSize+lineSpacing};let groupsSize=-lineSpacing;for(let idx=0;idx<children.length;idx++){let element=children[idx],bbox=children[idx].clippedBBox();element.visible()&&bbox&&(wrap&&group.size+bbox.size[sizeField]+spacing>this._rect.size[sizeField]?0===group.bboxes.length?(this._addToGroup(group,bbox,element),addGroup(),group=this._newGroup()):(addGroup(),group=this._newGroup(),this._addToGroup(group,bbox,element)):this._addToGroup(group,bbox,element))}return group.bboxes.length&&addGroup(),{groups:groups,groupsSize:groupsSize}}_addToGroup(group,bbox,element){group.size+=bbox.size[this._fieldMap.sizeField]+this.options.spacing,group.lineSize=Math.max(bbox.size[this._fieldMap.groupsSizeField],group.lineSize),group.bboxes.push(bbox),group.elements.push(element)}_newGroup(){return{lineSize:0,size:-this.options.spacing,bboxes:[],elements:[]}}}},eMc0:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return exportGroup});var _root_node__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"wJcK\"),_shapes__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"qUqW\"),_geometry__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"uBxF\"),_constants__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(\"V34t\");function exportGroup(group){const root=new _root_node__WEBPACK_IMPORTED_MODULE_0__.a({skipBaseHref:!0}),bbox=group.clippedBBox();let rootGroup=group;if(bbox){const origin=bbox.getOrigin(),exportRoot=new _shapes__WEBPACK_IMPORTED_MODULE_1__.a;exportRoot.transform(Object(_geometry__WEBPACK_IMPORTED_MODULE_2__.a)().translate(-origin.x,-origin.y)),exportRoot.children.push(group),rootGroup=exportRoot}root.load([rootGroup]);const svg=`<?xml version='1.0' ?><svg xmlns='${_constants__WEBPACK_IMPORTED_MODULE_3__.b}' xmlns:xlink='http://www.w3.org/1999/xlink' version='1.1'>${root.render()}</svg>`;return root.destroy(),svg}},eO0B:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return exportSVG});var _util__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"iYt6\"),_util__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"dsTk\"),_export_group__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"eMc0\");function exportSVG(group,options){let svg=Object(_export_group__WEBPACK_IMPORTED_MODULE_2__.a)(group);return options&&options.raw||(svg=\"data:image/svg+xml;base64,\"+Object(_util__WEBPACK_IMPORTED_MODULE_0__.a)(svg)),Object(_util__WEBPACK_IMPORTED_MODULE_1__.a)().resolve(svg)}},f4aR:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return close});var _constants__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"TD7o\"),_util__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"RlWg\");function close(a,b,tolerance=_constants__WEBPACK_IMPORTED_MODULE_0__.a){return 0===Object(_util__WEBPACK_IMPORTED_MODULE_1__.a)(Math.abs(a-b),tolerance)}},fdcc:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_exports__.a=(TBase,childrenField)=>class extends TBase{traverse(callback){const children=this[childrenField];for(let i=0;i<children.length;i++){let child=children[i];child.traverse?child.traverse(callback):callback(child)}return this}}},gNPy:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _node__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"7Prh\");__webpack_exports__.a=class extends _node__WEBPACK_IMPORTED_MODULE_0__.a{constructor(srcElement){super(),this.srcElement=srcElement,this.id=srcElement.id,this.load([srcElement])}template(){return`<clipPath id='${this.id}'>${this.renderChildren()}</clipPath>`}}},gQeN:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_exports__.a={}},gofQ:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _core_has_observers__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"7joe\"),_to_matrix__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"x/GK\"),_matrix__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"hL34\"),_point__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(\"lRJa\");class Transformation extends _core_has_observers__WEBPACK_IMPORTED_MODULE_0__.a{constructor(matrix=_matrix__WEBPACK_IMPORTED_MODULE_2__.a.unit()){super(),this._matrix=matrix}clone(){return new Transformation(this._matrix.clone())}equals(other){return other&&other._matrix.equals(this._matrix)}translate(x,y){return this._matrix=this._matrix.multiplyCopy(_matrix__WEBPACK_IMPORTED_MODULE_2__.a.translate(x,y)),this._optionsChange(),this}scale(scaleX,scaleY=scaleX,origin=null){let originPoint=origin;return originPoint&&(originPoint=_point__WEBPACK_IMPORTED_MODULE_3__.a.create(originPoint),this._matrix=this._matrix.multiplyCopy(_matrix__WEBPACK_IMPORTED_MODULE_2__.a.translate(originPoint.x,originPoint.y))),this._matrix=this._matrix.multiplyCopy(_matrix__WEBPACK_IMPORTED_MODULE_2__.a.scale(scaleX,scaleY)),originPoint&&(this._matrix=this._matrix.multiplyCopy(_matrix__WEBPACK_IMPORTED_MODULE_2__.a.translate(-originPoint.x,-originPoint.y))),this._optionsChange(),this}rotate(angle,origin){const originPoint=_point__WEBPACK_IMPORTED_MODULE_3__.a.create(origin)||_point__WEBPACK_IMPORTED_MODULE_3__.a.ZERO;return this._matrix=this._matrix.multiplyCopy(_matrix__WEBPACK_IMPORTED_MODULE_2__.a.rotate(angle,originPoint.x,originPoint.y)),this._optionsChange(),this}multiply(transformation){const matrix=Object(_to_matrix__WEBPACK_IMPORTED_MODULE_1__.a)(transformation);return this._matrix=this._matrix.multiplyCopy(matrix),this._optionsChange(),this}matrix(value){return value?(this._matrix=value,this._optionsChange(),this):this._matrix}_optionsChange(){this.optionsChange({field:\"transform\",value:this})}}__webpack_exports__.a=Transformation},hL34:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _common__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"LHUb\"),_util_defined__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"VqL+\"),_util_rad__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"6USk\"),_util_round__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(\"RlWg\");__webpack_exports__.a=(()=>{class Matrix extends _common__WEBPACK_IMPORTED_MODULE_0__.a{constructor(a=0,b=0,c=0,d=0,e=0,f=0){super(),this.a=a,this.b=b,this.c=c,this.d=d,this.e=e,this.f=f}multiplyCopy(matrix){return new Matrix(this.a*matrix.a+this.c*matrix.b,this.b*matrix.a+this.d*matrix.b,this.a*matrix.c+this.c*matrix.d,this.b*matrix.c+this.d*matrix.d,this.a*matrix.e+this.c*matrix.f+this.e,this.b*matrix.e+this.d*matrix.f+this.f)}invert(){const{a:a,b:b,c:d,d:e,e:g,f:h}=this,det=a*e-b*d;return 0===det?null:new Matrix(e/det,-b/det,-d/det,a/det,(d*h-e*g)/det,(b*g-a*h)/det)}clone(){return new Matrix(this.a,this.b,this.c,this.d,this.e,this.f)}equals(other){return!!other&&this.a===other.a&&this.b===other.b&&this.c===other.c&&this.d===other.d&&this.e===other.e&&this.f===other.f}round(precision){return this.a=Object(_util_round__WEBPACK_IMPORTED_MODULE_3__.a)(this.a,precision),this.b=Object(_util_round__WEBPACK_IMPORTED_MODULE_3__.a)(this.b,precision),this.c=Object(_util_round__WEBPACK_IMPORTED_MODULE_3__.a)(this.c,precision),this.d=Object(_util_round__WEBPACK_IMPORTED_MODULE_3__.a)(this.d,precision),this.e=Object(_util_round__WEBPACK_IMPORTED_MODULE_3__.a)(this.e,precision),this.f=Object(_util_round__WEBPACK_IMPORTED_MODULE_3__.a)(this.f,precision),this}toArray(precision){const result=[this.a,this.b,this.c,this.d,this.e,this.f];if(Object(_util_defined__WEBPACK_IMPORTED_MODULE_1__.a)(precision))for(let i=0;i<result.length;i++)result[i]=Object(_util_round__WEBPACK_IMPORTED_MODULE_3__.a)(result[i],precision);return result}toString(precision,separator=\",\"){return this.toArray(precision).join(separator)}static translate(x,y){return new Matrix(1,0,0,1,x,y)}static unit(){return new Matrix(1,0,0,1,0,0)}static rotate(angle,x,y){const matrix=new Matrix;return matrix.a=Math.cos(Object(_util_rad__WEBPACK_IMPORTED_MODULE_2__.a)(angle)),matrix.b=Math.sin(Object(_util_rad__WEBPACK_IMPORTED_MODULE_2__.a)(angle)),matrix.c=-matrix.b,matrix.d=matrix.a,matrix.e=x-x*matrix.a+y*matrix.b||0,matrix.f=y-y*matrix.a-x*matrix.b||0,matrix}static scale(scaleX,scaleY){return new Matrix(scaleX,0,0,scaleY,0,0)}}return Matrix.IDENTITY=Matrix.unit(),Matrix})()},hSuW:function(module,__webpack_exports__,__webpack_require__){\"use strict\";const now=Date.now||function(){return(new Date).getTime()};__webpack_exports__.a=now},hype:function(module,__webpack_exports__,__webpack_require__){\"use strict\";function renderPath(ctx,path){const segments=path.segments;if(0===segments.length)return;let segment=segments[0],anchor=segment.anchor();ctx.moveTo(anchor.x,anchor.y);for(let i=1;i<segments.length;i++){segment=segments[i],anchor=segment.anchor();let prevOut=segments[i-1].controlOut(),controlIn=segment.controlIn();prevOut&&controlIn?ctx.bezierCurveTo(prevOut.x,prevOut.y,controlIn.x,controlIn.y,anchor.x,anchor.y):ctx.lineTo(anchor.x,anchor.y)}path.options.closed&&ctx.closePath()}__webpack_require__.d(__webpack_exports__,\"a\",function(){return renderPath})},i9ZU:function(module,__webpack_exports__,__webpack_require__){\"use strict\";function append(first,second){return first.push.apply(first,second),first}__webpack_require__.d(__webpack_exports__,\"a\",function(){return append})},iYt6:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return encodeBase64});const fromCharCode=String.fromCharCode,KEY_STR=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";function encodeBase64(input){let output=\"\",i=0;const utfInput=function(input){let output=\"\";for(let i=0;i<input.length;i++){let code=input.charCodeAt(i);if(55296<=code&&code<=56319){const hi=code,low=input.charCodeAt(++i);isNaN(low)||(code=1024*(hi-55296)+(low-56320)+65536)}code<128?output+=fromCharCode(code):code<2048?(output+=fromCharCode(192|code>>>6),output+=fromCharCode(128|63&code)):code<65536?(output+=fromCharCode(224|code>>>12),output+=fromCharCode(128|code>>>6&63),output+=fromCharCode(128|63&code)):code<1114111&&(output+=fromCharCode(240|code>>>18),output+=fromCharCode(128|code>>>12&63),output+=fromCharCode(128|code>>>6&63),output+=fromCharCode(128|63&code))}return output}(input);for(;i<utfInput.length;){let chr1=utfInput.charCodeAt(i++),chr2=utfInput.charCodeAt(i++),chr3=utfInput.charCodeAt(i++),enc1=chr1>>2,enc2=(3&chr1)<<4|chr2>>4,enc3=(15&chr2)<<2|chr3>>6,enc4=63&chr3;isNaN(chr2)?enc3=enc4=64:isNaN(chr3)&&(enc4=64),output=output+KEY_STR.charAt(enc1)+KEY_STR.charAt(enc2)+KEY_STR.charAt(enc3)+KEY_STR.charAt(enc4)}return output}},ijzS:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _path_node__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"UzJa\"),_util__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"dsTk\");__webpack_exports__.a=class extends _path_node__WEBPACK_IMPORTED_MODULE_0__.a{constructor(srcElement,cors){super(srcElement),this.onLoad=this.onLoad.bind(this),this.onError=this.onError.bind(this),this.loading=Object(_util__WEBPACK_IMPORTED_MODULE_1__.a)();const img=this.img=new Image;cors&&!/^data:/i.test(srcElement.src())&&(img.crossOrigin=cors),img.src=srcElement.src(),img.complete?this.onLoad():(img.onload=this.onLoad,img.onerror=this.onError)}renderTo(ctx){\"resolved\"===this.loading.state()&&(ctx.save(),this.setTransform(ctx),this.setClip(ctx),this.drawImage(ctx),ctx.restore())}optionsChange(e){\"src\"===e.field?(this.loading=Object(_util__WEBPACK_IMPORTED_MODULE_1__.a)(),this.img.src=this.srcElement.src()):super.optionsChange(e)}onLoad(){this.loading.resolve(),this.invalidate()}onError(){this.loading.reject(new Error(\"Unable to load image '\"+this.img.src+\"'. Check for connectivity and verify CORS headers.\"))}drawImage(ctx){const rect=this.srcElement.rect(),topLeft=rect.topLeft();ctx.drawImage(this.img,topLeft.x,topLeft.y,rect.width(),rect.height())}}},inPS:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _gradient_node__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"7PhV\");__webpack_exports__.a=class extends _gradient_node__WEBPACK_IMPORTED_MODULE_0__.a{template(){return`<radialGradient id='${this.id}' ${this.renderCoordinates()}>${this.renderChildren()}</radialGradient>`}mapCoordinates(){const srcElement=this.srcElement,center=srcElement.center(),radius=srcElement.radius();return[[\"cx\",center.x],[\"cy\",center.y],[\"r\",radius],this.mapSpace()]}}},jQ5i:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _lru_cache__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"kTcp\"),_common__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"LHUb\"),_util__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"C91f\");const DEFAULT_OPTIONS={baselineMarkerSize:1};let defaultMeasureBox;\"undefined\"!=typeof document&&(defaultMeasureBox=document.createElement(\"div\"),defaultMeasureBox.style.cssText=\"position: absolute !important; top: -4000px !important; width: auto !important; height: auto !important;padding: 0 !important; margin: 0 !important; border: 0 !important;line-height: normal !important; visibility: hidden !important; white-space: pre!important;\"),__webpack_exports__.a=(()=>{class TextMetrics extends _common__WEBPACK_IMPORTED_MODULE_1__.a{constructor(options){super(),this._cache=new _lru_cache__WEBPACK_IMPORTED_MODULE_0__.a(1e3),this.options=Object.assign({},DEFAULT_OPTIONS,options)}measure(text,style,options={}){if(null==text)return{width:0,height:0,baseline:0};const styleKey=Object(_util__WEBPACK_IMPORTED_MODULE_2__.c)(style),cacheKey=Object(_util__WEBPACK_IMPORTED_MODULE_2__.a)(text+styleKey),cachedResult=this._cache.get(cacheKey);if(cachedResult)return cachedResult;const size={width:0,height:0,baseline:0},measureBox=options.box||defaultMeasureBox,baselineMarker=this._baselineMarker().cloneNode(!1);for(let key in style){let value=style[key];void 0!==value&&(measureBox.style[key]=value)}const textStr=!1!==options.normalizeText?Object(_util__WEBPACK_IMPORTED_MODULE_2__.b)(text):String(text);return measureBox.textContent=textStr,measureBox.appendChild(baselineMarker),document.body.appendChild(measureBox),textStr.length&&(size.width=measureBox.offsetWidth-this.options.baselineMarkerSize,size.height=measureBox.offsetHeight,size.baseline=baselineMarker.offsetTop+this.options.baselineMarkerSize),size.width>0&&size.height>0&&this._cache.put(cacheKey,size),measureBox.parentNode.removeChild(measureBox),size}_baselineMarker(){const marker=document.createElement(\"div\");return marker.style.cssText=\"display: inline-block; vertical-align: baseline;width: \"+this.options.baselineMarkerSize+\"px; height: \"+this.options.baselineMarkerSize+\"px;overflow: hidden;\",marker}}return TextMetrics.current=new TextMetrics,TextMetrics})()},kGoT:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var surface=__webpack_require__(\"mcME\"),element_size=__webpack_require__(\"wd4i\"),bind_events=__webpack_require__(\"APnZ\"),unbind_events=__webpack_require__(\"Aie7\"),create_promise=__webpack_require__(\"dsTk\"),promise_all=__webpack_require__(\"Z3TV\"),root_node=__webpack_require__(\"Ytya\"),shapes_quad_tree=__webpack_require__(\"5FN0\"),defined=__webpack_require__(\"VqL+\"),arc_node=__webpack_require__(\"bRfn\"),circle_node=__webpack_require__(\"FSED\"),group_node=__webpack_require__(\"xYjD\"),image_node=__webpack_require__(\"ijzS\"),multi_path_node=__webpack_require__(\"5HPa\"),path_node=__webpack_require__(\"UzJa\"),rect_node=__webpack_require__(\"SMq3\"),text_node=__webpack_require__(\"G/KS\"),node_map=__webpack_require__(\"gQeN\");node_map.a.Arc=arc_node.a,node_map.a.Circle=circle_node.a,node_map.a.Group=group_node.a,node_map.a.Image=image_node.a,node_map.a.MultiPath=multi_path_node.a,node_map.a.Path=path_node.a,node_map.a.Rect=rect_node.a,node_map.a.Text=text_node.a,__webpack_exports__.a=class extends surface.a{get type(){return\"canvas\"}constructor(element,options){super(element,options),this.element.innerHTML=this._template(this);const canvas=this.element.firstElementChild,size=Object(element_size.a)(element);canvas.width=size.width,canvas.height=size.height,this._rootElement=canvas,this._root=new root_node.a(canvas,size),this._mouseTrackHandler=this._trackMouse.bind(this),Object(bind_events.a)(this.element,{click:this._mouseTrackHandler,mousemove:this._mouseTrackHandler})}destroy(){super.destroy(),this._root&&(this._root.destroy(),this._root=null),this._searchTree&&(this._searchTree.clear(),delete this._searchTree),this._cursor&&(this._cursor.destroy(),delete this._cursor),Object(unbind_events.a)(this.element,{click:this._mouseTrackHandler,mousemove:this._mouseTrackHandler})}draw(element){super.draw(element),this._root.load([element],void 0,this.options.cors),this._searchTree&&this._searchTree.add([element])}clear(){super.clear(),this._root.clear(),this._searchTree&&this._searchTree.clear(),this._cursor&&this._cursor.clear()}eventTarget(e){if(this._searchTree){const point=this._surfacePoint(e);return this._searchTree.pointShape(point)}}image(){const{_root:root,_rootElement:rootElement}=this,loadingStates=[];root.traverse(childNode=>{childNode.loading&&loadingStates.push(childNode.loading)});const promise=Object(create_promise.a)(),resolveDataURL=()=>{root._invalidate({fixedScale:!0});try{const data=rootElement.toDataURL();promise.resolve(data)}catch(e){promise.reject(e)}};return Object(promise_all.a)(loadingStates).then(resolveDataURL,resolveDataURL),promise}suspendTracking(){super.suspendTracking(),this._searchTree&&(this._searchTree.clear(),delete this._searchTree)}resumeTracking(){if(super.resumeTracking(),!this._searchTree){this._searchTree=new shapes_quad_tree.a;const childNodes=this._root.childNodes,rootElements=[];for(let idx=0;idx<childNodes.length;idx++)rootElements.push(childNodes[idx].srcElement);this._searchTree.add(rootElements)}}_resize(){this._rootElement.width=this._size.width,this._rootElement.height=this._size.height,this._root.size=this._size,this._root.invalidate()}_template(){return\"<canvas style='width: 100%; height: 100%;'></canvas>\"}_enableTracking(){this._searchTree=new shapes_quad_tree.a,this._cursor=new class{constructor(surface){surface.bind(\"mouseenter\",this._mouseenter.bind(this)),surface.bind(\"mouseleave\",this._mouseleave.bind(this)),this.element=surface.element}clear(){this._resetCursor()}destroy(){this._resetCursor(),delete this.element}_mouseenter(e){const cursor=this._shapeCursor(e);cursor?(this._current||(this._defaultCursor=this._getCursor()),this._setCursor(cursor)):this._resetCursor()}_mouseleave(){this._resetCursor()}_shapeCursor(e){let shape=e.element;for(;shape&&!Object(defined.a)(shape.options.cursor);)shape=shape.parent;if(shape)return shape.options.cursor}_getCursor(){if(this.element)return this.element.style.cursor}_setCursor(cursor){this.element&&(this.element.style.cursor=cursor,this._current=cursor)}_resetCursor(){this._current&&(this._setCursor(this._defaultCursor||\"\"),delete this._current)}}(this),super._enableTracking()}_trackMouse(e){if(this._suspendedTracking)return;const shape=this.eventTarget(e);if(\"click\"!==e.type){const currentShape=this._currentShape;currentShape&&currentShape!==shape&&this.trigger(\"mouseleave\",{element:currentShape,originalEvent:e,type:\"mouseleave\"}),shape&&currentShape!==shape&&this.trigger(\"mouseenter\",{element:shape,originalEvent:e,type:\"mouseenter\"}),this.trigger(\"mousemove\",{element:shape,originalEvent:e,type:\"mousemove\"}),this._currentShape=shape}else shape&&this.trigger(\"click\",{element:shape,originalEvent:e,type:\"click\"})}}},kTcp:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _common__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"LHUb\");__webpack_exports__.a=class extends _common__WEBPACK_IMPORTED_MODULE_0__.a{constructor(size){super(),this._size=size,this._length=0,this._map={}}put(key,value){const map=this._map,entry={key:key,value:value};map[key]=entry,this._head?(this._tail.newer=entry,entry.older=this._tail,this._tail=entry):this._head=this._tail=entry,this._length>=this._size?(map[this._head.key]=null,this._head=this._head.newer,this._head.older=null):this._length++}get(key){const entry=this._map[key];if(entry)return entry===this._head&&entry!==this._tail&&(this._head=entry.newer,this._head.older=null),entry!==this._tail&&(entry.older&&(entry.older.newer=entry.newer,entry.newer.older=entry.older),entry.older=this._tail,entry.newer=null,this._tail.newer=entry,this._tail=entry),entry.value}}},\"l/PP\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";function logToConsole(message){const console=window.console;void 0!==console&&console.log&&console.log(message)}__webpack_require__.d(__webpack_exports__,\"a\",function(){return logToConsole})},lRJa:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _mixins_with_accessors__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"bp4U\"),_core_has_observers__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"7joe\"),_util__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"RlWg\"),_util__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(\"VqL+\"),_util__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(\"2Ic7\"),_matrix__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__(\"hL34\"),_to_matrix__WEBPACK_IMPORTED_MODULE_6__=__webpack_require__(\"x/GK\");class Point extends(Object(_mixins_with_accessors__WEBPACK_IMPORTED_MODULE_0__.a)(_core_has_observers__WEBPACK_IMPORTED_MODULE_1__.a,[\"x\",\"y\"])){constructor(x,y){super(),this.x=x||0,this.y=y||0}equals(other){return other&&other.x===this.x&&other.y===this.y}clone(){return new Point(this.x,this.y)}rotate(angle,origin){const originPoint=Point.create(origin)||Point.ZERO;return this.transform(_matrix__WEBPACK_IMPORTED_MODULE_5__.a.rotate(angle,originPoint.x,originPoint.y))}translate(x,y){return this.x+=x,this.y+=y,this.geometryChange(),this}translateWith(point){return this.translate(point.x,point.y)}move(x,y){return this.x=this.y=0,this.translate(x,y)}scale(scaleX,scaleY=scaleX){return this.x*=scaleX,this.y*=scaleY,this.geometryChange(),this}scaleCopy(scaleX,scaleY){return this.clone().scale(scaleX,scaleY)}transform(transformation){const matrix=Object(_to_matrix__WEBPACK_IMPORTED_MODULE_6__.a)(transformation),{x:x,y:y}=this;return this.x=matrix.a*x+matrix.c*y+matrix.e,this.y=matrix.b*x+matrix.d*y+matrix.f,this.geometryChange(),this}transformCopy(transformation){const point=this.clone();return transformation&&point.transform(transformation),point}distanceTo(point){const dx=this.x-point.x,dy=this.y-point.y;return Math.sqrt(dx*dx+dy*dy)}round(digits){return this.x=Object(_util__WEBPACK_IMPORTED_MODULE_2__.a)(this.x,digits),this.y=Object(_util__WEBPACK_IMPORTED_MODULE_2__.a)(this.y,digits),this.geometryChange(),this}toArray(digits){const doRound=Object(_util__WEBPACK_IMPORTED_MODULE_3__.a)(digits);return[doRound?Object(_util__WEBPACK_IMPORTED_MODULE_2__.a)(this.x,digits):this.x,doRound?Object(_util__WEBPACK_IMPORTED_MODULE_2__.a)(this.y,digits):this.y]}toString(digits,separator=\" \"){let{x:x,y:y}=this;return Object(_util__WEBPACK_IMPORTED_MODULE_3__.a)(digits)&&(x=Object(_util__WEBPACK_IMPORTED_MODULE_2__.a)(x,digits),y=Object(_util__WEBPACK_IMPORTED_MODULE_2__.a)(y,digits)),x+separator+y}static create(arg0,arg1){if(Object(_util__WEBPACK_IMPORTED_MODULE_3__.a)(arg0))return arg0 instanceof Point?arg0:1===arguments.length&&2===arg0.length?new Point(arg0[0],arg0[1]):new Point(arg0,arg1)}static min(){let minX=_util__WEBPACK_IMPORTED_MODULE_4__.b,minY=_util__WEBPACK_IMPORTED_MODULE_4__.b;for(let i=0;i<arguments.length;i++){let point=arguments[i];minX=Math.min(point.x,minX),minY=Math.min(point.y,minY)}return new Point(minX,minY)}static max(){let maxX=_util__WEBPACK_IMPORTED_MODULE_4__.c,maxY=_util__WEBPACK_IMPORTED_MODULE_4__.c;for(let i=0;i<arguments.length;i++){const point=arguments[i];maxX=Math.max(point.x,maxX),maxY=Math.max(point.y,maxY)}return new Point(maxX,maxY)}static minPoint(){return new Point(_util__WEBPACK_IMPORTED_MODULE_4__.c,_util__WEBPACK_IMPORTED_MODULE_4__.c)}static maxPoint(){return new Point(_util__WEBPACK_IMPORTED_MODULE_4__.b,_util__WEBPACK_IMPORTED_MODULE_4__.b)}static get ZERO(){return new Point(0,0)}}__webpack_exports__.a=Point},mcME:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _shapes_group__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"qUqW\"),_geometry_point__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"lRJa\"),_common__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"bSS5\"),_util__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(\"wd4i\"),_util__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(\"IU+O\"),_util__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__(\"DPs4\"),_util__WEBPACK_IMPORTED_MODULE_6__=__webpack_require__(\"IsCa\"),_util__WEBPACK_IMPORTED_MODULE_7__=__webpack_require__(\"dH2W\"),_util__WEBPACK_IMPORTED_MODULE_8__=__webpack_require__(\"JZGi\");const events=[\"click\",\"mouseenter\",\"mouseleave\",\"mousemove\",\"resize\"];__webpack_exports__.a=class extends _common__WEBPACK_IMPORTED_MODULE_2__.a{constructor(element,options){super(),this.options=Object.assign({},options),this.element=element,this.element._kendoExportVisual=this.exportVisual.bind(this),this._click=this._handler(\"click\"),this._mouseenter=this._handler(\"mouseenter\"),this._mouseleave=this._handler(\"mouseleave\"),this._mousemove=this._handler(\"mousemove\"),this._visual=new _shapes_group__WEBPACK_IMPORTED_MODULE_0__.a,Object(_util__WEBPACK_IMPORTED_MODULE_3__.a)(element,this.options),this.bind(events,this.options),this._enableTracking()}draw(element){this._visual.children.push(element)}clear(){this._visual.children=[]}destroy(){this._visual=null,this.element._kendoExportVisual=null,this.unbind()}eventTarget(e){let node,domNode=Object(_util__WEBPACK_IMPORTED_MODULE_4__.a)(e);for(;!node&&domNode&&(node=domNode._kendoNode,domNode!==this.element);)domNode=domNode.parentElement;if(node)return node.srcElement}exportVisual(){return this._visual}getSize(){return Object(_util__WEBPACK_IMPORTED_MODULE_3__.a)(this.element)}currentSize(size){if(!size)return this._size;this._size=size}setSize(size){Object(_util__WEBPACK_IMPORTED_MODULE_3__.a)(this.element,size),this.currentSize(size),this._resize()}resize(force){const size=this.getSize(),currentSize=this.currentSize();(force||(size.width>0||size.height>0)&&(!currentSize||size.width!==currentSize.width||size.height!==currentSize.height))&&(this.currentSize(size),this._resize(size,force),this.trigger(\"resize\",size))}size(value){if(!value)return this.getSize();this.setSize(value)}suspendTracking(){this._suspendedTracking=!0}resumeTracking(){this._suspendedTracking=!1}_enableTracking(){}_resize(){}_handler(eventName){return e=>{const node=this.eventTarget(e);node&&!this._suspendedTracking&&this.trigger(eventName,{element:node,originalEvent:e,type:eventName})}}_elementOffset(){const element=this.element,padding=Object(_util__WEBPACK_IMPORTED_MODULE_5__.a)(element),{left:left,top:top}=Object(_util__WEBPACK_IMPORTED_MODULE_6__.a)(element);return{left:left+padding.left,top:top+padding.top}}_surfacePoint(e){const offset=this._elementOffset(),coord=Object(_util__WEBPACK_IMPORTED_MODULE_7__.a)(e),x=coord.x-offset.left,y=coord.y-offset.top,inverseTransform=Object(_util__WEBPACK_IMPORTED_MODULE_8__.a)(this.element).invert();return new _geometry_point__WEBPACK_IMPORTED_MODULE_1__.a(x,y).transform(inverseTransform)}}},mjA8:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.r(__webpack_exports__);var _geometry_circle__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"BIVv\");__webpack_require__.d(__webpack_exports__,\"Circle\",function(){return _geometry_circle__WEBPACK_IMPORTED_MODULE_0__.a});var _geometry_arc__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"HKF7\");__webpack_require__.d(__webpack_exports__,\"Arc\",function(){return _geometry_arc__WEBPACK_IMPORTED_MODULE_1__.a});var _geometry_rect__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"XJRY\");__webpack_require__.d(__webpack_exports__,\"Rect\",function(){return _geometry_rect__WEBPACK_IMPORTED_MODULE_2__.a});var _geometry_point__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(\"lRJa\");__webpack_require__.d(__webpack_exports__,\"Point\",function(){return _geometry_point__WEBPACK_IMPORTED_MODULE_3__.a});var _geometry_segment__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(\"63qr\");__webpack_require__.d(__webpack_exports__,\"Segment\",function(){return _geometry_segment__WEBPACK_IMPORTED_MODULE_4__.a});var _geometry_matrix__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__(\"hL34\");__webpack_require__.d(__webpack_exports__,\"Matrix\",function(){return _geometry_matrix__WEBPACK_IMPORTED_MODULE_5__.a});var _geometry_size__WEBPACK_IMPORTED_MODULE_6__=__webpack_require__(\"ZfP6\");__webpack_require__.d(__webpack_exports__,\"Size\",function(){return _geometry_size__WEBPACK_IMPORTED_MODULE_6__.a});var _geometry_to_matrix__WEBPACK_IMPORTED_MODULE_7__=__webpack_require__(\"x/GK\");__webpack_require__.d(__webpack_exports__,\"toMatrix\",function(){return _geometry_to_matrix__WEBPACK_IMPORTED_MODULE_7__.a});var _geometry_transformation__WEBPACK_IMPORTED_MODULE_8__=__webpack_require__(\"gofQ\");__webpack_require__.d(__webpack_exports__,\"Transformation\",function(){return _geometry_transformation__WEBPACK_IMPORTED_MODULE_8__.a});var _geometry_transform__WEBPACK_IMPORTED_MODULE_9__=__webpack_require__(\"uBxF\");__webpack_require__.d(__webpack_exports__,\"transform\",function(){return _geometry_transform__WEBPACK_IMPORTED_MODULE_9__.a})},\"o+K8\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _core_base_node__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"ztN+\"),_node_map__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"gQeN\"),_utils_render_path__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"hype\"),_util__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(\"VqL+\");__webpack_exports__.a=class extends _core_base_node__WEBPACK_IMPORTED_MODULE_0__.a{constructor(srcElement){super(srcElement),srcElement&&this.initClip()}initClip(){const clip=this.srcElement.clip();clip&&(this.clip=clip,clip.addObserver(this))}clear(){this.srcElement&&this.srcElement.removeObserver(this),this.clearClip(),super.clear()}clearClip(){this.clip&&(this.clip.removeObserver(this),delete this.clip)}setClip(ctx){this.clip&&(ctx.beginPath(),Object(_utils_render_path__WEBPACK_IMPORTED_MODULE_2__.a)(ctx,this.clip),ctx.clip())}optionsChange(e){\"clip\"===e.field&&(this.clearClip(),this.initClip()),super.optionsChange(e)}setTransform(ctx){if(this.srcElement){const transform=this.srcElement.transform();transform&&ctx.transform.apply(ctx,transform.matrix().toArray(6))}}loadElements(elements,pos,cors){for(let i=0;i<elements.length;i++){let srcElement=elements[i],children=srcElement.children,childNode=new _node_map__WEBPACK_IMPORTED_MODULE_1__.a[srcElement.nodeType](srcElement,cors);children&&children.length>0&&childNode.load(children,pos,cors),Object(_util__WEBPACK_IMPORTED_MODULE_3__.a)(pos)?this.insertAt(childNode,pos):this.append(childNode)}}load(elements,pos,cors){this.loadElements(elements,pos,cors),this.invalidate()}setOpacity(ctx){if(this.srcElement){const opacity=this.srcElement.opacity();Object(_util__WEBPACK_IMPORTED_MODULE_3__.a)(opacity)&&this.globalAlpha(ctx,opacity)}}globalAlpha(ctx,value){let opactity=value;opactity&&ctx.globalAlpha&&(opactity*=ctx.globalAlpha),ctx.globalAlpha=opactity}visible(){const src=this.srcElement;return!src||src&&!1!==src.options.visible}}},oY8A:function(module,__webpack_exports__,__webpack_require__){\"use strict\";function elementStyles(element,styles){const result={},style=window.getComputedStyle(element)||{},stylesArray=Array.isArray(styles)?styles:[styles];for(let idx=0;idx<stylesArray.length;idx++){let field=stylesArray[idx];result[field]=style[field]}return result}__webpack_require__.d(__webpack_exports__,\"a\",function(){return elementStyles})},om2P:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"d\",function(){return RGB}),__webpack_require__.d(__webpack_exports__,\"a\",function(){return Bytes}),__webpack_require__.d(__webpack_exports__,\"c\",function(){return HSV}),__webpack_require__.d(__webpack_exports__,\"b\",function(){return HSL}),__webpack_require__.d(__webpack_exports__,\"e\",function(){return parseColor});var _class__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"LHUb\"),_support__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"/EQf\"),_named_colors__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"T8t9\");const browser=_support__WEBPACK_IMPORTED_MODULE_1__.a.browser;let matchNamedColor=color=>{const colorNames=Object.keys(_named_colors__WEBPACK_IMPORTED_MODULE_2__.a);colorNames.push(\"transparent\");const regexp=new RegExp(\"^(\"+colorNames.join(\"|\")+\")(\\\\W|$)\",\"i\");return matchNamedColor=color=>regexp.exec(color),regexp.exec(color)};class BaseColor extends _class__WEBPACK_IMPORTED_MODULE_0__.a{constructor(){super()}toHSV(){return this}toRGB(){return this}toHex(){return this.toBytes().toHex()}toBytes(){return this}toCss(){return\"#\"+this.toHex()}toCssRgba(){const rgb=this.toBytes();return`rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${parseFloat(Number(this.a).toFixed(3))})`}toDisplay(){return browser.msie&&browser.version<9?this.toCss():this.toCssRgba()}equals(c){return c===this||null!==c&&this.toCssRgba()===parseColor(c).toCssRgba()}diff(other){if(null===other)return NaN;const c1=this.toBytes(),c2=other.toBytes();return Math.sqrt(Math.pow(.3*(c1.r-c2.r),2)+Math.pow(.59*(c1.g-c2.g),2)+Math.pow(.11*(c1.b-c2.b),2))}clone(){let c=this.toBytes();return c===this&&(c=new Bytes(c.r,c.g,c.b,c.a)),c}}class RGB extends BaseColor{constructor(r,g,b,a){super(),this.r=r,this.g=g,this.b=b,this.a=a}toHSV(){const{r:r,g:g,b:b}=this,min=Math.min(r,g,b),max=Math.max(r,g,b),delta=max-min,v=max;let h,s;return 0===delta?new HSV(0,0,v,this.a):(0!==max?(s=delta/max,h=r===max?(g-b)/delta:g===max?2+(b-r)/delta:4+(r-g)/delta,h*=60,h<0&&(h+=360)):(s=0,h=-1),new HSV(h,s,v,this.a))}toHSL(){const{r:r,g:g,b:b}=this,max=Math.max(r,g,b),min=Math.min(r,g,b);let h,s,l=(max+min)/2;if(max===min)h=s=0;else{const d=max-min;switch(s=l>.5?d/(2-max-min):d/(max+min),max){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4}}return new HSL(60*h,100*s,100*l,this.a)}toBytes(){return new Bytes(255*this.r,255*this.g,255*this.b,this.a)}}class Bytes extends RGB{constructor(r,g,b,a){super(Math.round(r),Math.round(g),Math.round(b),a)}toRGB(){return new RGB(this.r/255,this.g/255,this.b/255,this.a)}toHSV(){return this.toRGB().toHSV()}toHSL(){return this.toRGB().toHSL()}toHex(){return hex(this.r,2)+hex(this.g,2)+hex(this.b,2)}toBytes(){return this}}function hex(n,width,pad=\"0\"){let result=n.toString(16);for(;width>result.length;)result=pad+result;return result}class HSV extends BaseColor{constructor(h,s,v,a){super(),this.h=h,this.s=s,this.v=v,this.a=a}toRGB(){let r,g,b,{h:h,s:s,v:v}=this;if(0===s)r=g=b=v;else{h/=60;const i=Math.floor(h),f=h-i,p=v*(1-s),q=v*(1-s*f),t=v*(1-s*(1-f));switch(i){case 0:r=v,g=t,b=p;break;case 1:r=q,g=v,b=p;break;case 2:r=p,g=v,b=t;break;case 3:r=p,g=q,b=v;break;case 4:r=t,g=p,b=v;break;default:r=v,g=p,b=q}}return new RGB(r,g,b,this.a)}toHSL(){return this.toRGB().toHSL()}toBytes(){return this.toRGB().toBytes()}}class HSL extends BaseColor{constructor(h,s,l,a){super(),this.h=h,this.s=s,this.l=l,this.a=a}toRGB(){let r,g,b,h=this.h/360,s=this.s/100,l=this.l/100;if(0===s)r=g=b=l;else{const q=l<.5?l*(1+s):l+s-l*s,p=2*l-q;r=hue2rgb(p,q,h+1/3),g=hue2rgb(p,q,h),b=hue2rgb(p,q,h-1/3)}return new RGB(r,g,b,this.a)}toHSV(){return this.toRGB().toHSV()}toBytes(){return this.toRGB().toBytes()}}function hue2rgb(p,q,s){let t=s;return t<0&&(t+=1),t>1&&(t-=1),t<1/6?p+6*(q-p)*t:t<.5?q:t<2/3?p+(q-p)*(2/3-t)*6:p}function parseColor(value,safe){let m,ret;if(null==value||\"none\"===value)return null;if(value instanceof BaseColor)return value;let color=value.toLowerCase();if(m=matchNamedColor(color))return color=\"transparent\"===m[1]?new RGB(1,1,1,0):parseColor(_named_colors__WEBPACK_IMPORTED_MODULE_2__.a[m[1]],safe),color.match=[m[1]],color;if((m=/^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})\\b/i.exec(color))?ret=new Bytes(parseInt(m[1],16),parseInt(m[2],16),parseInt(m[3],16),1):(m=/^#?([0-9a-f])([0-9a-f])([0-9a-f])\\b/i.exec(color))?ret=new Bytes(parseInt(m[1]+m[1],16),parseInt(m[2]+m[2],16),parseInt(m[3]+m[3],16),1):(m=/^rgb\\(\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*\\)/.exec(color))?ret=new Bytes(parseInt(m[1],10),parseInt(m[2],10),parseInt(m[3],10),1):(m=/^rgba\\(\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9.]+)\\s*\\)/.exec(color))?ret=new Bytes(parseInt(m[1],10),parseInt(m[2],10),parseInt(m[3],10),parseFloat(m[4])):(m=/^rgb\\(\\s*([0-9]*\\.?[0-9]+)%\\s*,\\s*([0-9]*\\.?[0-9]+)%\\s*,\\s*([0-9]*\\.?[0-9]+)%\\s*\\)/.exec(color))?ret=new RGB(parseFloat(m[1])/100,parseFloat(m[2])/100,parseFloat(m[3])/100,1):(m=/^rgba\\(\\s*([0-9]*\\.?[0-9]+)%\\s*,\\s*([0-9]*\\.?[0-9]+)%\\s*,\\s*([0-9]*\\.?[0-9]+)%\\s*,\\s*([0-9.]+)\\s*\\)/.exec(color))&&(ret=new RGB(parseFloat(m[1])/100,parseFloat(m[2])/100,parseFloat(m[3])/100,parseFloat(m[4]))),ret)ret.match=m;else if(!safe)throw new Error(\"Cannot parse color: \"+color);return ret}},ouFi:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return measureText});var _text_metrics__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"jQ5i\");function measureText(text,style,measureBox){return _text_metrics__WEBPACK_IMPORTED_MODULE_0__.a.current.measure(text,style,measureBox)}},pVqk:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return translateToPoint});var _geometry_transform__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"uBxF\");function translateToPoint(point,bbox,element){const transofrm=element.transform()||Object(_geometry_transform__WEBPACK_IMPORTED_MODULE_0__.a)(),matrix=transofrm.matrix();matrix.e+=point.x-bbox.origin.x,matrix.f+=point.y-bbox.origin.y,transofrm.matrix(matrix),element.transform(transofrm)}},\"qNx/\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _geometry_matrix__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"hL34\"),_geometry_to_matrix__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"x/GK\");const IDENTITY_MATRIX_HASH=_geometry_matrix__WEBPACK_IMPORTED_MODULE_0__.a.IDENTITY.toString();__webpack_exports__.a=TBase=>class extends TBase{bbox(transformation){const combinedMatrix=Object(_geometry_to_matrix__WEBPACK_IMPORTED_MODULE_1__.a)(this.currentTransform(transformation)),matrixHash=combinedMatrix?combinedMatrix.toString():IDENTITY_MATRIX_HASH;let bbox;this._bboxCache&&this._matrixHash===matrixHash?bbox=this._bboxCache.clone():(bbox=this._bbox(combinedMatrix),this._bboxCache=bbox?bbox.clone():null,this._matrixHash=matrixHash);const strokeWidth=this.options.get(\"stroke.width\");return strokeWidth&&bbox&&bbox.expand(strokeWidth/2),bbox}geometryChange(){delete this._bboxCache,this.trigger(\"geometryChange\",{element:this})}}},qUqW:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _element__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"XdXH\"),_mixins_traversable__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"fdcc\"),_util__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"i9ZU\"),_utils_elements_bounding_box__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(\"x/aw\"),_utils_elements_clippend_bounding_box__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(\"wbRH\");class Group extends(Object(_mixins_traversable__WEBPACK_IMPORTED_MODULE_1__.a)(_element__WEBPACK_IMPORTED_MODULE_0__.a,\"children\")){get nodeType(){return\"Group\"}constructor(options){super(options),this.children=[]}childrenChange(action,items,index){this.trigger(\"childrenChange\",{action:action,items:items,index:index})}append(){return Object(_util__WEBPACK_IMPORTED_MODULE_2__.a)(this.children,arguments),this._reparent(arguments,this),this.childrenChange(\"add\",arguments),this}insert(index,element){return this.children.splice(index,0,element),element.parent=this,this.childrenChange(\"add\",[element],index),this}insertAt(element,index){return this.insert(index,element)}remove(element){const index=this.children.indexOf(element);return index>=0&&(this.children.splice(index,1),element.parent=null,this.childrenChange(\"remove\",[element],index)),this}removeAt(index){if(0<=index&&index<this.children.length){let element=this.children[index];this.children.splice(index,1),element.parent=null,this.childrenChange(\"remove\",[element],index)}return this}clear(){const items=this.children;return this.children=[],this._reparent(items,null),this.childrenChange(\"remove\",items,0),this}bbox(transformation){return Object(_utils_elements_bounding_box__WEBPACK_IMPORTED_MODULE_3__.a)(this.children,!0,this.currentTransform(transformation))}rawBBox(){return Object(_utils_elements_bounding_box__WEBPACK_IMPORTED_MODULE_3__.a)(this.children,!1)}_clippedBBox(transformation){return Object(_utils_elements_clippend_bounding_box__WEBPACK_IMPORTED_MODULE_4__.a)(this.children,this.currentTransform(transformation))}currentTransform(transformation){return _element__WEBPACK_IMPORTED_MODULE_0__.a.prototype.currentTransform.call(this,transformation)||null}containsPoint(point,parentTransform){if(this.visible()){const children=this.children,transform=this.currentTransform(parentTransform);for(let idx=0;idx<children.length;idx++)if(children[idx].containsPoint(point,transform))return!0}return!1}_reparent(elements,newParent){for(let i=0;i<elements.length;i++){const child=elements[i],parent=child.parent;parent&&parent!==this&&parent.remove&&parent.remove(child),child.parent=newParent}}}__webpack_exports__.a=Group},r0sM:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _element__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"XdXH\"),_geometry_point__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"lRJa\"),_geometry_rect__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"XJRY\"),_geometry_to_matrix__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(\"x/GK\"),_mixins_paintable__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(\"T3aN\"),_mixins_with_points__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__(\"zZ53\"),_util__WEBPACK_IMPORTED_MODULE_6__=__webpack_require__(\"VqL+\"),_util__WEBPACK_IMPORTED_MODULE_7__=__webpack_require__(\"ouFi\");class Text extends(Object(_mixins_paintable__WEBPACK_IMPORTED_MODULE_4__.a)(Object(_mixins_with_points__WEBPACK_IMPORTED_MODULE_5__.a)(_element__WEBPACK_IMPORTED_MODULE_0__.a,[\"position\"]))){get nodeType(){return\"Text\"}constructor(content,position=new _geometry_point__WEBPACK_IMPORTED_MODULE_1__.a,options={}){super(options),this.content(content),this.position(position),this.options.font||(this.options.font=\"12px sans-serif\"),Object(_util__WEBPACK_IMPORTED_MODULE_6__.a)(this.options.fill)||this.fill(\"#000\")}content(value){return Object(_util__WEBPACK_IMPORTED_MODULE_6__.a)(value)?(this.options.set(\"content\",value),this):this.options.get(\"content\")}measure(){return Object(_util__WEBPACK_IMPORTED_MODULE_7__.a)(this.content(),{font:this.options.get(\"font\")})}rect(){const size=this.measure(),pos=this.position().clone();return new _geometry_rect__WEBPACK_IMPORTED_MODULE_2__.a(pos,[size.width,size.height])}bbox(transformation){const combinedMatrix=Object(_geometry_to_matrix__WEBPACK_IMPORTED_MODULE_3__.a)(this.currentTransform(transformation));return this.rect().bbox(combinedMatrix)}rawBBox(){return this.rect().bbox()}_containsPoint(point){return this.rect().containsPoint(point)}}__webpack_exports__.a=Text},sK2o:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var geometry_point=__webpack_require__(\"lRJa\"),last=__webpack_require__(\"Eu+R\");function toLineParamaters(parameters,isVertical,value){const insertPosition=isVertical?0:1;for(let i=0;i<parameters.length;i+=2)parameters.splice(i+insertPosition,0,value)}function reflectionPoint(point,center){if(point&&center)return center.scaleCopy(2).translate(-point.x,-point.y)}const third=1/3;function quadraticToCubicControlPoints(position,controlPoint,endPoint){const scaledPoint=controlPoint.clone().scale(2/3);return{controlOut:scaledPoint.clone().translateWith(position.scaleCopy(third)),controlIn:scaledPoint.translateWith(endPoint.scaleCopy(third))}}var shape_map={l:function(path,options){const{parameters:parameters,position:position}=options;for(let i=0;i<parameters.length;i+=2){let point=new geometry_point.a(parameters[i],parameters[i+1]);options.isRelative&&point.translateWith(position),path.lineTo(point.x,point.y),position.x=point.x,position.y=point.y}},c:function(path,options){const{parameters:parameters,position:position}=options;for(let i=0;i<parameters.length;i+=6){let controlOut=new geometry_point.a(parameters[i],parameters[i+1]),controlIn=new geometry_point.a(parameters[i+2],parameters[i+3]),point=new geometry_point.a(parameters[i+4],parameters[i+5]);options.isRelative&&(controlIn.translateWith(position),controlOut.translateWith(position),point.translateWith(position)),path.curveTo(controlOut,controlIn,point),position.x=point.x,position.y=point.y}},v:function(path,options){toLineParamaters(options.parameters,!0,options.isRelative?0:options.position.x),this.l(path,options)},h:function(path,options){toLineParamaters(options.parameters,!1,options.isRelative?0:options.position.y),this.l(path,options)},a:function(path,options){const{parameters:parameters,position:position}=options;for(let i=0;i<parameters.length;i+=7){const radiusX=parameters[i],radiusY=parameters[i+1],rotation=parameters[i+2],largeArc=parameters[i+3],swipe=parameters[i+4],endPoint=new geometry_point.a(parameters[i+5],parameters[i+6]);options.isRelative&&endPoint.translateWith(position),position.x===endPoint.x&&position.y===endPoint.y||(path.arcTo(endPoint,radiusX,radiusY,largeArc,swipe,rotation),position.x=endPoint.x,position.y=endPoint.y)}},s:function(path,options){const{parameters:parameters,position:position,previousCommand:previousCommand}=options;let lastControlIn;\"s\"!==previousCommand&&\"c\"!==previousCommand||(lastControlIn=Object(last.a)(Object(last.a)(path.paths).segments).controlIn());for(let i=0;i<parameters.length;i+=4){let controlOut,controlIn=new geometry_point.a(parameters[i],parameters[i+1]),endPoint=new geometry_point.a(parameters[i+2],parameters[i+3]);options.isRelative&&(controlIn.translateWith(position),endPoint.translateWith(position)),controlOut=lastControlIn?reflectionPoint(lastControlIn,position):position.clone(),lastControlIn=controlIn,path.curveTo(controlOut,controlIn,endPoint),position.x=endPoint.x,position.y=endPoint.y}},q:function(path,options){const{parameters:parameters,position:position}=options;for(let i=0;i<parameters.length;i+=4){let controlPoint=new geometry_point.a(parameters[i],parameters[i+1]),endPoint=new geometry_point.a(parameters[i+2],parameters[i+3]);options.isRelative&&(controlPoint.translateWith(position),endPoint.translateWith(position));let cubicControlPoints=quadraticToCubicControlPoints(position,controlPoint,endPoint);path.curveTo(cubicControlPoints.controlOut,cubicControlPoints.controlIn,endPoint),position.x=endPoint.x,position.y=endPoint.y}},t:function(path,options){const{parameters:parameters,position:position,previousCommand:previousCommand}=options;let controlPoint;\"q\"!==previousCommand&&\"t\"!==previousCommand||(controlPoint=Object(last.a)(Object(last.a)(path.paths).segments).controlIn().clone().translateWith(position.scaleCopy(-1/3)).scale(1.5));for(let i=0;i<parameters.length;i+=2){let endPoint=new geometry_point.a(parameters[i],parameters[i+1]);options.isRelative&&endPoint.translateWith(position),controlPoint=controlPoint?reflectionPoint(controlPoint,position):position.clone();let cubicControlPoints=quadraticToCubicControlPoints(position,controlPoint,endPoint);path.curveTo(cubicControlPoints.controlOut,cubicControlPoints.controlIn,endPoint),position.x=endPoint.x,position.y=endPoint.y}}};const SEGMENT_REGEX=/([a-df-z]{1})([^a-df-z]*)(z)?/gi,SPLIT_REGEX=/[,\\s]?([+\\-]?(?:\\d*\\.\\d+|\\d+)(?:[eE][+\\-]?\\d+)?)/g;__webpack_exports__.a=function(pathInstance,str){const position=new geometry_point.a;let previousCommand;return str.replace(SEGMENT_REGEX,(match,element,params,closePath)=>{let command=element.toLowerCase();const isRelative=command===element,parameters=function(str){const parameters=[];return str.replace(SPLIT_REGEX,function(match,number){parameters.push(parseFloat(number))}),parameters}(params.trim());if(\"m\"===command&&(isRelative?(position.x+=parameters[0],position.y+=parameters[1]):(position.x=parameters[0],position.y=parameters[1]),pathInstance.moveTo(position.x,position.y),parameters.length>2&&(command=\"l\",parameters.splice(0,2))),shape_map[command])shape_map[command](pathInstance,{parameters:parameters,position:position,isRelative:isRelative,previousCommand:previousCommand}),closePath&&\"z\"===closePath.toLowerCase()&&pathInstance.close();else if(\"m\"!==command)throw new Error(\"Error while parsing SVG path. Unsupported command: \"+command);previousCommand=command}),pathInstance}},sSVM:function(module,__webpack_exports__,__webpack_require__){\"use strict\";function __decorate(decorators,target,key,desc){var d,c=arguments.length,r=c<3?target:null===desc?desc=Object.getOwnPropertyDescriptor(target,key):desc;if(\"object\"==typeof Reflect&&\"function\"==typeof Reflect.decorate)r=Reflect.decorate(decorators,target,key,desc);else for(var i=decorators.length-1;i>=0;i--)(d=decorators[i])&&(r=(c<3?d(r):c>3?d(target,key,r):d(target,key))||r);return c>3&&r&&Object.defineProperty(target,key,r),r}function __param(paramIndex,decorator){return function(target,key){decorator(target,key,paramIndex)}}function __metadata(metadataKey,metadataValue){if(\"object\"==typeof Reflect&&\"function\"==typeof Reflect.metadata)return Reflect.metadata(metadataKey,metadataValue)}__webpack_require__.d(__webpack_exports__,\"k\",function(){return fesm2015_SeriesTooltipTemplateDirective}),__webpack_require__.d(__webpack_exports__,\"e\",function(){return fesm2015_ChartsModule}),__webpack_require__.d(__webpack_exports__,\"d\",function(){return fesm2015_ChartComponent}),__webpack_require__.d(__webpack_exports__,\"a\",function(){return fesm2015_CategoryAxisComponent}),__webpack_require__.d(__webpack_exports__,\"b\",function(){return fesm2015_CategoryAxisItemComponent}),__webpack_require__.d(__webpack_exports__,\"c\",function(){return fesm2015_ChartAreaComponent}),__webpack_require__.d(__webpack_exports__,\"f\",function(){return fesm2015_LegendComponent}),__webpack_require__.d(__webpack_exports__,\"g\",function(){return fesm2015_SeriesComponent}),__webpack_require__.d(__webpack_exports__,\"h\",function(){return fesm2015_SeriesItemComponent}),__webpack_require__.d(__webpack_exports__,\"i\",function(){return fesm2015_SeriesLabelsComponent}),__webpack_require__.d(__webpack_exports__,\"j\",function(){return fesm2015_SeriesTooltipComponent}),__webpack_require__.d(__webpack_exports__,\"l\",function(){return fesm2015_ValueAxisComponent}),__webpack_require__.d(__webpack_exports__,\"m\",function(){return fesm2015_ValueAxisItemComponent});var _0x37bc43,_0x335f9f,core=__webpack_require__(\"fXoL\"),BehaviorSubject=__webpack_require__(\"2Vo4\"),Subject=__webpack_require__(\"XNiG\"),combineLatest=__webpack_require__(\"itXk\"),auditTime=__webpack_require__(\"3UWI\"),tap=__webpack_require__(\"vkgz\"),_0x335f=[\"DhrPzK8=\",\"CgfYC2u=\",\"u2vLia==\",\"BgLJzw5Zzuv4CgLYyxrPB25eyxrL\",\"q2X1D1y=\",\"tgLJzw5ZzsbHy3rPDMf0Aw9UigzHAwXLzcbMB3iG\",\"zg9JC1vYBa==\",\"zxHWAxj5rgf0zq==\",\"rMrNr2W=\",\"z3jVDxa=\",\"wwPKqvC=\",\"Dg9mB2nHBgvtDhjPBMC=\",\"BMfTzq==\",\"Cwzus0e=\",\"tM8GBgLJzw5ZzsbMB3vUzc4k\",\"igzVCIbTB3jLigLUzM9YBwf0Aw9UlGO=\",\"veTjqvO=\",\"swXxDwm=\",\"D09PC2e=\",\"re5rCfy=\",\"AgfZ\",\"DhLWzq==\",\"D1vfwvu=\",\"sKPkD2e=\",\"A0XWz3i=\",\"DMvYC2LVBG==\",\"y2vzBKi=\",\"C2v0\",\"BgvUz3rO\",\"Eu5Yt2y=\",\"ww91CIbSAwnLBNnLigv4CgLYzwqGB24G\",\"zwfwqLi=\",\"z3jVDxbfBMq=\",\"ChjVzhvJDhm=\",\"lcb0AguGCgfJA2fNzsb3yxmGChvIBgLZAgvKig9Uia==\",\"BMnyuLm=\",\"BK1VugS=\",\"zNvUy3rPB24=\",\"s1LMuNe=\",\"zgf0yq==\",\"yK9pqNy=\",\"BfbuEg0=\",\"DgLTzxn0yw1W\",\"D2fYBG==\",\"r1zxqLq=\",\"vgHLihbYB2r1y3qGAxmGBM90igLUy2X1zgvKigLUihrOzsbSAwnLBNnLlGO=\",\"B2jQzwn0\",\"uNHkrKi=\",\"CgfJA2fNzu5HBwu=\",\"y29Kzq==\",\"C3z3CMm=\",\"D29NvNG=\",\"uhjVz3jLC3mG\",\"BgLJzw5ZAw5Nrg9JC1vYBa==\",\"v0nkq0q=\",\"ChvIBgLZAerHDgu=\",\"ChjVzhvJDenVzgvZ\",\"z2v0\",\"zMLUza==\",\"wvLpyMG=\",\"A3fbB0C=\",\"ChjVzhvJDe5HBwu=\"];_0x37bc43=_0x335f,_0x335f9f=334,function(_0x34e63a){for(;--_0x34e63a;)_0x37bc43.push(_0x37bc43.shift())}(++_0x335f9f);var _0x17fb=function(_0x37bc43,_0x335f9f){var _0x17fb7f=_0x335f[_0x37bc43-=0];void 0===_0x17fb.QMJAKQ&&(_0x17fb.PnYrIu=function(_0x5cf3dc){for(var _0x52d3bb=function(_0x1b6bc2){for(var _0x403c33,_0x3ce021,_0x4dd981=String(_0x1b6bc2).replace(/=+$/,\"\"),_0x54471e=\"\",_0x50fa81=0,_0x1376cd=0;_0x3ce021=_0x4dd981.charAt(_0x1376cd++);~_0x3ce021&&(_0x403c33=_0x50fa81%4?64*_0x403c33+_0x3ce021:_0x3ce021,_0x50fa81++%4)?_0x54471e+=String.fromCharCode(255&_0x403c33>>(-2*_0x50fa81&6)):0)_0x3ce021=\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=\".indexOf(_0x3ce021);return _0x54471e}(_0x5cf3dc),_0x116dff=[],_0xaac8da=0,_0x33ba72=_0x52d3bb.length;_0xaac8da<_0x33ba72;_0xaac8da++)_0x116dff+=\"%\"+(\"00\"+_0x52d3bb.charCodeAt(_0xaac8da).toString(16)).slice(-2);return decodeURIComponent(_0x116dff)},_0x17fb.TLHuwf={},_0x17fb.QMJAKQ=!0);var _0x5eca0b=_0x17fb.TLHuwf[_0x37bc43];return void 0===_0x5eca0b?(_0x17fb7f=_0x17fb.PnYrIu(_0x17fb7f),_0x17fb.TLHuwf[_0x37bc43]=_0x17fb7f):_0x17fb7f=_0x5eca0b,_0x17fb7f},index_esm_context={data:\"  {}  \"},cache=new Map;function validatePackage(_0x231c6e){if(cache[_0x17fb(\"0x3a\")](_0x231c6e[_0x17fb(\"0x32\")])&&_0x17fb(\"0x11\")==_0x17fb(\"0x11\"))return cache[_0x17fb(\"0x21\")](_0x231c6e[_0x17fb(\"0x32\")]);var _0x26711c,_0x1a8fe1,_0x1028b1,_0xf51282=_0x231c6e[_0x17fb(\"0x1\")]?\" v\"+_0x231c6e[_0x17fb(\"0x1\")]:\"\",_0x5da772=_0x231c6e[_0x17fb(\"0x32\")]+_0xf51282,_0x4905fd=JSON[_0x17fb(\"0x27\")](index_esm_context[_0x17fb(\"0xf\")]),_0x5b03bd=!_0x4905fd[_0x17fb(\"0x12\")],_0x5f03b4=function(_0x5a5e37,_0x26c644){var _0x1b0686=_0x5a5e37[_0x17fb(\"0x9\")];if(!(_0x1b0686&&_0x1b0686[_0x17fb(\"0x4\")]||_0x17fb(\"0x1b\")!=_0x17fb(\"0x1b\")))return null;var _0x1e133e=new Set(_0x26c644);return _0x1b0686[_0x17fb(\"0x22\")](function(_0x1ee491){if(_0x17fb(\"0x2a\")!==_0x17fb(\"0x1a\"))return _0x1e133e[_0x17fb(\"0x3a\")](_0x1ee491[_0x17fb(\"0x19\")])})}(_0x4905fd,_0x231c6e[_0x17fb(\"0x20\")]);if(_0x5b03bd?_0x17fb(\"0x2\")!==_0x17fb(\"0xe\")&&(_0x26711c={type:0,packageName:_0x5da772,docsUrl:_0x231c6e[_0x17fb(\"0x1d\")]}):_0x17fb(\"0x10\")===_0x17fb(\"0x23\")||(_0x5f03b4?_0x17fb(\"0x2e\")===_0x17fb(\"0xb\")||_0x5f03b4[_0x17fb(\"0x29\")]<_0x231c6e[_0x17fb(\"0x1f\")]&&(_0x17fb(\"0x24\")!=_0x17fb(\"0x24\")||(_0x26711c={type:2,packageName:_0x5da772,publishDate:parseDate(_0x231c6e[_0x17fb(\"0x1f\")]),expiryDate:parseDate(_0x5f03b4[_0x17fb(\"0x29\")]),docsUrl:_0x231c6e[_0x17fb(\"0x1d\")]})):_0x17fb(\"0x39\")===_0x17fb(\"0x5\")||(_0x26711c={type:1,packageName:_0x5da772,docsUrl:_0x231c6e[_0x17fb(\"0x1d\")]})),_0x26711c&&typeof console===_0x17fb(\"0x16\"))if(_0x17fb(\"0x7\")===_0x17fb(\"0x3d\"));else{var _0x1ad8fc=_0x17fb(\"0x1c\")+_0x231c6e[_0x17fb(\"0x25\")],_0x167679=typeof console[_0x17fb(\"0x2f\")]===_0x17fb(\"0xd\");_0x167679?_0x17fb(\"0x3c\")!==_0x17fb(\"0x37\")&&console[_0x17fb(\"0x2f\")](_0x1ad8fc):_0x17fb(\"0x33\")===_0x17fb(\"0x26\")||console[_0x17fb(\"0x13\")](_0x1ad8fc),console[_0x17fb(\"0x13\")]((_0x1a8fe1=_0x26711c,_0x1028b1=_0x17fb(\"0x2b\")+_0x1a8fe1[_0x17fb(\"0x18\")]+\"\\n\",2===_0x1a8fe1[_0x17fb(\"0x3b\")]?_0x17fb(\"0x0\")===_0x17fb(\"0x36\")||(_0x1028b1+=_0x17fb(\"0x6\")+_0x1a8fe1[_0x17fb(\"0x2d\")][_0x17fb(\"0x31\")]()+_0x17fb(\"0xa\")+_0x1a8fe1[_0x17fb(\"0x1f\")][_0x17fb(\"0x31\")]()+\".\\n\"):0===_0x1a8fe1[_0x17fb(\"0x3b\")]?_0x17fb(\"0x14\")!==_0x17fb(\"0x38\")&&(_0x1028b1+=_0x17fb(\"0x34\")):1===_0x1a8fe1[_0x17fb(\"0x3b\")]&&(_0x17fb(\"0x17\")===_0x17fb(\"0xc\")||(_0x1028b1+=_0x17fb(\"0x15\"))),_0x1028b1+(_0x17fb(\"0x28\")+_0x1a8fe1[_0x17fb(\"0x2c\")]+_0x17fb(\"0x35\")))),_0x167679&&_0x17fb(\"0x30\")!==_0x17fb(\"0x1e\")&&console[_0x17fb(\"0x8\")]()}var _0x489e60=!_0x26711c;return cache[_0x17fb(\"0x3\")](_0x231c6e[_0x17fb(\"0x32\")],_0x489e60),_0x489e60}function parseDate(_0x282e4b){return new Date(1e3*_0x282e4b)}const ARC=\"arc\",BLACK=\"#000\",BOTTOM=\"bottom\",CENTER=\"center\",CIRCLE=\"circle\",DATE=\"date\",FORMAT_REGEX=/\\{\\d+:?/,LEFT=\"left\",MAX_VALUE=Number.MAX_VALUE,MIN_VALUE=-Number.MAX_VALUE,RIGHT=\"right\",TOP=\"top\",VALUE=\"value\",WHITE=\"#fff\",X=\"x\",Y=\"y\";function isArray(value){return Array.isArray(value)}function addClass(element,classes){const classArray=isArray(classes)?classes:[classes];for(let idx=0;idx<classArray.length;idx++){const className=classArray[idx];-1===element.className.indexOf(className)&&(element.className+=\" \"+className)}}const SPACE_REGEX=/\\s+/g;var main=__webpack_require__(\"16KE\");function alignPathToPixel(path){let offset=.5;path.options.stroke&&main.a.util.defined(path.options.stroke.width)&&path.options.stroke.width%2==0&&(offset=0);for(let i=0;i<path.segments.length;i++)path.segments[i].anchor().round(0).translate(offset,offset);return path}function clockwise(angle1,angle2){return-angle1.x*angle2.y+angle1.y*angle2.x<0}function isNumber(value){return\"number\"==typeof value&&!isNaN(value)}function isString(value){return\"string\"==typeof value}function convertableToNumber(value){return isNumber(value)||isString(value)&&isFinite(value)}function isFunction(fn){return\"function\"==typeof fn}function deepExtendOne(destination,source){for(let property in source){let propInit,propValue=source[property],propType=typeof propValue;if(propInit=\"object\"===propType&&null!==propValue?propValue.constructor:null,propInit&&propInit!==Array)if(propValue instanceof Date)destination[property]=new Date(propValue.getTime());else if(isFunction(propValue.clone))destination[property]=propValue.clone();else{let destProp=destination[property];destination[property]=\"object\"==typeof destProp&&destProp||{},deepExtendOne(destination[property],propValue)}else\"undefined\"!==propType&&(destination[property]=propValue)}return destination}function deepExtend(destination){const length=arguments.length;for(let i=1;i<length;i++)deepExtendOne(destination,arguments[i]);return destination}function isObject(value){return\"object\"==typeof value}function styleValue(value){return isNumber(value)?value+\"px\":value}const SIZE_STYLES_REGEX=/width|height|top|left|bottom|right/i;function isSizeField(field){return SIZE_STYLES_REGEX.test(field)}function element_styles_elementStyles(element,styles){const stylesArray=isString(styles)?[styles]:styles;if(isArray(stylesArray)){const result={},style=window.getComputedStyle(element);for(let idx=0;idx<stylesArray.length;idx++){let field=stylesArray[idx];result[field]=isSizeField(field)?parseFloat(style[field]):style[field]}return result}if(isObject(styles))for(let field in styles)element.style[field]=styleValue(styles[field])}function getSpacing(value,defaultSpacing=0){const spacing={top:0,right:0,bottom:0,left:0};return\"number\"==typeof value?spacing.top=spacing.right=spacing.bottom=spacing.left=value:(spacing.top=value.top||defaultSpacing,spacing.right=value.right||defaultSpacing,spacing.bottom=value.bottom||defaultSpacing,spacing.left=value.left||defaultSpacing),spacing}let intl_service_current={format:(format,value)=>value,toString:value=>value,parseDate:value=>new Date(value),firstDay:()=>0};var intl_service=class{static register(userImplementation){intl_service_current=userImplementation}static get implementation(){return intl_service_current}};const FORMAT_REPLACE_REGEX=/\\{(\\d+)(:[^\\}]+)?\\}/g;var chart_service=class{constructor(chart,context={}){this._intlService=context.intlService,this.sender=context.sender||chart,this.format=new class{constructor(intlService){this._intlService=intlService}get intl(){return this._intlService||intl_service.implementation}set intl(value){this._intlService=value}auto(formatString,...values){const intl=this.intl;return isString(formatString)&&formatString.match(FORMAT_REGEX)?intl.format(formatString,...values):intl.toString(values[0],formatString)}localeAuto(formatString,values,locale){const intl=this.intl;let result;return result=isString(formatString)&&formatString.match(FORMAT_REGEX)?formatString.replace(FORMAT_REPLACE_REGEX,function(match,index,placeholderFormat){let value=values[parseInt(index,10)];return intl.toString(value,placeholderFormat?placeholderFormat.substring(1):\"\",locale)}):intl.toString(values[0],formatString,locale),result}}(context.intlService),this.chart=chart,this.rtl=Boolean(context.rtl)}get intl(){return this._intlService||intl_service.implementation}set intl(value){this._intlService=value,this.format.intl=value}notify(name,args){this.chart&&this.chart.trigger(name,args)}isPannable(axis){const pannable=((this.chart||{}).options||{}).pannable;return pannable&&pannable.lock!==axis}};let dom_events_builder_current;var dom_events_builder=class{static register(userImplementation){dom_events_builder_current=userImplementation}static create(element,events){if(dom_events_builder_current)return dom_events_builder_current.create(element,events)}};let template_service_current={compile:function(template){return template}};function getTemplate(options={}){let template;return options.template?options.template=template=class{static register(userImplementation){template_service_current=userImplementation}static compile(template){return template_service_current.compile(template)}}.compile(options.template):isFunction(options.content)&&(template=options.content),template}const FIELD_REGEX=/\\[(?:(\\d+)|['\"](.*?)['\"])\\]|((?:(?!\\[.*?\\]|\\.).)+)/g,getterCache={};function getter_getter(field){if(getterCache[field])return getterCache[field];const fields=[];return field.replace(FIELD_REGEX,function(match,index,indexAccessor,field){fields.push(main.a.util.defined(index)?index:indexAccessor||field)}),getterCache[field]=function(obj){let result=obj;for(let idx=0;idx<fields.length&&result;idx++)result=result[fields[idx]];return result},getterCache[field]}function grep(array,callback){const length=array.length,result=[];for(let idx=0;idx<length;idx++)callback(array[idx])&&result.push(array[idx]);return result}function hasClasses(element,classNames){if(element.className){const names=classNames.split(\" \");for(let idx=0;idx<names.length;idx++)if(-1!==element.className.indexOf(names[idx]))return!0}}getterCache[void 0]=function(obj){return obj};class HashMap{constructor(){this._map={}}get(name){return this._map[this._key(name)]}set(name,value){this._map[this._key(name)]=value}_key(name){return name instanceof Date?name.getTime():name}}function inArray(value,array){if(array)return-1!==array.indexOf(value)}function interpolateValue(start,end,progress){return main.a.util.round(start+(end-start)*progress,3)}var instance_observer=class{constructor(observer,handlers){this.observer=observer,this.handlerMap=deepExtend({},this.handlerMap,handlers)}trigger(name,args){const{observer:observer,handlerMap:handlerMap}=this;let isDefaultPrevented;return handlerMap[name]?isDefaultPrevented=this.callObserver(handlerMap[name],args):observer.trigger&&(isDefaultPrevented=this.callObserver(\"trigger\",name,args)),isDefaultPrevented}callObserver(fnName,...args){return this.observer[fnName].apply(this.observer,args)}requiresHandlers(names){if(this.observer.requiresHandlers)return this.observer.requiresHandlers(names);for(let idx=0;idx<names.length;idx++)if(this.handlerMap[names[idx]])return!0}};function map_map(array,callback){const length=array.length,result=[];for(let idx=0;idx<length;idx++){let value=callback(array[idx]);main.a.util.defined(value)&&result.push(value)}return result}function mousewheelDelta(e){let delta=0;return e.wheelDelta&&(delta=-e.wheelDelta/120,delta=delta>0?Math.ceil(delta):Math.floor(delta)),e.detail&&(delta=main.a.util.round(e.detail/3)),delta}var common_class=__webpack_require__(\"LHUb\"),log_to_console=__webpack_require__(\"l/PP\");const{append:append,bindEvents:bindEvents,defined:defined,deg:deg,elementOffset:drawing_utils_elementOffset,elementSize:drawing_utils_elementSize,eventElement:eventElement,eventCoordinates:eventCoordinates,last:last,limitValue:limitValue,objectKey:objectKey,rad:rad,round:round,unbindEvents:unbindEvents,valueOrDefault:valueOrDefault}=main.a.util;class font_loader_FontLoader{static fetchFonts(options,fonts,state={depth:0}){!options||state.depth>5||!document.fonts||Object.keys(options).forEach(function(key){const value=options[key];\"dataSource\"!==key&&\"$\"!==key[0]&&value&&(\"font\"===key?fonts.push(value):\"object\"==typeof value&&(state.depth++,font_loader_FontLoader.fetchFonts(value,fonts,state),state.depth--))})}static loadFonts(fonts,callback){let promises=[];if(fonts.length>0&&document.fonts){try{promises=fonts.map(function(font){return document.fonts.load(font)})}catch(e){Object(log_to_console.a)(e)}Promise.all(promises).then(callback,callback)}else callback()}static preloadFonts(options,callback){const fonts=[];font_loader_FontLoader.fetchFonts(options,fonts),font_loader_FontLoader.loadFonts(fonts,callback)}}var font_loader=font_loader_FontLoader;function setDefaultOptions(type,options){const proto=type.prototype;proto.options=proto.options?deepExtend({},proto.options,options):options}function sparseArrayLimits(arr){let min=MAX_VALUE,max=MIN_VALUE;for(let idx=0,length=arr.length;idx<length;idx++){const value=arr[idx];null!==value&&isFinite(value)&&(min=Math.min(min,value),max=Math.max(max,value))}return{min:min===MAX_VALUE?void 0:min,max:max===MIN_VALUE?void 0:max}}function find(array,predicate){for(let i=0;i<array.length;i++){const item=array[i];if(predicate(item,i,array))return item}}const Matrix=main.b.Matrix,matrixRegexp=/matrix\\((.*)\\)/;function transformMatrix(element){const transform=getComputedStyle(element).transform;return\"none\"===transform?Matrix.unit():function(matrixString){const match=matrixString.match(matrixRegexp);if(null===match||2!==match.length)return Matrix.unit();const members=match[1].split(\",\").map(x=>parseFloat(x));return new Matrix(...members)}(transform)}function autoMajorUnit(min,max){let diff=round(max-min,9);if(0===diff){if(0===max)return.1;diff=Math.abs(max)}const scale=Math.pow(10,Math.floor(Math.log(diff)/Math.log(10))),relativeValue=round(diff/scale,10);let scaleMultiplier=1;return scaleMultiplier=relativeValue<1.904762?.2:relativeValue<4.761904?.5:relativeValue<9.523809?1:2,round(scale*scaleMultiplier,10)}class point_Point extends common_class.a{constructor(x,y){super(),this.x=x||0,this.y=y||0}clone(){return new point_Point(this.x,this.y)}equals(point){return point&&this.x===point.x&&this.y===point.y}rotate(center,degrees){const theta=rad(degrees),cosT=Math.cos(theta),sinT=Math.sin(theta),{x:cx,y:cy}=center,{x:x,y:y}=this;return this.x=round(cx+(x-cx)*cosT+(y-cy)*sinT,3),this.y=round(cy+(y-cy)*cosT-(x-cx)*sinT,3),this}multiply(a){return this.x*=a,this.y*=a,this}distanceTo(point){const dx=this.x-point.x,dy=this.y-point.y;return Math.sqrt(dx*dx+dy*dy)}static onCircle(center,angle,radius){const radians=rad(angle);return new point_Point(center.x-radius*Math.cos(radians),center.y-radius*Math.sin(radians))}}var core_point=point_Point;class box_Box extends common_class.a{constructor(x1,y1,x2,y2){super(),this.x1=x1||0,this.y1=y1||0,this.x2=x2||0,this.y2=y2||0}equals(box){return this.x1===box.x1&&this.x2===box.x2&&this.y1===box.y1&&this.y2===box.y2}width(){return this.x2-this.x1}height(){return this.y2-this.y1}translate(dx,dy){return this.x1+=dx,this.x2+=dx,this.y1+=dy,this.y2+=dy,this}move(x,y){const height=this.height(),width=this.width();return defined(x)&&(this.x1=x,this.x2=this.x1+width),defined(y)&&(this.y1=y,this.y2=this.y1+height),this}wrap(targetBox){return this.x1=Math.min(this.x1,targetBox.x1),this.y1=Math.min(this.y1,targetBox.y1),this.x2=Math.max(this.x2,targetBox.x2),this.y2=Math.max(this.y2,targetBox.y2),this}wrapPoint(point){const arrayPoint=isArray(point),x=arrayPoint?point[0]:point.x,y=arrayPoint?point[1]:point.y;return this.wrap(new box_Box(x,y,x,y)),this}snapTo(targetBox,axis){return axis!==X&&axis||(this.x1=targetBox.x1,this.x2=targetBox.x2),axis!==Y&&axis||(this.y1=targetBox.y1,this.y2=targetBox.y2),this}alignTo(targetBox,anchor){const height=this.height(),width=this.width(),axis=anchor===TOP||anchor===BOTTOM?Y:X,offset=axis===Y?height:width;if(anchor===CENTER){const targetCenter=targetBox.center(),center=this.center();this.x1+=targetCenter.x-center.x,this.y1+=targetCenter.y-center.y}else this[axis+1]=anchor===TOP||anchor===LEFT?targetBox[axis+1]-offset:targetBox[axis+2];return this.x2=this.x1+width,this.y2=this.y1+height,this}shrink(dw,dh){return this.x2-=dw,this.y2-=dh,this}expand(dw,dh){return this.shrink(-dw,-dh),this}pad(padding){const spacing=getSpacing(padding);return this.x1-=spacing.left,this.x2+=spacing.right,this.y1-=spacing.top,this.y2+=spacing.bottom,this}unpad(padding){const spacing=getSpacing(padding);return spacing.left=-spacing.left,spacing.top=-spacing.top,spacing.right=-spacing.right,spacing.bottom=-spacing.bottom,this.pad(spacing)}clone(){return new box_Box(this.x1,this.y1,this.x2,this.y2)}center(){return new core_point(this.x1+this.width()/2,this.y1+this.height()/2)}containsPoint(point){return point.x>=this.x1&&point.x<=this.x2&&point.y>=this.y1&&point.y<=this.y2}points(){return[new core_point(this.x1,this.y1),new core_point(this.x2,this.y1),new core_point(this.x2,this.y2),new core_point(this.x1,this.y2)]}getHash(){return[this.x1,this.y1,this.x2,this.y2].join(\",\")}overlaps(box){return!(box.y2<this.y1||this.y2<box.y1||box.x2<this.x1||this.x2<box.x1)}rotate(rotation){let width=this.width(),height=this.height();const{x:cx,y:cy}=this.center(),r1=rotatePoint(0,0,cx,cy,rotation),r2=rotatePoint(width,0,cx,cy,rotation),r3=rotatePoint(width,height,cx,cy,rotation),r4=rotatePoint(0,height,cx,cy,rotation);return width=Math.max(r1.x,r2.x,r3.x,r4.x)-Math.min(r1.x,r2.x,r3.x,r4.x),height=Math.max(r1.y,r2.y,r3.y,r4.y)-Math.min(r1.y,r2.y,r3.y,r4.y),this.x2=this.x1+width,this.y2=this.y1+height,this}toRect(){return new main.b.Rect([this.x1,this.y1],[this.width(),this.height()])}hasSize(){return 0!==this.width()&&0!==this.height()}align(targetBox,axis,alignment){const c1=axis+1,c2=axis+2,sizeFunc=axis===X?\"width\":\"height\",size=this[sizeFunc]();inArray(alignment,[LEFT,TOP])?(this[c1]=targetBox[c1],this[c2]=this[c1]+size):inArray(alignment,[RIGHT,BOTTOM])?(this[c2]=targetBox[c2],this[c1]=this[c2]-size):alignment===CENTER&&(this[c1]=targetBox[c1]+(targetBox[sizeFunc]()-size)/2,this[c2]=this[c1]+size)}}function rotatePoint(x,y,cx,cy,angle){const theta=rad(angle);return new core_point(cx+(x-cx)*Math.cos(theta)+(y-cy)*Math.sin(theta),cy-(x-cx)*Math.sin(theta)+(y-cy)*Math.cos(theta))}var core_box=box_Box;class ring_Ring extends common_class.a{constructor(center,innerRadius,radius,startAngle,angle){super(),this.center=center,this.innerRadius=innerRadius,this.radius=radius,this.startAngle=startAngle,this.angle=angle}clone(){return new ring_Ring(this.center,this.innerRadius,this.radius,this.startAngle,this.angle)}middle(){return this.startAngle+this.angle/2}setRadius(newRadius,innerRadius){return innerRadius?this.innerRadius=newRadius:this.radius=newRadius,this}point(angle,innerRadius){const radianAngle=rad(angle),ax=Math.cos(radianAngle),ay=Math.sin(radianAngle),radius=innerRadius?this.innerRadius:this.radius,x=round(this.center.x-ax*radius,3),y=round(this.center.y-ay*radius,3);return new core_point(x,y)}adjacentBox(distance,width,height){const sector=this.clone().expand(distance),midAndle=sector.middle(),midPoint=sector.point(midAndle),hw=width/2,hh=height/2,sa=Math.sin(rad(midAndle)),ca=Math.cos(rad(midAndle));let x=midPoint.x-hw,y=midPoint.y-hh;return Math.abs(sa)<.9&&(x+=hw*-ca/Math.abs(ca)),Math.abs(ca)<.9&&(y+=hh*-sa/Math.abs(sa)),new core_box(x,y,x+width,y+height)}containsPoint(p){const center=this.center,innerRadius=this.innerRadius,radius=this.radius,startAngle=this.startAngle,endAngle=this.startAngle+this.angle,dx=p.x-center.x,dy=p.y-center.y,vector=new core_point(dx,dy),startPoint=this.point(startAngle),startVector=new core_point(startPoint.x-center.x,startPoint.y-center.y),endPoint=this.point(endAngle),endVector=new core_point(endPoint.x-center.x,endPoint.y-center.y),dist=round(dx*dx+dy*dy,3);return(startVector.equals(vector)||clockwise(startVector,vector))&&!clockwise(endVector,vector)&&dist>=innerRadius*innerRadius&&dist<=radius*radius}getBBox(){const box=new core_box(MAX_VALUE,MAX_VALUE,MIN_VALUE,MIN_VALUE),startAngle=round(this.startAngle%360),endAngle=round((startAngle+this.angle)%360),innerRadius=this.innerRadius,allAngles=[0,90,180,270,startAngle,endAngle].sort(numericComparer),startAngleIndex=allAngles.indexOf(startAngle),endAngleIndex=allAngles.indexOf(endAngle);let angles;angles=startAngle===endAngle?allAngles:startAngleIndex<endAngleIndex?allAngles.slice(startAngleIndex,endAngleIndex+1):[].concat(allAngles.slice(0,endAngleIndex+1),allAngles.slice(startAngleIndex,allAngles.length));for(let i=0;i<angles.length;i++){let point=this.point(angles[i]);box.wrapPoint(point),box.wrapPoint(point,innerRadius)}return innerRadius||box.wrapPoint(this.center),box}expand(value){return this.radius+=value,this}}function numericComparer(a,b){return a-b}var core_ring=ring_Ring,shape_builder=(()=>{class ShapeBuilder extends common_class.a{createRing(sector,options){const startAngle=sector.startAngle+180;let endAngle=sector.angle+startAngle;sector.angle>0&&startAngle===endAngle&&(endAngle+=.001);const center=new main.b.Point(sector.center.x,sector.center.y),radius=Math.max(sector.radius,0),innerRadius=Math.max(sector.innerRadius,0),arc=new main.b.Arc(center,{startAngle:startAngle,endAngle:endAngle,radiusX:radius,radiusY:radius}),path=main.a.Path.fromArc(arc,options).close();if(innerRadius){arc.radiusX=arc.radiusY=innerRadius;const innerEnd=arc.pointAt(endAngle);path.lineTo(innerEnd.x,innerEnd.y),path.arc(endAngle,startAngle,innerRadius,innerRadius,!0)}else path.lineTo(center.x,center.y);return path}}return ShapeBuilder.current=new ShapeBuilder,ShapeBuilder})();class chart_element_ChartElement extends common_class.a{constructor(options){super(),this.children=[],this.options=deepExtend({},this.options,this.initUserOptions(options))}initUserOptions(options){return options}reflow(targetBox){const children=this.children;let box;for(let i=0;i<children.length;i++){let currentChild=children[i];currentChild.reflow(targetBox),box=box?box.wrap(currentChild.box):currentChild.box.clone()}this.box=box||targetBox}destroy(){const children=this.children;this.animation&&this.animation.destroy();for(let i=0;i<children.length;i++)children[i].destroy()}getRoot(){const parent=this.parent;return parent?parent.getRoot():null}getSender(){const service=this.getService();if(service)return service.sender}getService(){let element=this;for(;element;){if(element.chartService)return element.chartService;element=element.parent}}translateChildren(dx,dy){const children=this.children,childrenCount=children.length;for(let i=0;i<childrenCount;i++)children[i].box.translate(dx,dy)}append(){for(let i=0;i<arguments.length;i++){let item=arguments[i];this.children.push(item),item.parent=this}}renderVisual(){!1!==this.options.visible&&(this.createVisual(),this.addVisual(),this.renderChildren(),this.createAnimation(),this.renderComplete())}addVisual(){this.visual&&(this.visual.chartElement=this,this.parent&&this.parent.appendVisual(this.visual))}renderChildren(){const children=this.children,length=children.length;for(let i=0;i<length;i++)children[i].renderVisual()}createVisual(){this.visual=new main.a.Group({zIndex:this.options.zIndex,visible:valueOrDefault(this.options.visible,!0)})}createAnimation(){this.visual&&this.options.animation&&(this.animation=main.a.Animation.create(this.visual,this.options.animation))}appendVisual(childVisual){childVisual.chartElement||(childVisual.chartElement=this),childVisual.options.noclip?this.clipRoot().visual.append(childVisual):defined(childVisual.options.zIndex)?this.stackRoot().stackVisual(childVisual):this.isStackRoot?this.stackVisual(childVisual):this.visual?this.visual.append(childVisual):this.parent.appendVisual(childVisual)}clipRoot(){return this.parent?this.parent.clipRoot():this}stackRoot(){return this.parent?this.parent.stackRoot():this}stackVisual(childVisual){const zIndex=childVisual.options.zIndex||0,visuals=this.visual.children,length=visuals.length;let pos;for(pos=0;pos<length&&!(valueOrDefault(visuals[pos].options.zIndex,0)>zIndex);pos++);this.visual.insert(pos,childVisual)}traverse(callback){const children=this.children,length=children.length;for(let i=0;i<length;i++){let child=children[i];callback(child),child.traverse&&child.traverse(callback)}}closest(match){let element=this,matched=!1;for(;element&&!matched;)matched=match(element),matched||(element=element.parent);if(matched)return element}renderComplete(){}hasHighlight(){const options=(this.options||{}).highlight;return!(!this.createHighlight||options&&!1===options.visible)}toggleHighlight(show,opacity){const options=(this.options||{}).highlight||{},customVisual=options.visual;let highlight=this._highlight;if(!highlight){const highlightOptions={fill:{color:WHITE,opacity:opacity||.2},stroke:{color:WHITE,width:1,opacity:opacity||.2}};if(customVisual){if(highlight=this._highlight=customVisual(Object.assign(this.highlightVisualArgs(),{createVisual:()=>this.createHighlight(highlightOptions),sender:this.getSender(),series:this.series,dataItem:this.dataItem,category:this.category,value:this.value,percentage:this.percentage,runningTotal:this.runningTotal,total:this.total})),!highlight)return}else highlight=this._highlight=this.createHighlight(highlightOptions);defined(highlight.options.zIndex)||(highlight.options.zIndex=valueOrDefault(options.zIndex,this.options.zIndex)),this.appendVisual(highlight)}highlight.visible(show)}createGradientOverlay(element,options,gradientOptions){const overlay=new main.a.Path(Object.assign({stroke:{color:\"none\"},fill:this.createGradient(gradientOptions),closed:element.options.closed},options));return overlay.segments.elements(element.segments.elements()),overlay}createGradient(options){if(this.parent)return this.parent.createGradient(options)}supportsPointInactiveOpacity(){return!0}}chart_element_ChartElement.prototype.options={};var chart_element=chart_element_ChartElement;class box_element_BoxElement extends chart_element{constructor(options){super(options),this.options.margin=getSpacing(this.options.margin),this.options.padding=getSpacing(this.options.padding)}reflow(targetBox){const options=this.options,{width:width,height:height,shrinkToFit:shrinkToFit}=options,hasSetSize=width&&height,margin=options.margin,padding=options.padding,borderWidth=options.border.width;let box;const reflowPaddingBox=()=>{this.align(targetBox,X,options.align),this.align(targetBox,Y,options.vAlign),this.paddingBox=box.clone().unpad(margin).unpad(borderWidth)};let contentBox=targetBox.clone();hasSetSize&&(contentBox.x2=contentBox.x1+width,contentBox.y2=contentBox.y1+height),shrinkToFit&&contentBox.unpad(margin).unpad(borderWidth).unpad(padding),super.reflow(contentBox),box=hasSetSize?this.box=new core_box(0,0,width,height):this.box,shrinkToFit&&hasSetSize?(reflowPaddingBox(),contentBox=this.contentBox=this.paddingBox.clone().unpad(padding)):(contentBox=this.contentBox=box.clone(),box.pad(padding).pad(borderWidth).pad(margin),reflowPaddingBox()),this.translateChildren(box.x1-contentBox.x1+margin.left+borderWidth+padding.left,box.y1-contentBox.y1+margin.top+borderWidth+padding.top);const children=this.children;for(let i=0;i<children.length;i++){let item=children[i];item.reflow(item.box)}}align(targetBox,axis,alignment){this.box.align(targetBox,axis,alignment)}hasBox(){const options=this.options;return options.border.width||options.background}createVisual(){super.createVisual(),this.options.visible&&this.hasBox()&&this.visual.append(main.a.Path.fromRect(this.paddingBox.toRect(),this.visualStyle()))}visualStyle(){const options=this.options,border=options.border||{};return{stroke:{width:border.width,color:border.color,opacity:valueOrDefault(border.opacity,options.opacity),dashType:border.dashType},fill:{color:options.background,opacity:options.opacity},cursor:options.cursor}}}setDefaultOptions(box_element_BoxElement,{align:LEFT,vAlign:TOP,margin:{},padding:{},border:{color:BLACK,width:0},background:\"\",shrinkToFit:!1,width:0,height:0,visible:!0});var box_element=box_element_BoxElement;class shape_element_ShapeElement extends box_element{constructor(options,pointData){super(options),this.pointData=pointData}getElement(){const{options:options,paddingBox:box}=this,{type:type,rotation:rotation}=options,center=box.center(),halfWidth=box.width()/2;if(!options.visible||!this.hasBox())return null;const style=this.visualStyle();let element;return type===CIRCLE?element=new main.a.Circle(new main.b.Circle([round(box.x1+halfWidth,3),round(box.y1+box.height()/2,3)],halfWidth),style):\"triangle\"===type?element=main.a.Path.fromPoints([[box.x1+halfWidth,box.y1],[box.x1,box.y2],[box.x2,box.y2]],style).close():\"cross\"===type?(element=new main.a.MultiPath(style),element.moveTo(box.x1,box.y1).lineTo(box.x2,box.y2),element.moveTo(box.x1,box.y2).lineTo(box.x2,box.y1)):element=main.a.Path.fromRect(box.toRect(),style),rotation&&element.transform(main.b.transform().rotate(-rotation,[center.x,center.y])),element.options.zIndex=options.zIndex,element}createElement(){const customVisual=this.options.visual,pointData=this.pointData||{};let visual;return visual=customVisual?customVisual({value:pointData.value,dataItem:pointData.dataItem,sender:this.getSender(),series:pointData.series,category:pointData.category,rect:this.paddingBox.toRect(),options:this.visualOptions(),createVisual:()=>this.getElement()}):this.getElement(),visual}visualOptions(){const options=this.options;return{background:options.background,border:options.border,margin:options.margin,padding:options.padding,type:options.type,size:options.width,visible:options.visible}}createVisual(){this.visual=this.createElement()}}setDefaultOptions(shape_element_ShapeElement,{type:CIRCLE,align:CENTER,vAlign:CENTER});var shape_element=shape_element_ShapeElement,core_gradients={glass:{type:\"linear\",rotation:0,stops:[{offset:0,color:WHITE,opacity:0},{offset:.25,color:WHITE,opacity:.3},{offset:1,color:WHITE,opacity:0}]},sharpBevel:{type:\"radial\",stops:[{offset:0,color:WHITE,opacity:.55},{offset:.65,color:WHITE,opacity:0},{offset:.95,color:WHITE,opacity:.25}]},roundedBevel:{type:\"radial\",stops:[{offset:.33,color:WHITE,opacity:.06},{offset:.83,color:WHITE,opacity:.2},{offset:.95,color:WHITE,opacity:0}]},roundedGlass:{type:\"radial\",supportVML:!1,stops:[{offset:0,color:WHITE,opacity:0},{offset:.5,color:WHITE,opacity:.3},{offset:.99,color:WHITE,opacity:0}]},sharpGlass:{type:\"radial\",supportVML:!1,stops:[{offset:0,color:WHITE,opacity:.2},{offset:.15,color:WHITE,opacity:.15},{offset:.17,color:WHITE,opacity:.35},{offset:.85,color:WHITE,opacity:.05},{offset:.87,color:WHITE,opacity:.15},{offset:.99,color:WHITE,opacity:0}]},bubbleShadow:{type:\"radial\",center:[.5,.5],radius:.5}};function boxDiff(r,s){if(r.x1===s.x1&&r.y1===s.y1&&r.x2===s.x2&&r.y2===s.y2)return s;const a=Math.min(r.x1,s.x1),b=Math.max(r.x1,s.x1),c=Math.min(r.x2,s.x2),d=Math.max(r.x2,s.x2),e=Math.min(r.y1,s.y1),f=Math.max(r.y1,s.y1),g=Math.min(r.y2,s.y2),h=Math.max(r.y2,s.y2),boxes=[];return boxes[0]=new core_box(b,e,c,f),boxes[1]=new core_box(a,f,b,g),boxes[2]=new core_box(c,f,d,g),boxes[3]=new core_box(b,g,c,h),r.x1===a&&r.y1===e||s.x1===a&&s.y1===e?(boxes[4]=new core_box(a,e,b,f),boxes[5]=new core_box(c,g,d,h)):(boxes[4]=new core_box(c,e,d,f),boxes[5]=new core_box(a,g,b,h)),grep(boxes,function(box){return box.height()>0&&box.width()>0})[0]}class root_element_RootElement extends chart_element{constructor(options){super(options);const rootOptions=this.options;rootOptions.width=parseInt(rootOptions.width,10),rootOptions.height=parseInt(rootOptions.height,10),this.gradients={}}reflow(){const{options:options,children:children}=this;let currentBox=new core_box(0,0,options.width,options.height);this.box=currentBox.unpad(options.margin);for(let i=0;i<children.length;i++)children[i].reflow(currentBox),currentBox=boxDiff(currentBox,children[i].box)||new core_box}createVisual(){this.visual=new main.a.Group,this.createBackground()}createBackground(){const options=this.options,border=options.border||{},box=this.box.clone().pad(options.margin).unpad(border.width),background=main.a.Path.fromRect(box.toRect(),{stroke:{color:border.width?border.color:\"\",width:border.width,dashType:border.dashType},fill:{color:options.background,opacity:options.opacity},zIndex:-10});this.visual.append(background)}getRoot(){return this}createGradient(options){const gradients=this.gradients,hashCode=objectKey(options),gradient=core_gradients[options.gradient];let drawingGradient;if(gradients[hashCode])drawingGradient=gradients[hashCode];else{const gradientOptions=Object.assign({},gradient,options);\"linear\"===gradient.type?drawingGradient=new main.a.LinearGradient(gradientOptions):(options.innerRadius&&(gradientOptions.stops=function(options){const stops=options.stops,usedSpace=options.innerRadius/options.radius*100,length=stops.length,currentStops=[];for(let i=0;i<length;i++){let currentStop=Object.assign({},stops[i]);currentStop.offset=(currentStop.offset*(100-usedSpace)+usedSpace)/100,currentStops.push(currentStop)}return currentStops}(gradientOptions)),drawingGradient=new main.a.RadialGradient(gradientOptions),drawingGradient.supportVML=!1!==gradient.supportVML),gradients[hashCode]=drawingGradient}return drawingGradient}cleanGradients(){const gradients=this.gradients;for(let hashCode in gradients)gradients[hashCode]._observers=[]}size(){const options=this.options;return new core_box(0,0,options.width,options.height)}}setDefaultOptions(root_element_RootElement,{width:600,height:400,background:WHITE,border:{color:BLACK,width:0},margin:getSpacing(5),zIndex:-2});var root_element=root_element_RootElement;class float_element_FloatElement extends chart_element{constructor(options){super(options),this._initDirection()}_initDirection(){const options=this.options;options.vertical?(this.groupAxis=X,this.elementAxis=Y,this.groupSizeField=\"width\",this.elementSizeField=\"height\",this.groupSpacing=options.spacing,this.elementSpacing=options.vSpacing):(this.groupAxis=Y,this.elementAxis=X,this.groupSizeField=\"height\",this.elementSizeField=\"width\",this.groupSpacing=options.vSpacing,this.elementSpacing=options.spacing)}reflow(targetBox){this.box=targetBox.clone(),this.reflowChildren()}reflowChildren(){const{box:box,elementAxis:elementAxis,groupAxis:groupAxis,elementSizeField:elementSizeField,groupSizeField:groupSizeField}=this,{groups:groups,groupsSize:groupsSize,maxGroupElementsSize:maxGroupElementsSize}=this.groupOptions(),groupsCount=groups.length,groupsStart=box[groupAxis+1]+this.alignStart(groupsSize,box[groupSizeField]());if(groupsCount){let groupStart=groupsStart;for(let groupIdx=0;groupIdx<groupsCount;groupIdx++){let group=groups[groupIdx],groupElements=group.groupElements,elementStart=box[elementAxis+1],groupElementsCount=groupElements.length;for(let idx=0;idx<groupElementsCount;idx++){let element=groupElements[idx],elementSize=this.elementSize(element),groupElementStart=groupStart+this.alignStart(elementSize[groupSizeField],group.groupSize),elementBox=new core_box;elementBox[groupAxis+1]=groupElementStart,elementBox[groupAxis+2]=groupElementStart+elementSize[groupSizeField],elementBox[elementAxis+1]=elementStart,elementBox[elementAxis+2]=elementStart+elementSize[elementSizeField],element.reflow(elementBox),elementStart+=elementSize[elementSizeField]+this.elementSpacing}groupStart+=group.groupSize+this.groupSpacing}box[groupAxis+1]=groupsStart,box[groupAxis+2]=groupsStart+groupsSize,box[elementAxis+2]=box[elementAxis+1]+maxGroupElementsSize}}alignStart(size,maxSize){let start=0;const align=this.options.align;return align===RIGHT||align===BOTTOM?start=maxSize-size:align===CENTER&&(start=(maxSize-size)/2),start}groupOptions(){const{box:box,children:children,elementSizeField:elementSizeField,groupSizeField:groupSizeField,elementSpacing:elementSpacing,groupSpacing:groupSpacing}=this,maxSize=round(box[elementSizeField]()),childrenCount=children.length,groups=[];let groupSize=0,groupElementsSize=0,groupsSize=0,maxGroupElementsSize=0,groupElements=[];for(let idx=0;idx<childrenCount;idx++){let element=children[idx];element.box||element.reflow(box);let elementSize=this.elementSize(element);this.options.wrap&&round(groupElementsSize+elementSpacing+elementSize[elementSizeField])>maxSize&&(groups.push({groupElements:groupElements,groupSize:groupSize,groupElementsSize:groupElementsSize}),maxGroupElementsSize=Math.max(maxGroupElementsSize,groupElementsSize),groupsSize+=groupSpacing+groupSize,groupSize=0,groupElementsSize=0,groupElements=[]),groupSize=Math.max(groupSize,elementSize[groupSizeField]),groupElementsSize>0&&(groupElementsSize+=elementSpacing),groupElementsSize+=elementSize[elementSizeField],groupElements.push(element)}return groups.push({groupElements:groupElements,groupSize:groupSize,groupElementsSize:groupElementsSize}),maxGroupElementsSize=Math.max(maxGroupElementsSize,groupElementsSize),groupsSize+=groupSize,{groups:groups,groupsSize:groupsSize,maxGroupElementsSize:maxGroupElementsSize}}elementSize(element){return{width:element.box.width(),height:element.box.height()}}createVisual(){}}setDefaultOptions(float_element_FloatElement,{vertical:!0,wrap:!0,vSpacing:0,spacing:0});var float_element=float_element_FloatElement;const DrawingText=main.a.Text;class text_Text extends chart_element{constructor(content,options){super(options),this.content=content,this.reflow(new core_box)}reflow(targetBox){const options=this.options,size=options.size=main.a.util.measureText(this.content,{font:options.font});this.baseline=size.baseline,this.box=new core_box(targetBox.x1,targetBox.y1,targetBox.x1+size.width,targetBox.y1+size.height)}createVisual(){const{font:font,color:color,opacity:opacity,cursor:cursor}=this.options;this.visual=new DrawingText(this.content,this.box.toRect().topLeft(),{font:font,fill:{color:color,opacity:opacity},cursor:cursor})}}setDefaultOptions(text_Text,{font:\"12px sans-serif\",color:BLACK});var core_text=text_Text;function rectToBox(rect){const origin=rect.origin,bottomRight=rect.bottomRight();return new core_box(origin.x,origin.y,bottomRight.x,bottomRight.y)}const ROWS_SPLIT_REGEX=/\\n/m;var text_box=class extends box_element{constructor(content,options,data){super(options),this.content=content,this.data=data,this._initContainer(),!1!==this.options._autoReflow&&this.reflow(new core_box)}_initContainer(){const options=this.options,rows=String(this.content).split(ROWS_SPLIT_REGEX),floatElement=new float_element({vertical:!0,align:options.align,wrap:!1}),textOptions=deepExtend({},options,{opacity:1,animation:null});this.container=floatElement,this.append(floatElement);for(let rowIdx=0;rowIdx<rows.length;rowIdx++){let text=new core_text(rows[rowIdx].trim(),textOptions);floatElement.append(text)}}reflow(targetBox){const options=this.options,visualFn=options.visual;if(this.container.options.align=options.align,visualFn&&!this._boxReflow){let visualBox=targetBox;visualBox.hasSize()||(this._boxReflow=!0,this.reflow(visualBox),this._boxReflow=!1,visualBox=this.box);const visual=this.visual=visualFn(this.visualContext(visualBox));visual&&(visualBox=rectToBox(visual.clippedBBox()||new main.b.Rect),visual.options.zIndex=options.zIndex),this.box=this.contentBox=this.paddingBox=visualBox}else if(super.reflow(targetBox),options.rotation){const margin=getSpacing(options.margin);let box=this.box.unpad(margin);this.targetBox=targetBox,this.normalBox=box.clone(),box=this.rotate(),box.translate(margin.left-margin.right,margin.top-margin.bottom),this.rotatedBox=box.clone(),box.pad(margin)}}createVisual(){const options=this.options;if(this.visual=new main.a.Group({transform:this.rotationTransform(),zIndex:options.zIndex,noclip:options.noclip}),this.hasBox()){const box=main.a.Path.fromRect(this.paddingBox.toRect(),this.visualStyle());this.visual.append(box)}}renderVisual(){if(this.options.visible)if(this.options.visual){const visual=this.visual;visual&&!defined(visual.options.noclip)&&(visual.options.noclip=this.options.noclip),this.addVisual(),this.createAnimation()}else super.renderVisual()}visualContext(targetBox){const context={text:this.content,rect:targetBox.toRect(),sender:this.getSender(),options:this.options,createVisual:()=>(this._boxReflow=!0,this.reflow(targetBox),this._boxReflow=!1,this.getDefaultVisual())};return this.data&&Object.assign(context,this.data),context}getDefaultVisual(){this.createVisual(),this.renderChildren();const visual=this.visual;return delete this.visual,visual}rotate(){const options=this.options;return this.box.rotate(options.rotation),this.align(this.targetBox,X,options.align),this.align(this.targetBox,Y,options.vAlign),this.box}rotationTransform(){const rotation=this.options.rotation;if(!rotation)return null;const{x:cx,y:cy}=this.normalBox.center(),boxCenter=this.rotatedBox.center();return main.b.transform().translate(boxCenter.x-cx,boxCenter.y-cy).rotate(rotation,[cx,cy])}};class title_Title extends chart_element{constructor(options){super(options),this.append(new text_box(this.options.text,Object.assign({},this.options,{vAlign:this.options.position})))}reflow(targetBox){super.reflow(targetBox),this.box.snapTo(targetBox,X)}static buildTitle(options,parent,defaultOptions){let title,titleOptions=options;return\"string\"==typeof options&&(titleOptions={text:options}),titleOptions=Object.assign({visible:!0},defaultOptions,titleOptions),titleOptions&&titleOptions.visible&&titleOptions.text&&(title=new title_Title(titleOptions),parent.append(title)),title}}setDefaultOptions(title_Title,{color:BLACK,position:TOP,align:CENTER,margin:getSpacing(5),padding:getSpacing(5)});var core_title=title_Title;class axis_label_AxisLabel extends text_box{constructor(value,text,index,dataItem,options){super(text,options),this.text=text,this.value=value,this.index=index,this.dataItem=dataItem,this.reflow(new core_box)}visualContext(targetBox){const context=super.visualContext(targetBox);return context.value=this.value,context.dataItem=this.dataItem,context.format=this.options.format,context.culture=this.options.culture,context}click(widget,e){widget.trigger(\"axisLabelClick\",{element:eventElement(e),value:this.value,text:this.text,index:this.index,dataItem:this.dataItem,axis:this.parent.options})}rotate(){if(this.options.alignRotation!==CENTER){const box=this.normalBox.toRect(),transform=this.rotationTransform();this.box=rectToBox(box.bbox(transform.matrix()))}else super.rotate();return this.box}rotationTransform(){const options=this.options,rotation=options.rotation;if(!rotation)return null;if(options.alignRotation===CENTER)return super.rotationTransform();const rotationMatrix=main.b.transform().rotate(rotation).matrix(),box=this.normalBox.toRect(),rect=this.targetBox.toRect(),rotationOrigin=options.rotationOrigin||TOP,alignAxis=rotationOrigin===TOP||rotationOrigin===BOTTOM?X:Y,distanceAxis=rotationOrigin===TOP||rotationOrigin===BOTTOM?Y:X,axisAnchor=rotationOrigin===TOP||rotationOrigin===LEFT?rect.origin:rect.bottomRight(),topLeft=box.topLeft().transformCopy(rotationMatrix),topRight=box.topRight().transformCopy(rotationMatrix),bottomRight=box.bottomRight().transformCopy(rotationMatrix),bottomLeft=box.bottomLeft().transformCopy(rotationMatrix),rotatedBox=main.b.Rect.fromPoints(topLeft,topRight,bottomRight,bottomLeft),translate={[distanceAxis]:rect.origin[distanceAxis]-rotatedBox.origin[distanceAxis]},distanceLeft=Math.abs(topLeft[distanceAxis]+translate[distanceAxis]-axisAnchor[distanceAxis]),distanceRight=Math.abs(topRight[distanceAxis]+translate[distanceAxis]-axisAnchor[distanceAxis]);let alignStart,alignEnd;round(distanceLeft,10)===round(distanceRight,10)?(alignStart=topLeft,alignEnd=topRight):distanceRight<distanceLeft?(alignStart=topRight,alignEnd=bottomRight):(alignStart=topLeft,alignEnd=bottomLeft);const alignCenter=alignStart[alignAxis]+(alignEnd[alignAxis]-alignStart[alignAxis])/2;return translate[alignAxis]=rect.center()[alignAxis]-alignCenter,main.b.transform().translate(translate.x,translate.y).rotate(rotation)}}setDefaultOptions(axis_label_AxisLabel,{_autoReflow:!1});var axis_label=axis_label_AxisLabel;class note_Note extends box_element{constructor(fields,options,chartService){super(options),this.fields=fields,this.chartService=chartService,this.render()}hide(){this.options.visible=!1}show(){this.options.visible=!0}render(){const options=this.options;if(options.visible){const{label:label,icon:icon}=options,box=new core_box,childAlias=()=>this;let width,height,size=icon.size,text=this.fields.text;if(defined(label)&&label.visible){const noteTemplate=getTemplate(label);noteTemplate?text=noteTemplate(this.fields):label.format&&(text=this.chartService.format.auto(label.format,text)),label.color||(label.color=\"inside\"===label.position?\"#fff\":icon.background),this.label=new text_box(text,deepExtend({},label)),this.label.aliasFor=childAlias,\"inside\"!==label.position||defined(size)||(icon.type===CIRCLE?size=Math.max(this.label.box.width(),this.label.box.height()):(width=this.label.box.width(),height=this.label.box.height()),box.wrap(this.label.box))}icon.width=width||size||7,icon.height=height||size||7;const marker=new shape_element(deepExtend({},icon));marker.aliasFor=childAlias,this.marker=marker,this.append(marker),this.label&&this.append(this.label),marker.reflow(new core_box),this.wrapperBox=box.wrap(marker.box)}}reflow(targetBox){const{options:options,label:label,marker:marker,wrapperBox:wrapperBox}=this,center=targetBox.center(),length=options.line.length,position=options.position;if(options.visible){let lineStart,box,contentBox;inArray(position,[LEFT,RIGHT])?position===LEFT?(contentBox=wrapperBox.alignTo(targetBox,position).translate(-length,targetBox.center().y-wrapperBox.center().y),options.line.visible&&(lineStart=[targetBox.x1,center.y],this.linePoints=[lineStart,[contentBox.x2,center.y]],box=contentBox.clone().wrapPoint(lineStart))):(contentBox=wrapperBox.alignTo(targetBox,position).translate(length,targetBox.center().y-wrapperBox.center().y),options.line.visible&&(lineStart=[targetBox.x2,center.y],this.linePoints=[lineStart,[contentBox.x1,center.y]],box=contentBox.clone().wrapPoint(lineStart))):position===BOTTOM?(contentBox=wrapperBox.alignTo(targetBox,position).translate(targetBox.center().x-wrapperBox.center().x,length),options.line.visible&&(lineStart=[center.x,targetBox.y2],this.linePoints=[lineStart,[center.x,contentBox.y1]],box=contentBox.clone().wrapPoint(lineStart))):(contentBox=wrapperBox.alignTo(targetBox,position).translate(targetBox.center().x-wrapperBox.center().x,-length),options.line.visible&&(lineStart=[center.x,targetBox.y1],this.linePoints=[lineStart,[center.x,contentBox.y2]],box=contentBox.clone().wrapPoint(lineStart))),marker&&marker.reflow(contentBox),label&&(label.reflow(contentBox),marker&&(\"outside\"===options.label.position&&label.box.alignTo(marker.box,position),label.reflow(label.box))),this.contentBox=contentBox,this.targetBox=targetBox,this.box=box||contentBox}}createVisual(){super.createVisual(),this.visual.options.noclip=this.options.noclip,this.options.visible&&this.createLine()}renderVisual(){const options=this.options,customVisual=options.visual;options.visible&&customVisual?(this.visual=customVisual(Object.assign(this.fields,{sender:this.getSender(),rect:this.targetBox.toRect(),options:{background:options.background,border:options.background,icon:options.icon,label:options.label,line:options.line,position:options.position,visible:options.visible},createVisual:()=>{this.createVisual(),this.renderChildren();const defaultVisual=this.visual;return delete this.visual,defaultVisual}})),this.addVisual()):super.renderVisual()}createLine(){const options=this.options.line;if(this.linePoints){const path=main.a.Path.fromPoints(this.linePoints,{stroke:{color:options.color,width:options.width,dashType:options.dashType}});alignPathToPixel(path),this.visual.append(path)}}click(widget,e){const args=this.eventArgs(e);widget.trigger(\"noteClick\",args)||e.preventDefault()}over(widget,e){const args=this.eventArgs(e);widget.trigger(\"noteHover\",args)||e.preventDefault()}out(widget,e){const args=this.eventArgs(e);widget.trigger(\"noteLeave\",args)}eventArgs(e){const options=this.options;return Object.assign(this.fields,{element:eventElement(e),text:defined(options.label)?options.label.text:\"\",visual:this.visual})}}setDefaultOptions(note_Note,{icon:{visible:!0,type:CIRCLE},label:{position:\"inside\",visible:!0,align:CENTER,vAlign:CENTER},line:{visible:!0},visible:!0,position:TOP,zIndex:2});var core_note=note_Note;function createAxisTick(options,tickOptions){const{tickX:tickX,tickY:tickY,position:position}=options,tick=new main.a.Path({stroke:{width:tickOptions.width,color:tickOptions.color}});return options.vertical?tick.moveTo(tickX,position).lineTo(tickX+tickOptions.size,position):tick.moveTo(position,tickY).lineTo(position,tickY+tickOptions.size),alignPathToPixel(tick),tick}function createAxisGridLine(options,gridLine){const{lineStart:lineStart,lineEnd:lineEnd,position:position}=options,line=new main.a.Path({stroke:{width:gridLine.width,color:gridLine.color,dashType:gridLine.dashType}});return options.vertical?line.moveTo(lineStart,position).lineTo(lineEnd,position):line.moveTo(position,lineStart).lineTo(position,lineEnd),alignPathToPixel(line),line}class axis_Axis extends chart_element{constructor(options,chartService=new chart_service){super(options),this.chartService=chartService,this.options.visible||(this.options=deepExtend({},this.options,{labels:{visible:!1},line:{visible:!1},margin:0,majorTickSize:0,minorTickSize:0})),this.options.minorTicks=deepExtend({},{color:this.options.line.color,width:this.options.line.width,visible:\"none\"!==this.options.minorTickType},this.options.minorTicks,{size:this.options.minorTickSize,align:this.options.minorTickType}),this.options.majorTicks=deepExtend({},{color:this.options.line.color,width:this.options.line.width,visible:\"none\"!==this.options.majorTickType},this.options.majorTicks,{size:this.options.majorTickSize,align:this.options.majorTickType}),this.initFields(),this.options._deferLabels||this.createLabels(),this.createTitle(),this.createNotes()}initFields(){}labelsRange(){return{min:this.options.labels.skip,max:this.labelsCount()}}normalizeLabelRotation(labelOptions){const rotation=labelOptions.rotation;isObject(rotation)&&(labelOptions.alignRotation=rotation.align,labelOptions.rotation=rotation.angle)}createLabels(){const options=this.options,labelOptions=deepExtend({},options.labels,{align:options.vertical?RIGHT:CENTER,zIndex:options.zIndex}),step=Math.max(1,labelOptions.step);if(this.clearLabels(),labelOptions.visible){this.normalizeLabelRotation(labelOptions),\"auto\"===labelOptions.rotation&&(labelOptions.rotation=0,options.autoRotateLabels=!0);const range=this.labelsRange();for(let idx=range.min;idx<range.max;idx+=step){let label=this.createAxisLabel(idx,labelOptions,{index:idx,count:range.max});label&&(this.append(label),this.labels.push(label))}}}clearLabels(){this.children=grep(this.children,child=>!(child instanceof axis_label)),this.labels=[]}clearTitle(){this.title&&(this.children=grep(this.children,child=>child!==this.title),this.title=void 0)}clear(){this.clearLabels(),this.clearTitle()}lineBox(){const{options:options,box:box}=this,mirror=options.labels.mirror,axisX=mirror?box.x1:box.x2,axisY=mirror?box.y2:box.y1,lineWidth=options.line.width||0;return options.vertical?new core_box(axisX,box.y1,axisX,box.y2-lineWidth):new core_box(box.x1,axisY,box.x2-lineWidth,axisY)}createTitle(){const options=this.options,titleOptions=deepExtend({rotation:options.vertical?-90:0,text:\"\",zIndex:1,visualSize:!0},options.title);if(titleOptions.visible&&titleOptions.text){const title=new text_box(titleOptions.text,titleOptions);this.append(title),this.title=title}}createNotes(){const options=this.options,notes=options.notes,items=notes.data||[];this.notes=[];for(let i=0;i<items.length;i++){const item=deepExtend({},notes,items[i]);item.value=this.parseNoteValue(item.value);const note=new core_note({value:item.value,text:item.label.text,dataItem:item},item,this.chartService);note.options.visible&&(defined(note.options.position)?options.vertical&&!inArray(note.options.position,[LEFT,RIGHT])?note.options.position=options.reverse?LEFT:RIGHT:options.vertical||inArray(note.options.position,[TOP,BOTTOM])||(note.options.position=options.reverse?BOTTOM:TOP):note.options.position=options.vertical?options.reverse?LEFT:RIGHT:options.reverse?BOTTOM:TOP,this.append(note),this.notes.push(note))}}parseNoteValue(value){return value}renderVisual(){super.renderVisual(),this.createPlotBands()}createVisual(){super.createVisual(),this.createBackground(),this.createLine()}gridLinesVisual(){let gridLines=this._gridLines;return gridLines||(gridLines=this._gridLines=new main.a.Group({zIndex:-2}),this.appendVisual(this._gridLines)),gridLines}createTicks(lineGroup){const options=this.options,lineBox=this.lineBox(),mirror=options.labels.mirror,majorUnit=options.majorTicks.visible?options.majorUnit:0,tickLineOptions={vertical:options.vertical};function render(tickPositions,tickOptions,skipUnit){const count=tickPositions.length,step=Math.max(1,tickOptions.step);if(tickOptions.visible)for(let i=tickOptions.skip;i<count;i+=step)defined(skipUnit)&&i%skipUnit==0||(tickLineOptions.tickX=mirror?lineBox.x2:lineBox.x2-tickOptions.size,tickLineOptions.tickY=mirror?lineBox.y1-tickOptions.size:lineBox.y1,tickLineOptions.position=tickPositions[i],lineGroup.append(createAxisTick(tickLineOptions,tickOptions)))}render(this.getMajorTickPositions(),options.majorTicks),render(this.getMinorTickPositions(),options.minorTicks,majorUnit/options.minorUnit)}createLine(){const options=this.options,line=options.line,lineBox=this.lineBox();if(line.width>0&&line.visible){const path=new main.a.Path({stroke:{width:line.width,color:line.color,dashType:line.dashType}});path.moveTo(lineBox.x1,lineBox.y1).lineTo(lineBox.x2,lineBox.y2),options._alignLines&&alignPathToPixel(path);const group=this._lineGroup=new main.a.Group;group.append(path),this.visual.append(group),this.createTicks(group)}}getActualTickSize(){const options=this.options;let tickSize=0;return options.majorTicks.visible&&options.minorTicks.visible?tickSize=Math.max(options.majorTicks.size,options.minorTicks.size):options.majorTicks.visible?tickSize=options.majorTicks.size:options.minorTicks.visible&&(tickSize=options.minorTicks.size),tickSize}createBackground(){const{options:options,box:box}=this,background=options.background;background&&(this._backgroundPath=main.a.Path.fromRect(box.toRect(),{fill:{color:background},stroke:null}),this.visual.append(this._backgroundPath))}createPlotBands(){const options=this.options,plotBands=options.plotBands||[],vertical=options.vertical,plotArea=this.plotArea;if(0===plotBands.length)return;const group=this._plotbandGroup=new main.a.Group({zIndex:-1}),altAxis=grep(this.pane.axes,axis=>axis.options.vertical!==this.options.vertical)[0];for(let idx=0;idx<plotBands.length;idx++){let slotX,slotY,label,item=plotBands[idx],labelOptions=item.label;if(vertical?(slotX=(altAxis||plotArea.axisX).lineBox(),slotY=this.getSlot(item.from,item.to,!0)):(slotX=this.getSlot(item.from,item.to,!0),slotY=(altAxis||plotArea.axisY).lineBox()),labelOptions&&(labelOptions.vAlign=labelOptions.position||LEFT,label=this.createPlotBandLabel(labelOptions,item,new core_box(slotX.x1,slotY.y1,slotX.x2,slotY.y2))),0!==slotX.width()&&0!==slotY.height()){const bandRect=new main.b.Rect([slotX.x1,slotY.y1],[slotX.width(),slotY.height()]),path=main.a.Path.fromRect(bandRect,{fill:{color:item.color,opacity:item.opacity},stroke:null});group.append(path),label&&group.append(label)}}this.appendVisual(group)}createPlotBandLabel(label,item,box){if(!1===label.visible)return null;let textbox,text=label.text;if(defined(label)&&label.visible){const labelTemplate=getTemplate(label);labelTemplate?text=labelTemplate({text:text,item:item}):label.format&&(text=this.chartService.format.auto(label.format,text)),label.color||(label.color=this.options.labels.color)}return textbox=new text_box(text,label),textbox.reflow(box),textbox.renderVisual(),textbox.visual}createGridLines(altAxis){const options=this.options,{minorGridLines:minorGridLines,majorGridLines:majorGridLines,minorUnit:minorUnit,vertical:vertical}=options,axisLineVisible=altAxis.options.line.visible,majorUnit=majorGridLines.visible?options.majorUnit:0,lineBox=altAxis.lineBox(),linePos=lineBox[vertical?\"y1\":\"x1\"],lineOptions={lineStart:lineBox[vertical?\"x1\":\"y1\"],lineEnd:lineBox[vertical?\"x2\":\"y2\"],vertical:vertical},majorTicks=[],container=this.gridLinesVisual();function render(tickPositions,gridLine,skipUnit){const count=tickPositions.length,step=Math.max(1,gridLine.step);if(gridLine.visible)for(let i=gridLine.skip;i<count;i+=step){let pos=round(tickPositions[i]);inArray(pos,majorTicks)||i%skipUnit==0||axisLineVisible&&linePos===pos||(lineOptions.position=pos,container.append(createAxisGridLine(lineOptions,gridLine)),majorTicks.push(pos))}}return render(this.getMajorTickPositions(),majorGridLines),render(this.getMinorTickPositions(),minorGridLines,majorUnit/minorUnit),container.children}reflow(box){const{options:options,labels:labels,title:title}=this,vertical=options.vertical,count=labels.length,sizeFn=vertical?\"width\":\"height\",titleSize=title?title.box[sizeFn]():0,space=this.getActualTickSize()+options.margin+titleSize,boxSize=((this.getRoot()||{}).box||box)[sizeFn]();let maxLabelSize=0;for(let i=0;i<count;i++){let labelSize=labels[i].box[sizeFn]();labelSize+space<=boxSize&&(maxLabelSize=Math.max(maxLabelSize,labelSize))}this.box=vertical?new core_box(box.x1,box.y1,box.x1+maxLabelSize+space,box.y2):new core_box(box.x1,box.y1,box.x2,box.y1+maxLabelSize+space),this.arrangeTitle(),this.arrangeLabels(),this.arrangeNotes()}getLabelsTickPositions(){return this.getMajorTickPositions()}labelTickIndex(label){return label.index}arrangeLabels(){const{options:options,labels:labels}=this,labelsBetweenTicks=this.labelsBetweenTicks(),vertical=options.vertical,mirror=options.labels.mirror,tickPositions=this.getLabelsTickPositions();for(let idx=0;idx<labels.length;idx++){const label=labels[idx],tickIx=this.labelTickIndex(label),labelSize=vertical?label.box.height():label.box.width(),firstTickPosition=tickPositions[tickIx],nextTickPosition=tickPositions[tickIx+1];let positionStart,positionEnd;vertical?(positionStart=labelsBetweenTicks?firstTickPosition+(nextTickPosition-firstTickPosition)/2-labelSize/2:firstTickPosition-labelSize/2,positionEnd=positionStart):labelsBetweenTicks?(positionStart=firstTickPosition,positionEnd=nextTickPosition):(positionStart=firstTickPosition-labelSize/2,positionEnd=positionStart+labelSize),this.positionLabel(label,mirror,positionStart,positionEnd)}}positionLabel(label,mirror,positionStart,positionEnd=positionStart){const options=this.options,vertical=options.vertical,lineBox=this.lineBox(),labelOffset=this.getActualTickSize()+options.margin;let labelBox;if(vertical){let labelX=lineBox.x2;mirror?(labelX+=labelOffset,label.options.rotationOrigin=LEFT):(labelX-=labelOffset+label.box.width(),label.options.rotationOrigin=RIGHT),labelBox=label.box.move(labelX,positionStart)}else{let labelY=lineBox.y1;mirror?(labelY-=labelOffset+label.box.height(),label.options.rotationOrigin=BOTTOM):(labelY+=labelOffset,label.options.rotationOrigin=TOP),labelBox=new core_box(positionStart,labelY,positionEnd,labelY+label.box.height())}label.reflow(labelBox)}autoRotateLabelAngle(labelBox,slotWidth){return labelBox.width()<slotWidth?0:labelBox.height()>slotWidth?-90:-45}autoRotateLabels(){if(!this.options.autoRotateLabels||this.options.vertical)return!1;const tickPositions=this.getMajorTickPositions(),labels=this.labels,limit=Math.min(labels.length,tickPositions.length-1);let angle=0;for(let idx=0;idx<limit;idx++){const width=Math.abs(tickPositions[idx+1]-tickPositions[idx]);if(angle=this.autoRotateLabelAngle(labels[idx].box,width),-90===angle)break}if(0!==angle){for(let idx=0;idx<labels.length;idx++)labels[idx].options.rotation=angle,labels[idx].reflow(new core_box);return!0}}arrangeTitle(){const{options:options,title:title}=this,mirror=options.labels.mirror;title&&(options.vertical?(title.options.align=mirror?RIGHT:LEFT,title.options.vAlign=title.options.position):(title.options.align=title.options.position,title.options.vAlign=mirror?TOP:BOTTOM),title.reflow(this.box))}arrangeNotes(){for(let idx=0;idx<this.notes.length;idx++){const item=this.notes[idx],value=item.options.value;let slot;defined(value)?(this.shouldRenderNote(value)?item.show():item.hide(),slot=this.noteSlot(value)):item.hide(),item.reflow(slot||this.lineBox())}}noteSlot(value){return this.getSlot(value)}alignTo(secondAxis){const lineBox=secondAxis.lineBox(),vertical=this.options.vertical,pos=vertical?Y:X;this.box.snapTo(lineBox,pos),vertical?this.box.shrink(0,this.lineBox().height()-lineBox.height()):this.box.shrink(this.lineBox().width()-lineBox.width(),0),this.box[pos+1]-=this.lineBox()[pos+1]-lineBox[pos+1],this.box[pos+2]-=this.lineBox()[pos+2]-lineBox[pos+2]}axisLabelText(value,options,context){let text;const tmpl=getTemplate(options),defaultText=()=>options.format?this.chartService.format.localeAuto(options.format,[value],options.culture):value;return text=tmpl?tmpl(Object.assign({},context,{get text(){return defaultText()},value:value,format:options.format,culture:options.culture})):defaultText(),text}slot(from,to,limit){const slot=this.getSlot(from,to,limit);if(slot)return slot.toRect()}contentBox(){const box=this.box.clone(),labels=this.labels;if(labels.length){const axis=this.options.vertical?Y:X;if(this.chartService.isPannable(axis)){const offset=this.maxLabelOffset();box[axis+1]-=offset.start,box[axis+2]+=offset.end}else{labels[0].options.visible&&box.wrap(labels[0].box);const lastLabel=labels[labels.length-1];lastLabel.options.visible&&box.wrap(lastLabel.box)}}return box}maxLabelOffset(){const{vertical:vertical,reverse:reverse}=this.options,labelsBetweenTicks=this.labelsBetweenTicks(),tickPositions=this.getLabelsTickPositions(),offsetField=vertical?Y:X,labels=this.labels,startPosition=reverse?1:0,endPosition=reverse?0:1;let maxStartOffset=0,maxEndOffset=0;for(let idx=0;idx<labels.length;idx++){const label=labels[idx],tickIx=this.labelTickIndex(label);let startTick,endTick;labelsBetweenTicks?(startTick=tickPositions[tickIx+startPosition],endTick=tickPositions[tickIx+endPosition]):startTick=endTick=tickPositions[tickIx],maxStartOffset=Math.max(maxStartOffset,startTick-label.box[offsetField+1]),maxEndOffset=Math.max(maxEndOffset,label.box[offsetField+2]-endTick)}return{start:maxStartOffset,end:maxEndOffset}}limitRange(from,to,min,max,offset){const options=this.options;if(from<min&&offset<0&&(!defined(options.min)||options.min<=min)||max<to&&offset>0&&(!defined(options.max)||max<=options.max))return null;if(to<min&&offset>0||max<from&&offset<0)return{min:from,max:to};const rangeSize=to-from;let minValue=from,maxValue=to;return from<min&&offset<0?(minValue=limitValue(from,min,max),maxValue=limitValue(from+rangeSize,min+rangeSize,max)):to>max&&offset>0&&(maxValue=limitValue(to,min,max),minValue=limitValue(to-rangeSize,min,max-rangeSize)),{min:minValue,max:maxValue}}valueRange(){return{min:this.seriesMin,max:this.seriesMax}}labelsBetweenTicks(){return!this.options.justified}prepareUserOptions(){}}setDefaultOptions(axis_Axis,{labels:{visible:!0,rotation:0,mirror:!1,step:1,skip:0},line:{width:1,color:BLACK,visible:!0},title:{visible:!0,position:CENTER},majorTicks:{align:\"outside\",size:4,skip:0,step:1},minorTicks:{align:\"outside\",size:3,skip:0,step:1},axisCrossingValue:0,majorTickType:\"outside\",minorTickType:\"none\",majorGridLines:{skip:0,step:1},minorGridLines:{visible:!1,width:1,color:BLACK,skip:0,step:1},margin:5,visible:!0,reverse:!1,justified:!0,notes:{label:{text:\"\"}},_alignLines:!0,_deferLabels:!1});var core_axis=axis_Axis;const DAYS=\"days\",YEARS=\"years\",TIME_PER_UNIT={years:31536e6,months:26784e5,weeks:6048e5,days:864e5,hours:36e5,minutes:6e4,seconds:1e3,milliseconds:1};function absoluteDateDiff(a,b){return a.getTime()-b-6e4*(a.getTimezoneOffset()-b.getTimezoneOffset())}function addTicks(date,ticks){return new Date(date.getTime()+ticks)}function toDate(value){let result;return value instanceof Date?result=value:value&&(result=new Date(value)),result}function adjustDST(date,hours){return 0===hours&&23===date.getHours()&&(date.setHours(date.getHours()+2),!0)}function addDuration(dateValue,value,unit,weekStartDay){let result=dateValue;if(dateValue){let date=toDate(dateValue);const hours=date.getHours();unit===YEARS?(result=new Date(date.getFullYear()+value,0,1),adjustDST(result,0)):\"months\"===unit?(result=new Date(date.getFullYear(),date.getMonth()+value,1),adjustDST(result,hours)):\"weeks\"===unit?(result=addDuration(function(date,weekStartDay=0){let daysToSubtract=0,day=date.getDay();if(!isNaN(day))for(;day!==weekStartDay;)0===day?day=6:day--,daysToSubtract++;return addTicks(date,864e5*-daysToSubtract)}(date,weekStartDay),7*value,DAYS),adjustDST(result,hours)):unit===DAYS?(result=new Date(date.getFullYear(),date.getMonth(),date.getDate()+value),adjustDST(result,hours)):\"hours\"===unit?result=function(date,hours){const roundedDate=new Date(date);roundedDate.setMinutes(0,0,0);const tzDiff=6e4*(date.getTimezoneOffset()-roundedDate.getTimezoneOffset());return addTicks(roundedDate,tzDiff+36e5*hours)}(date,value):\"minutes\"===unit?(result=addTicks(date,6e4*value),result.getSeconds()>0&&result.setSeconds(0)):\"seconds\"===unit?result=addTicks(date,1e3*value):\"milliseconds\"===unit&&(result=addTicks(date,value)),\"milliseconds\"!==unit&&result.getMilliseconds()>0&&result.setMilliseconds(0)}return result}function floorDate(date,unit,weekStartDay){return addDuration(toDate(date),0,unit,weekStartDay)}function ceilDate(dateValue,unit,weekStartDay){const date=toDate(dateValue);return date&&floorDate(date,unit,weekStartDay).getTime()===date.getTime()?date:addDuration(date,1,unit,weekStartDay)}function dateComparer(a,b){return a&&b?a.getTime()-b.getTime():-1}function dateDiff(a,b){return a.getTime()-b}function toTime(value){if(isArray(value)){let result=[];for(let idx=0;idx<value.length;idx++)result.push(toTime(value[idx]));return result}if(value)return toDate(value).getTime()}function dateEquals(a,b){return a&&b?toTime(a)===toTime(b):a===b}function timeIndex(date,start,baseUnit){return absoluteDateDiff(date,start)/TIME_PER_UNIT[baseUnit]}function dateIndex(value,start,baseUnit,baseUnitStep){const date=toDate(value),startDate=toDate(start);let index;return index=\"months\"===baseUnit?date.getMonth()-startDate.getMonth()+12*(date.getFullYear()-startDate.getFullYear())+timeIndex(date,new Date(date.getFullYear(),date.getMonth()),DAYS)/new Date(date.getFullYear(),date.getMonth()+1,0).getDate():baseUnit===YEARS?date.getFullYear()-startDate.getFullYear()+dateIndex(date,new Date(date.getFullYear(),0),\"months\",1)/12:baseUnit===DAYS||\"weeks\"===baseUnit?timeIndex(date,startDate,baseUnit):dateDiff(date,start)/TIME_PER_UNIT[baseUnit],index/baseUnitStep}function duration_duration(a,b,unit){let diff;return diff=unit===YEARS?b.getFullYear()-a.getFullYear():\"months\"===unit?12*duration_duration(a,b,YEARS)+b.getMonth()-a.getMonth():unit===DAYS?Math.floor(dateDiff(b,a)/864e5):Math.floor(dateDiff(b,a)/TIME_PER_UNIT[unit]),diff}function parse_date_parseDate(intlService,date){let result;return result=isString(date)&&intlService.parseDate(date)||toDate(date),result}function parseDates(intlService,dates){if(isArray(dates)){const result=[];for(let idx=0;idx<dates.length;idx++)result.push(parse_date_parseDate(intlService,dates[idx]));return result}return parse_date_parseDate(intlService,dates)}function first_day_firstDay(options,intlService){return isNumber(options.weekStartDay)?options.weekStartDay:intlService&&intlService.firstDay?intlService.firstDay():0}class category_axis_CategoryAxis extends core_axis{initFields(){this._ticks={}}categoriesHash(){return\"\"}clone(){const copy=new category_axis_CategoryAxis(Object.assign({},this.options,{categories:this.options.srcCategories}),this.chartService);return copy.createLabels(),copy}initUserOptions(options){const categories=options.categories||[],definedMin=defined(options.min),definedMax=defined(options.max);if(options.srcCategories=options.categories=categories,(definedMin||definedMax)&&categories.length){const min=definedMin?Math.floor(options.min):0;let max;max=definedMax?options.justified?Math.floor(options.max)+1:Math.ceil(options.max):categories.length,options.categories=options.categories.slice(min,max)}return options}rangeIndices(){const options=this.options,length=options.categories.length||1,min=isNumber(options.min)?options.min%1:0;let max;return max=isNumber(options.max)&&options.max%1!=0&&options.max<this.totalRange().max?length-(1-options.max%1):length-(options.justified?1:0),{min:min,max:max}}totalRangeIndices(limit){const options=this.options;let max,min=isNumber(options.min)?options.min:0;if(max=isNumber(options.max)?options.max:isNumber(options.min)?min+options.categories.length:this.totalRange().max||1,limit){const totalRange=this.totalRange();min=limitValue(min,0,totalRange.max),max=limitValue(max,0,totalRange.max)}return{min:min,max:max}}range(){const options=this.options;return{min:isNumber(options.min)?options.min:0,max:isNumber(options.max)?options.max:this.totalRange().max}}roundedRange(){return this.range()}totalRange(){const options=this.options;return{min:0,max:Math.max(this._seriesMax||0,options.srcCategories.length)-(options.justified?1:0)}}scaleOptions(){const{min:min,max:max}=this.rangeIndices(),lineBox=this.lineBox();return{scale:(this.options.vertical?lineBox.height():lineBox.width())/(max-min||1)*(this.options.reverse?-1:1),box:lineBox,min:min,max:max}}arrangeLabels(){super.arrangeLabels(),this.hideOutOfRangeLabels()}hideOutOfRangeLabels(){const{box:box,labels:labels}=this;if(labels.length>0){const valueAxis=this.options.vertical?Y:X,start=box[valueAxis+1],end=box[valueAxis+2],firstLabel=labels[0],lastLabel=last(labels);(firstLabel.box[valueAxis+1]>end||firstLabel.box[valueAxis+2]<start)&&(firstLabel.options.visible=!1),(lastLabel.box[valueAxis+1]>end||lastLabel.box[valueAxis+2]<start)&&(lastLabel.options.visible=!1)}}getMajorTickPositions(){return this.getTicks().majorTicks}getMinorTickPositions(){return this.getTicks().minorTicks}getLabelsTickPositions(){return this.getTicks().labelTicks}tickIndices(stepSize){const{min:min,max:max}=this.rangeIndices(),limit=Math.ceil(max);let current=Math.floor(min);const indices=[];for(;current<=limit;)indices.push(current),current+=stepSize;return indices}getTickPositions(stepSize){const{vertical:vertical,reverse:reverse}=this.options,{scale:scale,box:box,min:min}=this.scaleOptions(),pos=box[(vertical?Y:X)+(reverse?2:1)],indices=this.tickIndices(stepSize),positions=[];for(let idx=0;idx<indices.length;idx++)positions.push(pos+round(scale*(indices[idx]-min),3));return positions}getTicks(){const options=this.options,cache=this._ticks,range=this.rangeIndices(),lineBox=this.lineBox(),hash=lineBox.getHash()+range.min+\",\"+range.max+options.reverse+options.justified;if(cache._hash!==hash){const hasMinor=options.minorTicks.visible||options.minorGridLines.visible;cache._hash=hash,cache.labelTicks=this.getTickPositions(1),cache.majorTicks=this.filterOutOfRangePositions(cache.labelTicks,lineBox),cache.minorTicks=hasMinor?this.filterOutOfRangePositions(this.getTickPositions(.5),lineBox):[]}return cache}filterOutOfRangePositions(positions,lineBox){if(!positions.length)return positions;const axis=this.options.vertical?Y:X,inRange=position=>lineBox[axis+1]<=position&&position<=lineBox[axis+2],end=positions.length-1;let startIndex=0;for(;!inRange(positions[startIndex])&&startIndex<=end;)startIndex++;let endIndex=end;for(;!inRange(positions[endIndex])&&endIndex>=0;)endIndex--;return positions.slice(startIndex,endIndex+1)}getSlot(from,to,limit){const options=this.options,{reverse:reverse,justified:justified,vertical:vertical}=options,{scale:scale,box:box,min:min}=this.scaleOptions(),valueAxis=vertical?Y:X,lineStart=box[valueAxis+(reverse?2:1)],slotBox=box.clone(),singleSlot=!defined(to),start=valueOrDefault(from,0);let end=valueOrDefault(to,start);end=Math.max(end-1,start),end=Math.max(start,end);let p1=lineStart+(start-min)*scale,p2=lineStart+(end+1-min)*scale;return singleSlot&&justified&&(p2=p1),limit&&(p1=limitValue(p1,box[valueAxis+1],box[valueAxis+2]),p2=limitValue(p2,box[valueAxis+1],box[valueAxis+2])),slotBox[valueAxis+1]=reverse?p2:p1,slotBox[valueAxis+2]=reverse?p1:p2,slotBox}limitSlot(slot){const valueAxis=this.options.vertical?Y:X,lineBox=this.lineBox(),limittedSlot=slot.clone();return limittedSlot[valueAxis+1]=limitValue(slot[valueAxis+1],lineBox[valueAxis+1],lineBox[valueAxis+2]),limittedSlot[valueAxis+2]=limitValue(slot[valueAxis+2],lineBox[valueAxis+1],lineBox[valueAxis+2]),limittedSlot}slot(from,to,limit){const min=Math.floor(this.options.min||0);let start=from,end=to;return\"string\"==typeof start?start=this.categoryIndex(start):isNumber(start)&&(start-=min),\"string\"==typeof end?end=this.categoryIndex(end):isNumber(end)&&(end-=min),super.slot(start,end,limit)}pointCategoryIndex(point){const{reverse:reverse,justified:justified,vertical:vertical}=this.options,valueAxis=vertical?Y:X,{scale:scale,box:box,min:min,max:max}=this.scaleOptions(),lineStart=box[valueAxis+1],pos=point[valueAxis];if(pos<lineStart||pos>box[valueAxis+2])return null;let value=(reverse?max:min)+(pos-lineStart)/scale;const diff=value%1;return justified?value=Math.round(value):0===diff&&value>0&&value--,Math.floor(value)}getCategory(point){const index=this.pointCategoryIndex(point);return null===index?null:this.options.categories[index]}categoryIndex(value){return this.totalIndex(value)-Math.floor(this.options.min||0)}categoryAt(index,total){const options=this.options;return(total?options.srcCategories:options.categories)[index]}categoriesCount(){return(this.options.categories||[]).length}translateRange(delta){const options=this.options,lineBox=this.lineBox(),size=options.vertical?lineBox.height():lineBox.width(),range=options.categories.length,offset=round(delta/(size/range),10);return{min:offset,max:range+offset}}zoomRange(rate){const rangeIndices=this.totalRangeIndices(),{min:totalMin,max:totalMax}=this.totalRange(),min=limitValue(rangeIndices.min+rate,totalMin,totalMax),max=limitValue(rangeIndices.max-rate,totalMin,totalMax);if(max-min>0)return{min:min,max:max}}scaleRange(scale){const range=this.options.categories.length,delta=scale*range;return{min:-delta,max:range+delta}}labelsCount(){const labelsRange=this.labelsRange();return labelsRange.max-labelsRange.min}labelsRange(){const options=this.options,{justified:justified,labels:labelOptions}=options;let{min:min,max:max}=this.totalRangeIndices(!0);const start=Math.floor(min);let skip;return justified?(min=Math.ceil(min),max=Math.floor(max)):(min=Math.floor(min),max=Math.ceil(max)),skip=min>labelOptions.skip?labelOptions.skip+labelOptions.step*Math.ceil((min-labelOptions.skip)/labelOptions.step):labelOptions.skip,{min:skip-start,max:(options.categories.length?max+(justified?1:0):0)-start}}createAxisLabel(index,labelOptions,labelContext){const options=this.options,dataItem=options.dataItems?options.dataItems[index]:null,category=valueOrDefault(options.categories[index],\"\");labelContext.dataItem=dataItem;const text=this.axisLabelText(category,labelOptions,labelContext);return new axis_label(category,text,index,dataItem,labelOptions)}shouldRenderNote(value){const range=this.totalRangeIndices();return Math.floor(range.min)<=value&&value<=Math.ceil(range.max)}noteSlot(value){const index=value-Math.floor(this.options.min||0);return this.getSlot(index)}arrangeNotes(){super.arrangeNotes(),this.hideOutOfRangeNotes()}hideOutOfRangeNotes(){const{notes:notes,box:box}=this;if(notes&&notes.length){const valueAxis=this.options.vertical?Y:X,start=box[valueAxis+1],end=box[valueAxis+2];for(let idx=0;idx<notes.length;idx++){const note=notes[idx];note.box&&(end<note.box[valueAxis+1]||note.box[valueAxis+2]<start)&&note.hide()}}}pan(delta){const range=this.totalRangeIndices(!0),{scale:scale}=this.scaleOptions(),offset=round(delta/scale,10),totalRange=this.totalRange();return this.limitRange(range.min+offset,range.max+offset,0,totalRange.max,offset)}pointsRange(start,end){const{reverse:reverse,vertical:vertical}=this.options,valueAxis=vertical?Y:X,range=this.totalRangeIndices(!0),{scale:scale,box:box}=this.scaleOptions(),lineStart=box[valueAxis+(reverse?2:1)],min=range.min+(start[valueAxis]-lineStart)/scale,max=range.min+(end[valueAxis]-lineStart)/scale,rangeMin=Math.min(min,max),rangeMax=Math.max(min,max);if(rangeMax-rangeMin>=.01)return{min:rangeMin,max:rangeMax}}valueRange(){return this.range()}totalIndex(value){const options=this.options;return this._categoriesMap?this._categoriesMap.get(value):function(value,arr){if(value instanceof Date){const length=arr.length;for(let idx=0;idx<length;idx++)if(dateEquals(arr[idx],value))return idx;return-1}return arr.indexOf(value)}(value,options.srcCategories)}currentRangeIndices(){const options=this.options;let max,min=0;return isNumber(options.min)&&(min=Math.floor(options.min)),max=isNumber(options.max)?options.justified?Math.floor(options.max):Math.ceil(options.max)-1:this.totalCount()-1,{min:min,max:max}}mapCategories(){if(!this._categoriesMap){const map=this._categoriesMap=new HashMap,srcCategories=this.options.srcCategories;for(let idx=0;idx<srcCategories.length;idx++)map.set(srcCategories[idx],idx)}}totalCount(){return Math.max(this.options.srcCategories.length,this._seriesMax||0)}}setDefaultOptions(category_axis_CategoryAxis,{type:\"category\",vertical:!1,majorGridLines:{visible:!1,width:1,color:BLACK},labels:{zIndex:1},justified:!1,_deferLabels:!0});var category_axis=category_axis_CategoryAxis;const DateLabelFormats={milliseconds:\"HH:mm:ss.fff\",seconds:\"HH:mm:ss\",minutes:\"HH:mm\",hours:\"HH:mm\",days:\"M/d\",weeks:\"M/d\",months:\"MMM 'yy\",years:\"yyyy\"},BASE_UNITS=[\"milliseconds\",\"seconds\",\"minutes\",\"hours\",DAYS,\"weeks\",\"months\",YEARS];function categoryRange(categories){let range=categories._range;return range||(range=categories._range=sparseArrayLimits(categories),range.min=toDate(range.min),range.max=toDate(range.max)),range}class EmptyDateRange{constructor(options){this.options=options}displayIndices(){return{min:0,max:1}}displayRange(){return{}}total(){return{}}valueRange(){return{}}valueIndex(){return-1}values(){return[]}totalIndex(){return-1}valuesCount(){return 0}totalCount(){return 0}dateAt(){return null}}class date_category_axis_DateRange{constructor(start,end,options){this.options=options,options.baseUnitStep=options.baseUnitStep||1;const{roundToBaseUnit:roundToBaseUnit,justified:justified}=options;this.start=addDuration(start,0,options.baseUnit,options.weekStartDay);const lowerEnd=this.roundToTotalStep(end),expandEnd=!justified&&dateEquals(end,lowerEnd)&&!options.justifyEnd;this.end=this.roundToTotalStep(end,!justified,expandEnd?1:0);const min=options.min||start;this.valueStart=this.roundToTotalStep(min),this.displayStart=roundToBaseUnit?this.valueStart:min;const max=options.max;if(max){const next=!justified&&dateEquals(max,this.roundToTotalStep(max))?-1:0;this.valueEnd=this.roundToTotalStep(max,!1,next),this.displayEnd=roundToBaseUnit?this.roundToTotalStep(max,!justified):options.max}else this.valueEnd=lowerEnd,this.displayEnd=roundToBaseUnit||expandEnd?this.end:end;this.valueEnd<this.valueStart&&(this.valueEnd=this.valueStart),this.displayEnd<=this.displayStart&&(this.displayEnd=this.roundToTotalStep(this.displayStart,!1,1))}displayRange(){return{min:this.displayStart,max:this.displayEnd}}displayIndices(){if(!this._indices){const options=this.options,{baseUnit:baseUnit,baseUnitStep:baseUnitStep}=options,minIdx=dateIndex(this.displayStart,this.valueStart,baseUnit,baseUnitStep),maxIdx=dateIndex(this.displayEnd,this.valueStart,baseUnit,baseUnitStep);this._indices={min:minIdx,max:maxIdx}}return this._indices}total(){return{min:this.start,max:this.end}}totalCount(){return this.totalIndex(this.end)+(this.options.justified?1:0)}valueRange(){return{min:this.valueStart,max:this.valueEnd}}valueIndex(value){const options=this.options;return Math.floor(dateIndex(value,this.valueStart,options.baseUnit,options.baseUnitStep))}totalIndex(value){const options=this.options;return Math.floor(dateIndex(value,this.start,options.baseUnit,options.baseUnitStep))}dateIndex(value){const options=this.options;return dateIndex(value,this.valueStart,options.baseUnit,options.baseUnitStep)}valuesCount(){return this.valueIndex(this.valueEnd)+1}values(){let values=this._values;if(!values){const options=this.options,range=this.valueRange();this._values=values=[];for(let date=range.min;date<=range.max;)values.push(date),date=addDuration(date,options.baseUnitStep,options.baseUnit,options.weekStartDay)}return values}dateAt(index,total){const options=this.options;return addDuration(total?this.start:this.valueStart,options.baseUnitStep*index,options.baseUnit,options.weekStartDay)}roundToTotalStep(value,upper,next){const{baseUnit:baseUnit,baseUnitStep:baseUnitStep,weekStartDay:weekStartDay}=this.options,start=this.start,step=dateIndex(value,start,baseUnit,baseUnitStep);let roundedStep=upper?Math.ceil(step):Math.floor(step);return next&&(roundedStep+=next),addDuration(start,roundedStep*baseUnitStep,baseUnit,weekStartDay)}}function autoBaseUnit(options,startUnit,startStep){const categoryLimits=categoryRange(options.categories),span=(options.max||categoryLimits.max)-(options.min||categoryLimits.min),{autoBaseUnitSteps:autoBaseUnitSteps,maxDateGroups:maxDateGroups}=options,autoUnit=\"fit\"===options.baseUnit;let unitSteps,step,nextStep,autoUnitIx=startUnit?BASE_UNITS.indexOf(startUnit):0,baseUnit=autoUnit?BASE_UNITS[autoUnitIx++]:options.baseUnit,units=span/TIME_PER_UNIT[baseUnit],totalUnits=units;for(;!step||units>=maxDateGroups;){unitSteps=unitSteps||autoBaseUnitSteps[baseUnit].slice(0);do{nextStep=unitSteps.shift()}while(nextStep&&startUnit===baseUnit&&nextStep<startStep);if(nextStep)step=nextStep,units=totalUnits/step;else{if(baseUnit===last(BASE_UNITS)){step=Math.ceil(totalUnits/maxDateGroups);break}if(!autoUnit){units>maxDateGroups&&(step=Math.ceil(totalUnits/maxDateGroups));break}baseUnit=BASE_UNITS[autoUnitIx++]||last(BASE_UNITS),totalUnits=span/TIME_PER_UNIT[baseUnit],unitSteps=null}}options.baseUnitStep=step,options.baseUnit=baseUnit}class date_category_axis_DateCategoryAxis extends category_axis{clone(){const copy=new date_category_axis_DateCategoryAxis(Object.assign({},this.options),this.chartService);return copy.createLabels(),copy}categoriesHash(){const start=this.dataRange.total().min;return this.options.baseUnit+this.options.baseUnitStep+start}initUserOptions(options){return options}initFields(){super.initFields();const chartService=this.chartService,intlService=chartService.intl;let options=this.options,categories=options.categories||[];if(categories._parsed||(categories=parseDates(intlService,categories),categories._parsed=!0),options=deepExtend({roundToBaseUnit:!0},options,{categories:categories,min:parse_date_parseDate(intlService,options.min),max:parse_date_parseDate(intlService,options.max),weekStartDay:first_day_firstDay(options,intlService)}),chartService.panning&&chartService.isPannable(options.vertical?Y:X)&&(options.roundToBaseUnit=!1),options.userSetBaseUnit=options.userSetBaseUnit||options.baseUnit,options.userSetBaseUnitStep=options.userSetBaseUnitStep||options.baseUnitStep,this.options=options,options.srcCategories=categories,categories.length>0){const range=categoryRange(categories),maxDivisions=options.maxDivisions;if(this.dataRange=new date_category_axis_DateRange(range.min,range.max,function(options){const baseUnit=(options.baseUnit||\"\").toLowerCase();return\"fit\"!==baseUnit&&!inArray(baseUnit,BASE_UNITS)&&function(options){const categories=options.categories,count=defined(categories)?categories.length:0;let lastCategory,unit,minDiff=MAX_VALUE;for(let categoryIx=0;categoryIx<count;categoryIx++){const category=categories[categoryIx];if(category&&lastCategory){const diff=absoluteDateDiff(category,lastCategory);diff>0&&(minDiff=Math.min(minDiff,diff),unit=minDiff>=31536e6?YEARS:minDiff>=24192e5?\"months\":minDiff>=6048e5?\"weeks\":minDiff>=864e5?DAYS:minDiff>=36e5?\"hours\":minDiff>=6e4?\"minutes\":\"seconds\")}lastCategory=category}options.baseUnit=unit||DAYS}(options),\"fit\"!==baseUnit&&\"auto\"!==options.baseUnitStep||autoBaseUnit(options),options}(options)),maxDivisions){const dataRange=this.dataRange.displayRange(),divisionOptions=Object.assign({},options,{justified:!0,roundToBaseUnit:!1,baseUnit:\"fit\",min:dataRange.min,max:dataRange.max,maxDateGroups:maxDivisions}),dataRangeOptions=this.dataRange.options;autoBaseUnit(divisionOptions,dataRangeOptions.baseUnit,dataRangeOptions.baseUnitStep),this.divisionRange=new date_category_axis_DateRange(range.min,range.max,divisionOptions)}else this.divisionRange=this.dataRange}else options.baseUnit=options.baseUnit||DAYS,this.dataRange=this.divisionRange=new EmptyDateRange(options);this.rangeLabels=[]}tickIndices(stepSize){const{dataRange:dataRange,divisionRange:divisionRange}=this,valuesCount=divisionRange.valuesCount();if(!this.options.maxDivisions||!valuesCount)return super.tickIndices(stepSize);const indices=[];let values=divisionRange.values(),offset=0;this.options.justified||(values=values.concat(divisionRange.dateAt(valuesCount)),offset=.5);for(let idx=0;idx<values.length;idx++)if(indices.push(dataRange.dateIndex(values[idx])+offset),1!==stepSize&&idx>=1){const last=indices.length-1;indices.splice(idx,0,indices[last-1]+(indices[last]-indices[last-1])*stepSize)}return indices}shouldRenderNote(value){const range=this.range(),categories=this.options.categories||[];return dateComparer(value,range.min)>=0&&dateComparer(value,range.max)<=0&&categories.length}parseNoteValue(value){return parse_date_parseDate(this.chartService.intl,value)}noteSlot(value){return this.getSlot(value)}translateRange(delta){const options=this.options,{baseUnit:baseUnit,weekStartDay:weekStartDay,vertical:vertical}=options,lineBox=this.lineBox(),size=vertical?lineBox.height():lineBox.width();let range=this.range();const offset=round(delta/(size/(range.max-range.min)),10);if(range.min&&range.max){const from=addTicks(options.min||range.min,offset),to=addTicks(options.max||range.max,offset);range={min:addDuration(from,0,baseUnit,weekStartDay),max:addDuration(to,0,baseUnit,weekStartDay)}}return range}scaleRange(delta){let rounds=Math.abs(delta),result=this.range(),{min:from,max:to}=result;if(from&&to){for(;rounds--;){const range=dateDiff(from,to),step=Math.round(.1*range);delta<0?(from=addTicks(from,step),to=addTicks(to,-step)):(from=addTicks(from,-step),to=addTicks(to,step))}result={min:from,max:to}}return result}labelsRange(){return{min:this.options.labels.skip,max:this.divisionRange.valuesCount()}}pan(delta){if(this.isEmpty())return null;const options=this.options,lineBox=this.lineBox(),size=options.vertical?lineBox.height():lineBox.width(),{min:min,max:max}=this.dataRange.displayRange(),totalLimits=this.dataRange.total(),offset=round(delta/(size/(max-min)),10)*(options.reverse?-1:1),from=addTicks(min,offset),to=addTicks(max,offset),panRange=this.limitRange(toTime(from),toTime(to),toTime(totalLimits.min),toTime(totalLimits.max),offset);return panRange?(panRange.min=toDate(panRange.min),panRange.max=toDate(panRange.max),panRange.baseUnit=options.baseUnit,panRange.baseUnitStep=options.baseUnitStep||1,panRange.userSetBaseUnit=options.userSetBaseUnit,panRange.userSetBaseUnitStep=options.userSetBaseUnitStep,panRange):void 0}pointsRange(start,end){if(this.isEmpty())return null;const pointsRange=super.pointsRange(start,end),datesRange=this.dataRange.displayRange(),indicesRange=this.dataRange.displayIndices(),scale=dateDiff(datesRange.max,datesRange.min)/(indicesRange.max-indicesRange.min),options=this.options;return{min:addTicks(datesRange.min,pointsRange.min*scale),max:addTicks(datesRange.min,pointsRange.max*scale),baseUnit:options.userSetBaseUnit||options.baseUnit,baseUnitStep:options.userSetBaseUnitStep||options.baseUnitStep}}zoomRange(delta){if(this.isEmpty())return null;const options=this.options,fit=\"fit\"===options.userSetBaseUnit,totalLimits=this.dataRange.total(),{min:rangeMin,max:rangeMax}=this.dataRange.displayRange();let{weekStartDay:weekStartDay,baseUnit:baseUnit,baseUnitStep:baseUnitStep}=this.dataRange.options,min=addDuration(rangeMin,delta*baseUnitStep,baseUnit,weekStartDay),max=addDuration(rangeMax,-delta*baseUnitStep,baseUnit,weekStartDay);if(fit){const{autoBaseUnitSteps:autoBaseUnitSteps,maxDateGroups:maxDateGroups}=options,maxDiff=last(autoBaseUnitSteps[baseUnit])*maxDateGroups*TIME_PER_UNIT[baseUnit],rangeDiff=dateDiff(rangeMax,rangeMin),diff=dateDiff(max,min);let autoBaseUnitStep,ticks,baseUnitIndex=BASE_UNITS.indexOf(baseUnit);if(diff<TIME_PER_UNIT[baseUnit]&&\"milliseconds\"!==baseUnit)baseUnit=BASE_UNITS[baseUnitIndex-1],autoBaseUnitStep=last(autoBaseUnitSteps[baseUnit]),ticks=(rangeDiff-(maxDateGroups-1)*autoBaseUnitStep*TIME_PER_UNIT[baseUnit])/2,min=addTicks(rangeMin,ticks),max=addTicks(rangeMax,-ticks);else if(diff>maxDiff&&baseUnit!==YEARS){let stepIndex=0;do{baseUnitIndex++,baseUnit=BASE_UNITS[baseUnitIndex],stepIndex=0,ticks=2*TIME_PER_UNIT[baseUnit];do{autoBaseUnitStep=autoBaseUnitSteps[baseUnit][stepIndex],stepIndex++}while(stepIndex<autoBaseUnitSteps[baseUnit].length&&ticks*autoBaseUnitStep<rangeDiff)}while(baseUnit!==YEARS&&ticks*autoBaseUnitStep<rangeDiff);ticks=(ticks*autoBaseUnitStep-rangeDiff)/2,ticks>0&&(min=addTicks(rangeMin,-ticks),max=addTicks(rangeMax,ticks),min=addTicks(min,limitValue(max,totalLimits.min,totalLimits.max)-max),max=addTicks(max,limitValue(min,totalLimits.min,totalLimits.max)-min))}}return min<totalLimits.min&&(min=totalLimits.min),max>totalLimits.max&&(max=totalLimits.max),min&&max&&dateDiff(max,min)>0?{min:min,max:max,baseUnit:options.userSetBaseUnit||options.baseUnit,baseUnitStep:options.userSetBaseUnitStep||options.baseUnitStep}:void 0}range(){return this.dataRange.displayRange()}createLabels(){super.createLabels(),this.createRangeLabels()}clearLabels(){super.clearLabels(),this.rangeLabels=[]}arrangeLabels(){this.arrangeRangeLabels(),super.arrangeLabels()}arrangeRangeLabels(){const{options:options,rangeLabels:rangeLabels}=this;if(0===rangeLabels.length)return;const lineBox=this.lineBox(),vertical=options.vertical,mirror=options.rangeLabels.mirror||options.labels.mirror,firstLabel=rangeLabels[0];if(firstLabel){const position=vertical?lineBox.y1-firstLabel.box.height()/2:lineBox.x1;this.positionLabel(firstLabel,mirror,position)}const lastLabel=rangeLabels[1];if(lastLabel){const position=vertical?lineBox.y2-lastLabel.box.height()/2:lineBox.x2;this.positionLabel(lastLabel,mirror,position)}}autoRotateLabels(){super.autoRotateLabels(),this.autoRotateRangeLabels()}hideOutOfRangeLabels(){super.hideOutOfRangeLabels(),this.hideOverlappingLabels()}hideOverlappingLabels(){const{rangeLabels:rangeLabels,labels:labels}=this;if(0===rangeLabels.length)return;function clip(rangeLabel,label){return!(label.options.visible&&!label.box.overlaps(rangeLabel.box)||(label.options.visible=!1,0))}const firstRangeLabel=rangeLabels[0];if(firstRangeLabel&&firstRangeLabel.options.visible)for(let i=0;i<labels.length&&clip(firstRangeLabel,labels[i]);i++);const lastRangeLabel=rangeLabels[1];if(lastRangeLabel&&lastRangeLabel.options.visible)for(let i=labels.length-1;i>0&&clip(lastRangeLabel,labels[i]);--i);}contentBox(){const box=super.contentBox(),rangeLabels=this.rangeLabels;for(let i=0;i<rangeLabels.length;i++){const label=rangeLabels[i];label.options.visible&&box.wrap(label.box)}return box}createAxisLabel(index,labelOptions,labelContext={}){const options=this.options,dataItem=options.dataItems&&!options.maxDivisions?options.dataItems[index]:null,date=this.divisionRange.dateAt(index);labelOptions.format=labelOptions.format||labelOptions.dateFormats[this.divisionRange.options.baseUnit],labelContext.dataItem=dataItem;const text=this.axisLabelText(date,labelOptions,labelContext);if(text)return new axis_label(date,text,index,dataItem,labelOptions)}createRangeLabels(){const{displayStart:displayStart,displayEnd:displayEnd}=this.divisionRange,options=this.options,labelOptions=Object.assign({},options.labels,options.rangeLabels,{align:CENTER,zIndex:options.zIndex});if(!0!==labelOptions.visible)return;this.normalizeLabelRotation(labelOptions),labelOptions.alignRotation=CENTER,\"auto\"===labelOptions.rotation&&(labelOptions.rotation=0,options.autoRotateRangeLabels=!0),labelOptions.format=labelOptions.format||labelOptions.dateFormats[this.divisionRange.options.baseUnit];const createLabel=(index,date,text)=>{if(text){const label=new axis_label(date,text,index,null,labelOptions);this.append(label),this.rangeLabels.push(label)}};createLabel(0,displayStart,this.axisLabelText(displayStart,labelOptions,{index:0,count:2})),createLabel(1,displayEnd,this.axisLabelText(displayEnd,labelOptions,{index:1,count:2}))}autoRotateRangeLabels(){const labels=this.rangeLabels;if(!this.options.autoRotateRangeLabels||this.options.vertical||2!==labels.length)return;const rotateLabel=(label,tickPositions,index)=>{const width=2*Math.abs(tickPositions[index+1]-tickPositions[index]),angle=this.autoRotateLabelAngle(label.box,width);0!==angle&&(label.options.rotation=angle,label.reflow(new core_box))},tickPositions=this.getMajorTickPositions();rotateLabel(labels[0],tickPositions,0),rotateLabel(labels[1],tickPositions,tickPositions.length-2)}categoryIndex(value){return this.dataRange.valueIndex(value)}slot(from,to,limit){const dateRange=this.dataRange;let start=from,end=to;start instanceof Date&&(start=dateRange.dateIndex(start)),end instanceof Date&&(end=dateRange.dateIndex(end));const slot=this.getSlot(start,end,limit);if(slot)return slot.toRect()}getSlot(a,b,limit){let start=a,end=b;return\"object\"==typeof start&&(start=this.categoryIndex(start)),\"object\"==typeof end&&(end=this.categoryIndex(end)),super.getSlot(start,end,limit)}valueRange(){const range=categoryRange(this.options.srcCategories);return{min:toDate(range.min),max:toDate(range.max)}}categoryAt(index,total){return this.dataRange.dateAt(index,total)}categoriesCount(){return this.dataRange.valuesCount()}rangeIndices(){return this.dataRange.displayIndices()}labelsBetweenTicks(){return!this.divisionRange.options.justified}prepareUserOptions(){this.isEmpty()||(this.options.categories=this.dataRange.values())}getCategory(point){const index=this.pointCategoryIndex(point);return null===index?null:this.dataRange.dateAt(index)}totalIndex(value){return this.dataRange.totalIndex(value)}currentRangeIndices(){const range=this.dataRange.valueRange();return{min:this.dataRange.totalIndex(range.min),max:this.dataRange.totalIndex(range.max)}}totalRange(){return this.dataRange.total()}totalCount(){return this.dataRange.totalCount()}isEmpty(){return!this.options.srcCategories.length}roundedRange(){if(!1!==this.options.roundToBaseUnit||this.isEmpty())return this.range();const options=this.options,datesRange=categoryRange(options.srcCategories);return new date_category_axis_DateRange(datesRange.min,datesRange.max,Object.assign({},options,{justified:!1,roundToBaseUnit:!0,justifyEnd:options.justified})).displayRange()}}setDefaultOptions(date_category_axis_DateCategoryAxis,{type:DATE,labels:{dateFormats:DateLabelFormats},rangeLabels:{visible:!1},autoBaseUnitSteps:{milliseconds:[1,10,100],seconds:[1,2,5,15,30],minutes:[1,2,5,15,30],hours:[1,2,3],days:[1,2,3],weeks:[1,2],months:[1,2,3,6],years:[1,2,3,5,10,25,50]},maxDateGroups:10});var date_category_axis=date_category_axis_DateCategoryAxis;function floor(value,step){return round(Math.floor(value/step)*step,10)}function ceil(value,step){return round(Math.ceil(value/step)*step,10)}function limitCoordinate(value){return Math.max(Math.min(value,3e5),-3e5)}const MIN_VALUE_RANGE=Math.pow(10,-9);class numeric_axis_NumericAxis extends core_axis{constructor(seriesMin,seriesMax,options,chartService){super(Object.assign({},options,{seriesMin:seriesMin,seriesMax:seriesMax}),chartService)}initUserOptions(options){const autoOptions=function(seriesMin,seriesMax,options){const narrowRange=options.narrowRange;let autoMin=function(min,max,narrow){if(!min&&!max)return 0;let axisMin;if(min>=0&&max>=0){const minValue=min===max?0:min;let diff=(max-minValue)/max;if(!1===narrow||!narrow&&diff>.2)return 0;axisMin=Math.max(0,minValue-(max-minValue)/2)}else axisMin=min;return axisMin}(seriesMin,seriesMax,narrowRange),autoMax=function(min,max,narrow){if(!min&&!max)return 1;let axisMax;if(min<=0&&max<=0){const maxValue=min===max?0:max;let diff=Math.abs((maxValue-min)/maxValue);if(!1===narrow||!narrow&&diff>.2)return 0;axisMax=Math.min(0,maxValue-(min-maxValue)/2)}else axisMax=max;return axisMax}(seriesMin,seriesMax,narrowRange);const majorUnit=autoMajorUnit(autoMin,autoMax),autoOptions={majorUnit:majorUnit};return!1!==options.roundToMajorUnit&&(autoMin<0&&remainderClose(autoMin,majorUnit,1/3)&&(autoMin-=majorUnit),autoMax>0&&remainderClose(autoMax,majorUnit,1/3)&&(autoMax+=majorUnit)),autoOptions.min=floor(autoMin,majorUnit),autoOptions.max=ceil(autoMax,majorUnit),autoOptions}(options.seriesMin,options.seriesMax,options);return this.totalOptions=function(autoOptions,options){return{min:defined(options.min)?Math.min(autoOptions.min,options.min):autoOptions.min,max:defined(options.max)?Math.max(autoOptions.max,options.max):autoOptions.max,majorUnit:autoOptions.majorUnit}}(autoOptions,options),function(autoOptions,userOptions){let userSetMin,userSetMax,options=userOptions;if(userOptions){!function(options,fields){for(let idx=0;idx<fields.length;idx++){const field=fields[idx];null===options[field]&&(options[field]=void 0)}}(userOptions,[\"min\",\"max\"]),userSetMin=defined(userOptions.min),userSetMax=defined(userOptions.max);const userSetLimits=userSetMin||userSetMax;userSetLimits&&userOptions.min===userOptions.max&&(userOptions.min>0?userOptions.min=0:userOptions.max=1),userOptions.majorUnit?(autoOptions.min=floor(autoOptions.min,userOptions.majorUnit),autoOptions.max=ceil(autoOptions.max,userOptions.majorUnit)):userSetLimits&&(options=deepExtend(autoOptions,userOptions),autoOptions.majorUnit=autoMajorUnit(options.min,options.max))}autoOptions.minorUnit=(options.majorUnit||autoOptions.majorUnit)/5;const result=deepExtend(autoOptions,options);return result.min>=result.max&&(userSetMin&&!userSetMax?result.max=result.min+result.majorUnit:!userSetMin&&userSetMax&&(result.min=result.max-result.majorUnit)),result}(autoOptions,options)}initFields(){this.totalMin=this.totalOptions.min,this.totalMax=this.totalOptions.max,this.totalMajorUnit=this.totalOptions.majorUnit,this.seriesMin=this.options.seriesMin,this.seriesMax=this.options.seriesMax}clone(){return new numeric_axis_NumericAxis(this.seriesMin,this.seriesMax,Object.assign({},this.options),this.chartService)}startValue(){return 0}range(){const options=this.options;return{min:options.min,max:options.max}}getDivisions(stepValue){if(0===stepValue)return 1;const options=this.options;return Math.floor(round((options.max-options.min)/stepValue,3))+1}getTickPositions(unit,skipUnit){const options=this.options,{vertical:vertical,reverse:reverse}=options,lineBox=this.lineBox(),step=unit*((vertical?lineBox.height():lineBox.width())/(options.max-options.min)),divisions=this.getDivisions(unit),dir=(vertical?-1:1)*(reverse?-1:1),positions=[];let pos=lineBox[(vertical?Y:X)+(1===dir?1:2)],skipStep=0;skipUnit&&(skipStep=skipUnit/unit);for(let idx=0;idx<divisions;idx++)idx%skipStep!=0&&positions.push(round(pos,3)),pos+=step*dir;return positions}getMajorTickPositions(){return this.getTickPositions(this.options.majorUnit)}getMinorTickPositions(){return this.getTickPositions(this.options.minorUnit)}getSlot(a,b,limit=!1){const options=this.options,{vertical:vertical,reverse:reverse}=options,valueAxis=vertical?Y:X,lineBox=this.lineBox(),lineStart=lineBox[valueAxis+(reverse?2:1)],step=(reverse?-1:1)*((vertical?lineBox.height():lineBox.width())/(options.max-options.min)),slotBox=new core_box(lineBox.x1,lineBox.y1,lineBox.x1,lineBox.y1);let p1,p2,start=a,end=b;return defined(start)||(start=end||0),defined(end)||(end=start||0),limit&&(start=Math.max(Math.min(start,options.max),options.min),end=Math.max(Math.min(end,options.max),options.min)),vertical?(p1=options.max-Math.max(start,end),p2=options.max-Math.min(start,end)):(p1=Math.min(start,end)-options.min,p2=Math.max(start,end)-options.min),slotBox[valueAxis+1]=limitCoordinate(lineStart+step*(reverse?p2:p1)),slotBox[valueAxis+2]=limitCoordinate(lineStart+step*(reverse?p1:p2)),slotBox}getValue(point){const options=this.options,{vertical:vertical,reverse:reverse}=options,max=Number(options.max),min=Number(options.min),valueAxis=vertical?Y:X,lineBox=this.lineBox(),lineStart=lineBox[valueAxis+(reverse?2:1)],lineSize=vertical?lineBox.height():lineBox.width(),offset=(reverse?-1:1)*(point[valueAxis]-lineStart),valueOffset=offset*((max-min)/lineSize);return offset<0||offset>lineSize?null:round(vertical?max-valueOffset:min+valueOffset,10)}translateRange(delta){const options=this.options,{vertical:vertical,reverse:reverse,max:max,min:min}=options,lineBox=this.lineBox(),size=vertical?lineBox.height():lineBox.width();let offset=round(delta/(size/(max-min)),10);return!vertical&&!reverse||vertical&&reverse||(offset=-offset),{min:min+offset,max:max+offset,offset:offset}}scaleRange(delta){const options=this.options,offset=-delta*options.majorUnit;return{min:options.min-offset,max:options.max+offset}}labelsCount(){return this.getDivisions(this.options.majorUnit)}createAxisLabel(index,labelOptions,labelContext){const options=this.options,value=round(options.min+index*options.majorUnit,10),text=this.axisLabelText(value,labelOptions,labelContext);return new axis_label(value,text,index,null,labelOptions)}shouldRenderNote(value){const range=this.range();return range.min<=value&&value<=range.max}pan(delta){const range=this.translateRange(delta);return this.limitRange(range.min,range.max,this.totalMin,this.totalMax,range.offset)}pointsRange(start,end){const startValue=this.getValue(start),endValue=this.getValue(end),min=Math.min(startValue,endValue),max=Math.max(startValue,endValue);if(this.isValidRange(min,max))return{min:min,max:max}}zoomRange(delta){const{totalMin:totalMin,totalMax:totalMax}=this,newRange=this.scaleRange(delta),min=limitValue(newRange.min,totalMin,totalMax),max=limitValue(newRange.max,totalMin,totalMax);if(this.isValidRange(min,max))return{min:min,max:max}}isValidRange(min,max){return max-min>MIN_VALUE_RANGE}}function remainderClose(value,divisor,ratio){const remainder=round(Math.abs(value%divisor),10);return 0===remainder||remainder>divisor*(1-ratio)}setDefaultOptions(numeric_axis_NumericAxis,{type:\"numeric\",min:0,max:1,vertical:!0,majorGridLines:{visible:!0,width:1,color:BLACK},labels:{format:\"#.####################\"},zIndex:1});var numeric_axis=numeric_axis_NumericAxis;class date_value_axis_DateValueAxis extends core_axis{constructor(seriesMin,seriesMax,axisOptions,chartService){const min=toDate(seriesMin),max=toDate(seriesMax),intlService=chartService.intl;let options=axisOptions||{};options=deepExtend(options||{},{min:parse_date_parseDate(intlService,options.min),max:parse_date_parseDate(intlService,options.max),axisCrossingValue:parseDates(intlService,options.axisCrossingValues||options.axisCrossingValue),weekStartDay:first_day_firstDay(options,intlService)}),options=function(seriesMin,seriesMax,options){const min=options.min||seriesMin,max=options.max||seriesMax,baseUnit=options.baseUnit||(max&&min?function(delta){let unit=\"hours\";return delta>=31536e6?unit=YEARS:delta>=26784e5?unit=\"months\":delta>=6048e5?unit=\"weeks\":delta>=864e5&&(unit=DAYS),unit}(absoluteDateDiff(max,min)):\"hours\"),baseUnitTime=TIME_PER_UNIT[baseUnit],weekStartDay=options.weekStartDay||0,autoMin=floorDate(toTime(min)-1,baseUnit,weekStartDay)||toDate(max),autoMax=ceilDate(toTime(max)+1,baseUnit,weekStartDay),majorUnit=(options.majorUnit?options.majorUnit:void 0)||ceil(autoMajorUnit(autoMin.getTime(),autoMax.getTime()),baseUnitTime)/baseUnitTime,actualUnits=duration_duration(autoMin,autoMax,baseUnit),unitsToAdd=ceil(actualUnits,majorUnit)-actualUnits,head=Math.floor(unitsToAdd/2),tail=unitsToAdd-head;return options.baseUnit||delete options.baseUnit,options.baseUnit=options.baseUnit||baseUnit,options.min=options.min||addDuration(autoMin,-head,baseUnit,weekStartDay),options.max=options.max||addDuration(autoMax,tail,baseUnit,weekStartDay),options.minorUnit=options.minorUnit||majorUnit/5,options.majorUnit=majorUnit,options}(min,max,options),super(options,chartService),this.intlService=intlService,this.seriesMin=min,this.seriesMax=max;const weekStartDay=options.weekStartDay||0;this.totalMin=toTime(floorDate(toTime(min)-1,options.baseUnit,weekStartDay)),this.totalMax=toTime(ceilDate(toTime(max)+1,options.baseUnit,weekStartDay))}clone(){return new date_value_axis_DateValueAxis(this.seriesMin,this.seriesMax,Object.assign({},this.options),this.chartService)}range(){const options=this.options;return{min:options.min,max:options.max}}getDivisions(stepValue){const options=this.options;return Math.floor(duration_duration(options.min,options.max,options.baseUnit)/stepValue+1)}getTickPositions(step){const options=this.options,vertical=options.vertical,lineBox=this.lineBox(),dir=(vertical?-1:1)*(options.reverse?-1:1),start=lineBox[(vertical?Y:X)+(1===dir?1:2)],divisions=this.getDivisions(step),timeRange=dateDiff(options.max,options.min),scale=(vertical?lineBox.height():lineBox.width())/timeRange,weekStartDay=options.weekStartDay||0,positions=[start];for(let i=1;i<divisions;i++){const pos=start+dateDiff(addDuration(options.min,i*step,options.baseUnit,weekStartDay),options.min)*scale*dir;positions.push(round(pos,3))}return positions}getMajorTickPositions(){return this.getTickPositions(this.options.majorUnit)}getMinorTickPositions(){return this.getTickPositions(this.options.minorUnit)}getSlot(a,b,limit){return numeric_axis.prototype.getSlot.call(this,parse_date_parseDate(this.intlService,a),parse_date_parseDate(this.intlService,b),limit)}getValue(point){const value=numeric_axis.prototype.getValue.call(this,point);return null!==value?toDate(value):null}labelsCount(){return this.getDivisions(this.options.majorUnit)}createAxisLabel(index,labelOptions,labelContext){const options=this.options,offset=index*options.majorUnit;let date=options.min;offset>0&&(date=addDuration(date,offset,options.baseUnit,options.weekStartDay||0)),labelOptions.format=labelOptions.format||labelOptions.dateFormats[options.baseUnit];const text=this.axisLabelText(date,labelOptions,labelContext);return new axis_label(date,text,index,null,labelOptions)}translateRange(delta,exact){const options=this.options,baseUnit=options.baseUnit,weekStartDay=options.weekStartDay||0,lineBox=this.lineBox(),size=options.vertical?lineBox.height():lineBox.width(),range=this.range(),scale=size/dateDiff(range.max,range.min),offset=round(delta/scale,10)*(options.reverse?-1:1);let from=addTicks(options.min,offset),to=addTicks(options.max,offset);return exact||(from=addDuration(from,0,baseUnit,weekStartDay),to=addDuration(to,0,baseUnit,weekStartDay)),{min:from,max:to,offset:offset}}scaleRange(delta){let{min:from,max:to}=this.options,rounds=Math.abs(delta);for(;rounds--;){const range=dateDiff(from,to),step=Math.round(.1*range);delta<0?(from=addTicks(from,step),to=addTicks(to,-step)):(from=addTicks(from,-step),to=addTicks(to,step))}return{min:from,max:to}}shouldRenderNote(value){const range=this.range();return dateComparer(value,range.min)>=0&&dateComparer(value,range.max)<=0}pan(delta){const range=this.translateRange(delta,!0),limittedRange=this.limitRange(toTime(range.min),toTime(range.max),this.totalMin,this.totalMax,range.offset);if(limittedRange)return{min:toDate(limittedRange.min),max:toDate(limittedRange.max)}}pointsRange(start,end){const startValue=this.getValue(start),endValue=this.getValue(end),min=Math.min(startValue,endValue),max=Math.max(startValue,endValue);return{min:toDate(min),max:toDate(max)}}zoomRange(delta){const range=this.scaleRange(delta);return{min:toDate(limitValue(toTime(range.min),this.totalMin,this.totalMax)),max:toDate(limitValue(toTime(range.max),this.totalMin,this.totalMax))}}}setDefaultOptions(date_value_axis_DateValueAxis,{type:DATE,majorGridLines:{visible:!0,width:1,color:BLACK},labels:{dateFormats:DateLabelFormats}});var date_value_axis=date_value_axis_DateValueAxis;class logarithmic_axis_LogarithmicAxis extends core_axis{constructor(seriesMin,seriesMax,options,chartService){const axisOptions=deepExtend({majorUnit:10,min:seriesMin,max:seriesMax},options),base=axisOptions.majorUnit,autoMax=function(max,base){const logMaxRemainder=round(log(max,base),10)%1;let autoMax;return autoMax=max<=0?base:0!==logMaxRemainder&&(logMaxRemainder<.3||logMaxRemainder>.9)?Math.pow(base,log(max,base)+.2):Math.pow(base,Math.ceil(log(max,base))),autoMax}(seriesMax,base),autoMin=function(min,max,options){const base=options.majorUnit;let autoMin=min;return min<=0?autoMin=max<=1?Math.pow(base,-2):1:options.narrowRange||(autoMin=Math.pow(base,Math.floor(log(min,base)))),autoMin}(seriesMin,seriesMax,axisOptions),range=function(autoMin,autoMax,axisOptions,options){let{min:min,max:max}=axisOptions;return defined(axisOptions.axisCrossingValue)&&axisOptions.axisCrossingValue<=0&&throwNegativeValuesError(),defined(options.max)?options.max<=0&&throwNegativeValuesError():max=autoMax,defined(options.min)?options.min<=0&&throwNegativeValuesError():min=autoMin,{min:min,max:max}}(autoMin,autoMax,axisOptions,options);axisOptions.max=range.max,axisOptions.min=range.min,axisOptions.minorUnit=options.minorUnit||round(base-1,10),super(axisOptions,chartService),this.totalMin=defined(options.min)?Math.min(autoMin,options.min):autoMin,this.totalMax=defined(options.max)?Math.max(autoMax,options.max):autoMax,this.logMin=round(log(range.min,base),10),this.logMax=round(log(range.max,base),10),this.seriesMin=seriesMin,this.seriesMax=seriesMax,this.createLabels()}clone(){return new logarithmic_axis_LogarithmicAxis(this.seriesMin,this.seriesMax,Object.assign({},this.options),this.chartService)}startValue(){return this.options.min}getSlot(a,b,limit){const{options:options,logMin:logMin,logMax:logMax}=this,{reverse:reverse,vertical:vertical,majorUnit:base}=options,valueAxis=vertical?Y:X,lineBox=this.lineBox(),lineStart=lineBox[valueAxis+(reverse?2:1)],step=(reverse?-1:1)*((vertical?lineBox.height():lineBox.width())/(logMax-logMin)),slotBox=new core_box(lineBox.x1,lineBox.y1,lineBox.x1,lineBox.y1);let p1,p2,start=a,end=b;return defined(start)||(start=end||1),defined(end)||(end=start||1),start<=0||end<=0?null:(limit&&(start=Math.max(Math.min(start,options.max),options.min),end=Math.max(Math.min(end,options.max),options.min)),start=log(start,base),end=log(end,base),vertical?(p1=logMax-Math.max(start,end),p2=logMax-Math.min(start,end)):(p1=Math.min(start,end)-logMin,p2=Math.max(start,end)-logMin),slotBox[valueAxis+1]=limitCoordinate(lineStart+step*(reverse?p2:p1)),slotBox[valueAxis+2]=limitCoordinate(lineStart+step*(reverse?p1:p2)),slotBox)}getValue(point){const{options:options,logMin:logMin,logMax:logMax}=this,{reverse:reverse,vertical:vertical,majorUnit:base}=options,lineBox=this.lineBox(),dir=vertical===reverse?1:-1,startEdge=1===dir?1:2,lineSize=vertical?lineBox.height():lineBox.width(),valueAxis=vertical?Y:X,offset=dir*(point[valueAxis]-lineBox[valueAxis+startEdge]);return offset<0||offset>lineSize?null:round(Math.pow(base,logMin+offset*((logMax-logMin)/lineSize)),10)}range(){const options=this.options;return{min:options.min,max:options.max}}scaleRange(delta){const base=this.options.majorUnit,offset=-delta;return{min:Math.pow(base,this.logMin-offset),max:Math.pow(base,this.logMax+offset)}}translateRange(delta){const{options:options,logMin:logMin,logMax:logMax}=this,{reverse:reverse,vertical:vertical,majorUnit:base}=options,lineBox=this.lineBox(),size=vertical?lineBox.height():lineBox.width();let offset=round(delta/(size/(logMax-logMin)),10);return!vertical&&!reverse||vertical&&reverse||(offset=-offset),{min:Math.pow(base,logMin+offset),max:Math.pow(base,logMax+offset),offset:offset}}labelsCount(){const floorMax=Math.floor(this.logMax);return Math.floor(floorMax-this.logMin)+1}getMajorTickPositions(){const ticks=[];return this.traverseMajorTicksPositions(position=>{ticks.push(position)},{step:1,skip:0}),ticks}createTicks(lineGroup){const options=this.options,{majorTicks:majorTicks,minorTicks:minorTicks,vertical:vertical}=options,mirror=options.labels.mirror,lineBox=this.lineBox(),tickLineOptions={vertical:vertical};function render(tickPosition,tickOptions){tickLineOptions.tickX=mirror?lineBox.x2:lineBox.x2-tickOptions.size,tickLineOptions.tickY=mirror?lineBox.y1-tickOptions.size:lineBox.y1,tickLineOptions.position=tickPosition,lineGroup.append(createAxisTick(tickLineOptions,tickOptions))}return majorTicks.visible&&this.traverseMajorTicksPositions(render,majorTicks),minorTicks.visible&&this.traverseMinorTicksPositions(render,minorTicks),[]}createGridLines(altAxis){const options=this.options,{minorGridLines:minorGridLines,majorGridLines:majorGridLines,vertical:vertical}=options,lineBox=altAxis.lineBox(),lineOptions={lineStart:lineBox[vertical?\"x1\":\"y1\"],lineEnd:lineBox[vertical?\"x2\":\"y2\"],vertical:vertical},majorTicks=[],container=this.gridLinesVisual();function render(tickPosition,gridLine){inArray(tickPosition,majorTicks)||(lineOptions.position=tickPosition,container.append(createAxisGridLine(lineOptions,gridLine)),majorTicks.push(tickPosition))}return majorGridLines.visible&&this.traverseMajorTicksPositions(render,majorGridLines),minorGridLines.visible&&this.traverseMinorTicksPositions(render,minorGridLines),container.children}traverseMajorTicksPositions(callback,tickOptions){const{lineStart:lineStart,step:step}=this._lineOptions(),{logMin:logMin,logMax:logMax}=this;for(let power=Math.ceil(logMin)+tickOptions.skip;power<=logMax;power+=tickOptions.step)callback(round(lineStart+step*(power-logMin),10),tickOptions)}traverseMinorTicksPositions(callback,tickOptions){const{min:min,max:max,minorUnit:minorUnit,majorUnit:base}=this.options,{lineStart:lineStart,step:step}=this._lineOptions(),{logMin:logMin,logMax:logMax}=this;for(let power=Math.floor(logMin);power<logMax;power++){const minorOptions=this._minorIntervalOptions(power);for(let idx=tickOptions.skip;idx<minorUnit;idx+=tickOptions.step){const value=minorOptions.value+idx*minorOptions.minorStep;if(value>max)break;value>=min&&callback(round(lineStart+step*(log(value,base)-logMin),10),tickOptions)}}}createAxisLabel(index,labelOptions,labelContext){const power=Math.ceil(this.logMin+index),value=Math.pow(this.options.majorUnit,power),text=this.axisLabelText(value,labelOptions,labelContext);return new axis_label(value,text,index,null,labelOptions)}shouldRenderNote(value){const range=this.range();return range.min<=value&&value<=range.max}pan(delta){const range=this.translateRange(delta);return this.limitRange(range.min,range.max,this.totalMin,this.totalMax,range.offset)}pointsRange(start,end){const startValue=this.getValue(start),endValue=this.getValue(end);return{min:Math.min(startValue,endValue),max:Math.max(startValue,endValue)}}zoomRange(delta){const{options:options,totalMin:totalMin,totalMax:totalMax}=this,newRange=this.scaleRange(delta),min=limitValue(newRange.min,totalMin,totalMax),max=limitValue(newRange.max,totalMin,totalMax),base=options.majorUnit,acceptOptionsRange=max>min&&options.min&&options.max&&round(log(options.max,base)-log(options.min,base),10)<1,acceptNewRange=!(options.min===totalMin&&options.max===totalMax)&&round(log(max,base)-log(min,base),10)>=1;if(acceptOptionsRange||acceptNewRange)return{min:min,max:max}}_minorIntervalOptions(power){const{minorUnit:minorUnit,majorUnit:base}=this.options,value=Math.pow(base,power);return{value:value,minorStep:(Math.pow(base,power+1)-value)/minorUnit}}_lineOptions(){const{reverse:reverse,vertical:vertical}=this.options,valueAxis=vertical?Y:X,lineBox=this.lineBox(),dir=vertical===reverse?1:-1,startEdge=1===dir?1:2;return{step:dir*((vertical?lineBox.height():lineBox.width())/(this.logMax-this.logMin)),lineStart:lineBox[valueAxis+startEdge],lineBox:lineBox}}}function throwNegativeValuesError(){throw new Error(\"Non positive values cannot be used for a logarithmic axis\")}function log(y,x){return Math.log(y)/Math.log(x)}setDefaultOptions(logarithmic_axis_LogarithmicAxis,{type:\"log\",majorUnit:10,minorUnit:1,axisCrossingValue:1,vertical:!0,majorGridLines:{visible:!0,width:1,color:BLACK},zIndex:1,_deferLabels:!0});var logarithmic_axis=logarithmic_axis_LogarithmicAxis,grid_lines_mixin={createGridLines:function(altAxis){const options=this.options,radius=Math.abs(this.box.center().y-altAxis.lineBox().y1);let majorAngles,minorAngles,gridLines=[],skipMajor=!1;return options.majorGridLines.visible&&(majorAngles=this.majorGridLineAngles(altAxis),skipMajor=!0,gridLines=this.renderMajorGridLines(majorAngles,radius,options.majorGridLines)),options.minorGridLines.visible&&(minorAngles=this.minorGridLineAngles(altAxis,skipMajor),append(gridLines,this.renderMinorGridLines(minorAngles,radius,options.minorGridLines,altAxis,skipMajor))),gridLines},renderMajorGridLines:function(angles,radius,options){return this.renderGridLines(angles,radius,options)},renderMinorGridLines:function(angles,radius,options,altAxis,skipMajor){const radiusCallback=this.radiusCallback&&this.radiusCallback(radius,altAxis,skipMajor);return this.renderGridLines(angles,radius,options,radiusCallback)},renderGridLines:function(angles,radius,options,radiusCallback){const style={stroke:{width:options.width,color:options.color,dashType:options.dashType}},center=this.box.center(),circle=new main.b.Circle([center.x,center.y],radius),container=this.gridLinesVisual();for(let i=0;i<angles.length;i++){const line=new main.a.Path(style);radiusCallback&&(circle.radius=radiusCallback(angles[i])),line.moveTo(circle.center).lineTo(circle.pointAt(angles[i]+180)),container.append(line)}return container.children},gridLineAngles:function(altAxis,size,skip,step,skipAngles){const divs=this.intervals(size,skip,step,skipAngles),options=altAxis.options,altAxisVisible=options.visible&&!1!==(options.line||{}).visible;return map_map(divs,d=>{const alpha=this.intervalAngle(d);if(!altAxisVisible||90!==alpha)return alpha})}};class radar_category_axis_RadarCategoryAxis extends category_axis{range(){return{min:0,max:this.options.categories.length}}reflow(box){this.box=box,this.reflowLabels()}lineBox(){return this.box}reflowLabels(){const{labels:labels,options:{labels:labelOptions}}=this,skip=labelOptions.skip||0,step=labelOptions.step||1,measureBox=new core_box;for(let i=0;i<labels.length;i++){labels[i].reflow(measureBox);const labelBox=labels[i].box;labels[i].reflow(this.getSlot(skip+i*step).adjacentBox(0,labelBox.width(),labelBox.height()))}}intervals(size,skipOption,stepOption,skipAngles=!1){const options=this.options,divCount=options.categories.length/size||1,divAngle=360/divCount,step=stepOption||1,divs=[];let angle=0;for(let i=skipOption||0;i<divCount;i+=step)angle=options.reverse?360-i*divAngle:i*divAngle,angle=round(angle,3)%360,skipAngles&&inArray(angle,skipAngles)||divs.push(angle);return divs}majorIntervals(){return this.intervals(1)}minorIntervals(){return this.intervals(.5)}intervalAngle(interval){return(360+interval+this.options.startAngle)%360}majorAngles(){return map_map(this.majorIntervals(),interval=>this.intervalAngle(interval))}createLine(){return[]}majorGridLineAngles(altAxis){const majorGridLines=this.options.majorGridLines;return this.gridLineAngles(altAxis,1,majorGridLines.skip,majorGridLines.step)}minorGridLineAngles(altAxis,skipMajor){const{minorGridLines:minorGridLines,majorGridLines:majorGridLines}=this.options,majorGridLineAngles=skipMajor?this.intervals(1,majorGridLines.skip,majorGridLines.step):null;return this.gridLineAngles(altAxis,.5,minorGridLines.skip,minorGridLines.step,majorGridLineAngles)}radiusCallback(radius,altAxis,skipMajor){if(altAxis.options.type!==ARC){const minorAngle=rad(360/(2*this.options.categories.length)),minorRadius=Math.cos(minorAngle)*radius,majorAngles=this.majorAngles();return function(angle){return!skipMajor&&inArray(angle,majorAngles)?radius:minorRadius}}}createPlotBands(){const plotBands=this.options.plotBands||[],group=this._plotbandGroup=new main.a.Group({zIndex:-1});for(let i=0;i<plotBands.length;i++){const band=plotBands[i],slot=this.plotBandSlot(band),singleSlot=this.getSlot(band.from),head=band.from-Math.floor(band.from);slot.startAngle+=head*singleSlot.angle;const tail=Math.ceil(band.to)-band.to;slot.angle-=(tail+head)*singleSlot.angle;const ring=shape_builder.current.createRing(slot,{fill:{color:band.color,opacity:band.opacity},stroke:{opacity:band.opacity}});group.append(ring)}this.appendVisual(group)}plotBandSlot(band){return this.getSlot(band.from,band.to-1)}getSlot(from,to){const options=this.options,justified=options.justified,box=this.box,divs=this.majorAngles(),totalDivs=divs.length,slotAngle=360/totalDivs;let fromValue=from;options.reverse&&!justified&&(fromValue=(fromValue+1)%totalDivs),fromValue=limitValue(Math.floor(fromValue),0,totalDivs-1);let slotStart=divs[fromValue];justified&&(slotStart-=slotAngle/2,slotStart<0&&(slotStart+=360));const angle=slotAngle*(limitValue(Math.ceil(to||fromValue),fromValue,totalDivs-1)-fromValue+1);return new core_ring(box.center(),0,box.height()/2,slotStart,angle)}slot(from,to){const slot=this.getSlot(from,to),startAngle=slot.startAngle+180;return new main.b.Arc([slot.center.x,slot.center.y],{startAngle:startAngle,endAngle:startAngle+slot.angle,radiusX:slot.radius,radiusY:slot.radius})}pointCategoryIndex(point){const length=this.options.categories.length;let index=null;for(let i=0;i<length;i++)if(this.getSlot(i).containsPoint(point)){index=i;break}return index}}setDefaultOptions(radar_category_axis_RadarCategoryAxis,{startAngle:90,labels:{margin:getSpacing(10)},majorGridLines:{visible:!0},justified:!0}),deepExtend(radar_category_axis_RadarCategoryAxis.prototype,grid_lines_mixin);var radar_category_axis=radar_category_axis_RadarCategoryAxis;class polar_axis_PolarAxis extends core_axis{constructor(options,chartService){super(options,chartService);const instanceOptions=this.options;instanceOptions.minorUnit=instanceOptions.minorUnit||instanceOptions.majorUnit/2}getDivisions(stepValue){return numeric_axis.prototype.getDivisions.call(this,stepValue)-1}reflow(box){this.box=box,this.reflowLabels()}reflowLabels(){const{options:options,labels:labels,options:{labels:labelOptions}}=this,skip=labelOptions.skip||0,step=labelOptions.step||1,measureBox=new core_box,divs=this.intervals(options.majorUnit,skip,step);for(let i=0;i<labels.length;i++){labels[i].reflow(measureBox);const labelBox=labels[i].box;labels[i].reflow(this.getSlot(divs[i]).adjacentBox(0,labelBox.width(),labelBox.height()))}}lineBox(){return this.box}intervals(size,skipOption,stepOption,skipAngles=!1){const min=this.options.min,divisions=this.getDivisions(size),divs=[],step=stepOption||1;for(let i=skipOption||0;i<divisions;i+=step){const current=(360+min+i*size)%360;skipAngles&&inArray(current,skipAngles)||divs.push(current)}return divs}majorIntervals(){return this.intervals(this.options.majorUnit)}minorIntervals(){return this.intervals(this.options.minorUnit)}intervalAngle(i){return(540-i-this.options.startAngle)%360}createLine(){return[]}majorGridLineAngles(altAxis){const majorGridLines=this.options.majorGridLines;return this.gridLineAngles(altAxis,this.options.majorUnit,majorGridLines.skip,majorGridLines.step)}minorGridLineAngles(altAxis,skipMajor){const options=this.options,{minorGridLines:minorGridLines,majorGridLines:majorGridLines}=options,majorGridLineAngles=skipMajor?this.intervals(options.majorUnit,majorGridLines.skip,majorGridLines.step):null;return this.gridLineAngles(altAxis,options.minorUnit,minorGridLines.skip,minorGridLines.step,majorGridLineAngles)}plotBandSlot(band){return this.getSlot(band.from,band.to)}getSlot(a,b){const{options:options,box:box}=this,startAngle=options.startAngle;let start=limitValue(a,options.min,options.max),end=limitValue(b||start,start,options.max);if(options.reverse&&(start*=-1,end*=-1),start=(540-start-startAngle)%360,end=(540-end-startAngle)%360,end<start){const tmp=start;start=end,end=tmp}return new core_ring(box.center(),0,box.height()/2,start,end-start)}slot(from,to=from){const options=this.options,start=360-options.startAngle,slot=this.getSlot(from,to),min=Math.min(from,to),max=Math.max(from,to);let startAngle,endAngle;return options.reverse?(startAngle=min,endAngle=max):(startAngle=360-max,endAngle=360-min),startAngle=(startAngle+start)%360,endAngle=(endAngle+start)%360,new main.b.Arc([slot.center.x,slot.center.y],{startAngle:startAngle,endAngle:endAngle,radiusX:slot.radius,radiusY:slot.radius})}getValue(point){const options=this.options,center=this.box.center();let theta=Math.round(deg(Math.atan2(point.y-center.y,point.x-center.x))),start=options.startAngle;return options.reverse||(theta*=-1,start*=-1),(theta+start+360)%360}valueRange(){return{min:0,max:2*Math.PI}}}setDefaultOptions(polar_axis_PolarAxis,{type:\"polar\",startAngle:0,reverse:!1,majorUnit:60,min:0,max:360,labels:{margin:getSpacing(10)},majorGridLines:{color:BLACK,visible:!0,width:1},minorGridLines:{color:\"#aaa\"}}),deepExtend(polar_axis_PolarAxis.prototype,grid_lines_mixin,{createPlotBands:radar_category_axis.prototype.createPlotBands,majorAngles:radar_category_axis.prototype.majorAngles,range:numeric_axis.prototype.range,labelsCount:numeric_axis.prototype.labelsCount,createAxisLabel:numeric_axis.prototype.createAxisLabel});var polar_axis=polar_axis_PolarAxis;function angularDistance(a,b){return 180-Math.abs(Math.abs(a-b)-180)}var radar_numeric_axis_mixin={options:{majorGridLines:{visible:!0}},createPlotBands:function(){const{majorGridLines:{type:type},plotBands:plotBands=[]}=this.options,altAxis=this.plotArea.polarAxis,majorAngles=altAxis.majorAngles(),center=altAxis.box.center(),group=this._plotbandGroup=new main.a.Group({zIndex:-1});for(let i=0;i<plotBands.length;i++){const band=plotBands[i],bandStyle={fill:{color:band.color,opacity:band.opacity},stroke:{opacity:band.opacity}},slot=this.getSlot(band.from,band.to,!0),ring=new core_ring(center,center.y-slot.y2,center.y-slot.y1,0,360);let shape;shape=type===ARC?shape_builder.current.createRing(ring,bandStyle):main.a.Path.fromPoints(this.plotBandPoints(ring,majorAngles),bandStyle).close(),group.append(shape)}this.appendVisual(group)},plotBandPoints:function(ring,angles){const innerPoints=[],outerPoints=[],center=[ring.center.x,ring.center.y],innerCircle=new main.b.Circle(center,ring.innerRadius),outerCircle=new main.b.Circle(center,ring.radius);for(let i=0;i<angles.length;i++)innerPoints.push(innerCircle.pointAt(angles[i]+180)),outerPoints.push(outerCircle.pointAt(angles[i]+180));return innerPoints.reverse(),innerPoints.push(innerPoints[0]),outerPoints.push(outerPoints[0]),outerPoints.concat(innerPoints)},createGridLines:function(altAxis){const options=this.options,majorTicks=this.radarMajorGridLinePositions(),majorAngles=altAxis.majorAngles(),center=altAxis.box.center();let gridLines=[];if(options.majorGridLines.visible&&(gridLines=this.renderGridLines(center,majorTicks,majorAngles,options.majorGridLines)),options.minorGridLines.visible){const minorTicks=this.radarMinorGridLinePositions();append(gridLines,this.renderGridLines(center,minorTicks,majorAngles,options.minorGridLines))}return gridLines},renderGridLines:function(center,ticks,angles,options){const style={stroke:{width:options.width,color:options.color,dashType:options.dashType}},{skip:skip=0,step:step=0}=options,container=this.gridLinesVisual();for(let tickIx=skip;tickIx<ticks.length;tickIx+=step){const tickRadius=center.y-ticks[tickIx];if(tickRadius>0){const circle=new main.b.Circle([center.x,center.y],tickRadius);if(options.type===ARC)container.append(new main.a.Circle(circle,style));else{const line=new main.a.Path(style);for(let angleIx=0;angleIx<angles.length;angleIx++)line.lineTo(circle.pointAt(angles[angleIx]+180));line.close(),container.append(line)}}}return container.children},getValue:function(point){const lineBox=this.lineBox(),altAxis=this.plotArea.polarAxis,majorAngles=altAxis.majorAngles(),center=altAxis.box.center(),radius=point.distanceTo(center);let distance=radius;if(this.options.majorGridLines.type!==ARC&&majorAngles.length>1){const theta=(deg(Math.atan2(point.y-center.y,point.x-center.x))+540)%360;majorAngles.sort(function(a,b){return angularDistance(a,theta)-angularDistance(b,theta)});const midAngle=angularDistance(majorAngles[0],majorAngles[1])/2,alpha=angularDistance(theta,majorAngles[0]),gamma=90-midAngle;distance=radius*(Math.sin(rad(180-alpha-gamma))/Math.sin(rad(gamma)))}return this.axisType().prototype.getValue.call(this,new core_point(lineBox.x1,lineBox.y2-distance))}};class radar_numeric_axis_RadarNumericAxis extends numeric_axis{radarMajorGridLinePositions(){return this.getTickPositions(this.options.majorUnit)}radarMinorGridLinePositions(){const options=this.options;let minorSkipStep=0;return options.majorGridLines.visible&&(minorSkipStep=options.majorUnit),this.getTickPositions(options.minorUnit,minorSkipStep)}axisType(){return numeric_axis}}deepExtend(radar_numeric_axis_RadarNumericAxis.prototype,radar_numeric_axis_mixin);var radar_numeric_axis=radar_numeric_axis_RadarNumericAxis;class radar_logarithmic_axis_RadarLogarithmicAxis extends logarithmic_axis{radarMajorGridLinePositions(){const positions=[];return this.traverseMajorTicksPositions(function(position){positions.push(position)},this.options.majorGridLines),positions}radarMinorGridLinePositions(){const positions=[];return this.traverseMinorTicksPositions(function(position){positions.push(position)},this.options.minorGridLines),positions}axisType(){return logarithmic_axis}}deepExtend(radar_logarithmic_axis_RadarLogarithmicAxis.prototype,radar_numeric_axis_mixin);var radar_logarithmic_axis=radar_logarithmic_axis_RadarLogarithmicAxis;function numberSign(value){return value<=0?-1:1}var curve_processor=class extends common_class.a{constructor(closed){super(),this.closed=closed}process(dataPoints){const points=dataPoints.slice(0),segments=[];let closed=this.closed,length=points.length;if(length>2&&(this.removeDuplicates(0,points),length=points.length),length<2||2===length&&points[0].equals(points[1]))return segments;let initialControlPoint,lastControlPoint,p0=points[0],p1=points[1],p2=points[2];for(segments.push(new main.b.Segment(p0));p0.equals(points[length-1]);)closed=!0,points.pop(),length--;if(2===length){const tangent=this.tangent(p0,p1,X,Y);return last(segments).controlOut(this.firstControlPoint(tangent,p0,p1,X,Y)),segments.push(new main.b.Segment(p1,this.secondControlPoint(tangent,p0,p1,X,Y))),segments}if(closed){p0=points[length-1],p1=points[0],p2=points[1];const controlPoints=this.controlPoints(p0,p1,p2);initialControlPoint=controlPoints[1],lastControlPoint=controlPoints[0]}else{const tangent=this.tangent(p0,p1,X,Y);initialControlPoint=this.firstControlPoint(tangent,p0,p1,X,Y)}let cp0=initialControlPoint;for(let idx=0;idx<=length-3;idx++)if(this.removeDuplicates(idx,points),length=points.length,idx+3<=length){p0=points[idx],p1=points[idx+1],p2=points[idx+2];const controlPoints=this.controlPoints(p0,p1,p2);last(segments).controlOut(cp0),cp0=controlPoints[1],segments.push(new main.b.Segment(p1,controlPoints[0]))}if(closed){p0=points[length-2],p1=points[length-1],p2=points[0];const controlPoints=this.controlPoints(p0,p1,p2);last(segments).controlOut(cp0),segments.push(new main.b.Segment(p1,controlPoints[0])),last(segments).controlOut(controlPoints[1]),segments.push(new main.b.Segment(p2,lastControlPoint))}else{const tangent=this.tangent(p1,p2,X,Y);last(segments).controlOut(cp0),segments.push(new main.b.Segment(p2,this.secondControlPoint(tangent,p1,p2,X,Y)))}return segments}removeDuplicates(idx,points){for(;points[idx+1]&&(points[idx].equals(points[idx+1])||points[idx+1].equals(points[idx+2]));)points.splice(idx+1,1)}invertAxis(p0,p1,p2){let invertAxis=!1;if(p0.x===p1.x)invertAxis=!0;else if(p1.x===p2.x)(p1.y<p2.y&&p0.y<=p1.y||p2.y<p1.y&&p1.y<=p0.y)&&(invertAxis=!0);else{const fn=this.lineFunction(p0,p1),y2=this.calculateFunction(fn,p2.x);p0.y<=p1.y&&p2.y<=y2||p1.y<=p0.y&&p2.y>=y2||(invertAxis=!0)}return invertAxis}isLine(p0,p1,p2){const fn=this.lineFunction(p0,p1),y2=this.calculateFunction(fn,p2.x);return p0.x===p1.x&&p1.x===p2.x||round(y2,1)===round(p2.y,1)}lineFunction(p1,p2){const a=(p2.y-p1.y)/(p2.x-p1.x);return[p1.y-a*p1.x,a]}controlPoints(p0,p1,p2){let tangent,xField=X,yField=Y,restrict=!1,switchOrientation=!1;if(this.isLine(p0,p1,p2))tangent=this.tangent(p0,p1,X,Y);else{const monotonic={x:this.isMonotonicByField(p0,p1,p2,X),y:this.isMonotonicByField(p0,p1,p2,Y)};if(monotonic.x&&monotonic.y)tangent=this.tangent(p0,p2,X,Y),restrict=!0;else if(this.invertAxis(p0,p1,p2)&&(xField=Y,yField=X),monotonic[xField])tangent=0;else{let sign;sign=p2[yField]<p0[yField]&&p0[yField]<=p1[yField]||p0[yField]<p2[yField]&&p1[yField]<=p0[yField]?numberSign((p2[yField]-p0[yField])*(p1[xField]-p0[xField])):-numberSign((p2[xField]-p0[xField])*(p1[yField]-p0[yField])),tangent=.01*sign,switchOrientation=!0}}const secondControlPoint=this.secondControlPoint(tangent,p0,p1,xField,yField);if(switchOrientation){const oldXField=xField;xField=yField,yField=oldXField}const firstControlPoint=this.firstControlPoint(tangent,p1,p2,xField,yField);return restrict&&(this.restrictControlPoint(p0,p1,secondControlPoint,tangent),this.restrictControlPoint(p1,p2,firstControlPoint,tangent)),[secondControlPoint,firstControlPoint]}restrictControlPoint(p1,p2,cp,tangent){p1.y<p2.y?p2.y<cp.y?(cp.x=p1.x+(p2.y-p1.y)/tangent,cp.y=p2.y):cp.y<p1.y&&(cp.x=p2.x-(p2.y-p1.y)/tangent,cp.y=p1.y):cp.y<p2.y?(cp.x=p1.x-(p1.y-p2.y)/tangent,cp.y=p2.y):p1.y<cp.y&&(cp.x=p2.x+(p1.y-p2.y)/tangent,cp.y=p1.y)}tangent(p0,p1,xField,yField){const x=p1[xField]-p0[xField];let tangent;return tangent=0===x?0:(p1[yField]-p0[yField])/x,tangent}isMonotonicByField(p0,p1,p2,field){return p2[field]>p1[field]&&p1[field]>p0[field]||p2[field]<p1[field]&&p1[field]<p0[field]}firstControlPoint(tangent,p0,p3,xField,yField){const t1=p0[xField],distance=.333*(p3[xField]-t1);return this.point(t1+distance,p0[yField]+distance*tangent,xField,yField)}secondControlPoint(tangent,p0,p3,xField,yField){const t2=p3[xField],distance=.333*(t2-p0[xField]);return this.point(t2-distance,p3[yField]-distance*tangent,xField,yField)}point(xValue,yValue,xField,yField){const controlPoint=new main.b.Point;return controlPoint[xField]=xValue,controlPoint[yField]=yValue,controlPoint}calculateFunction(fn,x){const length=fn.length;let result=0;for(let i=0;i<length;i++)result+=Math.pow(x,i)*fn[i];return result}},chart_axis=class extends common_class.a{constructor(axis){super(),this._axis=axis,this.options=axis.options}value(point){const axis=this._axis;return axis.getCategory?axis.getCategory(point):axis.getValue(point)}slot(from,to,limit=!0){return this._axis.slot(from,to,limit)}range(){return this._axis.range()}valueRange(){return this._axis.valueRange()}};function findAxisByName(name,axes){for(let idx=0;idx<axes.length;idx++)if(axes[idx].options.name===name)return axes[idx].prepareUserOptions(),new chart_axis(axes[idx])}var chart_pane=class{constructor(pane){this.visual=pane.visual,this.chartsVisual=pane.chartContainer.visual,this._pane=pane}findAxisByName(name){return findAxisByName(name,this._pane.axes)}},chart_plotarea=class extends common_class.a{constructor(plotArea){super(),this._plotArea=plotArea,this.visual=plotArea.visual,this.backgroundVisual=plotArea._bgVisual}};function countNumbers(values){const length=values.length;let count=0;for(let i=0;i<length;i++)isNumber(values[i])&&count++;return count}const Aggregates={min:function(values){const length=values.length;let min=MAX_VALUE;for(let i=0;i<length;i++){const value=values[i];isNumber(value)&&(min=Math.min(min,value))}return min===MAX_VALUE?values[0]:min},max:function(values){const length=values.length;let max=MIN_VALUE;for(let i=0;i<length;i++){const value=values[i];isNumber(value)&&(max=Math.max(max,value))}return max===MIN_VALUE?values[0]:max},sum:function(values){const length=values.length;let sum=0;for(let i=0;i<length;i++){const value=values[i];isNumber(value)&&(sum+=value)}return sum},sumOrNull:function(values){let result=null;return countNumbers(values)&&(result=Aggregates.sum(values)),result},count:function(values){const length=values.length;let count=0;for(let i=0;i<length;i++){const value=values[i];null!==value&&defined(value)&&count++}return count},avg:function(values){const count=countNumbers(values);let result=values[0];return count>0&&(result=Aggregates.sum(values)/count),result},first:function(values){const length=values.length;for(let i=0;i<length;i++){const value=values[i];if(null!==value&&defined(value))return value}return values[0]}};var aggregates=Aggregates;function getField(field,row){return null===row?row:getter_getter(field)(row)}var series_binder=(()=>{class SeriesBinder extends common_class.a{constructor(){super(),this._valueFields={},this._otherFields={},this._nullValue={},this._undefinedValue={}}register(seriesTypes,valueFields=[VALUE],otherFields={}){for(let i=0;i<seriesTypes.length;i++){const type=seriesTypes[i];this._valueFields[type]=valueFields,this._otherFields[type]=otherFields,this._nullValue[type]=this._makeValue(valueFields,null),this._undefinedValue[type]=this._makeValue(valueFields,void 0)}}canonicalFields(series){return this.valueFields(series).concat(this.otherFields(series))}valueFields(series){return this._valueFields[series.type]||[VALUE]}otherFields(series){return this._otherFields[series.type]||[VALUE]}bindPoint(series,pointIx,item){const data=series.data,pointData=defined(item)?item:data[pointIx],result={valueFields:{value:pointData}},valueFields=this.valueFields(series),otherFields=this._otherFields[series.type];let fields,value;if(null===pointData)value=this._nullValue[series.type];else if(defined(pointData)){if(Array.isArray(pointData)){const fieldData=pointData.slice(valueFields.length);value=this._bindFromArray(pointData,valueFields),fields=this._bindFromArray(fieldData,otherFields)}else if(\"object\"==typeof pointData){const srcValueFields=this.sourceFields(series,valueFields),srcPointFields=this.sourceFields(series,otherFields);value=this._bindFromObject(pointData,valueFields,srcValueFields),fields=this._bindFromObject(pointData,otherFields,srcPointFields)}}else value=this._undefinedValue[series.type];return defined(value)&&(1===valueFields.length?result.valueFields.value=value[valueFields[0]]:result.valueFields=value),result.fields=fields||{},result}_makeValue(fields,initialValue){const value={},length=fields.length;for(let i=0;i<length;i++)value[fields[i]]=initialValue;return value}_bindFromArray(array,fields){const value={};if(fields){const length=Math.min(fields.length,array.length);for(let i=0;i<length;i++)value[fields[i]]=array[i]}return value}_bindFromObject(object,fields,srcFields=fields){const value={};if(fields){const length=fields.length;for(let i=0;i<length;i++){const fieldName=fields[i],srcFieldName=srcFields[i];null!==srcFieldName&&(value[fieldName]=getField(srcFieldName,object))}}return value}sourceFields(series,canonicalFields){const sourceFields=[];if(canonicalFields){const length=canonicalFields.length;for(let i=0;i<length;i++){const fieldName=canonicalFields[i],sourceFieldName=fieldName===VALUE?\"field\":fieldName+\"Field\";sourceFields.push(null!==series[sourceFieldName]?series[sourceFieldName]||fieldName:null)}}return sourceFields}}return SeriesBinder.current=new SeriesBinder,SeriesBinder})();const percentRegex=/percent(?:\\w*)\\((\\d+)\\)/,standardDeviationRegex=new RegExp(\"^stddev(?:\\\\((\\\\d+(?:\\\\.\\\\d+)?)\\\\))?$\");var error_range_calculator=class extends common_class.a{constructor(errorValue,series,field){super(),this.initGlobalRanges(errorValue,series,field)}initGlobalRanges(errorValue,series,field){const data=series.data,deviationMatch=standardDeviationRegex.exec(errorValue);if(deviationMatch){this.valueGetter=this.createValueGetter(series,field);const average=this.getAverage(data),deviation=this.getStandardDeviation(data,average,!1),multiple=deviationMatch[1]?parseFloat(deviationMatch[1]):1,errorRange={low:average.value-deviation*multiple,high:average.value+deviation*multiple};this.globalRange=function(){return errorRange}}else if(errorValue.indexOf&&errorValue.indexOf(\"stderr\")>=0){this.valueGetter=this.createValueGetter(series,field);const standardError=this.getStandardError(data,this.getAverage(data));this.globalRange=function(value){return{low:value-standardError,high:value+standardError}}}}createValueGetter(series,field){const data=series.data,binder=series_binder.current,valueFields=binder.valueFields(series),item=defined(data[0])?data[0]:{};let valueGetter;return isArray(item)?valueGetter=getter_getter(\"[\"+(field?valueFields.indexOf(field):0)+\"]\"):isNumber(item)?valueGetter=getter_getter():\"object\"==typeof item&&(valueGetter=getter_getter(binder.sourceFields(series,valueFields)[valueFields.indexOf(field)])),valueGetter}getErrorRange(pointValue,errorValue){let low,high,value;if(!defined(errorValue))return null;if(this.globalRange)return this.globalRange(pointValue);if(isArray(errorValue))low=pointValue-errorValue[0],high=pointValue+errorValue[1];else if(isNumber(value=parseFloat(errorValue)))low=pointValue-value,high=pointValue+value;else{if(!(value=percentRegex.exec(errorValue)))throw new Error(\"Invalid ErrorBar value: \"+errorValue);{const percentValue=pointValue*(parseFloat(value[1])/100);low=pointValue-Math.abs(percentValue),high=pointValue+Math.abs(percentValue)}}return{low:low,high:high}}getStandardError(data,average){return this.getStandardDeviation(data,average,!0)/Math.sqrt(average.count)}getStandardDeviation(data,average,isSample){const length=data.length,total=isSample?average.count-1:average.count;let squareDifferenceSum=0;for(let idx=0;idx<length;idx++){const value=this.valueGetter(data[idx]);isNumber(value)&&(squareDifferenceSum+=Math.pow(value-average.value,2))}return Math.sqrt(squareDifferenceSum/total)}getAverage(data){const length=data.length;let sum=0,count=0;for(let idx=0;idx<length;idx++){const value=this.valueGetter(data[idx]);isNumber(value)&&(sum+=value,count++)}return{value:sum/count,count:count}}};const START_SCALE=(__webpack_require__(\"/EQf\").a.browser||{}).msie?.001:0,ZERO=\"zero\",BAR=\"bar\",COLUMN=\"column\",LINE=\"line\",PIE=\"pie\",VERTICAL_LINE=\"verticalLine\",EQUALLY_SPACED_SERIES=[BAR,COLUMN,\"ohlc\",\"candlestick\",\"boxPlot\",\"verticalBoxPlot\",\"bullet\",\"rangeColumn\",\"rangeBar\",\"waterfall\",\"horizontalWaterfall\"],MOUSEWHEEL=\"DOMMouseScroll mousewheel\";class error_bar_base_ErrorBarBase extends chart_element{constructor(low,high,isVertical,chart,series,options){super(options),this.low=low,this.high=high,this.isVertical=isVertical,this.chart=chart,this.series=series}reflow(targetBox){const endCaps=this.options.endCaps,isVertical=this.isVertical,valueBox=this.getAxis().getSlot(this.low,this.high),centerBox=targetBox.center(),capsWidth=this.getCapsWidth(targetBox,isVertical),capValue=isVertical?centerBox.x:centerBox.y,capStart=capValue-capsWidth,capEnd=capValue+capsWidth;let linePoints;isVertical?(linePoints=[new core_point(centerBox.x,valueBox.y1),new core_point(centerBox.x,valueBox.y2)],endCaps&&linePoints.push(new core_point(capStart,valueBox.y1),new core_point(capEnd,valueBox.y1),new core_point(capStart,valueBox.y2),new core_point(capEnd,valueBox.y2)),this.box=new core_box(capStart,valueBox.y1,capEnd,valueBox.y2)):(linePoints=[new core_point(valueBox.x1,centerBox.y),new core_point(valueBox.x2,centerBox.y)],endCaps&&linePoints.push(new core_point(valueBox.x1,capStart),new core_point(valueBox.x1,capEnd),new core_point(valueBox.x2,capStart),new core_point(valueBox.x2,capEnd)),this.box=new core_box(valueBox.x1,capStart,valueBox.x2,capEnd)),this.linePoints=linePoints}getCapsWidth(box,isVertical){const boxSize=isVertical?box.width():box.height();return Math.min(Math.floor(boxSize/2),4)||4}createVisual(){const options=this.options,visual=options.visual;visual?this.visual=visual({low:this.low,high:this.high,rect:this.box.toRect(),sender:this.getSender(),options:{endCaps:options.endCaps,color:options.color,line:options.line},createVisual:()=>{this.createDefaultVisual();const defaultVisual=this.visual;return delete this.visual,defaultVisual}}):this.createDefaultVisual()}createDefaultVisual(){const{options:options,linePoints:linePoints}=this,lineOptions={stroke:{color:options.color,width:options.line.width,dashType:options.line.dashType}};super.createVisual();for(let idx=0;idx<linePoints.length;idx+=2){const line=new main.a.Path(lineOptions).moveTo(linePoints[idx].x,linePoints[idx].y).lineTo(linePoints[idx+1].x,linePoints[idx+1].y);alignPathToPixel(line),this.visual.append(line)}}}setDefaultOptions(error_bar_base_ErrorBarBase,{animation:{type:\"fadeIn\",delay:600},endCaps:!0,line:{width:2},zIndex:1});var error_bar_base=error_bar_base_ErrorBarBase,categorical_error_bar=class extends error_bar_base{getAxis(){return this.chart.seriesValueAxis(this.series)}};function evalOptions(options,context,state={},dryRun=!1){const defaults=state.defaults=state.defaults||{},depth=state.depth=state.depth||0;let needsEval=!1;if(state.excluded=state.excluded||[],depth>5)return null;for(let property in options)if(!inArray(property,state.excluded)&&options.hasOwnProperty(property)){const propValue=options[property];isFunction(propValue)?(needsEval=!0,dryRun||(options[property]=valueOrDefault(propValue(context),defaults[property]))):isObject(propValue)&&(dryRun||(state.defaults=defaults[property]),state.depth++,needsEval=evalOptions(propValue,context,state,dryRun)||needsEval,state.depth--)}return needsEval}function categoriesCount(series){const seriesCount=series.length;let categories=0;for(let i=0;i<seriesCount;i++)categories=Math.max(categories,series[i].data.length);return categories}class categorical_chart_CategoricalChart extends chart_element{constructor(plotArea,options){super(options),this.plotArea=plotArea,this.chartService=plotArea.chartService,this.categoryAxis=plotArea.seriesCategoryAxis(options.series[0]),this.valueAxisRanges={},this.points=[],this.categoryPoints=[],this.seriesPoints=[],this.seriesOptions=[],this._evalSeries=[],this.render()}render(){this.traverseDataPoints(this.addValue.bind(this))}pointOptions(series,seriesIx){let options=this.seriesOptions[seriesIx];if(!options){const defaults=this.pointType().prototype.defaults;this.seriesOptions[seriesIx]=options=deepExtend({},defaults,{vertical:!this.options.invertAxes},series)}return options}plotValue(point){if(!point)return 0;if(this.options.isStacked100&&isNumber(point.value)){const categoryPoints=this.categoryPoints[point.categoryIx],otherValues=[];let categorySum=0;for(let i=0;i<categoryPoints.length;i++){const other=categoryPoints[i];if(other){const stack=point.series.stack,otherStack=other.series.stack;if(stack&&otherStack&&stack.group!==otherStack.group)continue;isNumber(other.value)&&(categorySum+=Math.abs(other.value),otherValues.push(Math.abs(other.value)))}}if(categorySum>0)return point.value/categorySum}return point.value}plotRange(point,startValue=0){const categoryPoints=this.categoryPoints[point.categoryIx];if(this.options.isStacked){let plotValue=this.plotValue(point);const positive=plotValue>=0;let prevValue=startValue,isStackedBar=!1;for(let i=0;i<categoryPoints.length;i++){const other=categoryPoints[i];if(point===other)break;const stack=point.series.stack,otherStack=other.series.stack;if(stack&&otherStack){if(\"string\"==typeof stack&&stack!==otherStack)continue;if(stack.group&&stack.group!==otherStack.group)continue}const otherValue=this.plotValue(other);(otherValue>=0&&positive||otherValue<0&&!positive)&&(prevValue+=otherValue,plotValue+=otherValue,isStackedBar=!0,this.options.isStacked100&&(plotValue=Math.min(plotValue,1)))}return isStackedBar&&(prevValue-=startValue),[prevValue,plotValue]}const valueAxis=this.seriesValueAxis(point.series),axisCrossingValue=this.categoryAxisCrossingValue(valueAxis);return[axisCrossingValue,convertableToNumber(point.value)?point.value:axisCrossingValue]}stackLimits(axisName,stackName){let min=MAX_VALUE,max=MIN_VALUE;for(let i=0;i<this.categoryPoints.length;i++){const categoryPoints=this.categoryPoints[i];if(categoryPoints)for(let pIx=0;pIx<categoryPoints.length;pIx++){const point=categoryPoints[pIx];if(point&&(point.series.stack===stackName||point.series.axis===axisName)){const to=this.plotRange(point,0)[1];defined(to)&&isFinite(to)&&(max=Math.max(max,to),min=Math.min(min,to))}}}return{min:min,max:max}}updateStackRange(){const{isStacked:isStacked,series:chartSeries}=this.options,limitsCache={};if(isStacked)for(let i=0;i<chartSeries.length;i++){const series=chartSeries[i],axisName=series.axis,key=axisName+series.stack;let limits=limitsCache[key];if(!limits){limits=this.stackLimits(axisName,series.stack);const errorTotals=this.errorTotals;errorTotals&&(errorTotals.negative.length&&(limits.min=Math.min(limits.min,sparseArrayLimits(errorTotals.negative).min)),errorTotals.positive.length&&(limits.max=Math.max(limits.max,sparseArrayLimits(errorTotals.positive).max))),limits.min!==MAX_VALUE||limits.max!==MIN_VALUE?limitsCache[key]=limits:limits=null}limits&&(this.valueAxisRanges[axisName]=limits)}}addErrorBar(point,data,categoryIx){const{value:value,series:series,seriesIx:seriesIx}=point,errorBars=point.options.errorBars,lowValue=data.fields.errorLow,highValue=data.fields.errorHigh;let errorRange;isNumber(lowValue)&&isNumber(highValue)?errorRange={low:lowValue,high:highValue}:errorBars&&defined(errorBars.value)&&(this.seriesErrorRanges=this.seriesErrorRanges||[],this.seriesErrorRanges[seriesIx]=this.seriesErrorRanges[seriesIx]||new error_range_calculator(errorBars.value,series,VALUE),errorRange=this.seriesErrorRanges[seriesIx].getErrorRange(value,errorBars.value)),errorRange&&(point.low=errorRange.low,point.high=errorRange.high,this.addPointErrorBar(point,categoryIx))}addPointErrorBar(point,categoryIx){const isVertical=!this.options.invertAxes,options=point.options.errorBars;let{series:series,low:low,high:high}=point;if(this.options.isStacked){const stackedErrorRange=this.stackedErrorRange(point,categoryIx);low=stackedErrorRange.low,high=stackedErrorRange.high}else{const fields={categoryIx:categoryIx,series:series};this.updateRange({value:low},fields),this.updateRange({value:high},fields)}const errorBar=new categorical_error_bar(low,high,isVertical,this,series,options);point.errorBars=[errorBar],point.append(errorBar)}stackedErrorRange(point,categoryIx){const plotValue=this.plotRange(point,0)[1]-point.value,low=point.low+plotValue,high=point.high+plotValue;return this.errorTotals=this.errorTotals||{positive:[],negative:[]},low<0&&(this.errorTotals.negative[categoryIx]=Math.min(this.errorTotals.negative[categoryIx]||0,low)),high>0&&(this.errorTotals.positive[categoryIx]=Math.max(this.errorTotals.positive[categoryIx]||0,high)),{low:low,high:high}}addValue(data,fields){const{categoryIx:categoryIx,series:series,seriesIx:seriesIx}=fields;let categoryPoints=this.categoryPoints[categoryIx];categoryPoints||(this.categoryPoints[categoryIx]=categoryPoints=[]);let seriesPoints=this.seriesPoints[seriesIx];seriesPoints||(this.seriesPoints[seriesIx]=seriesPoints=[]);const point=this.createPoint(data,fields);point&&(Object.assign(point,fields),point.owner=this,point.noteText=data.fields.noteText,defined(point.dataItem)||(point.dataItem=series.data[categoryIx]),this.addErrorBar(point,data,categoryIx)),this.points.push(point),seriesPoints.push(point),categoryPoints.push(point),this.updateRange(data.valueFields,fields)}evalPointOptions(options,value,category,categoryIx,series,seriesIx){const state={defaults:series._defaults,excluded:[\"data\",\"aggregate\",\"_events\",\"tooltip\",\"content\",\"template\",\"visual\",\"toggle\",\"_outOfRangeMinPoint\",\"_outOfRangeMaxPoint\"]};let doEval=this._evalSeries[seriesIx];defined(doEval)||(this._evalSeries[seriesIx]=doEval=evalOptions(options,{},state,!0));let pointOptions=options;return doEval&&(pointOptions=deepExtend({},pointOptions),evalOptions(pointOptions,{value:value,category:category,index:categoryIx,series:series,dataItem:series.data[categoryIx]},state)),pointOptions}updateRange(data,fields){const axisName=fields.series.axis,value=data.value;let axisRange=this.valueAxisRanges[axisName];isFinite(value)&&null!==value&&(axisRange=this.valueAxisRanges[axisName]=axisRange||{min:MAX_VALUE,max:MIN_VALUE},axisRange.min=Math.min(axisRange.min,value),axisRange.max=Math.max(axisRange.max,value))}seriesValueAxis(series){const plotArea=this.plotArea,axisName=series.axis,axis=axisName?plotArea.namedValueAxes[axisName]:plotArea.valueAxis;if(!axis)throw new Error(\"Unable to locate value axis with name \"+axisName);return axis}reflow(targetBox){const categorySlots=this.categorySlots=[],chartPoints=this.points,categoryAxis=this.categoryAxis;let pointIx=0;this.traverseDataPoints((data,fields)=>{const{categoryIx:categoryIx,series:currentSeries}=fields,valueAxis=this.seriesValueAxis(currentSeries),point=chartPoints[pointIx++];let categorySlot=categorySlots[categoryIx];if(categorySlot||(categorySlots[categoryIx]=categorySlot=this.categorySlot(categoryAxis,categoryIx,valueAxis)),point){const plotRange=this.plotRange(point,valueAxis.startValue()),valueSlot=this.valueSlot(valueAxis,plotRange);if(valueSlot){const pointSlot=this.pointSlot(categorySlot,valueSlot);point.aboveAxis=this.aboveAxis(point,valueAxis),point.stackValue=plotRange[1],this.options.isStacked100&&(point.percentage=this.plotValue(point)),this.reflowPoint(point,pointSlot)}else point.visible=!1}}),this.reflowCategories(categorySlots),!this.options.clip&&this.options.limitPoints&&this.points.length&&this.limitPoints(),this.box=targetBox}valueSlot(valueAxis,plotRange){return valueAxis.getSlot(plotRange[0],plotRange[1],!this.options.clip)}limitPoints(){const categoryPoints=this.categoryPoints,points=categoryPoints[0].concat(last(categoryPoints));for(let idx=0;idx<points.length;idx++)points[idx]&&this.limitPoint(points[idx])}limitPoint(point){const limittedSlot=this.categoryAxis.limitSlot(point.box);limittedSlot.equals(point.box)||point.reflow(limittedSlot)}aboveAxis(point,valueAxis){const axisCrossingValue=this.categoryAxisCrossingValue(valueAxis),value=point.value;return valueAxis.options.reverse?value<axisCrossingValue:value>=axisCrossingValue}categoryAxisCrossingValue(valueAxis){const categoryAxis=this.categoryAxis,options=valueAxis.options;return[].concat(options.axisCrossingValues||options.axisCrossingValue)[categoryAxis.axisIndex||0]||0}reflowPoint(point,pointSlot){point.reflow(pointSlot)}reflowCategories(){}pointSlot(categorySlot,valueSlot){const invertAxes=this.options.invertAxes,slotX=invertAxes?valueSlot:categorySlot,slotY=invertAxes?categorySlot:valueSlot;return new core_box(slotX.x1,slotY.y1,slotX.x2,slotY.y2)}categorySlot(categoryAxis,categoryIx){return categoryAxis.getSlot(categoryIx)}traverseDataPoints(callback){const series=this.options.series,count=categoriesCount(series),seriesCount=series.length;for(let seriesIx=0;seriesIx<seriesCount;seriesIx++)this._outOfRangeCallback(series[seriesIx],\"_outOfRangeMinPoint\",seriesIx,callback);for(let categoryIx=0;categoryIx<count;categoryIx++)for(let seriesIx=0;seriesIx<seriesCount;seriesIx++){const currentSeries=series[seriesIx],currentCategory=this.categoryAxis.categoryAt(categoryIx);callback(this._bindPoint(currentSeries,seriesIx,categoryIx),{category:currentCategory,categoryIx:categoryIx,categoriesCount:count,series:currentSeries,seriesIx:seriesIx})}for(let seriesIx=0;seriesIx<seriesCount;seriesIx++)this._outOfRangeCallback(series[seriesIx],\"_outOfRangeMaxPoint\",seriesIx,callback)}_outOfRangeCallback(series,field,seriesIx,callback){const outOfRangePoint=series[field];if(outOfRangePoint){const categoryIx=outOfRangePoint.categoryIx;callback(this._bindPoint(series,seriesIx,categoryIx,outOfRangePoint.item),{category:outOfRangePoint.category,categoryIx:categoryIx,series:series,seriesIx:seriesIx,dataItem:outOfRangePoint.item})}}_bindPoint(series,seriesIx,categoryIx,item){this._bindCache||(this._bindCache=[]);let bindCache=this._bindCache[seriesIx];bindCache||(bindCache=this._bindCache[seriesIx]=[]);let data=bindCache[categoryIx];return data||(data=bindCache[categoryIx]=series_binder.current.bindPoint(series,categoryIx,item)),data}formatPointValue(point,format){return null===point.value?\"\":this.chartService.format.auto(format,point.value)}pointValue(data){return data.valueFields.value}}setDefaultOptions(categorical_chart_CategoricalChart,{series:[],invertAxes:!1,isStacked:!1,clip:!0,limitPoints:!0});var categorical_chart=categorical_chart_CategoricalChart,color_color=__webpack_require__(\"QUbS\"),point_events_mixin={click:function(chart,e){return chart.trigger(\"seriesClick\",this.eventArgs(e))},hover:function(chart,e){return chart.trigger(\"seriesHover\",this.eventArgs(e))},over:function(chart,e){return chart.trigger(\"seriesOver\",this.eventArgs(e))},out:function(chart,e){return chart.trigger(\"seriesLeave\",this.eventArgs(e))},eventArgs:function(e){return{value:this.value,percentage:this.percentage,stackValue:this.stackValue,category:this.category,series:this.series,dataItem:this.dataItem,runningTotal:this.runningTotal,total:this.total,element:eventElement(e),originalEvent:e,point:this}}},note_mixin={createNote:function(){const options=this.options.notes,text=this.noteText||options.label.text;!1!==options.visible&&defined(text)&&null!==text&&(this.note=new core_note({value:this.value,text:text,dataItem:this.dataItem,category:this.category,series:this.series},this.options.notes,this.owner.chartService),this.append(this.note))}};class line_point_LinePoint extends chart_element{constructor(value,options){super(),this.value=value,this.options=options,this.aboveAxis=valueOrDefault(this.options.aboveAxis,!0),this.tooltipTracking=!0}render(){const{markers:markers,labels:labels}=this.options;if(!this._rendered){if(this._rendered=!0,markers.visible&&markers.size&&(this.marker=this.createMarker(),this.append(this.marker)),labels.visible){const labelTemplate=getTemplate(labels),pointData=this.pointData();let labelText=this.value;labelTemplate?labelText=labelTemplate(pointData):labels.format&&(labelText=this.formatValue(labels.format)),this.label=new text_box(labelText,deepExtend({align:CENTER,vAlign:CENTER,margin:{left:5,right:5},zIndex:valueOrDefault(labels.zIndex,this.series.zIndex)},labels),pointData),this.append(this.label)}this.createNote(),this.errorBar&&this.append(this.errorBar)}}markerBorder(){const options=this.options.markers,background=options.background,border=deepExtend({color:this.color},options.border);return defined(border.color)||(border.color=new color_color.a(background).brightness(.8).toHex()),border}createVisual(){}createMarker(){const options=this.options.markers;return new shape_element({type:options.type,width:options.size,height:options.size,rotation:options.rotation,background:options.background,border:this.markerBorder(),opacity:this.series.opacity||options.opacity,zIndex:valueOrDefault(options.zIndex,this.series.zIndex),animation:options.animation,visual:options.visual},{dataItem:this.dataItem,value:this.value,series:this.series,category:this.category})}markerBox(){return this.marker||(this.marker=this.createMarker(),this.marker.reflow(this._childBox)),this.marker.box}reflow(targetBox){const{options:options,aboveAxis:aboveAxis}=this,vertical=options.vertical;this.render(),this.box=targetBox;const childBox=targetBox.clone();if(vertical?aboveAxis?childBox.y1-=childBox.height():childBox.y2+=childBox.height():aboveAxis?childBox.x1+=childBox.width():childBox.x2-=childBox.width(),this._childBox=childBox,this.marker&&this.marker.reflow(childBox),this.reflowLabel(childBox),this.errorBars)for(let i=0;i<this.errorBars.length;i++)this.errorBars[i].reflow(childBox);if(this.note){let noteTargetBox=this.markerBox();if(!options.markers.visible||!options.markers.size){const center=noteTargetBox.center();noteTargetBox=new core_box(center.x,center.y,center.x,center.y)}this.note.reflow(noteTargetBox)}}reflowLabel(box){const{options:options,label:label}=this;let anchor=options.labels.position;label&&(anchor=\"above\"===anchor?TOP:anchor,anchor=\"below\"===anchor?BOTTOM:anchor,label.reflow(box),label.box.alignTo(this.markerBox(),anchor),label.reflow(label.box))}createHighlight(){const markers=this.options.highlight.markers,defaultColor=this.markerBorder().color,options=this.options.markers,size=options.size+(options.border.width||0)+(markers.border.width||0),shadow=new shape_element({type:options.type,width:size,height:size,rotation:options.rotation,background:markers.color||defaultColor,border:{color:markers.border.color,width:markers.border.width,opacity:valueOrDefault(markers.border.opacity,1)},opacity:valueOrDefault(markers.opacity,1)});return shadow.reflow(this._childBox),shadow.getElement()}highlightVisual(){return(this.marker||{}).visual}highlightVisualArgs(){const marker=this.marker;let visual,rect;if(marker)rect=marker.paddingBox.toRect(),visual=marker.visual;else{const size=this.options.markers.size,halfSize=size/2,center=this.box.center();rect=new main.b.Rect([center.x-halfSize,center.y-halfSize],[size,size])}return{options:this.options,rect:rect,visual:visual}}tooltipAnchor(){const markerBox=this.markerBox(),clipBox=this.owner.pane.clipBox();if(!clipBox||clipBox.overlaps(markerBox)){const horizontalAlign=LEFT;let y,verticalAlign;return this.aboveAxis?(y=markerBox.y1,verticalAlign=BOTTOM):(y=markerBox.y2,verticalAlign=TOP),{point:new core_point(markerBox.x2+5,y),align:{horizontal:horizontalAlign,vertical:verticalAlign}}}}formatValue(format){return this.owner.formatPointValue(this,format)}overlapsBox(box){return this.markerBox().overlaps(box)}unclipElements(){this.label&&(this.label.options.noclip=!0),this.note&&(this.note.options.noclip=!0)}pointData(){return{dataItem:this.dataItem,category:this.category,value:this.value,percentage:this.percentage,stackValue:this.stackValue,series:this.series}}}line_point_LinePoint.prototype.defaults={vertical:!0,markers:{visible:!0,background:WHITE,size:8,type:CIRCLE,border:{width:2},opacity:1},labels:{visible:!1,position:\"above\",margin:getSpacing(3),padding:getSpacing(4),animation:{type:\"fadeIn\",delay:600}},notes:{label:{}},highlight:{markers:{border:{color:\"#fff\",width:2}},zIndex:100},errorBars:{line:{width:1}}},deepExtend(line_point_LinePoint.prototype,point_events_mixin),deepExtend(line_point_LinePoint.prototype,note_mixin);var line_point=line_point_LinePoint;class line_segment_LineSegment extends chart_element{constructor(linePoints,series,seriesIx){super(),this.linePoints=linePoints,this.series=series,this.seriesIx=seriesIx}points(){return this.toGeometryPoints(this.linePoints)}toGeometryPoints(points){const result=[];for(let i=0,length=points.length;i<length;i++)points[i]&&!1!==points[i].visible&&result.push(points[i]._childBox.toRect().center());return result}createVisual(){const customVisual=this.series.visual;customVisual?(this.visual=customVisual({points:this.toGeometryPoints(this.linePoints),series:this.series,sender:this.getSender(),createVisual:()=>(this.segmentVisual(),this.visual)}),this.visual&&!defined(this.visual.options.zIndex)&&(this.visual.options.zIndex=this.series.zIndex)):this.segmentVisual()}segmentVisual(){const{options:options,series:series}=this;let{color:color,_defaults:defaults}=series;isFunction(color)&&defaults&&(color=defaults.color);const line=main.a.Path.fromPoints(this.points(),{stroke:{color:color,width:series.width,opacity:series.opacity,dashType:series.dashType},zIndex:series.zIndex});options.closed&&line.close(),this.visual=line}aliasFor(e,coords){return this.parent.getNearestPoint(coords.x,coords.y,this.seriesIx)}}setDefaultOptions(line_segment_LineSegment,{closed:!1});var line_segment=line_segment_LineSegment;function toGeometryPoint(lintPoint,stepAxis,stepDir,axis,dir){const box=lintPoint.box,result=new main.b.Point;return result[stepAxis]=box[stepAxis+stepDir],result[axis]=box[axis+dir],result}var step_line_mixin={calculateStepPoints:function(points){const categoryAxis=this.parent.plotArea.seriesCategoryAxis(this.series),{justified:justified,vertical:vertical,reverse:reverse}=categoryAxis.options,stepAxis=vertical?X:Y,axis=vertical?Y:X,stepDir=reverse?2:1,dir=stepDir;let previousPoint=toGeometryPoint(points[0],stepAxis,stepDir,axis,dir);const result=[previousPoint];for(let idx=1;idx<points.length;idx++){const point=toGeometryPoint(points[idx],stepAxis,stepDir,axis,dir);if(previousPoint[stepAxis]!==point[stepAxis]){const stepPoint=new main.b.Point;stepPoint[stepAxis]=previousPoint[stepAxis],stepPoint[axis]=point[axis],result.push(stepPoint,point)}previousPoint=point}return justified?previousPoint!==last(result)&&result.push(previousPoint):result.push(toGeometryPoint(last(points),stepAxis,stepDir,axis,reverse?1:2)),result}};class step_line_segment_StepLineSegment extends line_segment{points(){return this.calculateStepPoints(this.linePoints)}}deepExtend(step_line_segment_StepLineSegment.prototype,step_line_mixin);var step_line_segment=step_line_segment_StepLineSegment,spline_segment=class extends line_segment{segmentVisual(){const series=this.series,defaults=series._defaults;let color=series.color;isFunction(color)&&defaults&&(color=defaults.color);const segments=new curve_processor(this.options.closed).process(this.points()),curve=new main.a.Path({stroke:{color:color,width:series.width,opacity:series.opacity,dashType:series.dashType},zIndex:series.zIndex});curve.segments.push.apply(curve.segments,segments),this.visual=curve}},line_chart_mixin={renderSegments:function(){const{options:options,seriesPoints:seriesPoints}=this,series=options.series,seriesCount=seriesPoints.length;let lastSegment;this._segments=[];for(let seriesIx=0;seriesIx<seriesCount;seriesIx++){const currentSeries=series[seriesIx],sortedPoints=this.sortPoints(seriesPoints[seriesIx]),pointCount=sortedPoints.length;let linePoints=[];for(let pointIx=0;pointIx<pointCount;pointIx++){const point=sortedPoints[pointIx];point?linePoints.push(point):\"interpolate\"!==this.seriesMissingValues(currentSeries)&&(linePoints.length>1&&(lastSegment=this.createSegment(linePoints,currentSeries,seriesIx,lastSegment),this._addSegment(lastSegment)),linePoints=[])}linePoints.length>1&&(lastSegment=this.createSegment(linePoints,currentSeries,seriesIx,lastSegment),this._addSegment(lastSegment))}this.children.unshift.apply(this.children,this._segments)},_addSegment:function(segment){this._segments.push(segment),segment.parent=this},sortPoints:function(points){return points},seriesMissingValues:function(series){const missingValues=series.missingValues;return!missingValues&&this.options.isStacked?ZERO:missingValues||\"interpolate\"},getNearestPoint:function(x,y,seriesIx){const target=new core_point(x,y),allPoints=this.seriesPoints[seriesIx];let nearestPoint,nearestPointDistance=MAX_VALUE;for(let i=0;i<allPoints.length;i++){const point=allPoints[i];if(point&&defined(point.value)&&null!==point.value&&!1!==point.visible){const pointDistance=point.box.center().distanceTo(target);pointDistance<nearestPointDistance&&(nearestPoint=point,nearestPointDistance=pointDistance)}}return nearestPoint}};class clip_animation_ClipAnimation extends main.a.Animation{setup(){this._setEnd(this.options.box.x1)}step(pos){const box=this.options.box;this._setEnd(interpolateValue(box.x1,box.x2,pos))}_setEnd(x){const element=this.element,segments=element.segments,topRight=segments[1].anchor(),bottomRight=segments[2].anchor();element.suspend(),topRight.setX(x),element.resume(),bottomRight.setX(x)}}setDefaultOptions(clip_animation_ClipAnimation,{duration:600}),main.a.AnimationFactory.current.register(\"clip\",clip_animation_ClipAnimation);var clip_animation=clip_animation_ClipAnimation;function anyHasZIndex(elements){for(let idx=0;idx<elements.length;idx++)if(defined(elements[idx].zIndex))return!0}var clip_animation_mixin={createAnimation:function(){const root=this.getRoot();if(root&&!1!==(root.options||{}).transitions){const box=root.size(),clipPath=main.a.Path.fromRect(box.toRect());this.visual.clip(clipPath),this.animation=new clip_animation(clipPath,{box:box}),anyHasZIndex(this.options.series)&&this._setChildrenAnimation(clipPath)}},_setChildrenAnimation:function(clipPath){const points=this.animationPoints();for(let idx=0;idx<points.length;idx++){const point=points[idx];point&&point.visual&&defined(point.visual.options.zIndex)&&point.visual.clip(clipPath)}}},line_chart=(()=>{class LineChart extends categorical_chart{render(){super.render(),this.updateStackRange(),this.renderSegments()}pointType(){return line_point}createPoint(data,fields){const{categoryIx:categoryIx,category:category,series:series,seriesIx:seriesIx}=fields,missingValues=this.seriesMissingValues(series);let value=data.valueFields.value;if(!defined(value)||null===value){if(missingValues!==ZERO)return null;value=0}let pointOptions=this.pointOptions(series,seriesIx);pointOptions=this.evalPointOptions(pointOptions,value,category,categoryIx,series,seriesIx);let color=data.fields.color||series.color;isFunction(series.color)&&(color=pointOptions.color);const point=new line_point(value,pointOptions);return point.color=color,this.append(point),point}plotRange(point){let plotValue=this.plotValue(point);if(this.options.isStacked){const categoryPoints=this.categoryPoints[point.categoryIx];for(let i=0;i<categoryPoints.length;i++){const other=categoryPoints[i];if(point===other)break;plotValue+=this.plotValue(other),this.options.isStacked100&&(plotValue=Math.min(plotValue,1))}}return[plotValue,plotValue]}createSegment(linePoints,currentSeries,seriesIx){const style=currentSeries.style;let pointType;return pointType=\"step\"===style?step_line_segment:\"smooth\"===style?spline_segment:line_segment,new pointType(linePoints,currentSeries,seriesIx)}animationPoints(){const points=this.points,result=[];for(let idx=0;idx<points.length;idx++)result.push((points[idx]||{}).marker);return result.concat(this._segments)}supportsPointInactiveOpacity(){return!1}}return deepExtend(LineChart.prototype,line_chart_mixin,clip_animation_mixin),LineChart})(),area_segment=class extends line_segment{constructor(linePoints,currentSeries,seriesIx,prevSegment,stackPoints){super(linePoints,currentSeries,seriesIx),this.prevSegment=prevSegment,this.stackPoints=stackPoints}createVisual(){const series=this.series,defaults=series._defaults,lineOptions=series.line||{};let color=series.color;isFunction(color)&&defaults&&(color=defaults.color),this.visual=new main.a.Group({zIndex:series.zIndex}),this.createFill({fill:{color:color,opacity:series.opacity},stroke:null}),lineOptions.width>0&&!1!==lineOptions.visible&&this.createStroke({stroke:deepExtend({color:color,opacity:series.opacity,lineCap:\"butt\"},lineOptions)})}strokeSegments(){let segments=this._strokeSegments;return segments||(segments=this._strokeSegments=this.createStrokeSegments()),segments}createStrokeSegments(){return this.segmentsFromPoints(this.points())}stackSegments(){return this.prevSegment?this.prevSegment.createStackSegments(this.stackPoints):this.createStackSegments(this.stackPoints)}createStackSegments(stackPoints){return this.segmentsFromPoints(this.toGeometryPoints(stackPoints)).reverse()}segmentsFromPoints(points){return points.map(point=>new main.b.Segment(point))}createStroke(style){const stroke=new main.a.Path(style);stroke.segments.push.apply(stroke.segments,this.strokeSegments()),this.visual.append(stroke)}hasStackSegment(){return this.prevSegment||this.stackPoints&&this.stackPoints.length}createFill(style){const strokeSegments=this.strokeSegments(),fillSegments=strokeSegments.slice(0),hasStackSegments=this.hasStackSegment();if(hasStackSegments){const stackSegments=this.stackSegments();append(fillSegments,stackSegments)}const fill=new main.a.Path(style);fill.segments.push.apply(fill.segments,fillSegments),!hasStackSegments&&strokeSegments.length>1&&this.fillToAxes(fill),this.visual.append(fill)}fillToAxes(fillPath){const chart=this.parent,invertAxes=chart.options.invertAxes,valueAxis=chart.seriesValueAxis(this.series),crossingValue=chart.categoryAxisCrossingValue(valueAxis),endSlot=valueAxis.getSlot(crossingValue,crossingValue,!0),segments=this.strokeSegments(),firstPoint=segments[0].anchor(),lastPoint=last(segments).anchor();let end=invertAxes?endSlot.x1:endSlot.y1;invertAxes?fillPath.lineTo(end,lastPoint.y).lineTo(end,firstPoint.y):fillPath.lineTo(lastPoint.x,end).lineTo(firstPoint.x,end)}};class step_area_segment_StepAreaSegment extends area_segment{createStrokeSegments(){return this.segmentsFromPoints(this.calculateStepPoints(this.linePoints))}createStackSegments(stackPoints){return this.segmentsFromPoints(this.calculateStepPoints(stackPoints)).reverse()}}deepExtend(step_area_segment_StepAreaSegment.prototype,step_line_mixin);var step_area_segment=step_area_segment_StepAreaSegment,spline_area_segment=class extends area_segment{createStrokeSegments(){const curveProcessor=new curve_processor(this.options.closed),linePoints=this.points();return curveProcessor.process(linePoints)}createStackSegments(){const strokeSegments=this.strokeSegments(),stackSegments=[];for(let idx=strokeSegments.length-1;idx>=0;idx--){const segment=strokeSegments[idx];stackSegments.push(new main.b.Segment(segment.anchor(),segment.controlOut(),segment.controlIn()))}return stackSegments}},area_chart=class extends line_chart{createSegment(linePoints,currentSeries,seriesIx,prevSegment){const style=(currentSeries.line||{}).style;let previousSegment,stackPoints,pointType;return this.options.isStacked&&seriesIx>0&&prevSegment&&(\"gap\"!==this.seriesMissingValues(currentSeries)?(stackPoints=prevSegment.linePoints,previousSegment=prevSegment):stackPoints=this._gapStackPoints(linePoints,seriesIx,style)),pointType=\"step\"===style?step_area_segment:\"smooth\"===style?spline_area_segment:area_segment,new pointType(linePoints,currentSeries,seriesIx,previousSegment,stackPoints)}reflow(targetBox){super.reflow(targetBox);const stackPoints=this._stackPoints;if(stackPoints)for(let idx=0;idx<stackPoints.length;idx++){const stackPoint=stackPoints[idx],pointSlot=this.categoryAxis.getSlot(stackPoint.categoryIx);stackPoint.reflow(pointSlot)}}_gapStackPoints(linePoints,seriesIx,style){const seriesPoints=this.seriesPoints;let startIdx=linePoints[0].categoryIx,length=linePoints.length;startIdx<0&&(startIdx=0,length--);const endIdx=startIdx+length,pointOffset=this.seriesOptions[0]._outOfRangeMinPoint?1:0,stackPoints=[];this._stackPoints=this._stackPoints||[];for(let categoryIx=startIdx;categoryIx<endIdx;categoryIx++){const pointIx=categoryIx+pointOffset;let point,currentSeriesIx=seriesIx;do{currentSeriesIx--,point=seriesPoints[currentSeriesIx][pointIx]}while(currentSeriesIx>0&&!point);if(point)\"step\"!==style&&categoryIx>startIdx&&!seriesPoints[currentSeriesIx][pointIx-1]&&stackPoints.push(this._previousSegmentPoint(categoryIx,pointIx,pointIx-1,currentSeriesIx)),stackPoints.push(point),\"step\"!==style&&categoryIx+1<endIdx&&!seriesPoints[currentSeriesIx][pointIx+1]&&stackPoints.push(this._previousSegmentPoint(categoryIx,pointIx,pointIx+1,currentSeriesIx));else{const gapStackPoint=this._createGapStackPoint(categoryIx);this._stackPoints.push(gapStackPoint),stackPoints.push(gapStackPoint)}}return stackPoints}_previousSegmentPoint(categoryIx,pointIx,segmentIx,seriesIdx){const seriesPoints=this.seriesPoints;let point,index=seriesIdx;for(;index>0&&!point;)index--,point=seriesPoints[index][segmentIx];return point?point=seriesPoints[index][pointIx]:(point=this._createGapStackPoint(categoryIx),this._stackPoints.push(point)),point}_createGapStackPoint(categoryIx){const options=this.pointOptions({},0),point=new line_point(0,options);return point.categoryIx=categoryIx,point.series={},point}seriesMissingValues(series){return series.missingValues||ZERO}supportsPointInactiveOpacity(){return!1}},axis_group_range_tracker=class extends common_class.a{constructor(){super(),this.axisRanges={}}update(chartAxisRanges){const axisRanges=this.axisRanges;for(let axisName in chartAxisRanges){const chartRange=chartAxisRanges[axisName];let range=axisRanges[axisName];axisRanges[axisName]=range=range||{min:MAX_VALUE,max:MIN_VALUE},range.min=Math.min(range.min,chartRange.min),range.max=Math.max(range.max,chartRange.max)}}reset(axisName){this.axisRanges[axisName]=void 0}query(axisName){return this.axisRanges[axisName]}};class bar_label_BarLabel extends chart_element{constructor(content,options,pointData){super(options),this.textBox=new text_box(content,this.options,pointData),this.append(this.textBox)}createVisual(){this.textBox.options.noclip=this.options.noclip}reflow(targetBox){const options=this.options,{vertical:vertical,aboveAxis:aboveAxis}=options,text=this.children[0],textOptions=text.options,box=text.box,padding=text.options.padding;let labelBox=targetBox;textOptions.align=vertical?CENTER:LEFT,textOptions.vAlign=vertical?TOP:CENTER,\"insideEnd\"===options.position?vertical?(textOptions.vAlign=TOP,!aboveAxis&&box.height()<targetBox.height()&&(textOptions.vAlign=BOTTOM)):textOptions.align=aboveAxis?RIGHT:LEFT:options.position===CENTER?(textOptions.vAlign=CENTER,textOptions.align=CENTER):\"insideBase\"===options.position?vertical?textOptions.vAlign=aboveAxis?BOTTOM:TOP:textOptions.align=aboveAxis?LEFT:RIGHT:\"outsideEnd\"===options.position&&(vertical?labelBox=aboveAxis?new core_box(targetBox.x1,targetBox.y1-box.height(),targetBox.x2,targetBox.y1):new core_box(targetBox.x1,targetBox.y2,targetBox.x2,targetBox.y2+box.height()):(textOptions.align=CENTER,labelBox=aboveAxis?new core_box(targetBox.x2,targetBox.y1,targetBox.x2+box.width(),targetBox.y2):new core_box(targetBox.x1-box.width(),targetBox.y1,targetBox.x1,targetBox.y2))),options.rotation||(vertical?padding.left=padding.right=(labelBox.width()-text.contentBox.width())/2:padding.top=padding.bottom=(labelBox.height()-text.contentBox.height())/2),text.reflow(labelBox)}alignToClipBox(clipBox){const field=this.options.vertical?Y:X,start=field+\"1\",end=field+\"2\",parentBox=this.parent.box;if(parentBox[start]<clipBox[start]||clipBox[end]<parentBox[end]){const targetBox=this.children[0].paddingBox.clone();targetBox[start]=Math.max(parentBox[start],clipBox[start]),targetBox[end]=Math.min(parentBox[end],clipBox[end]),this.reflow(targetBox)}}}setDefaultOptions(bar_label_BarLabel,{position:\"outsideEnd\",margin:getSpacing(3),padding:getSpacing(4),color:BLACK,background:\"\",border:{width:1,color:\"\"},aboveAxis:!0,vertical:!1,animation:{type:\"fadeIn\",delay:600},zIndex:2});var bar_label=bar_label_BarLabel;function hasGradientOverlay(options){const overlay=options.overlay;return overlay&&overlay.gradient&&\"none\"!==overlay.gradient}class bar_Bar extends chart_element{constructor(value,options){super(),this.options=options,this.color=options.color||WHITE,this.aboveAxis=valueOrDefault(this.options.aboveAxis,!0),this.value=value}render(){this._rendered||(this._rendered=!0,this.createLabel(),this.createNote(),this.errorBar&&this.append(this.errorBar))}createLabel(){const options=this.options,labels=options.labels;if(labels.visible){const pointData=this.pointData();let labelText,labelTemplate=getTemplate(labels);labelText=labelTemplate?labelTemplate(pointData):this.formatValue(labels.format),this.label=new bar_label(labelText,deepExtend({vertical:options.vertical},labels),pointData),this.append(this.label)}}formatValue(format){return this.owner.formatPointValue(this,format)}reflow(targetBox){this.render();const label=this.label;if(this.box=targetBox,label&&(label.options.aboveAxis=this.aboveAxis,label.reflow(targetBox)),this.note&&this.note.reflow(targetBox),this.errorBars)for(let i=0;i<this.errorBars.length;i++)this.errorBars[i].reflow(targetBox)}createVisual(){const{box:box,options:options}=this,customVisual=options.visual;if(!1!==this.visible)if(super.createVisual(),customVisual){const visual=this.rectVisual=customVisual({category:this.category,dataItem:this.dataItem,value:this.value,sender:this.getSender(),series:this.series,percentage:this.percentage,stackValue:this.stackValue,runningTotal:this.runningTotal,total:this.total,rect:box.toRect(),createVisual:()=>{const group=new main.a.Group;return this.createRect(group),group},options:options});visual&&this.visual.append(visual)}else box.width()>0&&box.height()>0&&this.createRect(this.visual)}createRect(visual){const options=this.options,border=options.border,strokeOpacity=defined(border.opacity)?border.opacity:options.opacity,rect=this.box.toRect();rect.size.width=Math.round(rect.size.width);const path=this.rectVisual=main.a.Path.fromRect(rect,{fill:{color:this.color,opacity:options.opacity},stroke:{color:this.getBorderColor(),width:border.width,opacity:strokeOpacity,dashType:border.dashType}}),width=this.box.width(),height=this.box.height();if((options.vertical?width:height)>6&&(alignPathToPixel(path),(width<1||height<1)&&(path.options.stroke.lineJoin=\"round\")),visual.append(path),hasGradientOverlay(options)){const overlay=this.createGradientOverlay(path,{baseColor:this.color},deepExtend({end:options.vertical?void 0:[0,1]},options.overlay));visual.append(overlay)}}createHighlight(style){return alignPathToPixel(main.a.Path.fromRect(this.box.toRect(),style))}highlightVisual(){return this.rectVisual}highlightVisualArgs(){return{options:this.options,rect:this.box.toRect(),visual:this.rectVisual}}getBorderColor(){const color=this.color,border=this.options.border,brightness=border._brightness||.8;let borderColor=border.color;return defined(borderColor)||(borderColor=new color_color.a(color).brightness(brightness).toHex()),borderColor}tooltipAnchor(){const{options:options,box:box,aboveAxis:aboveAxis}=this,clipBox=this.owner.pane.clipBox()||box;let x,y,horizontalAlign=LEFT,verticalAlign=TOP;if(options.vertical)x=Math.min(box.x2,clipBox.x2)+5,aboveAxis?y=Math.max(box.y1,clipBox.y1):(y=Math.min(box.y2,clipBox.y2),verticalAlign=BOTTOM);else{const x1=Math.max(box.x1,clipBox.x1),x2=Math.min(box.x2,clipBox.x2);options.isStacked?(verticalAlign=BOTTOM,aboveAxis?(horizontalAlign=RIGHT,x=x2):x=x1,y=Math.max(box.y1,clipBox.y1)-5):(aboveAxis?x=x2+5:(x=x1-5,horizontalAlign=RIGHT),y=Math.max(box.y1,clipBox.y1))}return{point:new core_point(x,y),align:{horizontal:horizontalAlign,vertical:verticalAlign}}}overlapsBox(box){return this.box.overlaps(box)}pointData(){return{dataItem:this.dataItem,category:this.category,value:this.value,percentage:this.percentage,stackValue:this.stackValue,runningTotal:this.runningTotal,total:this.total,series:this.series}}}deepExtend(bar_Bar.prototype,point_events_mixin),deepExtend(bar_Bar.prototype,note_mixin),bar_Bar.prototype.defaults={border:{width:1},vertical:!0,overlay:{gradient:\"glass\"},labels:{visible:!1,format:\"{0}\"},opacity:1,notes:{label:{}}};var bar=bar_Bar;function forEach(elements,callback){elements.forEach(callback)}function forEachReverse(elements,callback){const length=elements.length;for(let idx=length-1;idx>=0;idx--)callback(elements[idx],idx-length-1)}class cluster_layout_ClusterLayout extends chart_element{constructor(options){super(options),this.forEach=options.rtl?forEachReverse:forEach}reflow(box){const{vertical:vertical,gap:gap,spacing:spacing}=this.options,children=this.children,count=children.length,axis=vertical?Y:X,slots=count+gap+spacing*(count-1),slotSize=(vertical?box.height():box.width())/slots;let position=box[axis+1]+slotSize*(gap/2);this.forEach(children,(child,idx)=>{const childBox=(child.box||box).clone();childBox[axis+1]=position,childBox[axis+2]=position+slotSize,child.reflow(childBox),idx<count-1&&(position+=slotSize*spacing),position+=slotSize})}}setDefaultOptions(cluster_layout_ClusterLayout,{vertical:!1,gap:0,spacing:0});var cluster_layout=cluster_layout_ClusterLayout;class stack_wrap_StackWrap extends chart_element{reflow(targetBox){const positionAxis=this.options.vertical?X:Y,children=this.children,childrenCount=children.length;let box=this.box=new core_box;for(let i=0;i<childrenCount;i++){const currentChild=children[i];if(!1!==currentChild.visible){const childBox=currentChild.box.clone();childBox.snapTo(targetBox,positionAxis),0===i&&(box=this.box=childBox.clone()),currentChild.reflow(childBox),box.wrap(childBox)}}}}setDefaultOptions(stack_wrap_StackWrap,{vertical:!0});var stack_wrap=stack_wrap_StackWrap;class bar_chart_BarChart extends categorical_chart{render(){super.render(),this.updateStackRange()}pointType(){return bar}clusterType(){return cluster_layout}stackType(){return stack_wrap}stackLimits(axisName,stackName){return super.stackLimits(axisName,stackName)}createPoint(data,fields){const{categoryIx:categoryIx,category:category,series:series,seriesIx:seriesIx}=fields,{options:options,children:children}=this,isStacked=options.isStacked,value=this.pointValue(data);let pointOptions=this.pointOptions(series,seriesIx);const labelOptions=pointOptions.labels;isStacked&&\"outsideEnd\"===labelOptions.position&&(labelOptions.position=\"insideEnd\"),pointOptions.isStacked=isStacked;let color=data.fields.color||series.color;value<0&&pointOptions.negativeColor&&(color=pointOptions.negativeColor),pointOptions=this.evalPointOptions(pointOptions,value,category,categoryIx,series,seriesIx),isFunction(series.color)&&(color=pointOptions.color);const point=new(this.pointType())(value,pointOptions);point.color=color;let cluster=children[categoryIx];return cluster||(cluster=new(this.clusterType())({vertical:options.invertAxes,gap:options.gap,spacing:options.spacing,rtl:!options.invertAxes&&(this.chartService||{}).rtl}),this.append(cluster)),isStacked?this.getStackWrap(series,cluster).append(point):cluster.append(point),point}getStackWrap(series,cluster){const stack=series.stack,stackGroup=stack&&stack.group||stack,wraps=cluster.children;let stackWrap;if(\"string\"==typeof stackGroup){for(let i=0;i<wraps.length;i++)if(wraps[i]._stackGroup===stackGroup){stackWrap=wraps[i];break}}else stackWrap=wraps[0];return stackWrap||(stackWrap=new(this.stackType())({vertical:!this.options.invertAxes}),stackWrap._stackGroup=stackGroup,cluster.append(stackWrap)),stackWrap}categorySlot(categoryAxis,categoryIx,valueAxis){const options=this.options,categorySlot=categoryAxis.getSlot(categoryIx),startValue=valueAxis.startValue();if(options.isStacked){const zeroSlot=valueAxis.getSlot(startValue,startValue,!0),stackAxis=options.invertAxes?X:Y;categorySlot[stackAxis+1]=categorySlot[stackAxis+2]=zeroSlot[stackAxis+1]}return categorySlot}reflowCategories(categorySlots){const children=this.children,childrenLength=children.length;for(let i=0;i<childrenLength;i++)children[i].reflow(categorySlots[i])}createAnimation(){this._setAnimationOptions(),super.createAnimation(),anyHasZIndex(this.options.series)&&this._setChildrenAnimation()}_setChildrenAnimation(){const points=this.points;for(let idx=0;idx<points.length;idx++){const point=points[idx],pointVisual=point.visual;pointVisual&&defined(pointVisual.options.zIndex)&&(point.options.animation=this.options.animation,point.createAnimation())}}_setAnimationOptions(){const options=this.options,animation=options.animation||{};let origin;if(options.isStacked){const valueAxis=this.seriesValueAxis(options.series[0]);origin=valueAxis.getSlot(valueAxis.startValue())}else origin=this.categoryAxis.getSlot(0);animation.origin=new main.b.Point(origin.x1,origin.y1),animation.vertical=!options.invertAxes}}setDefaultOptions(bar_chart_BarChart,{animation:{type:BAR}});var bar_chart=bar_chart_BarChart;class candlestick_Candlestick extends chart_element{constructor(value,options){super(options),this.value=value}reflow(box){const{options:options,value:value,owner:chart}=this,valueAxis=chart.seriesValueAxis(options),ocSlot=valueAxis.getSlot(value.open,value.close),lhSlot=valueAxis.getSlot(value.low,value.high);ocSlot.x1=lhSlot.x1=box.x1,ocSlot.x2=lhSlot.x2=box.x2,this.realBody=ocSlot;const mid=lhSlot.center().x,points=[];points.push([[mid,lhSlot.y1],[mid,ocSlot.y1]]),points.push([[mid,ocSlot.y2],[mid,lhSlot.y2]]),this.lines=points,this.box=lhSlot.clone().wrap(ocSlot),this._rendered||(this._rendered=!0,this.createNote()),this.reflowNote()}reflowNote(){this.note&&this.note.reflow(this.box)}createVisual(){super.createVisual(),this._mainVisual=this.mainVisual(this.options),this.visual.append(this._mainVisual),this.createOverlay()}mainVisual(options){const group=new main.a.Group;return this.createBody(group,options),this.createLines(group,options),group}createBody(container,options){const body=main.a.Path.fromRect(this.realBody.toRect(),{fill:{color:this.color,opacity:options.opacity},stroke:null});options.border.width>0&&body.options.set(\"stroke\",{color:this.getBorderColor(),width:options.border.width,dashType:options.border.dashType,opacity:valueOrDefault(options.border.opacity,options.opacity)}),alignPathToPixel(body),container.append(body),hasGradientOverlay(options)&&container.append(this.createGradientOverlay(body,{baseColor:this.color},deepExtend({end:options.vertical?void 0:[0,1]},options.overlay)))}createLines(container,options){this.drawLines(container,options,this.lines,options.line)}drawLines(container,options,lines,lineOptions){if(!lines)return;const lineStyle={stroke:{color:lineOptions.color||this.color,opacity:valueOrDefault(lineOptions.opacity,options.opacity),width:lineOptions.width,dashType:lineOptions.dashType,lineCap:\"butt\"}};for(let i=0;i<lines.length;i++){const line=main.a.Path.fromPoints(lines[i],lineStyle);alignPathToPixel(line),container.append(line)}}getBorderColor(){const border=this.options.border;let borderColor=border.color;return defined(borderColor)||(borderColor=new color_color.a(this.color).brightness(border._brightness).toHex()),borderColor}createOverlay(){const overlay=main.a.Path.fromRect(this.box.toRect(),{fill:{color:WHITE,opacity:0},stroke:null});this.visual.append(overlay)}createHighlight(){const highlight=this.options.highlight,normalColor=this.color;this.color=highlight.color||this.color;const overlay=this.mainVisual(deepExtend({},this.options,{line:{color:this.getBorderColor()}},highlight));return this.color=normalColor,overlay}highlightVisual(){return this._mainVisual}highlightVisualArgs(){return{options:this.options,rect:this.box.toRect(),visual:this._mainVisual}}tooltipAnchor(){const box=this.box,clipBox=this.owner.pane.clipBox()||box;return{point:new core_point(box.x2+5,Math.max(box.y1,clipBox.y1)+5),align:{horizontal:LEFT,vertical:TOP}}}formatValue(format){return this.owner.formatPointValue(this,format)}overlapsBox(box){return this.box.overlaps(box)}}setDefaultOptions(candlestick_Candlestick,{vertical:!0,border:{_brightness:.8},line:{width:2},overlay:{gradient:\"glass\"},tooltip:{format:\"<table><tr><th colspan='2'>{4:d}</th></tr><tr><td>Open:</td><td>{0:C}</td></tr><tr><td>High:</td><td>{1:C}</td></tr><tr><td>Low:</td><td>{2:C}</td></tr><tr><td>Close:</td><td>{3:C}</td></tr></table>\"},highlight:{opacity:1,border:{width:1,opacity:1},line:{width:1,opacity:1}},notes:{visible:!0,label:{}}}),deepExtend(candlestick_Candlestick.prototype,point_events_mixin),deepExtend(candlestick_Candlestick.prototype,note_mixin);var candlestick=candlestick_Candlestick;function areNumbers(values){return countNumbers(values)===values.length}class candlestick_chart_CandlestickChart extends categorical_chart{reflowCategories(categorySlots){const children=this.children,childrenLength=children.length;for(let i=0;i<childrenLength;i++)children[i].reflow(categorySlots[i])}addValue(data,fields){const{categoryIx:categoryIx,category:category,series:series,seriesIx:seriesIx}=fields,{children:children,options:options}=this,value=data.valueFields,hasValue=areNumbers(this.splitValue(value)),dataItem=series.data[categoryIx];let point,categoryPoints=this.categoryPoints[categoryIx];categoryPoints||(this.categoryPoints[categoryIx]=categoryPoints=[]),hasValue&&(point=this.createPoint(data,fields));let cluster=children[categoryIx];cluster||(cluster=new cluster_layout({vertical:options.invertAxes,gap:options.gap,spacing:options.spacing,rtl:!options.invertAxes&&(this.chartService||{}).rtl}),this.append(cluster)),point&&(this.updateRange(value,fields),cluster.append(point),point.categoryIx=categoryIx,point.category=category,point.series=series,point.seriesIx=seriesIx,point.owner=this,point.dataItem=dataItem,point.noteText=data.fields.noteText),this.points.push(point),categoryPoints.push(point)}pointType(){return candlestick}createPoint(data,fields){const{categoryIx:categoryIx,category:category,series:series,seriesIx:seriesIx}=fields,pointType=this.pointType(),value=data.valueFields;let pointOptions=deepExtend({},series),color=data.fields.color||series.color;pointOptions=this.evalPointOptions(pointOptions,value,category,categoryIx,series,seriesIx),\"candlestick\"===series.type&&value.open>value.close&&(color=data.fields.downColor||series.downColor||series.color),isFunction(series.color)&&(color=pointOptions.color),pointOptions.vertical=!this.options.invertAxes;const point=new pointType(value,pointOptions);return point.color=color,point}splitValue(value){return[value.low,value.open,value.close,value.high]}updateRange(value,fields){const axisName=fields.series.axis,parts=this.splitValue(value);let axisRange=this.valueAxisRanges[axisName];axisRange=this.valueAxisRanges[axisName]=axisRange||{min:MAX_VALUE,max:MIN_VALUE},axisRange=this.valueAxisRanges[axisName]={min:Math.min.apply(Math,parts.concat([axisRange.min])),max:Math.max.apply(Math,parts.concat([axisRange.max]))}}formatPointValue(point,format){const value=point.value;return this.chartService.format.auto(format,value.open,value.high,value.low,value.close,point.category)}animationPoints(){return this.points}}deepExtend(candlestick_chart_CandlestickChart.prototype,clip_animation_mixin);var candlestick_chart=candlestick_chart_CandlestickChart;class box_plot_BoxPlot extends candlestick{constructor(value,options){super(value,options),this.createNote()}reflow(box){const{options:options,value:value,owner:chart}=this,valueAxis=chart.seriesValueAxis(options);let whiskerSlot,boxSlot;this.boxSlot=boxSlot=valueAxis.getSlot(value.q1,value.q3),this.realBody=boxSlot,this.reflowBoxSlot(box),this.whiskerSlot=whiskerSlot=valueAxis.getSlot(value.lower,value.upper),this.reflowWhiskerSlot(box);const medianSlot=valueAxis.getSlot(value.median);if(value.mean){const meanSlot=valueAxis.getSlot(value.mean);this.meanPoints=this.calcMeanPoints(box,meanSlot)}this.whiskerPoints=this.calcWhiskerPoints(boxSlot,whiskerSlot),this.medianPoints=this.calcMedianPoints(box,medianSlot),this.box=whiskerSlot.clone().wrap(boxSlot),this.reflowNote()}reflowBoxSlot(box){this.boxSlot.x1=box.x1,this.boxSlot.x2=box.x2}reflowWhiskerSlot(box){this.whiskerSlot.x1=box.x1,this.whiskerSlot.x2=box.x2}calcMeanPoints(box,meanSlot){return[[[box.x1,meanSlot.y1],[box.x2,meanSlot.y1]]]}calcWhiskerPoints(boxSlot,whiskerSlot){const mid=whiskerSlot.center().x;return[[[mid-5,whiskerSlot.y1],[mid+5,whiskerSlot.y1],[mid,whiskerSlot.y1],[mid,boxSlot.y1]],[[mid-5,whiskerSlot.y2],[mid+5,whiskerSlot.y2],[mid,whiskerSlot.y2],[mid,boxSlot.y2]]]}calcMedianPoints(box,medianSlot){return[[[box.x1,medianSlot.y1],[box.x2,medianSlot.y1]]]}renderOutliers(options){const value=this.value,outliers=value.outliers||[],outerFence=3*Math.abs(value.q3-value.q1),elements=[];let markers=options.markers||{};for(let i=0;i<outliers.length;i++){const outlierValue=outliers[i];markers=outlierValue<value.q3+outerFence&&outlierValue>value.q1-outerFence?options.outliers:options.extremes;let markersBorder=deepExtend({},markers.border);defined(markersBorder.color)||(markersBorder.color=defined(this.color)?this.color:new color_color.a(markers.background).brightness(.8).toHex());const shape=new shape_element({type:markers.type,width:markers.size,height:markers.size,rotation:markers.rotation,background:markers.background,border:markersBorder,opacity:markers.opacity});shape.value=outlierValue,elements.push(shape)}return this.reflowOutliers(elements),elements}reflowOutliers(outliers){const valueAxis=this.owner.seriesValueAxis(this.options),center=this.box.center();for(let i=0;i<outliers.length;i++){const markerBox=valueAxis.getSlot(outliers[i].value);this.options.vertical?markerBox.move(center.x):markerBox.move(void 0,center.y),this.box=this.box.wrap(markerBox),outliers[i].reflow(markerBox)}}mainVisual(options){const group=super.mainVisual(options),outliers=this.renderOutliers(options);for(let i=0;i<outliers.length;i++){const element=outliers[i].getElement();element&&group.append(element)}return group}createLines(container,options){this.drawLines(container,options,this.whiskerPoints,options.whiskers),this.drawLines(container,options,this.medianPoints,options.median),this.drawLines(container,options,this.meanPoints,options.mean)}getBorderColor(){return(this.options.border||{}).color?this.options.border.color:this.color?this.color:super.getBorderColor()}}setDefaultOptions(box_plot_BoxPlot,{border:{_brightness:.8},line:{width:2},median:{color:\"#f6f6f6\"},mean:{width:2,dashType:\"dash\",color:\"#f6f6f6\"},overlay:{gradient:\"glass\"},tooltip:{format:\"<table><tr><th colspan='2'>{6:d}</th></tr><tr><td>Lower:</td><td>{0:C}</td></tr><tr><td>Q1:</td><td>{1:C}</td></tr><tr><td>Median:</td><td>{2:C}</td></tr><tr><td>Mean:</td><td>{5:C}</td></tr><tr><td>Q3:</td><td>{3:C}</td></tr><tr><td>Upper:</td><td>{4:C}</td></tr></table>\"},highlight:{opacity:1,border:{width:1,opacity:1},line:{width:1,opacity:1}},notes:{visible:!0,label:{}},outliers:{visible:!0,size:8,type:\"cross\",background:WHITE,border:{width:2,opacity:1},opacity:0},extremes:{visible:!0,size:8,type:CIRCLE,background:WHITE,border:{width:2,opacity:1},opacity:0}}),deepExtend(box_plot_BoxPlot.prototype,point_events_mixin);var box_plot=box_plot_BoxPlot,vertical_box_plot=class extends box_plot{reflowBoxSlot(box){this.boxSlot.y1=box.y1,this.boxSlot.y2=box.y2}reflowWhiskerSlot(box){this.whiskerSlot.y1=box.y1,this.whiskerSlot.y2=box.y2}calcMeanPoints(box,meanSlot){return[[[meanSlot.x1,box.y1],[meanSlot.x1,box.y2]]]}calcWhiskerPoints(boxSlot,whiskerSlot){const mid=whiskerSlot.center().y;return[[[whiskerSlot.x1,mid-5],[whiskerSlot.x1,mid+5],[whiskerSlot.x1,mid],[boxSlot.x1,mid]],[[whiskerSlot.x2,mid-5],[whiskerSlot.x2,mid+5],[whiskerSlot.x2,mid],[boxSlot.x2,mid]]]}calcMedianPoints(box,medianSlot){return[[[medianSlot.x1,box.y1],[medianSlot.x1,box.y2]]]}},box_plot_chart=class extends candlestick_chart{addValue(data,fields){const{categoryIx:categoryIx,category:category,series:series,seriesIx:seriesIx}=fields,{children:children,options:options}=this,value=data.valueFields,hasValue=areNumbers(this.splitValue(value)),dataItem=series.data[categoryIx];let point,categoryPoints=this.categoryPoints[categoryIx];categoryPoints||(this.categoryPoints[categoryIx]=categoryPoints=[]),hasValue&&(point=this.createPoint(data,fields));let cluster=children[categoryIx];cluster||(cluster=new cluster_layout({vertical:options.invertAxes,gap:options.gap,spacing:options.spacing,rtl:!options.invertAxes&&(this.chartService||{}).rtl}),this.append(cluster)),point&&(this.updateRange(value,fields),cluster.append(point),point.categoryIx=categoryIx,point.category=category,point.series=series,point.seriesIx=seriesIx,point.owner=this,point.dataItem=dataItem),this.points.push(point),categoryPoints.push(point)}pointType(){return this.options.invertAxes?vertical_box_plot:box_plot}splitValue(value){return[value.lower,value.q1,value.median,value.q3,value.upper]}updateRange(value,fields){const axisName=fields.series.axis;let axisRange=this.valueAxisRanges[axisName],parts=this.splitValue(value).concat(this.filterOutliers(value.outliers));defined(value.mean)&&(parts=parts.concat(value.mean)),axisRange=this.valueAxisRanges[axisName]=axisRange||{min:MAX_VALUE,max:MIN_VALUE},axisRange=this.valueAxisRanges[axisName]={min:Math.min.apply(Math,parts.concat([axisRange.min])),max:Math.max.apply(Math,parts.concat([axisRange.max]))}}formatPointValue(point,format){const value=point.value;return this.chartService.format.auto(format,value.lower,value.q1,value.median,value.q3,value.upper,value.mean,point.category)}filterOutliers(items){const length=(items||[]).length,result=[];for(let i=0;i<length;i++){const item=items[i];defined(item)&&null!==item&&result.push(item)}return result}supportsPointInactiveOpacity(){return!1}},scatter_error_bar=class extends error_bar_base{getAxis(){const axes=this.chart.seriesAxes(this.series);return this.isVertical?axes.y:axes.x}};function has_value_hasValue(value){return defined(value)&&null!==value}class scatter_chart_ScatterChart extends chart_element{constructor(plotArea,options){super(options),this.plotArea=plotArea,this.chartService=plotArea.chartService,this._initFields(),this.render()}_initFields(){this.xAxisRanges={},this.yAxisRanges={},this.points=[],this.seriesPoints=[],this.seriesOptions=[],this._evalSeries=[]}render(){this.traverseDataPoints(this.addValue.bind(this))}addErrorBar(point,field,fields){const value=point.value[field],valueErrorField=field+\"Value\",lowField=field+\"ErrorLow\",highField=field+\"ErrorHigh\",{seriesIx:seriesIx,series:series}=fields,errorBars=point.options.errorBars,lowValue=fields[lowField],highValue=fields[highField];if(isNumber(value)){let errorRange;isNumber(lowValue)&&isNumber(highValue)&&(errorRange={low:lowValue,high:highValue}),errorBars&&defined(errorBars[valueErrorField])&&(this.seriesErrorRanges=this.seriesErrorRanges||{x:[],y:[]},this.seriesErrorRanges[field][seriesIx]=this.seriesErrorRanges[field][seriesIx]||new error_range_calculator(errorBars[valueErrorField],series,field),errorRange=this.seriesErrorRanges[field][seriesIx].getErrorRange(value,errorBars[valueErrorField])),errorRange&&this.addPointErrorBar(errorRange,point,field)}}addPointErrorBar(errorRange,point,field){const{low:low,high:high}=errorRange,{series:series,options:{errorBars:options}}=point,isVertical=field===Y,item={};point[field+\"Low\"]=low,point[field+\"High\"]=high,point.errorBars=point.errorBars||[];const errorBar=new scatter_error_bar(low,high,isVertical,this,series,options);point.errorBars.push(errorBar),point.append(errorBar),item[field]=low,this.updateRange(item,series),item[field]=high,this.updateRange(item,series)}addValue(value,fields){const{x:x,y:y}=value,seriesIx=fields.seriesIx,missingValues=this.seriesMissingValues(this.options.series[seriesIx]),seriesPoints=this.seriesPoints[seriesIx];let point,pointValue=value;has_value_hasValue(x)&&has_value_hasValue(y)||(pointValue=this.createMissingValue(pointValue,missingValues)),pointValue&&(point=this.createPoint(pointValue,fields),point&&(Object.assign(point,fields),this.addErrorBar(point,X,fields),this.addErrorBar(point,Y,fields)),this.updateRange(pointValue,fields.series)),this.points.push(point),seriesPoints.push(point)}seriesMissingValues(series){return series.missingValues}createMissingValue(){}updateRange(value,series){const intlService=this.chartService.intl,{xAxis:xAxisName,yAxis:yAxisName}=series;let{x:x,y:y}=value,xAxisRange=this.xAxisRanges[xAxisName],yAxisRange=this.yAxisRanges[yAxisName];has_value_hasValue(x)&&(xAxisRange=this.xAxisRanges[xAxisName]=xAxisRange||{min:MAX_VALUE,max:MIN_VALUE},isString(x)&&(x=parse_date_parseDate(intlService,x)),xAxisRange.min=Math.min(xAxisRange.min,x),xAxisRange.max=Math.max(xAxisRange.max,x)),has_value_hasValue(y)&&(yAxisRange=this.yAxisRanges[yAxisName]=yAxisRange||{min:MAX_VALUE,max:MIN_VALUE},isString(y)&&(y=parse_date_parseDate(intlService,y)),yAxisRange.min=Math.min(yAxisRange.min,y),yAxisRange.max=Math.max(yAxisRange.max,y))}evalPointOptions(options,value,fields){const{series:series,seriesIx:seriesIx}=fields,state={defaults:series._defaults,excluded:[\"data\",\"tooltip\",\"content\",\"template\",\"visual\",\"toggle\",\"_outOfRangeMinPoint\",\"_outOfRangeMaxPoint\"]};let doEval=this._evalSeries[seriesIx];defined(doEval)||(this._evalSeries[seriesIx]=doEval=evalOptions(options,{},state,!0));let pointOptions=options;return doEval&&(pointOptions=deepExtend({},options),evalOptions(pointOptions,{value:value,series:series,dataItem:fields.dataItem},state)),pointOptions}pointType(){return line_point}pointOptions(series,seriesIx){let options=this.seriesOptions[seriesIx];if(!options){const defaults=this.pointType().prototype.defaults;this.seriesOptions[seriesIx]=options=deepExtend({},defaults,{markers:{opacity:series.opacity},tooltip:{format:this.options.tooltip.format},labels:{format:this.options.labels.format}},series)}return options}createPoint(value,fields){const series=fields.series;let pointOptions=this.pointOptions(series,fields.seriesIx),color=fields.color||series.color;pointOptions=this.evalPointOptions(pointOptions,value,fields),isFunction(series.color)&&(color=pointOptions.color);const point=new line_point(value,pointOptions);return point.color=color,this.append(point),point}seriesAxes(series){const{xAxis:xAxisName,yAxis:yAxisName}=series,plotArea=this.plotArea,xAxis=xAxisName?plotArea.namedXAxes[xAxisName]:plotArea.axisX,yAxis=yAxisName?plotArea.namedYAxes[yAxisName]:plotArea.axisY;if(!xAxis)throw new Error(\"Unable to locate X axis with name \"+xAxisName);if(!yAxis)throw new Error(\"Unable to locate Y axis with name \"+yAxisName);return{x:xAxis,y:yAxis}}reflow(targetBox){const chartPoints=this.points,limit=!this.options.clip;let pointIx=0;this.traverseDataPoints((value,fields)=>{const point=chartPoints[pointIx++],seriesAxes=this.seriesAxes(fields.series),slotX=seriesAxes.x.getSlot(value.x,value.x,limit),slotY=seriesAxes.y.getSlot(value.y,value.y,limit);if(point)if(slotX&&slotY){const pointSlot=this.pointSlot(slotX,slotY);point.reflow(pointSlot)}else point.visible=!1}),this.box=targetBox}pointSlot(slotX,slotY){return new core_box(slotX.x1,slotY.y1,slotX.x2,slotY.y2)}traverseDataPoints(callback){const{options:{series:series},seriesPoints:seriesPoints}=this;for(let seriesIx=0;seriesIx<series.length;seriesIx++){const currentSeries=series[seriesIx];seriesPoints[seriesIx]||(seriesPoints[seriesIx]=[]);for(let pointIx=0;pointIx<currentSeries.data.length;pointIx++){const{valueFields:value,fields:fields}=this._bindPoint(currentSeries,seriesIx,pointIx);callback(value,deepExtend({pointIx:pointIx,series:currentSeries,seriesIx:seriesIx,dataItem:currentSeries.data[pointIx],owner:this},fields))}}}formatPointValue(point,format){const value=point.value;return this.chartService.format.auto(format,value.x,value.y)}animationPoints(){const points=this.points,result=[];for(let idx=0;idx<points.length;idx++)result.push((points[idx]||{}).marker);return result}}setDefaultOptions(scatter_chart_ScatterChart,{series:[],tooltip:{format:\"{0}, {1}\"},labels:{format:\"{0}, {1}\"},clip:!0}),deepExtend(scatter_chart_ScatterChart.prototype,clip_animation_mixin,{_bindPoint:categorical_chart.prototype._bindPoint});var scatter_chart=scatter_chart_ScatterChart;class bubble_Bubble extends line_point{constructor(value,options){super(value,options),this.category=value.category}createHighlight(){const highlight=this.options.highlight,border=highlight.border,markers=this.options.markers,center=this.box.center(),radius=(markers.size+markers.border.width+border.width)/2,highlightGroup=new main.a.Group,shadow=new main.a.Circle(new main.b.Circle([center.x,center.y+radius/5+border.width/2],radius+border.width/2),{stroke:{color:\"none\"},fill:this.createGradient({gradient:\"bubbleShadow\",color:markers.background,stops:[{offset:0,color:markers.background,opacity:.3},{offset:1,color:markers.background,opacity:0}]})}),overlay=new main.a.Circle(new main.b.Circle([center.x,center.y],radius),{stroke:{color:border.color||new color_color.a(markers.background).brightness(.8).toHex(),width:border.width,opacity:border.opacity},fill:{color:markers.background,opacity:highlight.opacity}});return highlightGroup.append(shadow,overlay),highlightGroup}}bubble_Bubble.prototype.defaults=deepExtend({},bubble_Bubble.prototype.defaults,{labels:{position:CENTER},highlight:{opacity:1,border:{color:\"#fff\",width:2,opacity:1}}}),bubble_Bubble.prototype.defaults.highlight.zIndex=void 0;var bubble=bubble_Bubble;class bubble_chart_BubbleChart extends scatter_chart{_initFields(){this._maxSize=MIN_VALUE,super._initFields()}addValue(value,fields){null!==value.size&&(value.size>0||value.size<0&&fields.series.negativeValues.visible)?(this._maxSize=Math.max(this._maxSize,Math.abs(value.size)),super.addValue(value,fields)):(this.points.push(null),this.seriesPoints[fields.seriesIx].push(null))}reflow(box){this.updateBubblesSize(box),super.reflow(box)}pointType(){return bubble}createPoint(value,fields){const series=fields.series,delay=fields.pointIx*(600/series.data.length),animationOptions={delay:delay,duration:600-delay,type:\"bubble\"};let color=fields.color||series.color;value.size<0&&series.negativeValues.visible&&(color=valueOrDefault(series.negativeValues.color,color));let pointOptions=deepExtend({labels:{animation:{delay:delay,duration:600-delay}}},this.pointOptions(series,fields.seriesIx),{markers:{type:CIRCLE,border:series.border,opacity:series.opacity,animation:animationOptions}});pointOptions=this.evalPointOptions(pointOptions,value,fields),isFunction(series.color)&&(color=pointOptions.color),pointOptions.markers.background=color;const point=new bubble(value,pointOptions);return point.color=color,this.append(point),point}updateBubblesSize(box){const{options:{series:series}}=this,boxSize=Math.min(box.width(),box.height());for(let seriesIx=0;seriesIx<series.length;seriesIx++){const currentSeries=series[seriesIx],seriesPoints=this.seriesPoints[seriesIx],minR=(currentSeries.minSize||Math.max(.02*boxSize,10))/2,maxR=(currentSeries.maxSize||.2*boxSize)/2,minArea=Math.PI*minR*minR,areaRatio=(Math.PI*maxR*maxR-minArea)/this._maxSize;for(let pointIx=0;pointIx<seriesPoints.length;pointIx++){const point=seriesPoints[pointIx];if(point){const area=Math.abs(point.value.size)*areaRatio,radius=Math.sqrt((minArea+area)/Math.PI),zIndex=valueOrDefault(point.options.zIndex,0)+(1-radius/maxR);deepExtend(point.options,{zIndex:zIndex,markers:{size:2*radius,zIndex:zIndex},labels:{zIndex:zIndex+1}})}}}}formatPointValue(point,format){const value=point.value;return this.chartService.format.auto(format,value.x,value.y,value.size,point.category)}createAnimation(){}createVisual(){}}setDefaultOptions(bubble_chart_BubbleChart,{tooltip:{format:\"{3}\"},labels:{format:\"{3}\"}});var bubble_chart=bubble_chart_BubbleChart;class target_Target extends shape_element{}deepExtend(target_Target.prototype,point_events_mixin);var bullet_chart_target=target_Target;class bullet_Bullet extends chart_element{constructor(value,options){super(options),this.aboveAxis=this.options.aboveAxis,this.color=options.color||WHITE,this.value=value}render(){const options=this.options;this._rendered||(this._rendered=!0,defined(this.value.target)&&(this.target=new bullet_chart_target({type:options.target.shape,background:options.target.color||this.color,opacity:options.opacity,zIndex:options.zIndex,border:options.target.border,vAlign:TOP,align:RIGHT}),this.target.value=this.value,this.target.dataItem=this.dataItem,this.target.series=this.series,this.append(this.target)),this.createNote())}reflow(box){this.render();const{options:options,target:target,owner:chart}=this,invertAxes=options.invertAxes,valueAxis=chart.seriesValueAxis(this.options),categorySlot=chart.categorySlot(chart.categoryAxis,options.categoryIx,valueAxis),targetValueSlot=valueAxis.getSlot(this.value.target),targetSlotX=invertAxes?targetValueSlot:categorySlot,targetSlotY=invertAxes?categorySlot:targetValueSlot;if(target){const targetSlot=new core_box(targetSlotX.x1,targetSlotY.y1,targetSlotX.x2,targetSlotY.y2);target.options.height=invertAxes?targetSlot.height():options.target.line.width,target.options.width=invertAxes?options.target.line.width:targetSlot.width(),target.reflow(targetSlot)}this.note&&this.note.reflow(box),this.box=box}createVisual(){super.createVisual();const options=this.options,body=main.a.Path.fromRect(this.box.toRect(),{fill:{color:this.color,opacity:options.opacity},stroke:null});options.border.width>0&&body.options.set(\"stroke\",{color:options.border.color||this.color,width:options.border.width,dashType:options.border.dashType,opacity:valueOrDefault(options.border.opacity,options.opacity)}),this.bodyVisual=body,alignPathToPixel(body),this.visual.append(body)}createAnimation(){this.bodyVisual&&(this.animation=main.a.Animation.create(this.bodyVisual,this.options.animation))}createHighlight(style){return main.a.Path.fromRect(this.box.toRect(),style)}highlightVisual(){return this.bodyVisual}highlightVisualArgs(){return{rect:this.box.toRect(),visual:this.bodyVisual,options:this.options}}formatValue(format){return this.owner.formatPointValue(this,format)}}bullet_Bullet.prototype.tooltipAnchor=bar.prototype.tooltipAnchor,setDefaultOptions(bullet_Bullet,{border:{width:1},vertical:!1,opacity:1,target:{shape:\"\",border:{width:0,color:\"green\"},line:{width:2}},tooltip:{format:\"Current: {0}<br />Target: {1}\"}}),deepExtend(bullet_Bullet.prototype,point_events_mixin),deepExtend(bullet_Bullet.prototype,note_mixin);var bullet_chart_bullet=bullet_Bullet;class bullet_chart_BulletChart extends categorical_chart{constructor(plotArea,options){!function(options){const series=options.series;for(let i=0;i<series.length;i++){const seriesItem=series[i],data=seriesItem.data;!data||isArray(data[0])||isObject(data[0])||(seriesItem.data=[data])}}(options),super(plotArea,options)}reflowCategories(categorySlots){const children=this.children,childrenLength=children.length;for(let i=0;i<childrenLength;i++)children[i].reflow(categorySlots[i])}plotRange(point){const valueAxis=this.seriesValueAxis(point.series),axisCrossingValue=this.categoryAxisCrossingValue(valueAxis);return[axisCrossingValue,point.value.current||axisCrossingValue]}createPoint(data,fields){const{categoryIx:categoryIx,category:category,series:series,seriesIx:seriesIx}=fields,{options:options,children:children}=this,value=data.valueFields;let bulletOptions=deepExtend({vertical:!options.invertAxes,overlay:series.overlay,categoryIx:categoryIx,invertAxes:options.invertAxes},series),color=data.fields.color||series.color;bulletOptions=this.evalPointOptions(bulletOptions,value,category,categoryIx,series,seriesIx),isFunction(series.color)&&(color=bulletOptions.color);const bullet=new bullet_chart_bullet(value,bulletOptions);bullet.color=color;let cluster=children[categoryIx];return cluster||(cluster=new cluster_layout({vertical:options.invertAxes,gap:options.gap,spacing:options.spacing,rtl:!options.invertAxes&&(this.chartService||{}).rtl}),this.append(cluster)),cluster.append(bullet),bullet}updateRange(value,fields){const{current:current,target:target}=value,axisName=fields.series.axis;let axisRange=this.valueAxisRanges[axisName];defined(current)&&!isNaN(current)&&defined(target&&!isNaN(target))&&(axisRange=this.valueAxisRanges[axisName]=axisRange||{min:MAX_VALUE,max:MIN_VALUE},axisRange.min=Math.min(axisRange.min,current,target),axisRange.max=Math.max(axisRange.max,current,target))}formatPointValue(point,format){return this.chartService.format.auto(format,point.value.current,point.value.target)}pointValue(data){return data.valueFields.current}aboveAxis(point){return point.value.current>0}createAnimation(){const points=this.points;this._setAnimationOptions();for(let idx=0;idx<points.length;idx++){const point=points[idx];point.options.animation=this.options.animation,point.createAnimation()}}}bullet_chart_BulletChart.prototype._setAnimationOptions=bar_chart.prototype._setAnimationOptions,setDefaultOptions(bullet_chart_BulletChart,{animation:{type:BAR}});var bullet_chart=bullet_chart_BulletChart;class base_tooltip_BaseTooltip extends common_class.a{constructor(chartService,options){super(),this.chartService=chartService,this.options=deepExtend({},this.options,options)}getStyle(options,point){let{background:background,border:{color:border}}=options;if(point){const pointColor=point.color||point.options.color;background=valueOrDefault(background,pointColor),border=valueOrDefault(border,pointColor)}const padding=getSpacing(options.padding||{},\"auto\");return{backgroundColor:background,borderColor:border,font:options.font,color:options.color,opacity:options.opacity,borderWidth:styleValue(options.border.width),paddingTop:styleValue(padding.top),paddingBottom:styleValue(padding.bottom),paddingLeft:styleValue(padding.left),paddingRight:styleValue(padding.right)}}show(options,tooltipOptions,point){options.format=tooltipOptions.format;const style=this.getStyle(tooltipOptions,point);options.style=style,!defined(tooltipOptions.color)&&new color_color.a(style.backgroundColor).percBrightness()>180&&(options.className=\"k-chart-tooltip-inverse\"),this.chartService.notify(\"showTooltip\",options),this.visible=!0}hide(){this.chartService&&this.chartService.notify(\"hideTooltip\"),this.visible=!1}destroy(){delete this.chartService}}setDefaultOptions(base_tooltip_BaseTooltip,{border:{width:1},opacity:1});var base_tooltip=base_tooltip_BaseTooltip;class crosshair_tooltip_CrosshairTooltip extends base_tooltip{constructor(chartService,crosshair,options){super(chartService,options),this.crosshair=crosshair,this.formatService=chartService.format,this.initAxisName()}initAxisName(){const axis=this.crosshair.axis;let name;name=axis.plotArea.categoryAxis?axis.getCategory?\"categoryAxis\":\"valueAxis\":axis.options.vertical?\"yAxis\":\"xAxis\",this.axisName=name}showAt(point){const{crosshair:{axis:axis},options:options}=this;let value=axis[options.stickyMode?\"getCategory\":\"getValue\"](point),formattedValue=value;options.format?formattedValue=this.formatService.auto(options.format,value):axis.options.type===DATE&&(formattedValue=this.formatService.auto(axis.options.labels.dateFormats[axis.options.baseUnit],value)),this.show({point:point,anchor:this.getAnchor(),crosshair:this.crosshair,value:formattedValue,axisName:this.axisName,axisIndex:this.crosshair.axis.axisIndex},this.options)}hide(){this.chartService.notify(\"hideTooltip\",{crosshair:this.crosshair,axisName:this.axisName,axisIndex:this.crosshair.axis.axisIndex})}getAnchor(){const{crosshair:crosshair,options:{position:position,padding:padding}}=this,vertical=!crosshair.axis.options.vertical,lineBox=crosshair.line.bbox();let horizontalAlign,verticalAlign,point;return vertical?(horizontalAlign=CENTER,position===BOTTOM?(verticalAlign=TOP,point=lineBox.bottomLeft().translate(0,padding)):(verticalAlign=BOTTOM,point=lineBox.topLeft().translate(0,-padding))):(verticalAlign=CENTER,position===LEFT?(horizontalAlign=RIGHT,point=lineBox.topLeft().translate(-padding,0)):(horizontalAlign=LEFT,point=lineBox.topRight().translate(padding,0))),{point:point,align:{horizontal:horizontalAlign,vertical:verticalAlign}}}}setDefaultOptions(crosshair_tooltip_CrosshairTooltip,{padding:10});var crosshair_tooltip=crosshair_tooltip_CrosshairTooltip;class crosshair_Crosshair extends chart_element{constructor(chartService,axis,options){super(options),this.axis=axis,this.stickyMode=axis instanceof category_axis;const tooltipOptions=this.options.tooltip;tooltipOptions.visible&&(this.tooltip=new crosshair_tooltip(chartService,this,deepExtend({},tooltipOptions,{stickyMode:this.stickyMode})))}showAt(point){this.point=point,this.moveLine(),this.line.visible(!0),this.tooltip&&this.tooltip.showAt(point)}hide(){this.line.visible(!1),this.tooltip&&this.tooltip.hide()}moveLine(){const{axis:axis,point:point}=this,vertical=axis.options.vertical,box=this.getBox(),dim=vertical?Y:X,lineStart=new main.b.Point(box.x1,box.y1);let lineEnd;if(lineEnd=vertical?new main.b.Point(box.x2,box.y1):new main.b.Point(box.x1,box.y2),point)if(this.stickyMode){const slot=axis.getSlot(axis.pointCategoryIndex(point));lineStart[dim]=lineEnd[dim]=slot.center()[dim]}else lineStart[dim]=lineEnd[dim]=point[dim];this.box=box,this.line.moveTo(lineStart).lineTo(lineEnd)}getBox(){const axis=this.axis,axes=axis.pane.axes,length=axes.length,vertical=axis.options.vertical,box=axis.lineBox().clone(),dim=vertical?X:Y;let axisLineBox;for(let i=0;i<length;i++){const currentAxis=axes[i];currentAxis.options.vertical!==vertical&&(axisLineBox?axisLineBox.wrap(currentAxis.lineBox()):axisLineBox=currentAxis.lineBox().clone())}return box[dim+1]=axisLineBox[dim+1],box[dim+2]=axisLineBox[dim+2],box}createVisual(){super.createVisual();const options=this.options;this.line=new main.a.Path({stroke:{color:options.color,width:options.width,opacity:options.opacity,dashType:options.dashType},visible:!1}),this.moveLine(),this.visual.append(this.line)}destroy(){this.tooltip&&this.tooltip.destroy(),super.destroy()}}setDefaultOptions(crosshair_Crosshair,{color:BLACK,width:2,zIndex:-1,tooltip:{visible:!1}});var crosshair_crosshair=crosshair_Crosshair;class chart_container_ChartContainer extends chart_element{constructor(options,pane){super(options),this.pane=pane}shouldClip(){const children=this.children,length=children.length;for(let i=0;i<length;i++)if(!0===children[i].options.clip)return!0;return!1}_clipBox(){return this.pane.chartsBox()}createVisual(){if(this.visual=new main.a.Group({zIndex:0}),this.shouldClip()){const clipRect=(this.clipBox=this._clipBox()).toRect(),clipPath=main.a.Path.fromRect(clipRect);alignPathToPixel(clipPath),this.visual.clip(clipPath),this.unclipLabels()}}stackRoot(){return this}unclipLabels(){const{children:charts,clipBox:clipBox}=this;for(let i=0;i<charts.length;i++){const points=charts[i].points||{},length=points.length;for(let j=0;j<length;j++){const point=points[j];if(point&&!1!==point.visible&&point.overlapsBox&&point.overlapsBox(clipBox))if(point.unclipElements)point.unclipElements();else{const{label:label,note:note}=point;label&&label.options.visible&&(label.alignToClipBox&&label.alignToClipBox(clipBox),label.options.noclip=!0),note&&note.options.visible&&(note.options.noclip=!0)}}}}destroy(){super.destroy(),delete this.parent}}chart_container_ChartContainer.prototype.isStackRoot=!0;var chart_container=chart_container_ChartContainer;class pane_Pane extends box_element{constructor(options){super(options),this.id=\"pane\"+ID++,this.createTitle(),this.content=new chart_element,this.chartContainer=new chart_container({},this),this.append(this.content),this.axes=[],this.charts=[]}createTitle(){let titleOptions=this.options.title;isObject(titleOptions)&&(titleOptions=deepExtend({},titleOptions,{align:titleOptions.position,position:TOP})),this.title=core_title.buildTitle(titleOptions,this,pane_Pane.prototype.options.title)}appendAxis(axis){this.content.append(axis),this.axes.push(axis),axis.pane=this}appendAxisAt(axis,pos){this.content.append(axis),this.axes.splice(pos,0,axis),axis.pane=this}appendChart(chart){this.chartContainer.parent!==this.content&&this.content.append(this.chartContainer),this.charts.push(chart),this.chartContainer.append(chart),chart.pane=this}empty(){const plotArea=this.parent;if(plotArea){for(let i=0;i<this.axes.length;i++)plotArea.removeAxis(this.axes[i]);for(let i=0;i<this.charts.length;i++)plotArea.removeChart(this.charts[i])}this.axes=[],this.charts=[],this.content.destroy(),this.content.children=[],this.chartContainer.children=[]}reflow(targetBox){let content;last(this.children)===this.content&&(content=this.children.pop()),super.reflow(targetBox),content&&this.children.push(content),this.title&&(this.contentBox.y1+=this.title.box.height())}visualStyle(){const style=super.visualStyle();return style.zIndex=-10,style}renderComplete(){this.options.visible&&this.createGridLines()}stackRoot(){return this}clipRoot(){return this}createGridLines(){const axes=this.axes,allAxes=axes.concat(this.parent.axes),vGridLines=[],hGridLines=[];for(let i=0;i<axes.length;i++){const axis=axes[i],vertical=axis.options.vertical,gridLines=vertical?vGridLines:hGridLines;for(let j=0;j<allAxes.length;j++)if(0===gridLines.length){const altAxis=allAxes[j];vertical!==altAxis.options.vertical&&append(gridLines,axis.createGridLines(altAxis))}}}refresh(){this.visual.clear(),this.content.parent=null,this.content.createGradient=this.createGradient.bind(this),this.content.renderVisual(),this.content.parent=this,this.title&&this.visual.append(this.title.visual),this.visual.append(this.content.visual),this.renderComplete(),this.notifyRender()}chartsBox(){const axes=this.axes,length=axes.length,chartsBox=new core_box;for(let idx=0;idx<length;idx++){const axis=axes[idx],axisValueField=axis.options.vertical?Y:X,lineBox=axis.lineBox();chartsBox[axisValueField+1]=lineBox[axisValueField+1],chartsBox[axisValueField+2]=lineBox[axisValueField+2]}if(0===chartsBox.x2){const allAxes=this.parent.axes,length=allAxes.length;for(let idx=0;idx<length;idx++){const axis=allAxes[idx];if(!axis.options.vertical){const lineBox=axis.lineBox();chartsBox.x1=lineBox.x1,chartsBox.x2=lineBox.x2}}}return chartsBox}clipBox(){return this.chartContainer.clipBox}notifyRender(){const service=this.getService();service&&service.notify(\"paneRender\",{pane:new chart_pane(this),index:this.paneIndex,name:this.options.name})}}let ID=1;pane_Pane.prototype.isStackRoot=!0,setDefaultOptions(pane_Pane,{zIndex:-1,shrinkToFit:!0,title:{align:LEFT},visible:!0});var es2015_chart_pane=pane_Pane;function appendIfNotNull(array,element){null!==element&&array.push(element)}function segmentVisible(series,fields,index){const visible=fields.visible;if(defined(visible))return visible;const pointVisibility=series.pointVisibility;return pointVisibility?pointVisibility[index]:void 0}function bindSegments(series){const data=series.data,points=[];let sum=0,count=0;for(let idx=0;idx<data.length;idx++){const pointData=series_binder.current.bindPoint(series,idx);let value=pointData.valueFields.value;isString(value)&&(value=parseFloat(value)),isNumber(value)?(pointData.visible=!1!==segmentVisible(series,pointData.fields,idx),pointData.value=Math.abs(value),points.push(pointData),pointData.visible&&(sum+=pointData.value),0!==value&&count++):points.push(null)}return{total:sum,points:points,count:count}}function equalsIgnoreCase(a,b){return a&&b?a.toLowerCase()===b.toLowerCase():a===b}function filterSeriesByType(series,types){const result=[],seriesTypes=[].concat(types);for(let idx=0;idx<series.length;idx++){const currentSeries=series[idx];inArray(currentSeries.type,seriesTypes)&&result.push(currentSeries)}return result}function getDateField(field,row,intlService){if(null===row)return row;const key=\"_date_\"+field;let value=row[key];return value||(value=parse_date_parseDate(intlService,getter_getter(field)(row)),row[key]=value),value}function isDateAxis(axisOptions,sampleCategory){const type=axisOptions.type,dateCategory=sampleCategory instanceof Date;return!type&&dateCategory||equalsIgnoreCase(type,DATE)}function singleItemOrArray(array){return 1===array.length?array[0]:array}const AREA_REGEX=/area/i;function create_out_of_range_points_hasValue(series,item){const valueFields=series_binder.current.bindPoint(series,null,item).valueFields;for(let field in valueFields)if(convertableToNumber(valueFields[field]))return!0}function findNext({start:start,dir:dir,min:min,max:max,getter:getter,hasItem:hasItem,series:series}){let pointHasValue,outPoint,idx=start;do{idx+=dir,hasItem(idx)&&(outPoint=getter(idx),pointHasValue=create_out_of_range_points_hasValue(series,outPoint.item))}while(min<=idx&&idx<=max&&!pointHasValue);if(pointHasValue)return outPoint}function createOutOfRangePoints(series,range,count,getter,hasItem){const{min:min,max:max}=range,hasMinPoint=min>0&&min<count,hasMaxPoint=max+1<count;if(hasMinPoint||hasMaxPoint){let minPoint,maxPoint;if(\"interpolate\"!==function(series){return series.missingValues?series.missingValues:AREA_REGEX.test(series.type)||series.stack?ZERO:\"interpolate\"}(series))hasMinPoint&&(minPoint=getter(min-1)),hasMaxPoint&&(maxPoint=getter(max+1));else{let outPoint,pointHasValue;hasMinPoint&&(outPoint=getter(min-1),pointHasValue=create_out_of_range_points_hasValue(series,outPoint.item),minPoint=pointHasValue?outPoint:findNext({start:min,dir:-1,min:0,max:count-1,getter:getter,hasItem:hasItem,series:series})),hasMaxPoint&&(outPoint=getter(max+1),pointHasValue=create_out_of_range_points_hasValue(series,outPoint.item),maxPoint=pointHasValue?outPoint:findNext({start:max,dir:1,min:0,max:count-1,getter:getter,hasItem:hasItem,series:series}))}minPoint&&(series._outOfRangeMinPoint=minPoint),maxPoint&&(series._outOfRangeMaxPoint=maxPoint)}}class plotarea_base_PlotAreaBase extends chart_element{constructor(series,options,chartService){super(options),this.initFields(series,options),this.series=series,this.initSeries(),this.charts=[],this.options.legend=this.options.legend||{},this.options.legend.items=[],this.axes=[],this.crosshairs=[],this.chartService=chartService,this.originalOptions=options,this.createPanes(),this.render(),this.createCrosshairs()}initFields(){}initSeries(){const series=this.series;for(let i=0;i<series.length;i++)series[i].index=i}createPanes(){const titleOptions=this.options.title||{},paneDefaults=this.options.paneDefaults,paneOptions=this.options.panes||[],panesLength=Math.max(paneOptions.length,1),panes=[],defaults=deepExtend({title:{color:titleOptions.color}},paneDefaults);for(let i=0;i<panesLength;i++){const options=deepExtend({},defaults,paneOptions[i]);isString(options.title)&&(options.title=deepExtend({text:options.title},defaults.title));const currentPane=new es2015_chart_pane(options);currentPane.paneIndex=i,panes.push(currentPane),this.append(currentPane)}this.panes=panes}createCrosshairs(panes=this.panes){for(let i=0;i<panes.length;i++){const pane=panes[i];for(let j=0;j<pane.axes.length;j++){const axis=pane.axes[j];if(axis.options.crosshair&&axis.options.crosshair.visible){const currentCrosshair=new crosshair_crosshair(this.chartService,axis,axis.options.crosshair);this.crosshairs.push(currentCrosshair),pane.content.append(currentCrosshair)}}}}removeCrosshairs(pane){const crosshairs=this.crosshairs,axes=pane.axes;for(let i=crosshairs.length-1;i>=0;i--)for(let j=0;j<axes.length;j++)if(crosshairs[i].axis===axes[j]){crosshairs.splice(i,1);break}}hideCrosshairs(){const crosshairs=this.crosshairs;for(let idx=0;idx<crosshairs.length;idx++)crosshairs[idx].hide()}findPane(name){const panes=this.panes;let matchingPane;for(let i=0;i<panes.length;i++)if(panes[i].options.name===name){matchingPane=panes[i];break}return matchingPane||panes[0]}findPointPane(point){const panes=this.panes;let matchingPane;for(let i=0;i<panes.length;i++)if(panes[i].box.containsPoint(point)){matchingPane=panes[i];break}return matchingPane}appendAxis(axis){this.findPane(axis.options.pane).appendAxis(axis),this.axes.push(axis),axis.plotArea=this}removeAxis(axisToRemove){const filteredAxes=[];for(let i=0;i<this.axes.length;i++){const axis=this.axes[i];axisToRemove!==axis?filteredAxes.push(axis):axis.destroy()}this.axes=filteredAxes}appendChart(chart,pane){this.charts.push(chart),pane?pane.appendChart(chart):this.append(chart)}removeChart(chartToRemove){const filteredCharts=[];for(let i=0;i<this.charts.length;i++){const chart=this.charts[i];chart!==chartToRemove?filteredCharts.push(chart):chart.destroy()}this.charts=filteredCharts}addToLegend(series){const count=series.length,legend=this.options.legend,labels=legend.labels||{},inactiveItems=legend.inactiveItems||{},inactiveItemsLabels=inactiveItems.labels||{},data=[];for(let i=0;i<count;i++){const currentSeries=series[i],seriesVisible=!1!==currentSeries.visible;if(!1===currentSeries.visibleInLegend)continue;let text=currentSeries.name;const labelTemplate=seriesVisible?getTemplate(labels):getTemplate(inactiveItemsLabels)||getTemplate(labels);labelTemplate&&(text=labelTemplate({text:has_value_hasValue(text)?text:\"\",series:currentSeries}));const defaults=currentSeries._defaults;let itemLabelOptions,markerColor,color=currentSeries.color;isFunction(color)&&defaults&&(color=defaults.color),seriesVisible?(itemLabelOptions={},markerColor=color):(itemLabelOptions={color:inactiveItemsLabels.color,font:inactiveItemsLabels.font},markerColor=inactiveItems.markers.color),has_value_hasValue(text)&&\"\"!==text&&data.push({text:text,labels:itemLabelOptions,markerColor:markerColor,series:currentSeries,active:seriesVisible})}append(legend.items,data)}groupAxes(panes){const xAxes=[],yAxes=[];for(let paneIx=0;paneIx<panes.length;paneIx++){const paneAxes=panes[paneIx].axes;for(let axisIx=0;axisIx<paneAxes.length;axisIx++){const axis=paneAxes[axisIx];axis.options.vertical?yAxes.push(axis):xAxes.push(axis)}}return{x:xAxes,y:yAxes,any:xAxes.concat(yAxes)}}groupSeriesByPane(){const series=this.series,seriesByPane={};for(let i=0;i<series.length;i++){const currentSeries=series[i],pane=this.seriesPaneName(currentSeries);seriesByPane[pane]?seriesByPane[pane].push(currentSeries):seriesByPane[pane]=[currentSeries]}return seriesByPane}filterVisibleSeries(series){const result=[];for(let i=0;i<series.length;i++){const currentSeries=series[i];!1!==currentSeries.visible&&result.push(currentSeries)}return result}reflow(targetBox){const panes=this.panes,margin=getSpacing(this.options.plotArea.margin);this.box=targetBox.clone().unpad(margin),this.reflowPanes(),this.detachLabels(),this.reflowAxes(panes),this.reflowCharts(panes)}redraw(panes){const panesArray=[].concat(panes);this.initSeries();const root=this.getRoot();root&&root.cleanGradients();for(let i=0;i<panesArray.length;i++)this.removeCrosshairs(panesArray[i]),panesArray[i].empty();this.render(panesArray),this.detachLabels(),this.reflowAxes(this.panes),this.reflowCharts(panesArray),this.createCrosshairs(panesArray);for(let i=0;i<panesArray.length;i++)panesArray[i].refresh()}axisCrossingValues(axis,crossingAxes){const options=axis.options,crossingValues=[].concat(options.axisCrossingValues||options.axisCrossingValue),valuesToAdd=crossingAxes.length-crossingValues.length,defaultValue=crossingValues[0]||0;for(let i=0;i<valuesToAdd;i++)crossingValues.push(defaultValue);return crossingValues}alignAxisTo(axis,targetAxis,crossingValue,targetCrossingValue){const slot=axis.getSlot(crossingValue,crossingValue,!0),slotEdge=axis.options.reverse?2:1,targetSlot=targetAxis.getSlot(targetCrossingValue,targetCrossingValue,!0),targetEdge=targetAxis.options.reverse?2:1,axisBox=axis.box.translate(targetSlot[X+targetEdge]-slot[X+slotEdge],targetSlot[Y+targetEdge]-slot[Y+slotEdge]);axis.pane!==targetAxis.pane&&axisBox.translate(0,axis.pane.box.y1-targetAxis.pane.box.y1),axis.reflow(axisBox)}alignAxes(xAxes,yAxes){const xAnchor=xAxes[0],yAnchor=yAxes[0],xAnchorCrossings=this.axisCrossingValues(xAnchor,yAxes),yAnchorCrossings=this.axisCrossingValues(yAnchor,xAxes),leftAnchors={},rightAnchors={},topAnchors={},bottomAnchors={};for(let i=0;i<yAxes.length;i++){const axis=yAxes[i],pane=axis.pane,paneId=pane.id,visible=!1!==axis.options.visible,anchor=paneAnchor(xAxes,pane)||xAnchor;let anchorCrossings=xAnchorCrossings;anchor!==xAnchor&&(anchorCrossings=this.axisCrossingValues(anchor,yAxes)),this.alignAxisTo(axis,anchor,yAnchorCrossings[i],anchorCrossings[i]),axis.options._overlap||(round(axis.lineBox().x1)===round(anchor.lineBox().x1)&&(leftAnchors[paneId]&&axis.reflow(axis.box.alignTo(leftAnchors[paneId].box,LEFT).translate(-axis.options.margin,0)),visible&&(leftAnchors[paneId]=axis)),round(axis.lineBox().x2)===round(anchor.lineBox().x2)&&(axis._mirrored||(axis.options.labels.mirror=!axis.options.labels.mirror,axis._mirrored=!0),this.alignAxisTo(axis,anchor,yAnchorCrossings[i],anchorCrossings[i]),rightAnchors[paneId]&&axis.reflow(axis.box.alignTo(rightAnchors[paneId].box,RIGHT).translate(axis.options.margin,0)),visible&&(rightAnchors[paneId]=axis)),0!==i&&yAnchor.pane===axis.pane&&(axis.alignTo(yAnchor),axis.reflow(axis.box)))}for(let i=0;i<xAxes.length;i++){const axis=xAxes[i],pane=axis.pane,paneId=pane.id,visible=!1!==axis.options.visible,anchor=paneAnchor(yAxes,pane)||yAnchor;let anchorCrossings=yAnchorCrossings;anchor!==yAnchor&&(anchorCrossings=this.axisCrossingValues(anchor,xAxes)),this.alignAxisTo(axis,anchor,xAnchorCrossings[i],anchorCrossings[i]),axis.options._overlap||(round(axis.lineBox().y1)===round(anchor.lineBox().y1)&&(axis._mirrored||(axis.options.labels.mirror=!axis.options.labels.mirror,axis._mirrored=!0),this.alignAxisTo(axis,anchor,xAnchorCrossings[i],anchorCrossings[i]),topAnchors[paneId]&&axis.reflow(axis.box.alignTo(topAnchors[paneId].box,TOP).translate(0,-axis.options.margin)),visible&&(topAnchors[paneId]=axis)),round(axis.lineBox().y2,3)===round(anchor.lineBox().y2,3)&&(bottomAnchors[paneId]&&axis.reflow(axis.box.alignTo(bottomAnchors[paneId].box,BOTTOM).translate(0,axis.options.margin)),visible&&(bottomAnchors[paneId]=axis)),0!==i&&(axis.alignTo(xAnchor),axis.reflow(axis.box)))}}shrinkAxisWidth(panes){const axes=this.groupAxes(panes).any,axisBox=axisGroupBox(axes);let overflowX=0;for(let i=0;i<panes.length;i++){const currentPane=panes[i];currentPane.axes.length>0&&(overflowX=Math.max(overflowX,axisBox.width()-currentPane.contentBox.width()))}if(0!==overflowX)for(let i=0;i<axes.length;i++){const currentAxis=axes[i];currentAxis.options.vertical||currentAxis.reflow(currentAxis.box.shrink(overflowX,0))}}shrinkAxisHeight(panes){let shrinked;for(let i=0;i<panes.length;i++){const currentPane=panes[i],axes=currentPane.axes,overflowY=Math.max(0,axisGroupBox(axes).height()-currentPane.contentBox.height());if(0!==overflowY){for(let j=0;j<axes.length;j++){const currentAxis=axes[j];currentAxis.options.vertical&&currentAxis.reflow(currentAxis.box.shrink(0,overflowY))}shrinked=!0}}return shrinked}fitAxes(panes){const axes=this.groupAxes(panes).any;let offsetX=0;for(let i=0;i<panes.length;i++){const currentPane=panes[i],paneAxes=currentPane.axes,paneBox=currentPane.contentBox;if(paneAxes.length>0){const axisBox=axisGroupBox(paneAxes),offsetY=Math.max(paneBox.y1-axisBox.y1,paneBox.y2-axisBox.y2);offsetX=Math.max(offsetX,paneBox.x1-axisBox.x1);for(let j=0;j<paneAxes.length;j++){const currentAxis=paneAxes[j];currentAxis.reflow(currentAxis.box.translate(0,offsetY))}}}for(let i=0;i<axes.length;i++){const currentAxis=axes[i];currentAxis.reflow(currentAxis.box.translate(offsetX,0))}}reflowAxes(panes){const axes=this.groupAxes(panes);for(let i=0;i<panes.length;i++)this.reflowPaneAxes(panes[i]);axes.x.length>0&&axes.y.length>0&&(this.alignAxes(axes.x,axes.y),this.shrinkAxisWidth(panes),this.autoRotateAxisLabels(axes),this.alignAxes(axes.x,axes.y),this.shrinkAxisWidth(panes)&&this.alignAxes(axes.x,axes.y),this.shrinkAxisHeight(panes),this.alignAxes(axes.x,axes.y),this.shrinkAxisHeight(panes)&&this.alignAxes(axes.x,axes.y),this.fitAxes(panes))}autoRotateAxisLabels(groupedAxes){const{panes:panes}=this,axes=allPaneAxes(panes);let rotated;for(let idx=0;idx<axes.length;idx++)axes[idx].autoRotateLabels()&&(rotated=!0);if(rotated){for(let idx=0;idx<panes.length;idx++)this.reflowPaneAxes(panes[idx]);groupedAxes.x.length>0&&groupedAxes.y.length>0&&(this.alignAxes(groupedAxes.x,groupedAxes.y),this.shrinkAxisWidth(panes))}}reflowPaneAxes(pane){const axes=pane.axes,length=axes.length;if(length>0)for(let i=0;i<length;i++)axes[i].reflow(pane.contentBox)}reflowCharts(panes){const charts=this.charts,count=charts.length,box=this.box;for(let i=0;i<count;i++){const chartPane=charts[i].pane;chartPane&&!inArray(chartPane,panes)||charts[i].reflow(box)}}reflowPanes(){const{box:box,panes:panes}=this,panesLength=panes.length;let remainingHeight=box.height(),autoHeightPanes=0,top=box.y1;for(let i=0;i<panesLength;i++){const currentPane=panes[i],height=currentPane.options.height;if(currentPane.options.width=box.width(),currentPane.options.height){if(height.indexOf&&height.indexOf(\"%\")){const percents=parseInt(height,10)/100;currentPane.options.height=percents*box.height()}currentPane.reflow(box.clone()),remainingHeight-=currentPane.options.height}else autoHeightPanes++}for(let i=0;i<panesLength;i++){const currentPane=panes[i];currentPane.options.height||(currentPane.options.height=remainingHeight/autoHeightPanes)}for(let i=0;i<panesLength;i++){const currentPane=panes[i],paneBox=box.clone().move(box.x1,top);currentPane.reflow(paneBox),top+=currentPane.options.height}}backgroundBox(){const axes=this.axes,axesCount=axes.length;let box;for(let i=0;i<axesCount;i++){const axisA=axes[i];for(let j=0;j<axesCount;j++){const axisB=axes[j];if(axisA.options.vertical!==axisB.options.vertical){const lineBox=axisA.lineBox().clone().wrap(axisB.lineBox());box=box?box.wrap(lineBox):lineBox}}}return box||this.box}chartsBoxes(){const panes=this.panes,boxes=[];for(let idx=0;idx<panes.length;idx++)boxes.push(panes[idx].chartsBox());return boxes}addBackgroundPaths(multipath){const boxes=this.chartsBoxes();for(let idx=0;idx<boxes.length;idx++)multipath.paths.push(main.a.Path.fromRect(boxes[idx].toRect()))}backgroundContainsPoint(point){const boxes=this.chartsBoxes();for(let idx=0;idx<boxes.length;idx++)if(boxes[idx].containsPoint(point))return!0}createVisual(){super.createVisual();const options=this.options.plotArea;let{opacity:opacity,background:background,border:border={}}=options;var color;\"\"!==(color=background)&&null!==color&&\"none\"!==color&&\"transparent\"!==color&&defined(color)||(background=WHITE,opacity=0);const bg=this._bgVisual=new main.a.MultiPath({fill:{color:background,opacity:opacity},stroke:{color:border.width?border.color:\"\",width:border.width,dashType:border.dashType},zIndex:-1});this.addBackgroundPaths(bg),this.appendVisual(bg)}pointsByCategoryIndex(categoryIndex){const charts=this.charts,result=[];if(null!==categoryIndex)for(let i=0;i<charts.length;i++){if(\"_navigator\"===charts[i].pane.options.name)continue;const points=charts[i].categoryPoints[categoryIndex];if(points&&points.length)for(let j=0;j<points.length;j++){const point=points[j];point&&defined(point.value)&&null!==point.value&&result.push(point)}}return result}pointsBySeriesIndex(seriesIndex){return this.filterPoints(function(point){return point.series.index===seriesIndex})}pointsBySeriesName(name){return this.filterPoints(function(point){return point.series.name===name})}filterPoints(callback){const charts=this.charts,result=[];for(let i=0;i<charts.length;i++){const points=charts[i].points;for(let j=0;j<points.length;j++){const point=points[j];point&&!1!==point.visible&&callback(point)&&result.push(point)}}return result}findPoint(callback){const charts=this.charts;for(let i=0;i<charts.length;i++){const points=charts[i].points;for(let j=0;j<points.length;j++){const point=points[j];if(point&&!1!==point.visible&&callback(point))return point}}}paneByPoint(point){const panes=this.panes;for(let i=0;i<panes.length;i++){const pane=panes[i];if(pane.box.containsPoint(point))return pane}}detachLabels(){const axes=this.groupAxes(this.panes),xAxes=axes.x,yAxes=axes.y;this.detachAxisGroupLabels(yAxes,xAxes),this.detachAxisGroupLabels(xAxes,yAxes)}detachAxisGroupLabels(axes,crossingAxes){let labelAxisCount=0;for(let i=0;i<axes.length;i++){const axis=axes[i],pane=axis.pane,anchor=paneAnchor(crossingAxes,pane)||crossingAxes[0],labelAxis=this.createLabelAxis(axis,i+labelAxisCount,anchor);if(labelAxis){labelAxisCount++;const pos=pane.axes.indexOf(axis)+labelAxisCount;pane.appendAxisAt(labelAxis,pos)}}}createLabelAxis(axis,axisIndex,anchor){const labelOptions=axis.options.labels,position=labelOptions.position;if(\"end\"!==position&&\"start\"!==position||!1===labelOptions.visible)return null;const allAxes=this.groupAxes(this.panes),anchorCrossings=this.axisCrossingValues(anchor,anchor.options.vertical?allAxes.x:allAxes.y),end=\"end\"===position,range=anchor.range(),edge=end?range.max:range.min;if(limitValue(anchorCrossings[axisIndex],range.min,range.max)-edge==0)return null;anchorCrossings.splice(axisIndex+1,0,edge),anchor.options.axisCrossingValues=anchorCrossings;const labelAxis=axis.clone();return axis.clear(),labelAxis.options.name=void 0,labelAxis.options.line.visible=!1,labelAxis.options.crosshair=void 0,labelAxis.options.notes=void 0,labelAxis.options.plotBands=void 0,labelAxis}}function isSingleAxis(axis){return!axis.pane.axes.some(a=>a.options.vertical===axis.options.vertical&&a!==axis&&!1!==a.options.visible)}function axisGroupBox(axes){const length=axes.length;let box;for(let i=0;i<length;i++){const axis=axes[i],visible=!1!==axis.options.visible;if(visible||isSingleAxis(axis)){const axisBox=visible?axis.contentBox():axis.lineBox();box?box.wrap(axisBox):box=axisBox.clone()}}return box||new core_box}function paneAnchor(axes,pane){for(let i=0;i<axes.length;i++){const anchor=axes[i];if(anchor&&anchor.pane===pane)return anchor}}const allPaneAxes=panes=>panes.reduce((acc,pane)=>acc.concat(pane.axes),[]);setDefaultOptions(plotarea_base_PlotAreaBase,{series:[],plotArea:{margin:{}},background:\"\",border:{color:BLACK,width:0},paneDefaults:{title:{}},legend:{inactiveItems:{labels:{color:\"#919191\"},markers:{color:\"#919191\"}}}});var plotarea_base=plotarea_base_PlotAreaBase,plotarea_events_mixin={hover:function(chart,e){this._dispatchEvent(chart,e,\"plotAreaHover\")},click:function(chart,e){this._dispatchEvent(chart,e,\"plotAreaClick\")}};function setValue(fieldName,target,value){let parentObj=target,field=fieldName;if(fieldName.indexOf(\".\")>-1){const parts=fieldName.split(\".\");for(;parts.length>1;)field=parts.shift(),defined(parentObj[field])||(parentObj[field]={}),parentObj=parentObj[field];field=parts.shift()}parentObj[field]=value}var series_aggregator=class extends common_class.a{constructor(series,binder,defaultAggregates){super();const canonicalFields=binder.canonicalFields(series),valueFields=binder.valueFields(series),sourceFields=binder.sourceFields(series,canonicalFields),seriesFields=this._seriesFields=[],defaults=defaultAggregates.query(series.type),rootAggregate=series.aggregate||defaults;this._series=series,this._binder=binder;for(let i=0;i<canonicalFields.length;i++){const field=canonicalFields[i];let fieldAggregate;if(isObject(rootAggregate))fieldAggregate=rootAggregate[field];else{if(0!==i&&!inArray(field,valueFields))break;fieldAggregate=rootAggregate}fieldAggregate&&seriesFields.push({canonicalName:field,name:sourceFields[i],transform:isFunction(fieldAggregate)?fieldAggregate:aggregates[fieldAggregate]})}}aggregatePoints(srcPoints,group){const{_series:series,_seriesFields:seriesFields}=this,data=this._bindPoints(srcPoints||[]),firstDataItem=data.dataItems[0];let result={};if(firstDataItem&&!isNumber(firstDataItem)&&!isArray(firstDataItem)){const fn=function(){};fn.prototype=firstDataItem,result=new fn}for(let i=0;i<seriesFields.length;i++){const field=seriesFields[i],srcValues=this._bindField(data.values,field.canonicalName),value=field.transform(srcValues,series,data.dataItems,group);if(!(null===value||!isObject(value)||defined(value.length)||value instanceof Date)){result=value;break}defined(value)&&setValue(field.name,result,value)}return result}_bindPoints(points){const{_binder:binder,_series:series}=this,values=[],dataItems=[];for(let i=0;i<points.length;i++){const pointIx=points[i];values.push(binder.bindPoint(series,pointIx)),dataItems.push(series.data[pointIx])}return{values:values,dataItems:dataItems}}_bindField(data,field){const values=[],count=data.length;for(let i=0;i<count;i++){const item=data[i],valueFields=item.valueFields;let value;value=defined(valueFields[field])?valueFields[field]:item.fields[field],values.push(value)}return values}},default_aggregates=(()=>{class DefaultAggregates extends common_class.a{constructor(){super(),this._defaults={}}register(seriesTypes,aggregates){for(let i=0;i<seriesTypes.length;i++)this._defaults[seriesTypes[i]]=aggregates}query(seriesType){return this._defaults[seriesType]}}return DefaultAggregates.current=new DefaultAggregates,DefaultAggregates})();class range_bar_RangeBar extends bar{createLabel(){const labels=this.options.labels,fromOptions=deepExtend({},labels,labels.from),toOptions=deepExtend({},labels,labels.to);fromOptions.visible&&(this.labelFrom=this._createLabel(fromOptions),this.append(this.labelFrom)),toOptions.visible&&(this.labelTo=this._createLabel(toOptions),this.append(this.labelTo))}_createLabel(options){const labelTemplate=getTemplate(options),pointData=this.pointData();let labelText;return labelText=labelTemplate?labelTemplate(pointData):this.formatValue(options.format),new bar_label(labelText,deepExtend({vertical:this.options.vertical},options),pointData)}reflow(targetBox){this.render();const{labelFrom:labelFrom,labelTo:labelTo,value:value}=this;this.box=targetBox,labelFrom&&(labelFrom.options.aboveAxis=value.from>value.to,labelFrom.reflow(targetBox)),labelTo&&(labelTo.options.aboveAxis=value.to>value.from,labelTo.reflow(targetBox)),this.note&&this.note.reflow(targetBox)}}range_bar_RangeBar.prototype.defaults=deepExtend({},range_bar_RangeBar.prototype.defaults,{labels:{format:\"{0} - {1}\"},tooltip:{format:\"{1}\"}});var range_bar=range_bar_RangeBar;class range_bar_chart_RangeBarChart extends bar_chart{pointType(){return range_bar}pointValue(data){return data.valueFields}formatPointValue(point,format){return null===point.value.from&&null===point.value.to?\"\":this.chartService.format.auto(format,point.value.from,point.value.to)}plotRange(point){return point?[point.value.from,point.value.to]:0}updateRange(value,fields){const axisName=fields.series.axis,{from:from,to:to}=value;let axisRange=this.valueAxisRanges[axisName];null!==value&&isNumber(from)&&isNumber(to)&&(axisRange=this.valueAxisRanges[axisName]=axisRange||{min:MAX_VALUE,max:MIN_VALUE},axisRange.min=Math.min(axisRange.min,from),axisRange.max=Math.max(axisRange.max,from),axisRange.min=Math.min(axisRange.min,to),axisRange.max=Math.max(axisRange.max,to))}aboveAxis(point){const value=point.value;return value.from<value.to}}range_bar_chart_RangeBarChart.prototype.plotLimits=categorical_chart.prototype.plotLimits;var range_bar_chart=range_bar_chart_RangeBarChart,range_line_point=class extends line_point{aliasFor(){return this.parent}};class range_area_point_RangeAreaPoint extends chart_element{constructor(value,options){super(),this.value=value,this.options=options,this.aboveAxis=valueOrDefault(this.options.aboveAxis,!0),this.tooltipTracking=!0,this.initLabelsFormat()}render(){if(this._rendered)return;this._rendered=!0;const{markers:markers,labels:labels}=this.options,value=this.value,fromPoint=this.fromPoint=new range_line_point(value,deepExtend({},this.options,{labels:labels.from,markers:markers.from})),toPoint=this.toPoint=new range_line_point(value,deepExtend({},this.options,{labels:labels.to,markers:markers.to}));this.copyFields(fromPoint),this.copyFields(toPoint),this.append(fromPoint),this.append(toPoint)}reflow(targetBox){this.render();const{from:fromBox,to:toBox}=targetBox;this.positionLabels(fromBox,toBox),this.fromPoint.reflow(fromBox),this.toPoint.reflow(toBox),this.box=this.fromPoint.markerBox().clone().wrap(this.toPoint.markerBox())}createHighlight(){const group=new main.a.Group;return group.append(this.fromPoint.createHighlight()),group.append(this.toPoint.createHighlight()),group}highlightVisual(){return this.visual}highlightVisualArgs(){return{options:this.options,from:this.fromPoint.highlightVisualArgs(),to:this.toPoint.highlightVisualArgs()}}tooltipAnchor(){const clipBox=this.owner.pane.clipBox();if(!clipBox||clipBox.overlaps(this.box)){const box=this.box,center=box.center(),horizontalAlign=LEFT;let x,y,verticalAlign;return this.options.vertical?(x=center.x,y=box.y1-5,verticalAlign=BOTTOM):(x=box.x2+5,y=center.y,verticalAlign=CENTER),{point:new core_point(x,y),align:{horizontal:horizontalAlign,vertical:verticalAlign}}}}formatValue(format){return this.owner.formatPointValue(this,format)}overlapsBox(box){return this.box.overlaps(box)}unclipElements(){this.fromPoint.unclipElements(),this.toPoint.unclipElements()}initLabelsFormat(){const labels=this.options.labels;labels.format||(labels.from&&labels.from.format||(labels.from=Object.assign({},labels.from,{format:\"{0}\"})),labels.to&&labels.to.format||(labels.to=Object.assign({},labels.to,{format:\"{1}\"})))}positionLabels(fromBox,toBox){const{labels:labels,vertical:vertical}=this.options;if(\"auto\"===labels.position){let fromLabelPosition,toLabelPosition;vertical?toBox.y1<=fromBox.y1?(toLabelPosition=\"above\",fromLabelPosition=\"below\"):(toLabelPosition=\"below\",fromLabelPosition=\"above\"):toBox.x1<=fromBox.x1?(toLabelPosition=LEFT,fromLabelPosition=RIGHT):(toLabelPosition=RIGHT,fromLabelPosition=LEFT),labels.from&&labels.from.position||(this.fromPoint.options.labels.position=fromLabelPosition),labels.to&&labels.to.position||(this.toPoint.options.labels.position=toLabelPosition)}}copyFields(point){point.dataItem=this.dataItem,point.category=this.category,point.series=this.series,point.color=this.color,point.owner=this.owner}}deepExtend(range_area_point_RangeAreaPoint.prototype,point_events_mixin),deepExtend(range_area_point_RangeAreaPoint.prototype,note_mixin),range_area_point_RangeAreaPoint.prototype.defaults={markers:{visible:!1,background:WHITE,size:8,type:CIRCLE,border:{width:2},opacity:1},labels:{visible:!1,margin:getSpacing(3),padding:getSpacing(4),animation:{type:\"fadeIn\",delay:600},position:\"auto\"},notes:{label:{}},highlight:{markers:{border:{color:WHITE,width:2}},zIndex:100},tooltip:{format:\"{0} - {1}\"}};var range_area_point=range_area_point_RangeAreaPoint,range_area_segment=class extends area_segment{createStrokeSegments(){return this.segmentsFromPoints(this.toGeometryPoints(this.toPoints()))}stackSegments(){let fromSegments=this.fromSegments;return this.fromSegments||(fromSegments=this.fromSegments=this.segmentsFromPoints(this.toGeometryPoints(this.fromPoints().reverse()))),fromSegments}createStroke(style){const toPath=new main.a.Path(style),fromPath=new main.a.Path(style);toPath.segments.push.apply(toPath.segments,this.strokeSegments()),fromPath.segments.push.apply(fromPath.segments,this.stackSegments()),this.visual.append(toPath),this.visual.append(fromPath)}hasStackSegment(){return!0}fromPoints(){return this.linePoints.map(point=>point.fromPoint)}toPoints(){return this.linePoints.map(point=>point.toPoint)}},spline_range_area_segment=class extends range_area_segment{createStrokeSegments(){return this.createCurveSegments(this.toPoints())}stackSegments(){let fromSegments=this.fromSegments;return this.fromSegments||(fromSegments=this.fromSegments=this.createCurveSegments(this.fromPoints().reverse())),fromSegments}createCurveSegments(points){return(new curve_processor).process(this.toGeometryPoints(points))}};class step_range_area_segment_StepRangeAreaSegment extends range_area_segment{createStrokeSegments(){return this.segmentsFromPoints(this.calculateStepPoints(this.toPoints()))}stackSegments(){let fromSegments=this.fromSegments;return this.fromSegments||(fromSegments=this.fromSegments=this.segmentsFromPoints(this.calculateStepPoints(this.fromPoints())),fromSegments.reverse()),fromSegments}}deepExtend(step_range_area_segment_StepRangeAreaSegment.prototype,step_line_mixin);var step_range_area_segment=step_range_area_segment_StepRangeAreaSegment,range_area_chart=(()=>{class RangeAreaChart extends categorical_chart{render(){super.render(),this.renderSegments()}pointType(){return range_area_point}createPoint(data,fields){const{categoryIx:categoryIx,category:category,series:series,seriesIx:seriesIx}=fields;let value=data.valueFields;if(!has_value_hasValue(value.from)&&!has_value_hasValue(value.to)){if(this.seriesMissingValues(series)!==ZERO)return null;value={from:0,to:0}}let pointOptions=this.pointOptions(series,seriesIx);pointOptions=this.evalPointOptions(pointOptions,value,category,categoryIx,series,seriesIx);let color=data.fields.color||series.color;isFunction(series.color)&&(color=pointOptions.color);const point=new range_area_point(value,pointOptions);return point.color=color,this.append(point),point}createSegment(linePoints,currentSeries,seriesIx){const style=(currentSeries.line||{}).style;let segmentType;return segmentType=\"smooth\"===style?spline_range_area_segment:\"step\"===style?step_range_area_segment:range_area_segment,new segmentType(linePoints,currentSeries,seriesIx)}plotRange(point,startValue){return point?[point.value.from,point.value.to]:[startValue,startValue]}valueSlot(valueAxis,plotRange){const fromSlot=valueAxis.getSlot(plotRange[0],plotRange[0],!this.options.clip),toSlot=valueAxis.getSlot(plotRange[1],plotRange[1],!this.options.clip);if(fromSlot&&toSlot)return{from:fromSlot,to:toSlot}}pointSlot(categorySlot,valueSlot){const{from:from,to:to}=valueSlot;let fromSlot,toSlot;return this.options.invertAxes?(fromSlot=new core_box(from.x1,categorySlot.y1,from.x2,categorySlot.y2),toSlot=new core_box(to.x1,categorySlot.y1,to.x2,categorySlot.y2)):(fromSlot=new core_box(categorySlot.x1,from.y1,categorySlot.x2,from.y2),toSlot=new core_box(categorySlot.x1,to.y1,categorySlot.x2,to.y2)),{from:fromSlot,to:toSlot}}addValue(data,fields){const valueFields=data.valueFields;isNumber(valueFields.from)||(valueFields.from=valueFields.to),isNumber(valueFields.to)||(valueFields.to=valueFields.from),super.addValue(data,fields)}updateRange(value,fields){if(null!==value&&isNumber(value.from)&&isNumber(value.to)){const axisName=fields.series.axis,axisRange=this.valueAxisRanges[axisName]=this.valueAxisRanges[axisName]||{min:MAX_VALUE,max:MIN_VALUE},{from:from,to:to}=value;axisRange.min=Math.min(axisRange.min,from,to),axisRange.max=Math.max(axisRange.max,from,to)}}formatPointValue(point,format){const value=point.value;return this.chartService.format.auto(format,value.from,value.to)}animationPoints(){const points=this.points,result=[];for(let idx=0;idx<points.length;idx++){const point=points[idx];point&&(result.push((point.fromPoint||{}).marker),result.push((point.toPoint||{}).marker))}return result.concat(this._segments)}}return deepExtend(RangeAreaChart.prototype,line_chart_mixin,clip_animation_mixin),RangeAreaChart})(),ohlc_point=class extends candlestick{reflow(box){const{options:options,value:value,owner:chart}=this,valueAxis=chart.seriesValueAxis(options),oPoints=[],cPoints=[],lhPoints=[],lhSlot=valueAxis.getSlot(value.low,value.high),oSlot=valueAxis.getSlot(value.open,value.open),cSlot=valueAxis.getSlot(value.close,value.close);oSlot.x1=cSlot.x1=lhSlot.x1=box.x1,oSlot.x2=cSlot.x2=lhSlot.x2=box.x2;const mid=lhSlot.center().x;oPoints.push([oSlot.x1,oSlot.y1]),oPoints.push([mid,oSlot.y1]),cPoints.push([mid,cSlot.y1]),cPoints.push([cSlot.x2,cSlot.y1]),lhPoints.push([mid,lhSlot.y1]),lhPoints.push([mid,lhSlot.y2]),this.lines=[oPoints,cPoints,lhPoints],this.box=lhSlot.clone().wrap(oSlot.clone().wrap(cSlot)),this.reflowNote()}createBody(){}},ohlc_chart=class extends candlestick_chart{pointType(){return ohlc_point}};class waterfall_segment_WaterfallSegment extends chart_element{constructor(from,to,series){super(),this.from=from,this.to=to,this.series=series}linePoints(){const from=this.from,{from:{box:fromBox},to:{box:toBox}}=this,points=[];if(from.isVertical){const y=from.aboveAxis?fromBox.y1:fromBox.y2;points.push([fromBox.x1,y],[toBox.x2,y])}else{const x=from.aboveAxis?fromBox.x2:fromBox.x1;points.push([x,fromBox.y1],[x,toBox.y2])}return points}createVisual(){super.createVisual();const line=this.series.line||{},path=main.a.Path.fromPoints(this.linePoints(),{stroke:{color:line.color,width:line.width,opacity:line.opacity,dashType:line.dashType}});alignPathToPixel(path),this.visual.append(path)}}setDefaultOptions(waterfall_segment_WaterfallSegment,{animation:{type:\"fadeIn\",delay:600}});var waterfall_segment=waterfall_segment_WaterfallSegment,waterfall_chart=class extends bar_chart{render(){super.render(),this.createSegments()}traverseDataPoints(callback){const series=this.options.series,totalCategories=categoriesCount(series),isVertical=!this.options.invertAxes;for(let seriesIx=0;seriesIx<series.length;seriesIx++){const currentSeries=series[seriesIx];let total=0,runningTotal=0;for(let categoryIx=0;categoryIx<totalCategories;categoryIx++){const data=series_binder.current.bindPoint(currentSeries,categoryIx),value=data.valueFields.value,summary=data.fields.summary;let to,from=total;summary?\"total\"===summary.toLowerCase()?(data.valueFields.value=total,from=0,to=total):(data.valueFields.value=runningTotal,to=from-runningTotal,runningTotal=0):isNumber(value)&&(runningTotal+=value,total+=value,to=total),callback(data,{category:this.categoryAxis.categoryAt(categoryIx),categoryIx:categoryIx,series:currentSeries,seriesIx:seriesIx,total:total,runningTotal:runningTotal,from:from,to:to,isVertical:isVertical})}}}updateRange(value,fields){super.updateRange({value:fields.to},fields)}aboveAxis(point){return point.value>=0}plotRange(point){return[point.from,point.to]}createSegments(){const series=this.options.series,seriesPoints=this.seriesPoints,segments=this.segments=[];for(let seriesIx=0;seriesIx<series.length;seriesIx++){const currentSeries=series[seriesIx],points=seriesPoints[seriesIx];if(points){let prevPoint;for(let pointIx=0;pointIx<points.length;pointIx++){const point=points[pointIx];if(point&&prevPoint){const segment=new waterfall_segment(prevPoint,point,currentSeries);segments.push(segment),this.append(segment)}prevPoint=point}}}}};const AREA_SERIES=[\"area\",\"verticalArea\",\"rangeArea\",\"verticalRangeArea\"],OUT_OF_RANGE_SERIES=[LINE,VERTICAL_LINE].concat(AREA_SERIES);class categorical_plotarea_CategoricalPlotArea extends plotarea_base{initFields(series){if(this.namedCategoryAxes={},this.namedValueAxes={},this.valueAxisRangeTracker=new axis_group_range_tracker,series.length>0){this.invertAxes=inArray(series[0].type,[BAR,\"bullet\",VERTICAL_LINE,\"verticalArea\",\"verticalRangeArea\",\"rangeBar\",\"horizontalWaterfall\",\"verticalBoxPlot\"]);for(let i=0;i<series.length;i++){const stack=series[i].stack;if(stack&&\"100%\"===stack.type){this.stack100=!0;break}}}}render(panes=this.panes){this.createCategoryAxes(panes),this.aggregateCategories(panes),this.createCategoryAxesLabels(panes),this.createCharts(panes),this.createValueAxes(panes)}removeAxis(axis){const axisName=axis.options.name;super.removeAxis(axis),axis instanceof category_axis?delete this.namedCategoryAxes[axisName]:(this.valueAxisRangeTracker.reset(axisName),delete this.namedValueAxes[axisName]),axis===this.categoryAxis&&delete this.categoryAxis,axis===this.valueAxis&&delete this.valueAxis}createCharts(panes){const seriesByPane=this.groupSeriesByPane();for(let i=0;i<panes.length;i++){const pane=panes[i],paneSeries=seriesByPane[pane.options.name||\"default\"]||[];this.addToLegend(paneSeries);const visibleSeries=this.filterVisibleSeries(paneSeries);if(!visibleSeries)continue;const groups=this.groupSeriesByCategoryAxis(visibleSeries);for(let groupIx=0;groupIx<groups.length;groupIx++)this.createChartGroup(groups[groupIx],pane)}}createChartGroup(series,pane){this.createAreaChart(filterSeriesByType(series,[\"area\",\"verticalArea\"]),pane),this.createRangeAreaChart(filterSeriesByType(series,[\"rangeArea\",\"verticalRangeArea\"]),pane),this.createBarChart(filterSeriesByType(series,[COLUMN,BAR]),pane),this.createRangeBarChart(filterSeriesByType(series,[\"rangeColumn\",\"rangeBar\"]),pane),this.createBulletChart(filterSeriesByType(series,[\"bullet\",\"verticalBullet\"]),pane),this.createCandlestickChart(filterSeriesByType(series,\"candlestick\"),pane),this.createBoxPlotChart(filterSeriesByType(series,[\"boxPlot\",\"verticalBoxPlot\"]),pane),this.createOHLCChart(filterSeriesByType(series,\"ohlc\"),pane),this.createWaterfallChart(filterSeriesByType(series,[\"waterfall\",\"horizontalWaterfall\"]),pane),this.createLineChart(filterSeriesByType(series,[LINE,VERTICAL_LINE]),pane)}aggregateCategories(panes){const series=this.srcSeries||this.series,processedSeries=[];this._currentPointsCache={},this._seriesPointsCache=this._seriesPointsCache||{};for(let i=0;i<series.length;i++){let currentSeries=series[i];const categoryAxis=this.seriesCategoryAxis(currentSeries),axisPane=this.findPane(categoryAxis.options.pane);currentSeries=(equalsIgnoreCase(categoryAxis.options.type,DATE)||currentSeries.categoryField)&&inArray(axisPane,panes)?this.aggregateSeries(currentSeries,categoryAxis):this.filterSeries(currentSeries,categoryAxis),processedSeries.push(currentSeries)}this._seriesPointsCache=this._currentPointsCache,this._currentPointsCache=null,this.srcSeries=series,this.series=processedSeries}filterSeries(series,categoryAxis){const dataLength=(series.data||{}).length;if(categoryAxis._seriesMax=Math.max(categoryAxis._seriesMax||0,dataLength),!isNumber(categoryAxis.options.min)&&!isNumber(categoryAxis.options.max))return series;const range=categoryAxis.currentRangeIndices(),outOfRangePoints=inArray(series.type,OUT_OF_RANGE_SERIES),currentSeries=deepExtend({},series);return currentSeries.data=(currentSeries.data||[]).slice(range.min,range.max+1),outOfRangePoints&&createOutOfRangePoints(currentSeries,range,dataLength,idx=>({item:series.data[idx],category:categoryAxis.categoryAt(idx,!0),categoryIx:idx-range.min}),idx=>defined(series.data[idx])),currentSeries}clearSeriesPointsCache(){this._seriesPointsCache={}}seriesSourcePoints(series,categoryAxis){const key=`${series.index};${categoryAxis.categoriesHash()}`;if(this._seriesPointsCache[key])return this._currentPointsCache[key]=this._seriesPointsCache[key],this._seriesPointsCache[key];const axisOptions=categoryAxis.options,srcCategories=axisOptions.srcCategories,dateAxis=equalsIgnoreCase(axisOptions.type,DATE),srcData=series.data,getFn=dateAxis?getDateField:getField,result=[];dateAxis||categoryAxis.mapCategories();for(let idx=0;idx<srcData.length;idx++){let category;if(category=series.categoryField?getFn(series.categoryField,srcData[idx],this.chartService.intl):srcCategories[idx],defined(category)&&null!==category){const categoryIx=categoryAxis.totalIndex(category);result[categoryIx]=result[categoryIx]||{items:[],category:category},result[categoryIx].items.push(idx)}}return this._currentPointsCache[key]=result,result}aggregateSeries(series,categoryAxis){if(!series.data.length)return series;const srcPoints=this.seriesSourcePoints(series,categoryAxis),result=deepExtend({},series),aggregator=new series_aggregator(deepExtend({},series),series_binder.current,default_aggregates.current),data=result.data=[],dataItems=categoryAxis.options.dataItems||[],range=categoryAxis.currentRangeIndices(),categoryItem=idx=>{const categoryIdx=idx-range.min;let point=srcPoints[idx];if(point||(point=srcPoints[idx]={}),point.categoryIx=categoryIdx,!point.item){const category=categoryAxis.categoryAt(idx,!0);point.category=category,point.item=aggregator.aggregatePoints(point.items,category)}return point};for(let idx=range.min;idx<=range.max;idx++){const point=categoryItem(idx);data[point.categoryIx]=point.item,point.items&&point.items.length&&(dataItems[point.categoryIx]=point.item)}return inArray(result.type,OUT_OF_RANGE_SERIES)&&createOutOfRangePoints(result,range,categoryAxis.totalCount(),categoryItem,idx=>srcPoints[idx]),categoryAxis.options.dataItems=dataItems,result}appendChart(chart,pane){const series=chart.options.series,categoryAxis=this.seriesCategoryAxis(series[0]);let categories=categoryAxis.options.categories,categoriesToAdd=Math.max(0,categoriesCount(series)-categories.length);if(categoriesToAdd>0)for(categories=categoryAxis.options.categories=categoryAxis.options.categories.slice(0);categoriesToAdd--;)categories.push(\"\");this.valueAxisRangeTracker.update(chart.valueAxisRanges),super.appendChart(chart,pane)}seriesPaneName(series){const options=this.options,axisName=series.axis;return(grep([].concat(options.valueAxis),function(a){return a.name===axisName})[0]||{}).pane||((options.panes||[{}])[0]||{}).name||\"default\"}seriesCategoryAxis(series){const axisName=series.categoryAxis,axis=axisName?this.namedCategoryAxes[axisName]:this.categoryAxis;if(!axis)throw new Error(\"Unable to locate category axis with name \"+axisName);return axis}stackableChartOptions(firstSeries,pane){const stack=firstSeries.stack;return{isStacked:stack,isStacked100:stack&&\"100%\"===stack.type,clip:pane.options.clip}}groupSeriesByCategoryAxis(series){const categoryAxes=[],unique={};for(let idx=0;idx<series.length;idx++){const name=series[idx].categoryAxis||\"$$default$$\";unique.hasOwnProperty(name)||(unique[name]=!0,categoryAxes.push(name))}const groups=[];for(let axisIx=0;axisIx<categoryAxes.length;axisIx++){const axisSeries=groupSeries(series,categoryAxes[axisIx],axisIx);0!==axisSeries.length&&groups.push(axisSeries)}return groups}createBarChart(series,pane){if(0===series.length)return;const firstSeries=series[0],barChart=new bar_chart(this,Object.assign({series:series,invertAxes:this.invertAxes,gap:firstSeries.gap,spacing:firstSeries.spacing},this.stackableChartOptions(firstSeries,pane)));this.appendChart(barChart,pane)}createRangeBarChart(series,pane){if(0===series.length)return;const firstSeries=series[0],rangeColumnChart=new range_bar_chart(this,{series:series,invertAxes:this.invertAxes,gap:firstSeries.gap,spacing:firstSeries.spacing});this.appendChart(rangeColumnChart,pane)}createBulletChart(series,pane){if(0===series.length)return;const firstSeries=series[0],bulletChart=new bullet_chart(this,{series:series,invertAxes:this.invertAxes,gap:firstSeries.gap,spacing:firstSeries.spacing,clip:pane.options.clip});this.appendChart(bulletChart,pane)}createLineChart(series,pane){if(0===series.length)return;const lineChart=new line_chart(this,Object.assign({invertAxes:this.invertAxes,series:series},this.stackableChartOptions(series[0],pane)));this.appendChart(lineChart,pane)}createAreaChart(series,pane){if(0===series.length)return;const areaChart=new area_chart(this,Object.assign({invertAxes:this.invertAxes,series:series},this.stackableChartOptions(series[0],pane)));this.appendChart(areaChart,pane)}createRangeAreaChart(series,pane){if(0===series.length)return;const rangeAreaChart=new range_area_chart(this,{invertAxes:this.invertAxes,series:series,clip:pane.options.clip});this.appendChart(rangeAreaChart,pane)}createOHLCChart(series,pane){if(0===series.length)return;const firstSeries=series[0],chart=new ohlc_chart(this,{invertAxes:this.invertAxes,gap:firstSeries.gap,series:series,spacing:firstSeries.spacing,clip:pane.options.clip});this.appendChart(chart,pane)}createCandlestickChart(series,pane){if(0===series.length)return;const firstSeries=series[0],chart=new candlestick_chart(this,{invertAxes:this.invertAxes,gap:firstSeries.gap,series:series,spacing:firstSeries.spacing,clip:pane.options.clip});this.appendChart(chart,pane)}createBoxPlotChart(series,pane){if(0===series.length)return;const firstSeries=series[0],chart=new box_plot_chart(this,{invertAxes:this.invertAxes,gap:firstSeries.gap,series:series,spacing:firstSeries.spacing,clip:pane.options.clip});this.appendChart(chart,pane)}createWaterfallChart(series,pane){if(0===series.length)return;const firstSeries=series[0],waterfallChart=new waterfall_chart(this,{series:series,invertAxes:this.invertAxes,gap:firstSeries.gap,spacing:firstSeries.spacing});this.appendChart(waterfallChart,pane)}axisRequiresRounding(categoryAxisName,categoryAxisIndex){const centeredSeries=filterSeriesByType(this.series,EQUALLY_SPACED_SERIES);for(let seriesIx=0;seriesIx<this.series.length;seriesIx++){const currentSeries=this.series[seriesIx];if(inArray(currentSeries.type,AREA_SERIES)){const line=currentSeries.line;line&&\"step\"===line.style&&centeredSeries.push(currentSeries)}}for(let seriesIx=0;seriesIx<centeredSeries.length;seriesIx++){const seriesAxis=centeredSeries[seriesIx].categoryAxis||\"\";if(seriesAxis===categoryAxisName||!seriesAxis&&0===categoryAxisIndex)return!0}}aggregatedAxis(categoryAxisName,categoryAxisIndex){const series=this.series;for(let seriesIx=0;seriesIx<series.length;seriesIx++){const seriesAxis=series[seriesIx].categoryAxis||\"\";if((seriesAxis===categoryAxisName||!seriesAxis&&0===categoryAxisIndex)&&series[seriesIx].categoryField)return!0}}createCategoryAxesLabels(){const axes=this.axes;for(let i=0;i<axes.length;i++)axes[i]instanceof category_axis&&axes[i].createLabels()}createCategoryAxes(panes){const invertAxes=this.invertAxes,definitions=[].concat(this.options.categoryAxis),axes=[];for(let i=0;i<definitions.length;i++){let axisOptions=definitions[i];if(inArray(this.findPane(axisOptions.pane),panes)){const{name:name,categories:categories=[]}=axisOptions;let categoryAxis;if(axisOptions=deepExtend({vertical:invertAxes,reverse:!invertAxes&&this.chartService.rtl,axisCrossingValue:invertAxes?MAX_VALUE:0},axisOptions),defined(axisOptions.justified)||(axisOptions.justified=this.isJustified()),this.axisRequiresRounding(name,i)&&(axisOptions.justified=!1),categoryAxis=isDateAxis(axisOptions,categories[0])?new date_category_axis(axisOptions,this.chartService):new category_axis(axisOptions,this.chartService),definitions[i].categories=categoryAxis.options.srcCategories,name){if(this.namedCategoryAxes[name])throw new Error(`Category axis with name ${name} is already defined`);this.namedCategoryAxes[name]=categoryAxis}categoryAxis.axisIndex=i,axes.push(categoryAxis),this.appendAxis(categoryAxis)}}const primaryAxis=this.categoryAxis||axes[0];this.categoryAxis=primaryAxis,invertAxes?this.axisY=primaryAxis:this.axisX=primaryAxis}isJustified(){const series=this.series;for(let i=0;i<series.length;i++)if(!inArray(series[i].type,AREA_SERIES))return!1;return!0}createValueAxes(panes){const tracker=this.valueAxisRangeTracker,defaultRange=tracker.query(),definitions=[].concat(this.options.valueAxis),invertAxes=this.invertAxes,baseOptions={vertical:!invertAxes,reverse:invertAxes&&this.chartService.rtl},axes=[];this.stack100&&(baseOptions.roundToMajorUnit=!1,baseOptions.labels={format:\"P0\"});for(let i=0;i<definitions.length;i++){const axisOptions=definitions[i];if(inArray(this.findPane(axisOptions.pane),panes)){const name=axisOptions.name,defaultAxisRange=equalsIgnoreCase(axisOptions.type,\"log\")?{min:.1,max:1}:{min:0,max:1},range=tracker.query(name)||defaultRange||defaultAxisRange;let axisType;0===i&&range&&defaultRange&&(range.min=Math.min(range.min,defaultRange.min),range.max=Math.max(range.max,defaultRange.max)),axisType=equalsIgnoreCase(axisOptions.type,\"log\")?logarithmic_axis:numeric_axis;const valueAxis=new axisType(range.min,range.max,deepExtend({},baseOptions,axisOptions),this.chartService);if(name){if(this.namedValueAxes[name])throw new Error(`Value axis with name ${name} is already defined`);this.namedValueAxes[name]=valueAxis}valueAxis.axisIndex=i,axes.push(valueAxis),this.appendAxis(valueAxis)}}const primaryAxis=this.valueAxis||axes[0];this.valueAxis=primaryAxis,invertAxes?this.axisX=primaryAxis:this.axisY=primaryAxis}_dispatchEvent(chart,e,eventType){const coords=chart._eventCoordinates(e),point=new core_point(coords.x,coords.y),pane=this.pointPane(point),categories=[],values=[];if(!pane)return;const allAxes=pane.axes;for(let i=0;i<allAxes.length;i++){const axis=allAxes[i];axis.getValue?appendIfNotNull(values,axis.getValue(point)):appendIfNotNull(categories,axis.getCategory(point))}0===categories.length&&appendIfNotNull(categories,this.categoryAxis.getCategory(point)),categories.length>0&&values.length>0&&chart.trigger(eventType,{element:eventElement(e),originalEvent:e,category:singleItemOrArray(categories),value:singleItemOrArray(values)})}pointPane(point){const panes=this.panes;for(let i=0;i<panes.length;i++){const currentPane=panes[i];if(currentPane.contentBox.containsPoint(point))return currentPane}}updateAxisOptions(axis,options){updateAxisOptions(this.options,axis,options),updateAxisOptions(this.originalOptions,axis,options)}}function updateAxisOptions(targetOptions,axis,options){deepExtend([].concat(axis instanceof category_axis?targetOptions.categoryAxis:targetOptions.valueAxis)[axis.axisIndex],options)}function groupSeries(series,axis,axisIx){return grep(series,function(s){return 0===axisIx&&!s.categoryAxis||s.categoryAxis===axis})}setDefaultOptions(categorical_plotarea_CategoricalPlotArea,{categoryAxis:{},valueAxis:{}}),deepExtend(categorical_plotarea_CategoricalPlotArea.prototype,plotarea_events_mixin);var categorical_plotarea=categorical_plotarea_CategoricalPlotArea,throttle=__webpack_require__(\"6BXq\");function preventDefault(){this._defaultPrevented=!0}var chart_highlight=class extends common_class.a{constructor(){super(),this._points=[]}destroy(){this._points=[]}show(points,opacity){const arrayPoints=[].concat(points);this.hide();for(let i=0;i<arrayPoints.length;i++){const point=arrayPoints[i];point&&point.toggleHighlight&&point.hasHighlight()&&(this.togglePointHighlight(point,!0,opacity),this._points.push(point))}}togglePointHighlight(point,show,opacity){const toggleHandler=(point.options.highlight||{}).toggle;if(toggleHandler){const eventArgs={category:point.category,series:point.series,dataItem:point.dataItem,value:point.value,stackValue:point.stackValue,preventDefault:preventDefault,visual:point.highlightVisual(),show:show};toggleHandler(eventArgs),eventArgs._defaultPrevented||point.toggleHighlight(show,opacity)}else point.toggleHighlight(show,opacity)}hide(){const points=this._points;for(;points.length;)this.togglePointHighlight(points.pop(),!1)}isHighlighted(element){const points=this._points;for(let i=0;i<points.length;i++)if(element===points[i])return!0;return!1}};function acceptKey(e,mouseKey){const key=(mouseKey||\"\").toLowerCase(),event=e.event;return\"none\"===key&&!(event.ctrlKey||event.shiftKey||event.altKey)||event[key+\"Key\"]}function toChartAxisRanges(axisRanges){const ranges={};for(let idx=0;idx<axisRanges.length;idx++){const axisRange=axisRanges[idx];axisRange.axis.options.name&&(ranges[axisRange.axis.options.name]={min:axisRange.range.min,max:axisRange.range.max})}return ranges}class pannable_Pannable extends common_class.a{constructor(plotArea,options){super(),this.plotArea=plotArea,this.options=deepExtend({},this.options,options)}start(e){return this._active=acceptKey(e,this.options.key),this._active}move(e){if(this._active){const axisRanges=this.axisRanges=this._panAxes(e,X).concat(this._panAxes(e,Y));if(axisRanges.length)return this.axisRanges=axisRanges,toChartAxisRanges(axisRanges)}}end(){const active=this._active;return this._active=!1,active}pan(){const{plotArea:plotArea,axisRanges:axisRanges}=this;if(axisRanges.length){for(let idx=0;idx<axisRanges.length;idx++){const range=axisRanges[idx];plotArea.updateAxisOptions(range.axis,range.range)}plotArea.redraw(plotArea.panes)}}destroy(){delete this.plotArea}_panAxes(e,position){const plotArea=this.plotArea,delta=-e[position].delta,lock=(this.options.lock||\"\").toLowerCase(),updatedAxes=[];if(0!==delta&&(lock||\"\").toLowerCase()!==position){const axes=plotArea.axes;for(let idx=0;idx<axes.length;idx++){const axis=axes[idx];if(position===X&&!axis.options.vertical||position===Y&&axis.options.vertical){const range=axis.pan(delta);range&&(range.limitRange=!0,updatedAxes.push({axis:axis,range:range}))}}}return updatedAxes}}pannable_Pannable.prototype.options={key:\"none\",lock:\"none\"};var pan_and_zoom_pannable=pannable_Pannable;class zoom_selection_ZoomSelection extends common_class.a{constructor(chart,options){super(),this.chart=chart,this.options=deepExtend({},this.options,options),this.createElement()}createElement(){const marquee=this._marquee=document.createElement(\"div\");marquee.className=\"k-marquee\";const marqueeColor=document.createElement(\"div\");marqueeColor.className=\"k-marquee-color\",marquee.appendChild(marqueeColor)}removeElement(){this._marquee.parentNode&&this._marquee.parentNode.removeChild(this._marquee)}setStyles(styles){element_styles_elementStyles(this._marquee,styles)}start(e){if(acceptKey(e,this.options.key)){const chart=this.chart,point=chart._eventCoordinates(e),zoomPane=this._zoomPane=chart._plotArea.paneByPoint(point),clipBox=zoomPane?zoomPane.chartsBox().clone():null;if(zoomPane&&clipBox){const offset=this._elementOffset();return clipBox.translate(offset.left,offset.top),this._zoomPaneClipBox=clipBox,document.body.appendChild(this._marquee),this.setStyles({left:e.pageX+1,top:e.pageY+1,width:0,height:0}),!0}}return!1}_elementOffset(){const chartElement=this.chart.element,{paddingLeft:paddingLeft,paddingTop:paddingTop}=element_styles_elementStyles(chartElement,[\"paddingLeft\",\"paddingTop\"]),offset=drawing_utils_elementOffset(chartElement);return{left:paddingLeft+offset.left,top:paddingTop+offset.top}}move(e){this._zoomPane&&this.setStyles(this._selectionPosition(e))}end(e){if(this._zoomPane){const elementOffset=this._elementOffset(),selectionPosition=this._selectionPosition(e);return selectionPosition.left-=elementOffset.left,selectionPosition.top-=elementOffset.top,this._updateAxisRanges({x:selectionPosition.left,y:selectionPosition.top},{x:selectionPosition.left+selectionPosition.width,y:selectionPosition.top+selectionPosition.height}),this.removeElement(),delete this._zoomPane,toChartAxisRanges(this.axisRanges)}}zoom(){const axisRanges=this.axisRanges;if(axisRanges&&axisRanges.length){const plotArea=this.chart._plotArea;for(let idx=0;idx<axisRanges.length;idx++){const axisRange=axisRanges[idx];plotArea.updateAxisOptions(axisRange.axis,axisRange.range)}plotArea.redraw(plotArea.panes)}}destroy(){this.removeElement(),delete this._marquee,delete this.chart}_updateAxisRanges(start,end){const lock=(this.options.lock||\"\").toLowerCase(),axisRanges=[],axes=this._zoomPane.axes;for(let idx=0;idx<axes.length;idx++){const axis=axes[idx],vertical=axis.options.vertical;if((lock!==X||vertical)&&(lock!==Y||!vertical)&&defined(axis.axisIndex)){const range=axis.pointsRange(start,end);range&&axisRanges.push({axis:axis,range:range})}}this.axisRanges=axisRanges}_selectionPosition(e){const clipBox=this._zoomPaneClipBox,startLocation={x:e.x.startLocation,y:e.y.startLocation},{x:{location:pageX},y:{location:pageY}}=e,lock=(this.options.lock||\"\").toLowerCase();let left=Math.min(startLocation.x,pageX),top=Math.min(startLocation.y,pageY),width=Math.abs(startLocation.x-pageX),height=Math.abs(startLocation.y-pageY);return lock===X&&(left=clipBox.x1,width=clipBox.width()),lock===Y&&(top=clipBox.y1,height=clipBox.height()),pageX>clipBox.x2&&(width=clipBox.x2-startLocation.x),pageX<clipBox.x1&&(width=startLocation.x-clipBox.x1),pageY>clipBox.y2&&(height=clipBox.y2-startLocation.y),pageY<clipBox.y1&&(height=startLocation.y-clipBox.y1),{left:Math.max(left,clipBox.x1),top:Math.max(top,clipBox.y1),width:width,height:height}}}zoom_selection_ZoomSelection.prototype.options={key:\"shift\",lock:\"none\"};var zoom_selection=zoom_selection_ZoomSelection,mousewheel_zoom=class extends common_class.a{constructor(chart,options){super(),this.chart=chart,this.options=deepExtend({},this.options,options)}updateRanges(delta){const lock=(this.options.lock||\"\").toLowerCase(),axisRanges=[],axes=this.chart._plotArea.axes;for(let idx=0;idx<axes.length;idx++){const axis=axes[idx],vertical=axis.options.vertical;if((lock!==X||vertical)&&(lock!==Y||!vertical)&&axis.zoomRange){const range=axis.zoomRange(-delta);range&&axisRanges.push({axis:axis,range:range})}}return this.axisRanges=axisRanges,toChartAxisRanges(axisRanges)}zoom(){const axisRanges=this.axisRanges,plotArea=this.chart._plotArea;if(axisRanges&&axisRanges.length&&plotArea.updateAxisOptions){for(let idx=0;idx<axisRanges.length;idx++){const axisRange=axisRanges[idx];plotArea.updateAxisOptions(axisRange.axis,axisRange.range)}plotArea.redraw(plotArea.panes)}}destroy(){delete this.chart}},legend_layout=class extends chart_element{constructor(options,chartService){super(options),this.chartService=chartService}render(){const{children:children,options:options}=this,vertical=options.vertical;this.visual=new main.a.Layout(null,{spacing:vertical?0:options.spacing,lineSpacing:vertical?options.spacing:0,orientation:vertical?\"vertical\":\"horizontal\",reverse:options.rtl,alignItems:vertical?\"start\":\"center\"});for(let idx=0;idx<children.length;idx++){let legendItem=children[idx];legendItem.reflow(new core_box),legendItem.renderVisual()}}reflow(box){this.visual.rect(box.toRect()),this.visual.reflow();const bbox=this.visual.clippedBBox();this.box=bbox?rectToBox(bbox):new core_box}renderVisual(){this.addVisual()}createVisual(){}},legend_item=class extends box_element{constructor(options){super(options),this.createContainer(),options.rtl?(this.createLabel(),this.createMarker()):(this.createMarker(),this.createLabel())}createContainer(){this.container=new float_element({vertical:!1,wrap:!1,align:CENTER,spacing:this.options.spacing}),this.append(this.container)}createMarker(){this.container.append(new shape_element(this.markerOptions()))}markerOptions(){const options=this.options,markerColor=options.markerColor;return deepExtend({},options.markers,{background:markerColor,border:{color:markerColor}})}createLabel(){const options=this.options,labelOptions=deepExtend({},options.labels);this.container.append(new text_box(options.text,labelOptions))}renderComplete(){super.renderComplete();const cursor=this.options.cursor||{},eventSink=this._itemOverlay=main.a.Path.fromRect(this.container.box.toRect(),{fill:{color:WHITE,opacity:0},stroke:null,cursor:cursor.style||cursor});this.appendVisual(eventSink)}click(widget,e){const args=this.eventArgs(e);!widget.trigger(\"legendItemClick\",args)&&e&&\"contextmenu\"===e.type&&e.preventDefault()}over(widget,e){const args=this.eventArgs(e);return widget.trigger(\"legendItemHover\",args)||widget._legendItemHover(args.seriesIndex,args.pointIndex),!0}out(widget,e){widget._unsetActivePoint(),widget.trigger(\"legendItemLeave\",this.eventArgs(e))}eventArgs(e){const options=this.options;return{element:eventElement(e),text:options.text,series:options.series,seriesIndex:options.series.index,pointIndex:options.pointIndex}}renderVisual(){const options=this.options,customVisual=options.visual;customVisual?(this.visual=customVisual({active:options.active,series:options.series,sender:this.getSender(),pointIndex:options.pointIndex,options:{markers:this.markerOptions(),labels:options.labels},createVisual:()=>{this.createVisual(),this.renderChildren(),this.renderComplete();const defaultVisual=this.visual;return delete this.visual,defaultVisual}}),this.addVisual()):super.renderVisual()}};class legend_Legend extends chart_element{constructor(options,chartService={}){super(options),this.chartService=chartService,inArray(this.options.position,[TOP,RIGHT,BOTTOM,LEFT,\"custom\"])||(this.options.position=RIGHT),this.createContainers(),this.createLegendTitle(options.title),this.createItems()}createContainers(){const options=this.options,{position:position,align:userAlign}=options;let align=position,vAlign=CENTER;\"custom\"===position?align=LEFT:inArray(position,[TOP,BOTTOM])?(align=\"start\"===userAlign?LEFT:\"end\"===userAlign?RIGHT:CENTER,vAlign=position):userAlign&&(\"start\"===userAlign?vAlign=TOP:\"end\"===userAlign&&(vAlign=BOTTOM)),this.container=new box_element({margin:options.margin,padding:options.padding,background:options.background,border:options.border,vAlign:vAlign,align:align,zIndex:options.zIndex,shrinkToFit:!0}),this.itemsContainer=this.hasTitle()?new box_element({vAlign:vAlign,align:align,zIndex:options.zIndex,shrinkToFit:!0}):this.container,this.append(this.container)}createItems(){const chartService=this.getService(),options=this.options,vertical=this.isVertical(),innerElement=new legend_layout({vertical:vertical,spacing:options.spacing,rtl:chartService.rtl},chartService);let items=options.items;options.reverse&&(items=items.slice(0).reverse());const count=items.length;for(let i=0;i<count;i++)innerElement.append(new legend_item(deepExtend({},{markers:options.markers,labels:options.labels,rtl:chartService.rtl},options.item,items[i])));innerElement.render(),this.itemsContainer.append(innerElement)}isVertical(){const{orientation:orientation,position:position}=this.options;return\"custom\"===position&&\"horizontal\"!==orientation||(defined(orientation)?\"horizontal\"!==orientation:inArray(position,[LEFT,RIGHT]))}hasItems(){return this.container.children[0].children.length>0}reflow(targetBox){const options=this.options,legendBox=targetBox.clone();this.hasItems()?(\"custom\"===options.position?(this.containerCustomReflow(legendBox),this.box=legendBox):this.containerReflow(legendBox),this.hasTitle()&&this.title.reflow(new core_box(this.container.box.x1,this.title.box.y1,this.container.box.x2,this.title.box.y2))):this.box=legendBox}containerReflow(targetBox){const{options:options,container:container}=this,{position:position,width:width,height:height}=options,pos=position===TOP||position===BOTTOM?X:Y,vertical=this.isVertical(),alignTarget=targetBox.clone();let containerBox=targetBox.clone();position!==LEFT&&position!==RIGHT||(containerBox.y1=alignTarget.y1=0),vertical&&height?(containerBox.y2=containerBox.y1+height,containerBox.align(alignTarget,Y,container.options.vAlign)):!vertical&&width&&(containerBox.x2=containerBox.x1+width,containerBox.align(alignTarget,X,container.options.align)),container.reflow(containerBox),containerBox=container.box;const box=containerBox.clone();(options.offsetX||options.offsetY)&&(containerBox.translate(options.offsetX,options.offsetY),container.reflow(containerBox)),box[pos+1]=targetBox[pos+1],box[pos+2]=targetBox[pos+2],this.box=box}containerCustomReflow(targetBox){const{options:options,container:container}=this,{offsetX:offsetX,offsetY:offsetY,width:width,height:height}=options,vertical=this.isVertical();let containerBox=targetBox.clone();vertical&&height?containerBox.y2=containerBox.y1+height:!vertical&&width&&(containerBox.x2=containerBox.x1+width),container.reflow(containerBox),containerBox=container.box,container.reflow(new core_box(offsetX,offsetY,offsetX+containerBox.width(),offsetY+containerBox.height()))}renderVisual(){this.hasItems()&&super.renderVisual()}createLegendTitle(title){let titleOptions=deepExtend({},{color:BLACK,position:TOP,align:CENTER},title),text=titleOptions.text;if(title&&!1!==title.visible){if(defined(titleOptions)&&titleOptions.visible){const labelTemplate=getTemplate(titleOptions);labelTemplate?text=labelTemplate({text:text}):titleOptions.format&&(text=this.chartService.format.auto(titleOptions.format,text))}this.title=new text_box(text,titleOptions),this.createTitleLayout(),this.appendTitleLayoutContent()}}createTitleLayout(){this.layout=new float_element({vertical:!0,wrap:!1}),this.container.append(this.layout)}hasTitle(){return Boolean(this.options.title&&!1!==this.options.title.visible)}appendTitleLayoutContent(){this.options.title.position===BOTTOM?(this.layout.append(this.itemsContainer),this.layout.append(this.title)):(this.layout.append(this.title),this.layout.append(this.itemsContainer))}}setDefaultOptions(legend_Legend,{position:RIGHT,items:[],offsetX:0,offsetY:0,margin:getSpacing(5),padding:getSpacing(5),border:{color:BLACK,width:0},item:{cursor:\"pointer\",spacing:6},spacing:6,background:\"\",zIndex:1,markers:{border:{width:0},width:15,height:3,type:\"rect\",align:LEFT,vAlign:CENTER}});var legend_legend=legend_Legend,plotarea_factory=(()=>{class PlotAreaFactory extends common_class.a{constructor(){super(),this._registry=[]}register(type,seriesTypes){this._registry.push({type:type,seriesTypes:seriesTypes})}create(srcSeries,options,chartService){const registry=this._registry;let series,match=registry[0];for(let idx=0;idx<registry.length;idx++){const entry=registry[idx];if(series=filterSeriesByType(srcSeries,entry.seriesTypes),series.length>0){match=entry;break}}return new match.type(series,options,chartService)}}return PlotAreaFactory.current=new PlotAreaFactory,PlotAreaFactory})();function createDiv(className){const element=document.createElement(\"div\");return className&&(element.className=className),element}function closestHandle(element){let current=element;for(;current&&!hasClasses(current,\"k-handle\");)current=current.parentNode;return current}class selection_Selection extends common_class.a{constructor(chart,categoryAxis,options,observer){super();const chartElement=chart.element;this.options=deepExtend({},this.options,options),this.chart=chart,this.observer=observer,this.chartElement=chartElement,this.categoryAxis=categoryAxis,this._dateAxis=this.categoryAxis instanceof date_category_axis,this.initOptions(),this.visible=this.options.visible&&chartElement.offsetHeight,this.visible&&(this.createElements(),this.set(this._index(this.options.from),this._index(this.options.to)),this.bindEvents())}onPane(pane){return this.categoryAxis.pane===pane}createElements(){const options=this.options,wrapper=this.wrapper=createDiv(\"k-selector\");element_styles_elementStyles(wrapper,{top:options.offset.top,left:options.offset.left,width:options.width,height:options.height,direction:\"ltr\"});const selection=this.selection=createDiv(\"k-selection\");this.leftMask=createDiv(\"k-mask\"),this.rightMask=createDiv(\"k-mask\"),wrapper.appendChild(this.leftMask),wrapper.appendChild(this.rightMask),wrapper.appendChild(selection),selection.appendChild(createDiv(\"k-selection-bg\"));const leftHandle=this.leftHandle=createDiv(\"k-handle k-left-handle\"),rightHandle=this.rightHandle=createDiv(\"k-handle k-right-handle\");leftHandle.appendChild(createDiv()),rightHandle.appendChild(createDiv()),selection.appendChild(leftHandle),selection.appendChild(rightHandle),this.chartElement.appendChild(wrapper);const selectionStyles=element_styles_elementStyles(selection,[\"borderLeftWidth\",\"borderRightWidth\",\"height\"]),leftHandleHeight=element_styles_elementStyles(leftHandle,\"height\").height,rightHandleHeight=element_styles_elementStyles(rightHandle,\"height\").height;options.selection={border:{left:selectionStyles.borderLeftWidth,right:selectionStyles.borderRightWidth}},element_styles_elementStyles(leftHandle,{top:(selectionStyles.height-leftHandleHeight)/2}),element_styles_elementStyles(rightHandle,{top:(selectionStyles.height-rightHandleHeight)/2}),wrapper.style.cssText=wrapper.style.cssText}bindEvents(){!1!==this.options.mousewheel&&(this._mousewheelHandler=this._mousewheel.bind(this),bindEvents(this.wrapper,{[MOUSEWHEEL]:this._mousewheelHandler})),this._domEvents=dom_events_builder.create(this.wrapper,{stopPropagation:!0,start:this._start.bind(this),move:this._move.bind(this),end:this._end.bind(this),tap:this._tap.bind(this),press:this._press.bind(this),gesturestart:this._gesturestart.bind(this),gesturechange:this._gesturechange.bind(this),gestureend:this._gestureend.bind(this)})}initOptions(){const{options:options,categoryAxis:categoryAxis}=this,box=categoryAxis.pane.chartsBox(),intlService=this.chart.chartService.intl;this._dateAxis&&deepExtend(options,{min:parse_date_parseDate(intlService,options.min),max:parse_date_parseDate(intlService,options.max),from:parse_date_parseDate(intlService,options.from),to:parse_date_parseDate(intlService,options.to)});const{paddingLeft:paddingLeft,paddingTop:paddingTop}=element_styles_elementStyles(this.chartElement,[\"paddingLeft\",\"paddingTop\"]);this.options=deepExtend({},{width:box.width(),height:box.height()+.1,padding:{left:paddingLeft,top:paddingTop},offset:{left:box.x1+paddingLeft,top:box.y1+paddingTop},from:options.min,to:options.max},options)}destroy(){this._domEvents&&(this._domEvents.destroy(),delete this._domEvents),clearTimeout(this._mwTimeout),this._state=null,this.wrapper&&(this._mousewheelHandler&&(unbindEvents(this.wrapper,{[MOUSEWHEEL]:this._mousewheelHandler}),this._mousewheelHandler=null),this.chartElement.removeChild(this.wrapper),this.wrapper=null)}_rangeEventArgs(range){return{axis:this.categoryAxis.options,from:this._value(range.from),to:this._value(range.to)}}_start(e){const options=this.options,target=eventElement(e);if(this._state||!target)return;this.chart._unsetActivePoint(),this._state={moveTarget:closestHandle(target)||target,startLocation:e.x?e.x.location:0,range:{from:this._index(options.from),to:this._index(options.to)}};const args=this._rangeEventArgs({from:this._index(options.from),to:this._index(options.to)});this.trigger(\"selectStart\",args)&&(this._state=null)}_press(e){let handle;handle=this._state?this._state.moveTarget:closestHandle(eventElement(e)),handle&&addClass(handle,\"k-handle-active\")}_move(e){if(!this._state)return;const{_state:state,options:options,categoryAxis:categoryAxis}=this,{range:range,moveTarget:target}=state,reverse=categoryAxis.options.reverse,from=this._index(options.from),to=this._index(options.to),min=this._index(options.min),max=this._index(options.max),delta=state.startLocation-e.x.location,oldRange_from=range.from,oldRange_to=range.to,span=range.to-range.from,scale=element_styles_elementStyles(this.wrapper,\"width\").width/(categoryAxis.categoriesCount()-1),offset=Math.round(delta/scale)*(reverse?-1:1);if(!target)return;const leftHandle=hasClasses(target,\"k-left-handle\"),rightHandle=hasClasses(target,\"k-right-handle\");hasClasses(target,\"k-selection k-selection-bg\")?(range.from=Math.min(Math.max(min,from-offset),max-span),range.to=Math.min(range.from+span,max)):leftHandle&&!reverse||rightHandle&&reverse?(range.from=Math.min(Math.max(min,from-offset),max-1),range.to=Math.max(range.from+1,range.to)):(leftHandle&&reverse||rightHandle&&!reverse)&&(range.to=Math.min(Math.max(min+1,to-offset),max),range.from=Math.min(range.to-1,range.from)),range.from===oldRange_from&&range.to===oldRange_to||(this.move(range.from,range.to),this.trigger(\"select\",this._rangeEventArgs(range)))}_end(){if(this._state){const moveTarget=this._state.moveTarget;moveTarget&&(element=moveTarget)&&element.className&&(element.className=element.className.replace(\"k-handle-active\",\"\").replace(SPACE_REGEX,\" \"));const range=this._state.range;this.set(range.from,range.to),this.trigger(\"selectEnd\",this._rangeEventArgs(range)),delete this._state}var element}_tap(e){const{options:options,categoryAxis:categoryAxis}=this,coords=this.chart._eventCoordinates(e),categoryIx=categoryAxis.pointCategoryIndex(new core_point(coords.x,categoryAxis.box.y1)),from=this._index(options.from),to=this._index(options.to),min=this._index(options.min),max=this._index(options.max),span=to-from,range={},rightClick=3===e.event.which;let offset=Math.round(from+span/2-categoryIx);this._state||rightClick||(this.chart._unsetActivePoint(),categoryAxis.options.justified||offset--,range.from=Math.min(Math.max(min,from-offset),max-span),range.to=Math.min(range.from+span,max),this._start(e),this._state&&(this._state.range=range,this.trigger(\"select\",this._rangeEventArgs(range)),this._end()))}_mousewheel(e){let delta=mousewheelDelta(e);if(this._start({target:this.selection}),this._state){const range=this._state.range;e.preventDefault(),e.stopPropagation(),Math.abs(delta)>1&&(delta*=3),this.options.mousewheel.reverse&&(delta*=-1),this.expand(delta)&&this.trigger(\"select\",{axis:this.categoryAxis.options,delta:delta,originalEvent:e,from:this._value(range.from),to:this._value(range.to)}),this._mwTimeout&&clearTimeout(this._mwTimeout),this._mwTimeout=setTimeout(()=>{this._end()},150)}}_gesturestart(e){const options=this.options;this._state={range:{from:this._index(options.from),to:this._index(options.to)}};const args=this._rangeEventArgs(this._state.range);this.trigger(\"selectStart\",args)?this._state=null:e.preventDefault()}_gestureend(){this._state&&(this.trigger(\"selectEnd\",this._rangeEventArgs(this._state.range)),delete this._state)}_gesturechange(e){const{chart:chart,_state:state,options:options,categoryAxis:categoryAxis}=this,range=state.range,p0=chart._toModelCoordinates(e.touches[0].x.location).x,p1=chart._toModelCoordinates(e.touches[1].x.location).x,left=Math.min(p0,p1),right=Math.max(p0,p1);e.preventDefault(),range.from=categoryAxis.pointCategoryIndex(new core_point(left))||options.min,range.to=categoryAxis.pointCategoryIndex(new core_point(right))||options.max,this.move(range.from,range.to),this.trigger(\"select\",this._rangeEventArgs(range))}_index(value){let index=value;return value instanceof Date&&(index=this.categoryAxis.categoryIndex(value)),index}_value(index){let value=index;return this._dateAxis&&(value=this.categoryAxis.categoryAt(index),value>this.options.max&&(value=this.options.max)),value}_slot(value){const categoryAxis=this.categoryAxis,index=this._index(value);return categoryAxis.getSlot(index,index,!0)}move(from,to){const options=this.options,reverse=this.categoryAxis.options.reverse,{offset:offset,padding:padding,selection:{border:border}}=options,right=reverse?from:to,edge=\"x\"+(reverse?2:1);let box=this._slot(reverse?to:from);const leftMaskWidth=round(box[edge]-offset.left+padding.left);element_styles_elementStyles(this.leftMask,{width:leftMaskWidth}),element_styles_elementStyles(this.selection,{left:leftMaskWidth}),box=this._slot(right);const rightMaskWidth=round(options.width-(box[edge]-offset.left+padding.left));element_styles_elementStyles(this.rightMask,{width:rightMaskWidth});let distance=options.width-rightMaskWidth;distance!==options.width&&(distance+=border.right),element_styles_elementStyles(this.rightMask,{left:distance}),element_styles_elementStyles(this.selection,{width:Math.max(options.width-(leftMaskWidth+rightMaskWidth)-border.right,0)})}set(from,to){const options=this.options,min=this._index(options.min),max=this._index(options.max),fromValue=limitValue(this._index(from),min,max),toValue=limitValue(this._index(to),fromValue+1,max);options.visible&&this.move(fromValue,toValue),options.from=this._value(fromValue),options.to=this._value(toValue)}expand(delta){const options=this.options,min=this._index(options.min),max=this._index(options.max),zDir=options.mousewheel.zoom,from=this._index(options.from),to=this._index(options.to);let range={from:from,to:to};const oldRange=deepExtend({},range);if(this._state&&(range=this._state.range),zDir!==RIGHT&&(range.from=limitValue(limitValue(from-delta,0,to-1),min,max)),zDir!==LEFT&&(range.to=limitValue(limitValue(to+delta,range.from+1,max),min,max)),range.from!==oldRange.from||range.to!==oldRange.to)return this.set(range.from,range.to),!0}trigger(name,args){return(this.observer||this.chart).trigger(name,args)}}setDefaultOptions(selection_Selection,{visible:!0,mousewheel:{zoom:\"both\"},min:MIN_VALUE,max:MAX_VALUE});var chart_selection=selection_Selection,tooltip_tooltip=class extends base_tooltip{show(point){if(!point||!point.tooltipAnchor||this._current&&this._current===point)return;const options=deepExtend({},this.options,point.options.tooltip),anchor=point.tooltipAnchor();anchor?(this._current=point,super.show({point:point,anchor:anchor},options,point)):this.hide()}hide(){delete this._current,super.hide()}};class shared_tooltip_SharedTooltip extends base_tooltip{constructor(plotArea,options){super(plotArea.chartService,options),this.plotArea=plotArea,this.formatService=plotArea.chartService.format}showAt(points,coords){const tooltipPoints=grep(points,function(point){const tooltip=point.series.tooltip;return!(tooltip&&!1===tooltip.visible)});if(tooltipPoints.length>0){const point=tooltipPoints[0],slot=this.plotArea.categoryAxis.getSlot(point.categoryIx),anchor=coords?this._slotAnchor(coords,slot):this._defaultAnchor(point,slot);this.show({anchor:anchor,shared:!0,points:points,category:point.category,categoryText:this.formatService.auto(this.options.categoryFormat,point.category),series:this.plotArea.series},this.options)}}_slotAnchor(point,slot){return this.plotArea.categoryAxis.options.vertical||(point.x=slot.center().x),{point:point,align:{horizontal:\"left\",vertical:\"center\"}}}_defaultAnchor(point,slot){const box=point.owner.pane.chartsBox(),vertical=this.plotArea.categoryAxis.options.vertical,center=box.center(),slotCenter=slot.center();let centerPoint;return centerPoint=vertical?new core_point(center.x,slotCenter.y):new core_point(slotCenter.x,center.y),{point:centerPoint,align:{horizontal:\"center\",vertical:\"center\"}}}}setDefaultOptions(shared_tooltip_SharedTooltip,{categoryFormat:\"{0:d}\"});var shared_tooltip=shared_tooltip_SharedTooltip;class bar_chart_animation_BarChartAnimation extends main.a.Animation{setup(){const{element:element,options:options}=this;if(element.bbox()){this.origin=options.origin;const axis=options.vertical?Y:X,fromScale=this.fromScale=new main.b.Point(1,1);fromScale[axis]=START_SCALE,element.transform(main.b.transform().scale(fromScale.x,fromScale.y))}else this.abort()}step(pos){const scaleX=interpolateValue(this.fromScale.x,1,pos),scaleY=interpolateValue(this.fromScale.y,1,pos);this.element.transform(main.b.transform().scale(scaleX,scaleY,this.origin))}abort(){super.abort(),this.element.transform(null)}}setDefaultOptions(bar_chart_animation_BarChartAnimation,{duration:600}),main.a.AnimationFactory.current.register(BAR,bar_chart_animation_BarChartAnimation);class bubble_animation_BubbleAnimation extends main.a.Animation{setup(){const center=this.center=this.element.bbox().center();this.element.transform(main.b.transform().scale(START_SCALE,START_SCALE,center))}step(pos){this.element.transform(main.b.transform().scale(pos,pos,this.center))}}setDefaultOptions(bubble_animation_BubbleAnimation,{easing:\"easeOutElastic\"}),main.a.AnimationFactory.current.register(\"bubble\",bubble_animation_BubbleAnimation);class fade_in_animation_FadeInAnimation extends main.a.Animation{setup(){this.fadeTo=this.element.opacity(),this.element.opacity(0)}step(pos){this.element.opacity(pos*this.fadeTo)}}setDefaultOptions(fade_in_animation_FadeInAnimation,{duration:200,easing:\"linear\"}),main.a.AnimationFactory.current.register(\"fadeIn\",fade_in_animation_FadeInAnimation);class pie_animation_PieAnimation extends main.a.Animation{setup(){this.element.transform(main.b.transform().scale(START_SCALE,START_SCALE,this.options.center))}step(pos){this.element.transform(main.b.transform().scale(pos,pos,this.options.center))}}setDefaultOptions(pie_animation_PieAnimation,{easing:\"easeOutElastic\",duration:600}),main.a.AnimationFactory.current.register(PIE,pie_animation_PieAnimation);class scatter_line_chart_ScatterLineChart extends scatter_chart{render(){super.render(),this.renderSegments()}createSegment(linePoints,currentSeries,seriesIx){let pointType;return pointType=\"smooth\"===currentSeries.style?spline_segment:line_segment,new pointType(linePoints,currentSeries,seriesIx)}animationPoints(){return super.animationPoints().concat(this._segments)}createMissingValue(value,missingValues){if(missingValues===ZERO){const missingValue={x:value.x,y:value.y};return has_value_hasValue(missingValue.x)||(missingValue.x=0),has_value_hasValue(missingValue.y)||(missingValue.y=0),missingValue}}}deepExtend(scatter_line_chart_ScatterLineChart.prototype,line_chart_mixin);var scatter_line_chart=scatter_line_chart_ScatterLineChart;class xy_plotarea_XYPlotArea extends plotarea_base{initFields(){this.namedXAxes={},this.namedYAxes={},this.xAxisRangeTracker=new axis_group_range_tracker,this.yAxisRangeTracker=new axis_group_range_tracker}render(panes=this.panes){const seriesByPane=this.groupSeriesByPane();for(let i=0;i<panes.length;i++){const pane=panes[i],paneSeries=seriesByPane[pane.options.name||\"default\"]||[];this.addToLegend(paneSeries);const filteredSeries=this.filterVisibleSeries(paneSeries);filteredSeries&&(this.createScatterChart(filterSeriesByType(filteredSeries,\"scatter\"),pane),this.createScatterLineChart(filterSeriesByType(filteredSeries,\"scatterLine\"),pane),this.createBubbleChart(filterSeriesByType(filteredSeries,\"bubble\"),pane))}this.createAxes(panes)}appendChart(chart,pane){this.xAxisRangeTracker.update(chart.xAxisRanges),this.yAxisRangeTracker.update(chart.yAxisRanges),super.appendChart(chart,pane)}removeAxis(axis){const axisName=axis.options.name;super.removeAxis(axis),axis.options.vertical?(this.yAxisRangeTracker.reset(axisName),delete this.namedYAxes[axisName]):(this.xAxisRangeTracker.reset(axisName),delete this.namedXAxes[axisName]),axis===this.axisX&&delete this.axisX,axis===this.axisY&&delete this.axisY}seriesPaneName(series){const options=this.options,xAxisName=series.xAxis,xAxis=grep([].concat(options.xAxis),function(a){return a.name===xAxisName})[0],yAxisName=series.yAxis,yAxis=grep([].concat(options.yAxis),function(a){return a.name===yAxisName})[0];return(xAxis||{}).pane||(yAxis||{}).pane||(options.panes||[{}])[0].name||\"default\"}createScatterChart(series,pane){series.length>0&&this.appendChart(new scatter_chart(this,{series:series,clip:pane.options.clip}),pane)}createScatterLineChart(series,pane){series.length>0&&this.appendChart(new scatter_line_chart(this,{series:series,clip:pane.options.clip}),pane)}createBubbleChart(series,pane){series.length>0&&this.appendChart(new bubble_chart(this,{series:series,clip:pane.options.clip}),pane)}createXYAxis(options,vertical,axisIndex){const axisName=options.name,namedAxes=vertical?this.namedYAxes:this.namedXAxes,tracker=vertical?this.yAxisRangeTracker:this.xAxisRangeTracker,axisOptions=deepExtend({reverse:!vertical&&this.chartService.rtl},options,{vertical:vertical}),isLog=equalsIgnoreCase(axisOptions.type,\"log\"),defaultRange=tracker.query(),defaultAxisRange=isLog?{min:.1,max:1}:{min:0,max:1},range=tracker.query(axisName)||defaultRange||defaultAxisRange,typeSamples=[axisOptions.min,axisOptions.max],series=this.series;for(let seriesIx=0;seriesIx<series.length;seriesIx++){const currentSeries=series[seriesIx],seriesAxisName=currentSeries[vertical?\"yAxis\":\"xAxis\"];if(seriesAxisName===axisOptions.name||0===axisIndex&&!seriesAxisName){const firstPointValue=series_binder.current.bindPoint(currentSeries,0).valueFields;typeSamples.push(firstPointValue[vertical?\"y\":\"x\"]);break}}let inferredDate,axisType;0===axisIndex&&defaultRange&&(range.min=Math.min(range.min,defaultRange.min),range.max=Math.max(range.max,defaultRange.max));for(let i=0;i<typeSamples.length;i++)if(typeSamples[i]instanceof Date){inferredDate=!0;break}axisType=equalsIgnoreCase(axisOptions.type,DATE)||!axisOptions.type&&inferredDate?date_value_axis:isLog?logarithmic_axis:numeric_axis;const axis=new axisType(range.min,range.max,axisOptions,this.chartService);if(axis.axisIndex=axisIndex,axisName){if(namedAxes[axisName])throw new Error(`${vertical?\"Y\":\"X\"} axis with name ${axisName} is already defined`);namedAxes[axisName]=axis}return this.appendAxis(axis),axis}createAxes(panes){const options=this.options,xAxesOptions=[].concat(options.xAxis),xAxes=[],yAxesOptions=[].concat(options.yAxis),yAxes=[];for(let idx=0;idx<xAxesOptions.length;idx++)inArray(this.findPane(xAxesOptions[idx].pane),panes)&&xAxes.push(this.createXYAxis(xAxesOptions[idx],!1,idx));for(let idx=0;idx<yAxesOptions.length;idx++)inArray(this.findPane(yAxesOptions[idx].pane),panes)&&yAxes.push(this.createXYAxis(yAxesOptions[idx],!0,idx));this.axisX=this.axisX||xAxes[0],this.axisY=this.axisY||yAxes[0]}_dispatchEvent(chart,e,eventType){const coords=chart._eventCoordinates(e),point=new core_point(coords.x,coords.y),allAxes=this.axes,length=allAxes.length,xValues=[],yValues=[];for(let i=0;i<length;i++){const axis=allAxes[i],values=axis.options.vertical?yValues:xValues,currentValue=axis.getValue(point);null!==currentValue&&values.push(currentValue)}xValues.length>0&&yValues.length>0&&chart.trigger(eventType,{element:eventElement(e),originalEvent:e,x:singleItemOrArray(xValues),y:singleItemOrArray(yValues)})}updateAxisOptions(axis,options){const vertical=axis.options.vertical,axes=this.groupAxes(this.panes),index=(vertical?axes.y:axes.x).indexOf(axis);xy_plotarea_updateAxisOptions(this.options,index,vertical,options),xy_plotarea_updateAxisOptions(this.originalOptions,index,vertical,options)}}function xy_plotarea_updateAxisOptions(targetOptions,axisIndex,vertical,options){deepExtend([].concat(vertical?targetOptions.yAxis:targetOptions.xAxis)[axisIndex],options)}setDefaultOptions(xy_plotarea_XYPlotArea,{xAxis:{},yAxis:{}}),deepExtend(xy_plotarea_XYPlotArea.prototype,plotarea_events_mixin);var xy_plotarea=xy_plotarea_XYPlotArea;class pie_segment_PieSegment extends chart_element{constructor(value,sector,options){super(options),this.value=value,this.sector=sector}render(){const labels=this.options.labels,chartService=this.owner.chartService;let labelText=this.value;if(this._rendered||!1===this.visible)return;this._rendered=!0;const labelTemplate=getTemplate(labels),pointData=this.pointData();if(labelTemplate?labelText=labelTemplate(pointData):labels.format&&(labelText=chartService.format.auto(labels.format,labelText)),labels.visible&&(labelText||0===labelText)){if(labels.position===CENTER||\"insideEnd\"===labels.position){if(!labels.color){const brightnessValue=new color_color.a(this.options.color).percBrightness();labels.color=brightnessValue>180?BLACK:WHITE}labels.background||(labels.background=this.options.color)}else{const themeLabels=chartService.theme.seriesDefaults.labels;labels.color=labels.color||themeLabels.color,labels.background=labels.background||themeLabels.background}this.label=new text_box(labelText,deepExtend({},labels,{align:CENTER,vAlign:\"\",animation:{type:\"fadeIn\",delay:this.animationDelay}}),pointData),this.append(this.label)}}reflow(targetBox){this.render(),this.box=targetBox,this.reflowLabel()}reflowLabel(){const{options:{labels:labelsOptions},label:label}=this,sector=this.sector.clone(),labelsDistance=labelsOptions.distance,angle=sector.middle();if(label){const labelHeight=label.box.height(),labelWidth=label.box.width();let lp;if(labelsOptions.position===CENTER)sector.radius=Math.abs((sector.radius-labelHeight)/2)+labelHeight,lp=sector.point(angle),label.reflow(new core_box(lp.x,lp.y-labelHeight/2,lp.x,lp.y));else if(\"insideEnd\"===labelsOptions.position)sector.radius=sector.radius-labelHeight/2,lp=sector.point(angle),label.reflow(new core_box(lp.x,lp.y-labelHeight/2,lp.x,lp.y));else{let x1;lp=sector.clone().expand(labelsDistance).point(angle),lp.x>=sector.center.x?(x1=lp.x+labelWidth,label.orientation=RIGHT):(x1=lp.x-labelWidth,label.orientation=LEFT),label.reflow(new core_box(x1,lp.y-labelHeight,lp.x,lp.y))}}}createVisual(){const{sector:sector,options:options}=this;if(super.createVisual(),this.value)if(options.visual){const startAngle=(sector.startAngle+180)%360,visual=options.visual({category:this.category,dataItem:this.dataItem,value:this.value,series:this.series,percentage:this.percentage,center:new main.b.Point(sector.center.x,sector.center.y),radius:sector.radius,innerRadius:sector.innerRadius,startAngle:startAngle,endAngle:startAngle+sector.angle,options:options,sender:this.getSender(),createVisual:()=>{const group=new main.a.Group;return this.createSegmentVisual(group),group}});visual&&this.visual.append(visual)}else this.createSegmentVisual(this.visual)}createSegmentVisual(group){const{sector:sector,options:options}=this,borderOptions=options.border||{},color=options.color,fill={color:color,opacity:options.opacity},visual=this.createSegment(sector,deepExtend({fill:fill,stroke:{opacity:options.opacity},zIndex:options.zIndex},borderOptions.width>0?{stroke:{color:borderOptions.color,width:borderOptions.width,opacity:borderOptions.opacity,dashType:borderOptions.dashType}}:{}));group.append(visual),hasGradientOverlay(options)&&group.append(this.createGradientOverlay(visual,{baseColor:color,fallbackFill:fill},deepExtend({center:[sector.center.x,sector.center.y],innerRadius:sector.innerRadius,radius:sector.radius,userSpace:!0},options.overlay)))}createSegment(sector,options){return options.singleSegment?new main.a.Circle(new main.b.Circle(new main.b.Point(sector.center.x,sector.center.y),sector.radius),options):shape_builder.current.createRing(sector,options)}createAnimation(){const{options:options,sector:{center:center}}=this;deepExtend(options,{animation:{center:[center.x,center.y],delay:this.animationDelay}}),super.createAnimation()}createHighlight(options){const highlight=this.options.highlight||{},border=highlight.border||{};return this.createSegment(this.sector,deepExtend({},options,{fill:{color:highlight.color,opacity:highlight.opacity},stroke:{opacity:border.opacity,width:border.width,color:border.color}}))}highlightVisual(){return this.visual.children[0]}highlightVisualArgs(){const sector=this.sector;return{options:this.options,radius:sector.radius,innerRadius:sector.innerRadius,center:new main.b.Point(sector.center.x,sector.center.y),startAngle:sector.startAngle,endAngle:sector.angle+sector.startAngle,visual:this.visual}}tooltipAnchor(){const sector=this.sector.clone().expand(5),midAndle=sector.middle();return{point:sector.point(midAndle),align:tooltipAlignment(midAndle+180)}}formatValue(format){return this.owner.formatPointValue(this,format)}pointData(){return{dataItem:this.dataItem,category:this.category,value:this.value,series:this.series,percentage:this.percentage}}}const RAD_30=round(rad(30),10),RAD_60=round(rad(60),10);function tooltipAlignment(angle){const radians=rad(angle),sine=round(Math.sin(radians),10),cosine=round(Math.cos(radians),10);let horizontal,vertical;return horizontal=Math.abs(sine)>RAD_60?CENTER:cosine<0?RIGHT:LEFT,vertical=Math.abs(sine)<RAD_30?CENTER:sine<0?BOTTOM:TOP,{horizontal:horizontal,vertical:vertical}}setDefaultOptions(pie_segment_PieSegment,{color:WHITE,overlay:{gradient:\"roundedBevel\"},border:{width:.5},labels:{visible:!1,distance:35,font:\"12px sans-serif\",margin:getSpacing(.5),align:CIRCLE,zIndex:1,position:\"outsideEnd\"},animation:{type:PIE},highlight:{visible:!0,border:{width:1}},visible:!0}),deepExtend(pie_segment_PieSegment.prototype,point_events_mixin);var pie_segment=pie_segment_PieSegment,pie_chart_mixin={createLegendItem:function(value,point,options){const legendOptions=this.options.legend||{},labelsOptions=legendOptions.labels||{},inactiveItems=legendOptions.inactiveItems||{},inactiveItemsLabels=inactiveItems.labels||{};if(options&&!1!==options.visibleInLegend){const pointVisible=!1!==options.visible,labelTemplate=pointVisible?getTemplate(labelsOptions):getTemplate(inactiveItemsLabels)||getTemplate(labelsOptions);let itemLabelOptions,markerColor,text=options.category;labelTemplate&&(text=labelTemplate({text:text,series:options.series,dataItem:options.dataItem,percentage:options.percentage,value:value})),pointVisible?(itemLabelOptions={},markerColor=point.color):(itemLabelOptions={color:inactiveItemsLabels.color,font:inactiveItemsLabels.font},markerColor=(inactiveItems.markers||{}).color),has_value_hasValue(text)&&\"\"!==text&&this.legendItems.push({active:pointVisible,pointIndex:options.index,text:text,series:options.series,markerColor:markerColor,labels:itemLabelOptions})}}};class pie_chart_PieChart extends chart_element{constructor(plotArea,options){super(options),this.plotArea=plotArea,this.chartService=plotArea.chartService,this.points=[],this.legendItems=[],this.render()}render(){this.traverseDataPoints(this.addValue.bind(this))}traverseDataPoints(callback){const{options:options,plotArea:{options:{seriesColors:seriesColors=[]}}}=this,colorsCount=seriesColors.length,series=options.series,seriesCount=series.length;for(let seriesIx=0;seriesIx<seriesCount;seriesIx++){const currentSeries=series[seriesIx],data=currentSeries.data,{total:total,points:points,count:count}=bindSegments(currentSeries),anglePerValue=360/total;let constantAngle,currentAngle;isFinite(anglePerValue)||(constantAngle=360/count),currentAngle=defined(currentSeries.startAngle)?currentSeries.startAngle:options.startAngle,seriesIx!==seriesCount-1&&\"outsideEnd\"===currentSeries.labels.position&&(currentSeries.labels.position=CENTER);for(let i=0;i<points.length;i++){const pointData=points[i];if(!pointData)continue;const{fields:fields,value:value,visible:visible}=pointData,angle=0!==value?constantAngle||value*anglePerValue:0,explode=1!==data.length&&Boolean(fields.explode);isFunction(currentSeries.color)||(currentSeries.color=fields.color||seriesColors[i%colorsCount]),callback(pointData.valueFields.value,new core_ring(null,0,0,currentAngle,angle),{owner:this,category:defined(fields.category)?fields.category:\"\",index:i,series:currentSeries,seriesIx:seriesIx,dataItem:data[i],percentage:0!==total?value/total:0,explode:explode,visibleInLegend:fields.visibleInLegend,visible:visible,zIndex:seriesCount-seriesIx,animationDelay:this.animationDelay(i,seriesIx,seriesCount)}),!1!==visible&&(currentAngle+=angle)}}}evalSegmentOptions(options,value,fields){const series=fields.series;evalOptions(options,{value:value,series:series,dataItem:fields.dataItem,category:fields.category,percentage:fields.percentage},{defaults:series._defaults,excluded:[\"data\",\"content\",\"template\",\"visual\",\"toggle\"]})}addValue(value,sector,fields){const segmentOptions=deepExtend({},fields.series,{index:fields.index});if(this.evalSegmentOptions(segmentOptions,value,fields),this.createLegendItem(value,segmentOptions,fields),!1===fields.visible)return;const segment=new pie_segment(value,sector,segmentOptions);Object.assign(segment,fields),this.append(segment),this.points.push(segment)}reflow(targetBox){const{options:options,points:points,seriesConfigs:seriesConfigs=[]}=this,count=points.length,box=targetBox.clone(),minWidth=Math.min(box.width(),box.height()),halfMinWidth=minWidth/2,defaultPadding=minWidth-.85*minWidth,newBox=new core_box(box.x1,box.y1,box.x1+minWidth,box.y1+minWidth),newBoxCenter=newBox.center(),boxCenter=box.center(),seriesCount=options.series.length,leftSideLabels=[],rightSideLabels=[];let padding=valueOrDefault(options.padding,defaultPadding);this.targetBox=targetBox,padding=padding>halfMinWidth-5?halfMinWidth-5:padding,newBox.translate(boxCenter.x-newBoxCenter.x,boxCenter.y-newBoxCenter.y);const radius=halfMinWidth-padding,center=new core_point(radius+newBox.x1+padding,radius+newBox.y1+padding);for(let i=0;i<count;i++){const segment=points[i],sector=segment.sector,seriesIndex=segment.seriesIx;if(sector.radius=radius,sector.center=center,seriesConfigs.length){const seriesConfig=seriesConfigs[seriesIndex];sector.innerRadius=seriesConfig.innerRadius,sector.radius=seriesConfig.radius}seriesIndex===seriesCount-1&&segment.explode&&(sector.center=sector.clone().setRadius(.15*sector.radius).point(sector.middle())),segment.reflow(newBox);const label=segment.label;label&&\"outsideEnd\"===label.options.position&&seriesIndex===seriesCount-1&&(label.orientation===RIGHT?rightSideLabels.push(label):leftSideLabels.push(label))}leftSideLabels.length>0&&(leftSideLabels.sort(this.labelComparator(!0)),this.leftLabelsReflow(leftSideLabels)),rightSideLabels.length>0&&(rightSideLabels.sort(this.labelComparator(!1)),this.rightLabelsReflow(rightSideLabels)),this.box=newBox}leftLabelsReflow(labels){const distances=this.distanceBetweenLabels(labels);this.distributeLabels(distances,labels)}rightLabelsReflow(labels){const distances=this.distanceBetweenLabels(labels);this.distributeLabels(distances,labels)}distanceBetweenLabels(labels){const segment=last(this.points),sector=segment.sector,count=labels.length-1,lr=sector.radius+segment.options.labels.distance,distances=[];let firstBox=labels[0].box,distance=round(firstBox.y1-(sector.center.y-lr-firstBox.height()-firstBox.height()/2));distances.push(distance);for(let i=0;i<count;i++)firstBox=labels[i].box,distance=round(labels[i+1].box.y1-firstBox.y2),distances.push(distance);return distance=round(sector.center.y+lr-labels[count].box.y2-labels[count].box.height()/2),distances.push(distance),distances}distributeLabels(distances,labels){const count=distances.length;let left,right,remaining;for(let i=0;i<count;i++)for(remaining=-distances[i],left=right=i;remaining>0&&(left>=0||right<count);)remaining=this._takeDistance(distances,i,--left,remaining),remaining=this._takeDistance(distances,i,++right,remaining);this.reflowLabels(distances,labels)}_takeDistance(distances,anchor,position,amount){let result=amount;if(distances[position]>0){const available=Math.min(distances[position],result);result-=available,distances[position]-=available,distances[anchor]+=available}return result}reflowLabels(distances,labels){const segment=last(this.points),sector=segment.sector,labelOptions=segment.options.labels,labelsCount=labels.length,labelDistance=labelOptions.distance;let boxX,boxY=sector.center.y-(sector.radius+labelDistance)-labels[0].box.height();distances[0]+=2;for(let i=0;i<labelsCount;i++){const label=labels[i],box=label.box;boxY+=distances[i],boxX=this.hAlignLabel(box.x2,sector.clone().expand(labelDistance),boxY,boxY+box.height(),label.orientation===RIGHT),label.orientation===RIGHT?(labelOptions.align!==CIRCLE&&(boxX=sector.radius+sector.center.x+labelDistance),label.reflow(new core_box(boxX+box.width(),boxY,boxX,boxY))):(labelOptions.align!==CIRCLE&&(boxX=sector.center.x-sector.radius-labelDistance),label.reflow(new core_box(boxX-box.width(),boxY,boxX,boxY))),boxY+=box.height()}}createVisual(){const{options:{connectors:connectors},points:points}=this,count=points.length;super.createVisual(),this._connectorLines=[];for(let i=0;i<count;i++){const segment=points[i],{sector:sector,label:label}=segment,angle=sector.middle(),connectorsColor=(segment.options.connectors||{}).color||connectors.color;if(label){const connectorLine=new main.a.Path({stroke:{color:connectorsColor,width:connectors.width},animation:{type:\"fadeIn\",delay:segment.animationDelay}});if(\"outsideEnd\"===label.options.position){const box=label.box,centerPoint=sector.center;let sr,end,crossing,start=sector.point(angle),middle=new core_point(box.x1,box.center().y);start=sector.clone().expand(connectors.padding).point(angle),connectorLine.moveTo(start.x,start.y),label.orientation===RIGHT?(end=new core_point(box.x1-connectors.padding,box.center().y),crossing=intersection(centerPoint,start,middle,end),middle=new core_point(end.x-4,end.y),crossing=crossing||middle,crossing.x=Math.min(crossing.x,middle.x),this.pointInCircle(crossing,sector.center,sector.radius+4)||crossing.x<sector.center.x?(sr=sector.center.x+sector.radius+4,connectorLine.lineTo(segment.options.labels.align!==COLUMN?sr<middle.x?sr:start.x+8:sr,start.y),connectorLine.lineTo(middle.x,end.y)):(crossing.y=end.y,connectorLine.lineTo(crossing.x,crossing.y))):(end=new core_point(box.x2+connectors.padding,box.center().y),crossing=intersection(centerPoint,start,middle,end),middle=new core_point(end.x+4,end.y),crossing=crossing||middle,crossing.x=Math.max(crossing.x,middle.x),this.pointInCircle(crossing,sector.center,sector.radius+4)||crossing.x>sector.center.x?(sr=sector.center.x-sector.radius-4,connectorLine.lineTo(segment.options.labels.align!==COLUMN?sr>middle.x?sr:start.x-8:sr,start.y),connectorLine.lineTo(middle.x,end.y)):(crossing.y=end.y,connectorLine.lineTo(crossing.x,crossing.y))),connectorLine.lineTo(end.x,end.y),this._connectorLines.push(connectorLine),this.visual.append(connectorLine)}}}}renderVisual(){if(super.renderVisual(),find(this.options.series,options=>options.autoFit)){const targetBox=this.targetBox,pieCenter=this.box.center(),bbox=this.visual.bbox();if(!bbox)return;const bboxBottom=bbox.bottomRight(),scale=Math.min((pieCenter.y-targetBox.y1)/(pieCenter.y-bbox.origin.y),(targetBox.y2-pieCenter.y)/(bboxBottom.y-pieCenter.y),(pieCenter.x-targetBox.x1)/(pieCenter.x-bbox.origin.x),(targetBox.x2-pieCenter.x)/(bboxBottom.x-pieCenter.x));scale<1&&this.visual.transform(main.b.transform().scale(scale,scale,[pieCenter.x,pieCenter.y]))}}labelComparator(reverse){const reverseValue=reverse?-1:1;return function(a,b){return((a.parent.sector.middle()+270)%360-(b.parent.sector.middle()+270)%360)*reverseValue}}hAlignLabel(originalX,sector,y1,y2,direction){const{radius:radius,center:{x:cx,y:cy}}=sector,t=Math.min(Math.abs(cy-y1),Math.abs(cy-y2));return t>radius?originalX:cx+Math.sqrt(radius*radius-t*t)*(direction?1:-1)}pointInCircle(point,center,radius){return Math.pow(center.x-point.x,2)+Math.pow(center.y-point.y,2)<Math.pow(radius,2)}formatPointValue(point,format){return this.chartService.format.auto(format,point.value)}animationDelay(categoryIndex){return 70*categoryIndex}stackRoot(){return this}}function intersection(a1,a2,b1,b2){const ub=(b2.y-b1.y)*(a2.x-a1.x)-(b2.x-b1.x)*(a2.y-a1.y);let result;if(0!==ub){const ua=((b2.x-b1.x)*(a1.y-b1.y)-(b2.y-b1.y)*(a1.x-b1.x))/ub;result=new core_point(a1.x+ua*(a2.x-a1.x),a1.y+ua*(a2.y-a1.y))}return result}setDefaultOptions(pie_chart_PieChart,{startAngle:90,connectors:{width:2,color:\"#939393\",padding:8},inactiveItems:{markers:{},labels:{}}}),deepExtend(pie_chart_PieChart.prototype,pie_chart_mixin),pie_chart_PieChart.prototype.isStackRoot=!0;var pie_chart=pie_chart_PieChart,pie_plotarea=class extends plotarea_base{render(){this.createPieChart(this.series)}createPieChart(series){const firstSeries=series[0],pieChart=new pie_chart(this,{series:series,padding:firstSeries.padding,startAngle:firstSeries.startAngle,connectors:firstSeries.connectors,legend:this.options.legend});this.appendChart(pieChart)}appendChart(chart,pane){super.appendChart(chart,pane),append(this.options.legend.items,chart.legendItems)}};class donut_segment_DonutSegment extends pie_segment{reflowLabel(){const{options:{labels:labelsOptions},label:label}=this,sector=this.sector.clone(),angle=sector.middle();if(label){const labelHeight=label.box.height();if(labelsOptions.position===CENTER){sector.radius-=(sector.radius-sector.innerRadius)/2;const lp=sector.point(angle);label.reflow(new core_box(lp.x,lp.y-labelHeight/2,lp.x,lp.y))}else super.reflowLabel()}}createSegment(sector,options){return shape_builder.current.createRing(sector,options)}}setDefaultOptions(donut_segment_DonutSegment,{overlay:{gradient:\"roundedGlass\"},labels:{position:CENTER},animation:{type:PIE}}),deepExtend(donut_segment_DonutSegment.prototype,point_events_mixin);var donut_segment=donut_segment_DonutSegment;class donut_chart_DonutChart extends pie_chart{addValue(value,sector,fields){const segmentOptions=deepExtend({},fields.series,{index:fields.index});if(this.evalSegmentOptions(segmentOptions,value,fields),this.createLegendItem(value,segmentOptions,fields),!value||!1===fields.visible)return;const segment=new donut_segment(value,sector,segmentOptions);Object.assign(segment,fields),this.append(segment),this.points.push(segment)}reflow(targetBox){const options=this.options,box=targetBox.clone(),minWidth=Math.min(box.width(),box.height()),halfMinWidth=minWidth/2,series=options.series,seriesCount=series.length;let padding=valueOrDefault(options.padding,minWidth-.85*minWidth);padding=padding>halfMinWidth-5?halfMinWidth-5:padding;let holeSize,totalSize=halfMinWidth-padding,seriesWithoutSize=0;for(let i=0;i<seriesCount;i++){const currentSeries=series[i];0===i&&defined(currentSeries.holeSize)&&(holeSize=currentSeries.holeSize,totalSize-=currentSeries.holeSize),defined(currentSeries.size)?totalSize-=currentSeries.size:seriesWithoutSize++,defined(currentSeries.margin)&&i!==seriesCount-1&&(totalSize-=currentSeries.margin)}defined(holeSize)||(holeSize=(halfMinWidth-padding)/(seriesCount+.75)*.75,totalSize-=holeSize);let size,radius,innerRadius=holeSize,margin=0;this.seriesConfigs=[];for(let i=0;i<seriesCount;i++){const currentSeries=series[i];size=valueOrDefault(currentSeries.size,totalSize/seriesWithoutSize),innerRadius+=margin,radius=innerRadius+size,this.seriesConfigs.push({innerRadius:innerRadius,radius:radius}),margin=currentSeries.margin||0,innerRadius=radius}super.reflow(targetBox)}animationDelay(categoryIndex,seriesIndex,seriesCount){return 50*categoryIndex+600*(seriesIndex+1)/(seriesCount+1)}}setDefaultOptions(donut_chart_DonutChart,{startAngle:90,connectors:{width:2,color:\"#939393\",padding:8}});var donut_chart=donut_chart_DonutChart,polar_plotarea_base=class extends plotarea_base{initFields(){this.valueAxisRangeTracker=new axis_group_range_tracker}render(){this.addToLegend(this.series),this.createPolarAxis(),this.createCharts(),this.createValueAxis()}alignAxes(){const axis=this.valueAxis,range=axis.range(),slot=axis.getSlot(axis.options.reverse?range.max:range.min),center=this.polarAxis.getSlot(0).center,axisBox=axis.box.translate(center.x-slot.x1,center.y-slot.y1);axis.reflow(axisBox)}createValueAxis(){const tracker=this.valueAxisRangeTracker,defaultRange=tracker.query(),axisOptions=this.valueAxisOptions({roundToMajorUnit:!1,zIndex:-1});let axisType,axisDefaultRange;\"log\"===axisOptions.type?(axisType=radar_logarithmic_axis,axisDefaultRange={min:.1,max:1}):(axisType=radar_numeric_axis,axisDefaultRange={min:0,max:1});const range=tracker.query(name)||defaultRange||axisDefaultRange;range&&defaultRange&&(range.min=Math.min(range.min,defaultRange.min),range.max=Math.max(range.max,defaultRange.max));const valueAxis=new axisType(range.min,range.max,axisOptions,this.chartService);this.valueAxis=valueAxis,this.appendAxis(valueAxis)}reflowAxes(){const{options:{plotArea:options},valueAxis:valueAxis,polarAxis:polarAxis,box:box}=this,defaultPadding=.15*Math.min(box.width(),box.height()),padding=getSpacing(options.padding||{},defaultPadding),paddingBox=box.clone().unpad(padding),axisBox=paddingBox.clone();axisBox.y2=axisBox.y1+Math.min(axisBox.width(),axisBox.height()),axisBox.align(paddingBox,Y,CENTER);const valueAxisBox=axisBox.clone().shrink(0,axisBox.height()/2);polarAxis.reflow(axisBox),valueAxis.reflow(valueAxisBox);const heightDiff=valueAxis.lineBox().height()-valueAxis.box.height();valueAxis.reflow(valueAxis.box.unpad({top:heightDiff})),this.axisBox=axisBox,this.alignAxes(axisBox)}backgroundBox(){return this.box}detachLabels(){}};class polar_scatter_chart_PolarScatterChart extends scatter_chart{pointSlot(slotX,slotY){const slot=core_point.onCircle(slotX.center,slotX.startAngle,slotX.center.y-slotY.y1);return new core_box(slot.x,slot.y,slot.x,slot.y)}}setDefaultOptions(polar_scatter_chart_PolarScatterChart,{clip:!1});var polar_scatter_chart=polar_scatter_chart_PolarScatterChart;class polar_line_chart_PolarLineChart extends scatter_line_chart{}polar_line_chart_PolarLineChart.prototype.pointSlot=polar_scatter_chart.prototype.pointSlot,setDefaultOptions(polar_line_chart_PolarLineChart,{clip:!1});var polar_line_chart=polar_line_chart_PolarLineChart,spline_polar_area_segment=class extends spline_area_segment{fillToAxes(fillPath){const center=this._polarAxisCenter();fillPath.lineTo(center.x,center.y)}_polarAxisCenter(){return this.parent.plotArea.polarAxis.box.center()}strokeSegments(){let segments=this._strokeSegments;if(!segments){const center=this._polarAxisCenter(),curveProcessor=new curve_processor(!1),linePoints=this.points();linePoints.push(center),segments=this._strokeSegments=curveProcessor.process(linePoints),segments.pop()}return segments}},polar_area_segment=class extends area_segment{fillToAxes(fillPath){const center=this.parent.plotArea.polarAxis.box.center(),centerSegment=new main.b.Segment([center.x,center.y]);fillPath.segments.unshift(centerSegment),fillPath.segments.push(centerSegment)}};function xComparer(a,b){return a.value.x-b.value.x}var polar_area_chart=class extends polar_line_chart{createSegment(linePoints,currentSeries,seriesIx){let segment;return segment=\"smooth\"===(currentSeries.line||{}).style?new spline_polar_area_segment(linePoints,currentSeries,seriesIx):new polar_area_segment(linePoints,currentSeries,seriesIx),segment}createMissingValue(value,missingValues){let missingValue;return has_value_hasValue(value.x)&&\"interpolate\"!==missingValues&&(missingValue={x:value.x,y:value.y},missingValues===ZERO&&(missingValue.y=0)),missingValue}seriesMissingValues(series){return series.missingValues||ZERO}_hasMissingValuesGap(){const series=this.options.series;for(let idx=0;idx<series.length;idx++)if(\"gap\"===this.seriesMissingValues(series[idx]))return!0}sortPoints(points){if(points.sort(xComparer),this._hasMissingValuesGap())for(let idx=0;idx<points.length;idx++){const point=points[idx];point&&(has_value_hasValue(point.value.y)||\"gap\"!==this.seriesMissingValues(point.series)||delete points[idx])}return points}};class polar_plotarea_PolarPlotArea extends polar_plotarea_base{createPolarAxis(){const polarAxis=new polar_axis(this.options.xAxis,this.chartService);this.polarAxis=polarAxis,this.axisX=polarAxis,this.appendAxis(polarAxis)}valueAxisOptions(defaults){return deepExtend(defaults,{majorGridLines:{type:ARC},minorGridLines:{type:ARC}},this.options.yAxis)}createValueAxis(){super.createValueAxis(),this.axisY=this.valueAxis}appendChart(chart,pane){this.valueAxisRangeTracker.update(chart.yAxisRanges),plotarea_base.prototype.appendChart.call(this,chart,pane)}createCharts(){const series=this.filterVisibleSeries(this.series),pane=this.panes[0];this.createLineChart(filterSeriesByType(series,[\"polarLine\"]),pane),this.createScatterChart(filterSeriesByType(series,[\"polarScatter\"]),pane),this.createAreaChart(filterSeriesByType(series,[\"polarArea\"]),pane)}createLineChart(series,pane){if(0===series.length)return;const lineChart=new polar_line_chart(this,{series:series});this.appendChart(lineChart,pane)}createScatterChart(series,pane){if(0===series.length)return;const scatterChart=new polar_scatter_chart(this,{series:series});this.appendChart(scatterChart,pane)}createAreaChart(series,pane){if(0===series.length)return;const areaChart=new polar_area_chart(this,{series:series});this.appendChart(areaChart,pane)}_dispatchEvent(chart,e,eventType){const coords=chart._eventCoordinates(e),point=new core_point(coords.x,coords.y),xValue=this.axisX.getValue(point),yValue=this.axisY.getValue(point);null!==xValue&&null!==yValue&&chart.trigger(eventType,{element:eventElement(e),x:xValue,y:yValue})}createCrosshairs(){}}setDefaultOptions(polar_plotarea_PolarPlotArea,{xAxis:{},yAxis:{}}),deepExtend(polar_plotarea_PolarPlotArea.prototype,plotarea_events_mixin);var polar_plotarea=polar_plotarea_PolarPlotArea;class radar_line_chart_RadarLineChart extends line_chart{pointSlot(categorySlot,valueSlot){const valueRadius=categorySlot.center.y-valueSlot.y1,slot=core_point.onCircle(categorySlot.center,categorySlot.middle(),valueRadius);return new core_box(slot.x,slot.y,slot.x,slot.y)}renderSegments(){if(super.renderSegments(),this._segments&&this._segments.length>1){const seriesSegments=function(segments){const seriesSegments=[];for(let idx=0;idx<segments.length;idx++){const segment=segments[idx];seriesSegments[segment.seriesIx]=seriesSegments[segment.seriesIx]||[],seriesSegments[segment.seriesIx].push(segment)}return seriesSegments}(this._segments);for(let idx=0;idx<seriesSegments.length;idx++){const segments=seriesSegments[idx];if(segments&&segments.length>1){const firstPoint=segments[0].linePoints[0],lastSegment=last(segments),lastPoint=last(lastSegment.linePoints),isLastDataPoint=lastPoint.categoryIx===lastPoint.categoriesCount-1;0===firstPoint.categoryIx&&isLastDataPoint&&last(segments).linePoints.push(firstPoint)}}}}createSegment(linePoints,currentSeries,seriesIx){let pointType;pointType=\"smooth\"===currentSeries.style?spline_segment:line_segment;const segment=new pointType(linePoints,currentSeries,seriesIx),missingValues=this.seriesMissingValues(currentSeries);return linePoints.length!==currentSeries.data.length&&\"interpolate\"!==missingValues||(segment.options.closed=!0),segment}}setDefaultOptions(radar_line_chart_RadarLineChart,{clip:!1,limitPoints:!1});var radar_line_chart=radar_line_chart_RadarLineChart,spline_radar_area_segment=class extends spline_area_segment{fillToAxes(){}},radar_area_segment=class extends area_segment{fillToAxes(){}},radar_area_chart=class extends radar_line_chart{createSegment(linePoints,currentSeries,seriesIx,prevSegment){const style=(currentSeries.line||{}).style;let previousSegment,stackPoints,segment;return this.options.isStacked&&seriesIx>0&&prevSegment&&(stackPoints=prevSegment.linePoints.slice(0),previousSegment=prevSegment),\"smooth\"===style?(segment=new spline_radar_area_segment(linePoints,currentSeries,seriesIx,previousSegment,stackPoints),segment.options.closed=!0):(linePoints.push(linePoints[0]),segment=new radar_area_segment(linePoints,currentSeries,seriesIx,previousSegment,stackPoints)),segment}seriesMissingValues(series){return series.missingValues||ZERO}};class radar_segment_RadarSegment extends donut_segment{constructor(value,options){super(value,null,options)}}setDefaultOptions(radar_segment_RadarSegment,{overlay:{gradient:\"none\"},labels:{distance:10}});var radar_segment=radar_segment_RadarSegment;class radar_cluster_layout_RadarClusterLayout extends chart_element{constructor(options){super(options),this.forEach=options.rtl?forEachReverse:forEach}reflow(sector){const{options:options,children:children}=this,{gap:gap,spacing:spacing}=options,count=children.length,slotAngle=sector.angle/(count+gap+spacing*(count-1));let angle=sector.startAngle+slotAngle*(gap/2);this.forEach(children,child=>{const slotSector=sector.clone();slotSector.startAngle=angle,slotSector.angle=slotAngle,child.sector&&(slotSector.radius=child.sector.radius),child.reflow(slotSector),child.sector=slotSector,angle+=slotAngle+slotAngle*spacing})}}setDefaultOptions(radar_cluster_layout_RadarClusterLayout,{gap:1,spacing:0});var radar_cluster_layout=radar_cluster_layout_RadarClusterLayout,radar_stack_layout=class extends chart_element{reflow(sector){const{options:{reverse:reverse},children:children}=this,childrenCount=children.length,first=reverse?childrenCount-1:0,step=reverse?-1:1;this.box=new core_box;for(let i=first;i>=0&&i<childrenCount;i+=step){const childSector=children[i].sector;childSector.startAngle=sector.startAngle,childSector.angle=sector.angle}}};class radar_bar_chart_RadarBarChart extends bar_chart{pointType(){return radar_segment}clusterType(){return radar_cluster_layout}stackType(){return radar_stack_layout}categorySlot(categoryAxis,categoryIx){return categoryAxis.getSlot(categoryIx)}pointSlot(categorySlot,valueSlot){const slot=categorySlot.clone(),y=categorySlot.center.y;return slot.radius=y-valueSlot.y1,slot.innerRadius=y-valueSlot.y2,slot}reflowPoint(point,pointSlot){point.sector=pointSlot,point.reflow()}createAnimation(){this.options.animation.center=this.box.toRect().center(),super.createAnimation()}}radar_bar_chart_RadarBarChart.prototype.reflow=categorical_chart.prototype.reflow,setDefaultOptions(radar_bar_chart_RadarBarChart,{clip:!1,limitPoints:!1,animation:{type:\"pie\"}});var radar_bar_chart=radar_bar_chart_RadarBarChart;let radar_plotarea_RadarPlotArea=(()=>{class RadarPlotArea extends polar_plotarea_base{createPolarAxis(){const categoryAxis=new radar_category_axis(this.options.categoryAxis,this.chartService);this.polarAxis=categoryAxis,this.categoryAxis=categoryAxis,this.appendAxis(categoryAxis),this.aggregateCategories(),this.createCategoryAxesLabels()}valueAxisOptions(defaults){return this._hasBarCharts&&deepExtend(defaults,{majorGridLines:{type:ARC},minorGridLines:{type:ARC}}),this._isStacked100&&deepExtend(defaults,{roundToMajorUnit:!1,labels:{format:\"P0\"}}),deepExtend(defaults,this.options.valueAxis)}aggregateCategories(){categorical_plotarea.prototype.aggregateCategories.call(this,this.panes)}createCategoryAxesLabels(){categorical_plotarea.prototype.createCategoryAxesLabels.call(this,this.panes)}filterSeries(currentSeries){return currentSeries}createCharts(){const series=this.filterVisibleSeries(this.series),pane=this.panes[0];this.createAreaChart(filterSeriesByType(series,[\"radarArea\"]),pane),this.createLineChart(filterSeriesByType(series,[\"radarLine\"]),pane),this.createBarChart(filterSeriesByType(series,[\"radarColumn\"]),pane)}chartOptions(series){const options={series:series},firstSeries=series[0];if(firstSeries){const filteredSeries=this.filterVisibleSeries(series),stack=firstSeries.stack;options.isStacked=stack&&filteredSeries.length>1,options.isStacked100=stack&&\"100%\"===stack.type&&filteredSeries.length>1,options.isStacked100&&(this._isStacked100=!0)}return options}createAreaChart(series,pane){if(0===series.length)return;const areaChart=new radar_area_chart(this,this.chartOptions(series));this.appendChart(areaChart,pane)}createLineChart(series,pane){if(0===series.length)return;const lineChart=new radar_line_chart(this,this.chartOptions(series));this.appendChart(lineChart,pane)}createBarChart(series,pane){if(0===series.length)return;const firstSeries=series[0],options=this.chartOptions(series);options.gap=firstSeries.gap,options.spacing=firstSeries.spacing;const barChart=new radar_bar_chart(this,options);this.appendChart(barChart,pane),this._hasBarCharts=!0}seriesCategoryAxis(){return this.categoryAxis}_dispatchEvent(chart,e,eventType){const coords=chart._eventCoordinates(e),point=new core_point(coords.x,coords.y),category=this.categoryAxis.getCategory(point),value=this.valueAxis.getValue(point);null!==category&&null!==value&&chart.trigger(eventType,{element:eventElement(e),category:category,value:value})}createCrosshairs(){}}return deepExtend(RadarPlotArea.prototype,plotarea_events_mixin,{appendChart:categorical_plotarea.prototype.appendChart,aggregateSeries:categorical_plotarea.prototype.aggregateSeries,seriesSourcePoints:categorical_plotarea.prototype.seriesSourcePoints}),RadarPlotArea})();setDefaultOptions(radar_plotarea_RadarPlotArea,{categoryAxis:{categories:[]},valueAxis:{}});var radar_plotarea=radar_plotarea_RadarPlotArea;class funnel_segment_FunnelSegment extends chart_element{constructor(value,options,segmentOptions){super(options),this.value=value,this.options.index=segmentOptions.index}reflow(chartBox){const points=this.points,label=this.children[0];this.box=new core_box(points[0].x,points[0].y,points[1].x,points[2].y),label&&label.reflow(new core_box(chartBox.x1,points[0].y,chartBox.x2,points[2].y))}createVisual(){const options=this.options;let visual;super.createVisual(),visual=options.visual?options.visual({category:this.category,dataItem:this.dataItem,value:this.value,series:this.series,percentage:this.percentage,points:this.points,options:options,sender:this.getSender(),createVisual:()=>this.createPath()}):this.createPath(),visual&&this.visual.append(visual)}createPath(){const options=this.options,border=options.border;return main.a.Path.fromPoints(this.points,{fill:{color:options.color,opacity:options.opacity},stroke:{color:border.color,opacity:border.opacity,width:border.width}}).close()}createHighlight(style){return main.a.Path.fromPoints(this.points,style)}highlightVisual(){return this.visual.children[0]}highlightVisualArgs(){const path=main.a.Path.fromPoints(this.points).close();return{options:this.options,path:path}}tooltipAnchor(){const box=this.box;return{point:new core_point(box.center().x,box.y1),align:{horizontal:\"center\",vertical:\"top\"}}}formatValue(format){return this.owner.formatPointValue(this,format)}}setDefaultOptions(funnel_segment_FunnelSegment,{color:WHITE,border:{width:1}}),deepExtend(funnel_segment_FunnelSegment.prototype,point_events_mixin);var funnel_segment=funnel_segment_FunnelSegment;class funnel_chart_FunnelChart extends chart_element{constructor(plotArea,options){super(options),this.plotArea=plotArea,this.points=[],this.labels=[],this.legendItems=[],this.render()}formatPointValue(point,format){return this.chartService.format.auto(format,point.value)}render(){const{options:options,plotArea:{options:{seriesColors:seriesColors=[]}}}=this,series=options.series[0],data=series.data;if(!data)return;const{total:total,points:points}=bindSegments(series);for(let i=0;i<points.length;i++){const pointData=points[i];if(!pointData)continue;let fields=pointData.fields;isFunction(series.color)||(series.color=fields.color||seriesColors[i%seriesColors.length]),fields=deepExtend({index:i,owner:this,series:series,dataItem:data[i],percentage:pointData.value/total},fields,{visible:pointData.visible});const value=pointData.valueFields.value,segment=this.createSegment(value,fields),label=this.createLabel(value,fields);segment&&label&&segment.append(label)}}evalSegmentOptions(options,value,fields){const series=fields.series;evalOptions(options,{value:value,series:series,dataItem:fields.dataItem,index:fields.index},{defaults:series._defaults,excluded:[\"data\",\"content\",\"template\",\"toggle\",\"visual\"]})}createSegment(value,fields){const seriesOptions=deepExtend({},fields.series);if(this.evalSegmentOptions(seriesOptions,value,fields),this.createLegendItem(value,seriesOptions,fields),!1!==fields.visible){const segment=new funnel_segment(value,seriesOptions,fields);return Object.assign(segment,fields),this.append(segment),this.points.push(segment),segment}}createLabel(value,fields){const{series:series,dataItem:dataItem}=fields,labels=deepExtend({},this.options.labels,series.labels);let text=value;if(labels.visible){const labelTemplate=getTemplate(labels),data={dataItem:dataItem,value:value,percentage:fields.percentage,category:fields.category,series:series};if(labelTemplate?text=labelTemplate(data):labels.format&&(text=this.plotArea.chartService.format.auto(labels.format,text)),!labels.color){const brightnessValue=new color_color.a(series.color).percBrightness();labels.color=brightnessValue>180?BLACK:WHITE,labels.background||(labels.background=series.color)}this.evalSegmentOptions(labels,value,fields);const textBox=new text_box(text,deepExtend({vAlign:labels.position},labels),data);return this.labels.push(textBox),textBox}}labelPadding(){const labels=this.labels,padding={left:0,right:0};for(let i=0;i<labels.length;i++){const align=labels[i].options.align;if(align!==CENTER){const width=labels[i].box.width();align===LEFT?padding.left=Math.max(padding.left,width):padding.right=Math.max(padding.right,width)}}return padding}dynamicSlopeReflow(box,width,totalHeight){const{options:options,points:segments}=this,count=segments.length,firstSegment=segments[0];let maxSegment=firstSegment;for(let idx=0;idx<segments.length;idx++)segments[idx].percentage>maxSegment.percentage&&(maxSegment=segments[idx]);let lastUpperSide=firstSegment.percentage/maxSegment.percentage*width,previousOffset=(width-lastUpperSide)/2,previousHeight=0;for(let idx=0;idx<count;idx++){const percentage=segments[idx].percentage,nextSegment=segments[idx+1],nextPercentage=nextSegment?nextSegment.percentage:percentage,points=segments[idx].points=[],height=options.dynamicHeight?totalHeight*percentage:totalHeight/count;let offset;offset=percentage?(width-lastUpperSide*(nextPercentage/percentage))/2:nextPercentage?0:width/2,offset=limitValue(offset,0,width),points.push(new main.b.Point(box.x1+previousOffset,box.y1+previousHeight)),points.push(new main.b.Point(box.x1+width-previousOffset,box.y1+previousHeight)),points.push(new main.b.Point(box.x1+width-offset,box.y1+height+previousHeight)),points.push(new main.b.Point(box.x1+offset,box.y1+height+previousHeight)),previousOffset=offset,previousHeight+=height+options.segmentSpacing,lastUpperSide=limitValue(width-2*offset,0,width)}}constantSlopeReflow(box,width,totalHeight){const{options:options,points:segments}=this,count=segments.length,decreasingWidth=options.neckRatio<=1;let previousOffset=decreasingWidth?0:(width-width/options.neckRatio)/2;const finalNarrow=((decreasingWidth?width:width-2*previousOffset)-(decreasingWidth?options.neckRatio*width:width))/2;let previousHeight=0;for(let idx=0;idx<count;idx++){const points=segments[idx].points=[],percentage=segments[idx].percentage,offset=options.dynamicHeight?finalNarrow*percentage:finalNarrow/count,height=options.dynamicHeight?totalHeight*percentage:totalHeight/count;points.push(new main.b.Point(box.x1+previousOffset,box.y1+previousHeight)),points.push(new main.b.Point(box.x1+width-previousOffset,box.y1+previousHeight)),points.push(new main.b.Point(box.x1+width-previousOffset-offset,box.y1+height+previousHeight)),points.push(new main.b.Point(box.x1+previousOffset+offset,box.y1+height+previousHeight)),previousOffset+=offset,previousHeight+=height+options.segmentSpacing}}reflow(chartBox){const points=this.points,count=points.length;if(!count)return;const options=this.options,box=chartBox.clone().unpad(this.labelPadding()),totalHeight=box.height()-options.segmentSpacing*(count-1),width=box.width();options.dynamicSlope?this.dynamicSlopeReflow(box,width,totalHeight):this.constantSlopeReflow(box,width,totalHeight);for(let idx=0;idx<count;idx++)points[idx].reflow(chartBox)}}setDefaultOptions(funnel_chart_FunnelChart,{neckRatio:.3,width:300,dynamicSlope:!1,dynamicHeight:!0,segmentSpacing:0,labels:{visible:!1,align:CENTER,position:CENTER,zIndex:1}}),deepExtend(funnel_chart_FunnelChart.prototype,pie_chart_mixin);var funnel_chart=funnel_chart_FunnelChart;const COLOR=\"color\",FIRST=\"first\",MAX=\"max\";plotarea_factory.current.register(categorical_plotarea,[BAR,COLUMN,LINE,VERTICAL_LINE,\"area\",\"verticalArea\",\"candlestick\",\"ohlc\",\"bullet\",\"verticalBullet\",\"boxPlot\",\"verticalBoxPlot\",\"rangeColumn\",\"rangeBar\",\"waterfall\",\"horizontalWaterfall\",\"rangeArea\",\"verticalRangeArea\"]),plotarea_factory.current.register(xy_plotarea,[\"scatter\",\"scatterLine\",\"bubble\"]),plotarea_factory.current.register(pie_plotarea,[PIE]),plotarea_factory.current.register(class extends pie_plotarea{render(){this.createDonutChart(this.series)}createDonutChart(series){const firstSeries=series[0],donutChart=new donut_chart(this,{series:series,padding:firstSeries.padding,connectors:firstSeries.connectors,legend:this.options.legend});this.appendChart(donutChart)}},[\"donut\"]),plotarea_factory.current.register(class extends plotarea_base{render(){this.createFunnelChart(this.series)}createFunnelChart(series){const firstSeries=series[0],funnelChart=new funnel_chart(this,{series:series,legend:this.options.legend,neckRatio:firstSeries.neckRatio,dynamicHeight:firstSeries.dynamicHeight,dynamicSlope:firstSeries.dynamicSlope,segmentSpacing:firstSeries.segmentSpacing,highlight:firstSeries.highlight});this.appendChart(funnelChart)}appendChart(chart,pane){super.appendChart(chart,pane),append(this.options.legend.items,chart.legendItems)}},[\"funnel\"]),plotarea_factory.current.register(polar_plotarea,[\"polarArea\",\"polarLine\",\"polarScatter\"]),plotarea_factory.current.register(radar_plotarea,[\"radarArea\",\"radarColumn\",\"radarLine\"]),series_binder.current.register([BAR,COLUMN,LINE,VERTICAL_LINE,\"area\",\"verticalArea\"],[VALUE],[\"category\",COLOR,\"noteText\",\"errorLow\",\"errorHigh\"]),series_binder.current.register([\"rangeColumn\",\"rangeBar\",\"rangeArea\",\"verticalRangeArea\"],[\"from\",\"to\"],[\"category\",COLOR,\"noteText\"]),series_binder.current.register([\"waterfall\",\"horizontalWaterfall\"],[VALUE],[\"category\",COLOR,\"noteText\",\"summary\"]),series_binder.current.register([\"polarArea\",\"polarLine\",\"polarScatter\"],[X,Y],[COLOR]),series_binder.current.register([\"radarArea\",\"radarColumn\",\"radarLine\"],[VALUE],[COLOR]),series_binder.current.register([\"funnel\"],[VALUE],[\"category\",COLOR,\"visibleInLegend\",\"visible\"]),default_aggregates.current.register([BAR,COLUMN,LINE,VERTICAL_LINE,\"area\",\"verticalArea\",\"waterfall\",\"horizontalWaterfall\"],{value:MAX,color:FIRST,noteText:FIRST,errorLow:\"min\",errorHigh:MAX}),default_aggregates.current.register([\"rangeColumn\",\"rangeBar\",\"rangeArea\",\"verticalRangeArea\"],{from:\"min\",to:MAX,color:FIRST,noteText:FIRST}),default_aggregates.current.register([\"radarArea\",\"radarColumn\",\"radarLine\"],{value:MAX,color:FIRST}),series_binder.current.register([\"scatter\",\"scatterLine\",\"bubble\"],[X,Y],[COLOR,\"noteText\",\"xErrorLow\",\"xErrorHigh\",\"yErrorLow\",\"yErrorHigh\"]),series_binder.current.register([\"bubble\"],[X,Y,\"size\"],[COLOR,\"category\",\"noteText\"]),series_binder.current.register([\"candlestick\",\"ohlc\"],[\"open\",\"high\",\"low\",\"close\"],[\"category\",COLOR,\"downColor\",\"noteText\"]),default_aggregates.current.register([\"candlestick\",\"ohlc\"],{open:MAX,high:MAX,low:\"min\",close:MAX,color:FIRST,downColor:FIRST,noteText:FIRST}),series_binder.current.register([\"boxPlot\",\"verticalBoxPlot\"],[\"lower\",\"q1\",\"median\",\"q3\",\"upper\",\"mean\",\"outliers\"],[\"category\",COLOR,\"noteText\"]),default_aggregates.current.register([\"boxPlot\",\"verticalBoxPlot\"],{lower:MAX,q1:MAX,median:MAX,q3:MAX,upper:MAX,mean:MAX,outliers:FIRST,color:FIRST,noteText:FIRST}),series_binder.current.register([\"bullet\",\"verticalBullet\"],[\"current\",\"target\"],[\"category\",COLOR,\"visibleInLegend\",\"noteText\"]),default_aggregates.current.register([\"bullet\",\"verticalBullet\"],{current:MAX,target:MAX,color:FIRST,noteText:FIRST}),series_binder.current.register([PIE,\"donut\"],[VALUE],[\"category\",COLOR,\"explode\",\"visibleInLegend\",\"visible\"]);const AXIS_NAMES=[\"category\",VALUE,X,Y];class chart_Chart extends common_class.a{constructor(element,userOptions,themeOptions,context={}){super(),this.observers=[],this.addObserver(context.observer),this.chartService=new chart_service(this,context),this.chartService.theme=themeOptions,this._initElement(element);const options=deepExtend({},this.options,userOptions);this._originalOptions=deepExtend({},options),this._theme=themeOptions,this._initTheme(options,themeOptions),this._initHandlers(),this._initSurface(),this.bindCategories(),font_loader.preloadFonts(userOptions,()=>{this.fontLoaded=!0,this._destroyed||(this.trigger(\"init\"),this._redraw(),this._attachEvents())})}_initElement(element){for(this._setElementClass(element),element.style.position=\"relative\";element.firstChild;)element.removeChild(element.firstChild);this.element=element}_setElementClass(element){addClass(element,\"k-chart\")}_initTheme(options,themeOptions){const seriesCopies=[],series=options.series||[];for(let i=0;i<series.length;i++)seriesCopies.push(Object.assign({},series[i]));options.series=seriesCopies,function(options){const aliases=AXIS_NAMES;for(let idx=0;idx<aliases.length;idx++){const alias=aliases[idx]+\"Axes\";options[alias]&&(options[aliases[idx]+\"Axis\"]=options[alias],delete options[alias])}}(options),this.applyDefaults(options,themeOptions),null===options.seriesColors&&delete options.seriesColors,this.options=deepExtend({},themeOptions,options),this.applySeriesColors()}getSize(){const chartArea=this.options.chartArea||{};return{width:chartArea.width?parseInt(chartArea.width,10):Math.floor(this.element.offsetWidth),height:chartArea.height?parseInt(chartArea.height,10):Math.floor(this.element.offsetHeight)}}resize(force){const size=this.getSize(),currentSize=this._size,hasSize=size.width>0||size.height>0;force||hasSize&&(!currentSize||size.width!==currentSize.width||size.height!==currentSize.height)?(this._size=size,this._resize(size,force),this.trigger(\"resize\",size)):hasSize&&this._selections&&find(this._selections,s=>!s.visible)&&(this._destroySelections(),this._setupSelection())}_resize(){this._noTransitionsRedraw()}redraw(paneName){if(this.applyDefaults(this.options),this.applySeriesColors(),paneName){const plotArea=this._model._plotArea,pane=plotArea.findPane(paneName);plotArea.redraw(pane)}else this._redraw()}getAxis(name){return findAxisByName(name,this._plotArea.axes)}findAxisByName(name){return this.getAxis(name)}findPaneByName(name){const panes=this._plotArea.panes;for(let idx=0;idx<panes.length;idx++)if(panes[idx].options.name===name)return new chart_pane(panes[idx])}findPaneByIndex(idx){const panes=this._plotArea.panes;if(panes[idx])return new chart_pane(panes[idx])}plotArea(){return new chart_plotarea(this._plotArea)}toggleHighlight(show,filter){const plotArea=this._plotArea,firstSeries=(plotArea.srcSeries||plotArea.series||[])[0];let points;if(isFunction(filter))points=plotArea.filterPoints(filter);else{let seriesName,categoryName;isObject(filter)?(seriesName=filter.series,categoryName=filter.category):seriesName=categoryName=filter,points=\"donut\"===firstSeries.type?pointByCategoryName(plotArea.pointsBySeriesName(seriesName),categoryName):firstSeries.type===PIE||\"funnel\"===firstSeries.type?pointByCategoryName((plotArea.charts[0]||{}).points,categoryName):plotArea.pointsBySeriesName(seriesName)}points&&this.togglePointsHighlight(show,points)}togglePointsHighlight(show,points){const highlight=this._highlight;for(let idx=0;idx<points.length;idx++)highlight.togglePointHighlight(points[idx],show)}showTooltip(filter){const shared=this._sharedTooltip(),{_tooltip:tooltip,_plotArea:plotArea}=this;let point,categoryIndex;if(isFunction(filter)?(point=plotArea.findPoint(filter),point&&shared&&(categoryIndex=point.categoryIx)):shared&&defined(filter)&&(categoryIndex=plotArea.categoryAxis.categoryIndex(filter)),shared){if(categoryIndex>=0){const points=this._plotArea.pointsByCategoryIndex(categoryIndex);tooltip.showAt(points)}}else point&&tooltip.show(point)}hideTooltip(){this._tooltip.hide()}_initSurface(){const surface=this.surface,wrap=this._surfaceWrap(),chartArea=this.options.chartArea||{};chartArea.width&&drawing_utils_elementSize(wrap,{width:chartArea.width}),chartArea.height&&drawing_utils_elementSize(wrap,{height:chartArea.height}),surface&&surface.options.type===this.options.renderAs?(this.surface.clear(),this.surface.resize()):(this._destroySurface(),this.surface=main.a.Surface.create(wrap,{type:this.options.renderAs}),this.surface.bind(\"mouseenter\",this._surfaceMouseenterHandler),this.surface.bind(\"mouseleave\",this._surfaceMouseleaveHandler))}_surfaceWrap(){return this.element}_redraw(){const model=this._getModel();this._size={width:model.options.width,height:model.options.height},this._destroyView(),this._model=model,this._plotArea=model._plotArea,model.renderVisual(),!1!==this.options.transitions&&model.traverse(function(element){element.animation&&element.animation.setup()}),this._initSurface(),this.surface.draw(model.visual),!1!==this.options.transitions&&model.traverse(function(element){element.animation&&element.animation.play()}),this._tooltip=this._createTooltip(),this._highlight=new chart_highlight,this._setupSelection(),this._createPannable(),this._createZoomSelection(),this._createMousewheelZoom(),this.trigger(\"render\"),triggerPaneRender(this._plotArea.panes),this._navState||this._cancelDomEvents()}exportVisual(exportOptions){let visual;if(exportOptions&&(exportOptions.width||exportOptions.height||exportOptions.options)){const currentOptions=this.options,options=deepExtend({},exportOptions.options,{chartArea:{width:exportOptions.width,height:exportOptions.height}});clearMissingValues(this._originalOptions,options),this.options=deepExtend({},this._originalOptions,options),this._initTheme(this.options,this._theme),this.bindCategories();const model=this._getModel();model.renderVisual(),triggerPaneRender(model._plotArea.panes),visual=model.visual,this.options=currentOptions}else visual=this.surface.exportVisual();return visual}_sharedTooltip(){return this._plotArea instanceof categorical_plotarea&&this.options.tooltip&&this.options.tooltip.shared}_createPannable(){const options=this.options;!1!==options.pannable&&(this._pannable=new pan_and_zoom_pannable(this._plotArea,options.pannable))}_createZoomSelection(){const zoomable=this.options.zoomable,selection=(zoomable||{}).selection;!1!==zoomable&&!1!==selection&&(this._zoomSelection=new zoom_selection(this,selection))}_createMousewheelZoom(){const zoomable=this.options.zoomable,mousewheel=(zoomable||{}).mousewheel;!1!==zoomable&&!1!==mousewheel&&(this._mousewheelZoom=new mousewheel_zoom(this,mousewheel))}_toggleDragZoomEvents(){const zoomable=this.options.zoomable,mousewheel=(zoomable||{}).mousewheel,allowDrag=!(this.options.pannable||!1!==zoomable&&!1!==(zoomable||{}).selection||this.requiresHandlers([\"dragStart\",\"drag\",\"dragEnd\"])),allowZoom=(!1===zoomable||!1===mousewheel)&&!this.requiresHandlers([\"zoomStart\",\"zoom\",\"zoomEnd\"]),element=this.element;this._dragZoomEnabled&&allowDrag&&allowZoom?(element.style.touchAction=this._touchAction||\"\",this._dragZoomEnabled=!1):this._dragZoomEnabled||allowDrag&&allowZoom||(element.style.touchAction=\"none\",this._dragZoomEnabled=!0),this._toggleDomEvents(!allowDrag,!allowZoom)}_toggleDomEvents(drag,zoom){const domEvents=this.domEvents;domEvents&&(domEvents.toggleDrag&&domEvents.toggleDrag(drag),domEvents.toggleZoom&&domEvents.toggleZoom(zoom))}_createTooltip(){const{options:{tooltip:tooltipOptions}}=this;let tooltip;return tooltip=this._sharedTooltip()?this._createSharedTooltip(tooltipOptions):new tooltip_tooltip(this.chartService,tooltipOptions),tooltip}_createSharedTooltip(options){return new shared_tooltip(this._plotArea,options)}applyDefaults(options,themeOptions){!function(options,themeOptions){const themeAxisDefaults=(themeOptions||{}).axisDefaults||{};let axisName,axisDefaults,axes;function mapAxisOptions(axisOptions){const axisColor=(axisOptions||{}).color||axisDefaults.color,result=deepExtend({},themeAxisDefaults,themeAxisDefaults[axisName],axisDefaults,axisDefaults[axisName],{line:{color:axisColor},labels:{color:axisColor},title:{color:axisColor}},axisOptions);return delete result[axisName],result}for(let idx=0;idx<AXIS_NAMES.length;idx++)axisName=AXIS_NAMES[idx]+\"Axis\",axisDefaults=options.axisDefaults||{},axes=[].concat(options[axisName]),axes=axes.map(mapAxisOptions),options[axisName]=axes.length>1?axes:axes[0]}(options,themeOptions),function(options,themeOptions){const series=options.series,seriesLength=series.length,seriesDefaults=options.seriesDefaults,commonDefaults=deepExtend({},options.seriesDefaults),themeSeriesDefaults=themeOptions?deepExtend({},themeOptions.seriesDefaults):{},commonThemeDefaults=deepExtend({},themeSeriesDefaults);cleanupNestedSeriesDefaults(commonDefaults),cleanupNestedSeriesDefaults(commonThemeDefaults);for(let i=0;i<seriesLength;i++){const seriesType=series[i].type||options.seriesDefaults.type,baseOptions=deepExtend({data:[]},commonThemeDefaults,themeSeriesDefaults[seriesType],{tooltip:options.tooltip},commonDefaults,seriesDefaults[seriesType]);series[i]._defaults=baseOptions,series[i]=deepExtend({},baseOptions,series[i]),series[i].data=series[i].data||[]}}(options,themeOptions)}applySeriesColors(){const options=this.options,series=options.series,colors=options.seriesColors||[];for(let i=0;i<series.length;i++){const currentSeries=series[i],seriesColor=colors[i%colors.length],defaults=currentSeries._defaults;currentSeries.color=currentSeries.color||seriesColor,defaults&&(defaults.color=defaults.color||seriesColor)}}_getModel(){const options=this.options,plotArea=this._createPlotArea(),model=new root_element(this._modelOptions());return model.chart=this,model._plotArea=plotArea,core_title.buildTitle(options.title,model),options.legend&&options.legend.visible&&model.append(new legend_legend(plotArea.options.legend,this.chartService)),model.append(plotArea),model.reflow(),model}_modelOptions(){const options=this.options,size=this.getSize();return deepExtend({transitions:options.transitions,width:size.width||600,height:size.height||400},options.chartArea)}_createPlotArea(skipSeries){const options=this.options;return plotarea_factory.current.create(skipSeries?[]:options.series,options,this.chartService)}_setupSelection(){const{_plotArea:{axes:axes}}=this,selections=this._selections=[];for(let i=0;i<axes.length;i++){const axis=axes[i],options=axis.options;if(axis instanceof category_axis&&options.select&&!options.vertical){const range=axis.range(),selection=new chart_selection(this,axis,deepExtend({min:range.min,max:range.max},options.select));selections.push(selection)}}}_selectStart(e){return this.trigger(\"selectStart\",e)}_select(e){return this.trigger(\"select\",e)}_selectEnd(e){return this.trigger(\"selectEnd\",e)}_initHandlers(){this._clickHandler=this._click.bind(this),this._mousewheelHandler=this._mousewheel.bind(this),this._mouseleaveHandler=this._mouseleave.bind(this),this._surfaceMouseenterHandler=this._mouseover.bind(this),this._surfaceMouseleaveHandler=this._mouseout.bind(this),this._mousemove=Object(throttle.a)(this._mousemove.bind(this),20)}addObserver(observer){observer&&this.observers.push(observer)}removeObserver(observer){const index=this.observers.indexOf(observer);index>=0&&this.observers.splice(index,1)}requiresHandlers(eventNames){const observers=this.observers;for(let idx=0;idx<observers.length;idx++)if(observers[idx].requiresHandlers(eventNames))return!0}trigger(name,args={}){\"showTooltip\"===name&&(args.anchor.point=this._toDocumentCoordinates(args.anchor.point)),args.sender=this;const observers=this.observers;let isDefaultPrevented=!1;for(let idx=0;idx<observers.length;idx++)observers[idx].trigger(name,args)&&(isDefaultPrevented=!0);return isDefaultPrevented}_attachEvents(){const element=this.element;this._touchAction=element.style.touchAction,bindEvents(element,{contextmenu:this._clickHandler,[MOUSEWHEEL]:this._mousewheelHandler,mouseleave:this._mouseleaveHandler}),this._shouldAttachMouseMove()&&bindEvents(element,{mousemove:this._mousemove}),this.domEvents=dom_events_builder.create(this.element,{start:this._start.bind(this),move:this._move.bind(this),end:this._end.bind(this),tap:this._tap.bind(this),gesturestart:this._gesturestart.bind(this),gesturechange:this._gesturechange.bind(this),gestureend:this._gestureend.bind(this)}),this._toggleDragZoomEvents()}_mouseleave(e){this._hoveredPoint&&(this._hoveredPoint.out(this,e),this._hoveredPoint=null),this._plotArea.hovered&&(this.trigger(\"plotAreaLeave\"),this._plotArea.hovered=!1)}_cancelDomEvents(){this.domEvents&&this.domEvents.cancel&&this.domEvents.cancel()}_gesturestart(e){this._mousewheelZoom&&!this._stopChartHandlers(e)&&(this._gestureDistance=e.distance,this._unsetActivePoint(),this.surface.suspendTracking())}_gestureend(e){this._zooming&&!this._stopChartHandlers(e)&&(this.surface&&this.surface.resumeTracking(),this._zooming=!1,this.trigger(\"zoomEnd\",{}))}_gesturechange(e){const mousewheelZoom=this._mousewheelZoom;if(mousewheelZoom&&!this._stopChartHandlers(e)){e.preventDefault();let scaleDelta=-e.distance/this._gestureDistance+1;if(Math.abs(scaleDelta)>=.1){scaleDelta=Math.round(10*scaleDelta),this._gestureDistance=e.distance;const args={delta:scaleDelta,axisRanges:chart_axisRanges(this._plotArea.axes),originalEvent:e};!this._zooming&&this.trigger(\"zoomStart\",args)||(this._zooming||(this._zooming=!0),(args.axisRanges=mousewheelZoom.updateRanges(scaleDelta))&&!this.trigger(\"zoom\",args)&&mousewheelZoom.zoom())}}}_mouseout(e){if(e.element){const element=this._drawingChartElement(e.element,e);element&&element.leave&&element.leave(this,e.originalEvent)}}_start(e){const coords=this._eventCoordinates(e);!this._stopChartHandlers(e)&&this._plotArea.backgroundContainsPoint(coords)&&(this.requiresHandlers([\"dragStart\",\"drag\",\"dragEnd\"])&&this._startNavigation(e,coords,\"dragStart\"),this._pannable&&this._pannable.start(e)&&(this.surface.suspendTracking(),this._unsetActivePoint(),this._suppressHover=!0,this.chartService.panning=!0),this._zoomSelection&&this._zoomSelection.start(e)&&this.trigger(\"zoomStart\",{axisRanges:chart_axisRanges(this._plotArea.axes),originalEvent:e}))}_move(e){let{_navState:state,_pannable:pannable}=this;if(!this._stopChartHandlers(e)){if(pannable){const ranges=pannable.move(e);ranges&&!this.trigger(\"drag\",{axisRanges:ranges,originalEvent:e})&&pannable.pan()}else if(state){const ranges={},axes=state.axes;for(let i=0;i<axes.length;i++){const currentAxis=axes[i];if(currentAxis.options.name){const axis=currentAxis.options.vertical?e.y:e.x,delta=axis.startLocation-axis.location;0!==delta&&(ranges[currentAxis.options.name]=currentAxis.translateRange(delta))}}state.axisRanges=ranges,this.trigger(\"drag\",{axisRanges:ranges,originalEvent:e})}this._zoomSelection&&this._zoomSelection.move(e)}}_end(e){if(this._stopChartHandlers(e))return;const pannable=this._pannable;if(pannable&&pannable.end(e)?(this.surface.resumeTracking(),this.trigger(\"dragEnd\",{axisRanges:chart_axisRanges(this._plotArea.axes),originalEvent:e}),this._suppressHover=!1,this.chartService.panning=!1):this._endNavigation(e,\"dragEnd\"),this._zoomSelection){const ranges=this._zoomSelection.end(e);ranges&&!this.trigger(\"zoom\",{axisRanges:ranges,originalEvent:e})&&(this._zoomSelection.zoom(),this.trigger(\"zoomEnd\",{axisRanges:ranges,originalEvent:e}))}}_stopChartHandlers(e){const selections=this._selections||[];if(!selections.length)return!1;const coords=this._eventCoordinates(e),pane=this._plotArea.paneByPoint(coords);if(pane)for(let idx=0;idx<selections.length;idx++)if(selections[idx].onPane(pane))return!0}_mousewheel(e){const delta=mousewheelDelta(e),mousewheelZoom=this._mousewheelZoom,coords=this._eventCoordinates(e);if(!this._stopChartHandlers(e)&&this._plotArea.backgroundContainsPoint(coords))if(mousewheelZoom){const args={delta:delta,axisRanges:chart_axisRanges(this._plotArea.axes),originalEvent:e};!this._zooming&&this.trigger(\"zoomStart\",args)||(e.preventDefault(),this._zooming||(this._unsetActivePoint(),this.surface.suspendTracking(),this._zooming=!0),this._mwTimeout&&clearTimeout(this._mwTimeout),args.axisRanges=mousewheelZoom.updateRanges(delta),args.axisRanges&&!this.trigger(\"zoom\",args)&&mousewheelZoom.zoom(),this._mwTimeout=setTimeout(()=>{this.trigger(\"zoomEnd\",args),this._zooming=!1,this.surface&&this.surface.resumeTracking()},150))}else{let state=this._navState;if(state||this._startNavigation(e,coords,\"zoomStart\")||(state=this._navState),state){const totalDelta=state.totalDelta||delta;state.totalDelta=totalDelta+delta;const axes=this._navState.axes,ranges={};for(let i=0;i<axes.length;i++){const currentAxis=axes[i],axisName=currentAxis.options.name;axisName&&(ranges[axisName]=currentAxis.scaleRange(-totalDelta))}this.trigger(\"zoom\",{delta:delta,axisRanges:ranges,originalEvent:e}),this._mwTimeout&&clearTimeout(this._mwTimeout),this._mwTimeout=setTimeout(()=>{this._endNavigation(e,\"zoomEnd\")},150)}}}_startNavigation(e,coords,chartEvent){const plotArea=this._model._plotArea,pane=plotArea.findPointPane(coords),axes=plotArea.axes.slice(0);if(!pane)return;const ranges=chart_axisRanges(axes);this.trigger(chartEvent,{axisRanges:ranges,originalEvent:e})?this._cancelDomEvents():(this._suppressHover=!0,this._unsetActivePoint(),this._navState={axisRanges:ranges,pane:pane,axes:axes})}_endNavigation(e,chartEvent){this._navState&&(this.trigger(chartEvent,{axisRanges:this._navState.axisRanges,originalEvent:e}),this._suppressHover=!1,this._navState=null)}_getChartElement(e,match){const element=this.surface.eventTarget(e);if(element)return this._drawingChartElement(element,e,match)}_drawingChartElement(element,e,match){let chartElement,current=element;for(;current&&!chartElement;)chartElement=current.chartElement,current=current.parent;if(chartElement)return chartElement.aliasFor&&(chartElement=chartElement.aliasFor(e,this._eventCoordinates(e))),match&&(chartElement=chartElement.closest(match),chartElement&&chartElement.aliasFor&&(chartElement=chartElement.aliasFor())),chartElement}_eventCoordinates(e){const coordinates=eventCoordinates(e);return this._toModelCoordinates(coordinates.x,coordinates.y)}_elementPadding(){if(!this._padding){const{paddingLeft:paddingLeft,paddingTop:paddingTop}=element_styles_elementStyles(this.element,[\"paddingLeft\",\"paddingTop\"]);this._padding={top:paddingTop,left:paddingLeft}}return this._padding}_toDocumentCoordinates(point){const padding=this._elementPadding(),offset=drawing_utils_elementOffset(this.element);return{left:round(point.x+padding.left+offset.left),top:round(point.y+padding.top+offset.top)}}_toModelCoordinates(clientX,clientY){const element=this.element,offset=drawing_utils_elementOffset(element),padding=this._elementPadding(),inverseTransform=function(element){if(!element)return Matrix.unit();let matrix=transformMatrix(element),parent=element.parentElement;for(;parent;){const parentMatrix=transformMatrix(parent);matrix=matrix.multiplyCopy(parentMatrix),parent=parent.parentElement}return matrix.b=matrix.c=matrix.e=matrix.f=0,matrix}(element).invert(),point=new main.b.Point(clientX-offset.left-padding.left,clientY-offset.top-padding.top).transform(inverseTransform);return new core_point(point.x,point.y)}_tap(e){const drawingElement=this.surface.eventTarget(e),element=this._drawingChartElement(drawingElement,e),sharedTooltip=this._sharedTooltip();this._startHover(drawingElement,e)||sharedTooltip||this._unsetActivePoint(),sharedTooltip&&this._trackSharedTooltip(this._eventCoordinates(e),e,!0),this._propagateClick(element,e),this.handlingTap=!0,setTimeout(()=>{this.handlingTap=!1},0)}_click(e){const element=this._getChartElement(e);this._propagateClick(element,e)}_propagateClick(element,e){let current=element;for(;current;)current.click&&current.click(this,e),current=current.parent}_startHover(element,e){if(this._suppressHover)return!1;let point=this._drawingChartElement(element,e,function(element){return(element.hover||element.over)&&!(element instanceof plotarea_base)});const activePoint=this._activePoint,multipleSeries=this._plotArea.series.length>1,hasInactiveOpacity=this._hasInactiveOpacity();return this._updateHoveredPoint(point,e),point&&activePoint!==point&&point.hover?(this._activePoint=point,this._sharedTooltip()||point.hover(this,e)||(this._displayTooltip(point),hasInactiveOpacity?this._displayInactiveOpacity(point,multipleSeries):this._highlight.show(point))):!point&&hasInactiveOpacity&&(multipleSeries&&this._activeChartInstance&&(this._updateSeriesOpacity(point,!0),this._applySeriesOpacity(this._activeChartInstance.children,null,!0),this._activeChartInstance=null),this._highlight&&this._highlight.hide(),this._activePoint=null),point}_displayTooltip(point){deepExtend({},this.options.tooltip,point.options.tooltip).visible&&this._tooltip.show(point)}_displayInactiveOpacity(activePoint,multipleSeries,highlightPoints){const chartInstance=this._activeChartInstance=this._chartInstanceFromPoint(activePoint);if(multipleSeries)this._updateSeriesOpacity(activePoint),this._applySeriesOpacity(chartInstance.children,null,!0),this._applySeriesOpacity(chartInstance.children,activePoint.series),this._highlight.show(highlightPoints||activePoint);else{let inactivePoints;if(!chartInstance.supportsPointInactiveOpacity())return void this._highlight.show(activePoint);inactivePoints=this._getInactivePoints(activePoint,chartInstance),inactivePoints&&inactivePoints.length&&this._highlight.show(inactivePoints,1-this._getInactiveOpacityForSeries(activePoint.series))}}_getInactivePoints(activePoint,chartInstance){return this._getAllPointsOfType(chartInstance,activePoint.constructor).filter(point=>point!==activePoint)}_getAllPointsOfType(container,type){let points=[];for(let i=0;i<container.children.length;i++){const element=container.children[i];element.constructor===type?points.push(element):element.children&&element.children.length&&(points=points.concat(this._getAllPointsOfType(element,type)))}return points}_updateHoveredPoint(point,e){const hoveredPoint=this._hoveredPoint;hoveredPoint&&hoveredPoint!==point&&(hoveredPoint.out(this,e),this._hoveredPoint=null),point&&hoveredPoint!==point&&point.over&&(this._hoveredPoint=point,point.over(this,e))}_updateSeriesOpacity(point,resetOpacity){const plotArea=this._plotArea,length=plotArea.series.length;for(let i=0;i<length;i++){const currSeries=plotArea.series[i],defaultOpacity=this._getDefaultOpacityForSeries(currSeries),inactiveOpacity=this._getInactiveOpacityForSeries(currSeries);resetOpacity||currSeries===point.series?(currSeries.opacity=defaultOpacity,currSeries.line&&(currSeries.line.opacity=defaultOpacity)):(currSeries.defaultOpacity=defaultOpacity,currSeries.opacity=inactiveOpacity,currSeries.line&&(currSeries.line.opacity=inactiveOpacity))}}_applySeriesOpacity(elements,activeSeries,reset,series){for(let i=0;i<elements.length;i++){const element=elements[i],currSeries=element.series||series;if(currSeries&&element.visual){const opacity=series?series.opacity:element.series.opacity;(currSeries!==activeSeries||reset)&&element.visual.opacity(reset?1:opacity)}element.children&&element.children.length&&this._applySeriesOpacity(element.children,activeSeries,reset,element.series)}}_chartInstanceFromPoint(point){let chartInstance=point.parent;for(;chartInstance&&!chartInstance.plotArea;)chartInstance=chartInstance.parent;return chartInstance}_hasInactiveOpacity(){let hasDefaultInactiveOpacity=void 0!==this.options.seriesDefaults.highlight.inactiveOpacity,hasInactiveOpacity=this.options.series.filter(s=>void 0!==s.highlight.inactiveOpacity).length>0;return hasDefaultInactiveOpacity||hasInactiveOpacity}_getInactiveOpacityForSeries(series){return series.highlight.inactiveOpacity||this.options.seriesDefaults.highlight.inactiveOpacity||series.opacity||1}_getDefaultOpacityForSeries(series){return series.defaultOpacity||series.opacity||1}_mouseover(e){const point=this._startHover(e.element,e.originalEvent);point&&point.tooltipTracking&&!this._mouseMoveTrackHandler&&!this._sharedTooltip()&&(this._mouseMoveTrackHandler=this._mouseMoveTracking.bind(this),bindEvents(document,{mousemove:this._mouseMoveTrackHandler}))}_mouseMoveTracking(e){const{options:options,_tooltip:tooltip,_highlight:highlight,_activePoint:point}=this,coords=this._eventCoordinates(e);if(this._plotArea.box.containsPoint(coords)){if(point&&point.tooltipTracking&&point.series&&point.parent.getNearestPoint){const seriesPoint=point.parent.getNearestPoint(coords.x,coords.y,point.seriesIx);seriesPoint&&seriesPoint!==point&&(this._activePoint=seriesPoint,!seriesPoint.hover(this,e))&&(deepExtend({},options.tooltip,seriesPoint.options.tooltip).visible&&tooltip.show(seriesPoint),highlight.show(seriesPoint))}}else unbindEvents(document,{mousemove:this._mouseMoveTrackHandler}),this._unsetActivePoint(),this._mouseMoveTrackHandler=null}_mousemove(e){const coords=this._eventCoordinates(e),plotArea=this._plotArea;if(this._trackCrosshairs(coords),plotArea.hover){const overPlotArea=plotArea.backgroundContainsPoint(coords);overPlotArea?(plotArea.hovered=!0,this._plotArea.hover(this,e)):plotArea.hovered&&!overPlotArea&&(this.trigger(\"plotAreaLeave\"),plotArea.hovered=!1)}this._sharedTooltip()&&this._trackSharedTooltip(coords,e)}_trackCrosshairs(coords){const crosshairs=this._plotArea.crosshairs;for(let i=0;i<crosshairs.length;i++){const current=crosshairs[i];current.box.containsPoint(coords)?current.showAt(coords):current.hide()}}_trackSharedTooltip(coords,e,toggle){if(this._suppressHover)return;const{options:{tooltip:tooltipOptions},_plotArea:plotArea,_plotArea:{categoryAxis:categoryAxis},_tooltip:tooltip,_highlight:highlight}=this;if(plotArea.backgroundContainsPoint(coords)){const index=categoryAxis.pointCategoryIndex(coords);if(index!==this._tooltipCategoryIx||!this._sharedHighlight&&toggle){const points=plotArea.pointsByCategoryIndex(index),pointArgs=points.map(function(point){return point.eventArgs(e)}),hoverArgs=pointArgs[0]||{};hoverArgs.categoryPoints=pointArgs,points.length>0&&!this.trigger(\"seriesHover\",hoverArgs)?(tooltipOptions.visible&&tooltip.showAt(points,coords),highlight.show(points),this._sharedHighlight=!0):tooltip.hide(),this._tooltipCategoryIx=index}else toggle&&this._sharedHighlight&&(highlight.hide(),tooltip.hide(),this._sharedHighlight=!1)}else this._sharedHighlight&&(highlight.hide(),tooltip.hide(),this._tooltipCategoryIx=null,this._sharedHighlight=!1)}hideElements(options){const plotArea=this._plotArea;this._mousemove.cancel(),plotArea.hideCrosshairs(),this._unsetActivePoint(options)}_unsetActivePoint(options){const{_tooltip:tooltip,_highlight:highlight}=this;this._activePoint=null,this._hoveredPoint=null,!tooltip||options&&options.keepTooltipOpen||tooltip.hide(),this._tooltipCategoryIx=null,this._sharedHighlight=!1,highlight&&highlight.hide()}_deferRedraw(){this._redraw()}_clearRedrawTimeout(){this._redrawTimeout&&(clearInterval(this._redrawTimeout),this._redrawTimeout=null)}bindCategories(){const definitions=[].concat(this.options.categoryAxis);for(let axisIx=0;axisIx<definitions.length;axisIx++){const axis=definitions[axisIx];!1!==axis.autoBind&&this.bindCategoryAxisFromSeries(axis,axisIx)}}bindCategoryAxisFromSeries(axis,axisIx){const series=this.options.series,seriesLength=series.length,uniqueCategories=new HashMap;let dateAxis,items=[],bindable=!1;for(let seriesIx=0;seriesIx<seriesLength;seriesIx++){const s=series[seriesIx],onAxis=s.categoryAxis===axis.name||!s.categoryAxis&&0===axisIx,data=s.data,dataLength=data.length,bind=s.categoryField&&onAxis;if(bindable=bind||bindable,bind&&dataLength>0){dateAxis=isDateAxis(axis,getField(s.categoryField,data[0]));const getFn=dateAxis?getDateField:getField;for(let dataIx=0;dataIx<dataLength;dataIx++){const dataRow=data[dataIx],category=getFn(s.categoryField,dataRow,this.chartService.intl);!dateAxis&&uniqueCategories.get(category)||(items.push([category,dataRow]),dateAxis||uniqueCategories.set(category,!0))}}}if(items.length>0){dateAxis&&(items=function(srcDates,comparer=dateComparer){const dates=function(dates,comparer=dateComparer){for(let i=1,length=dates.length;i<length;i++)if(comparer(dates[i],dates[i-1])<0){dates.sort(comparer);break}return dates}(srcDates,comparer),length=dates.length,result=length>0?[dates[0]]:[];for(let i=1;i<length;i++)0!==comparer(dates[i],last(result))&&result.push(dates[i]);return result}(items,function(a,b){return dateComparer(a[0],b[0])}));const result=function(rows){const rowCount=rows.length,result=[];for(let rowIx=0;rowIx<rowCount;rowIx++){const row=rows[rowIx],colCount=row.length;for(let colIx=0;colIx<colCount;colIx++)result[colIx]=result[colIx]||[],result[colIx].push(row[colIx])}return result}(items);axis.categories=result[0]}else bindable&&(axis.categories=[])}_isBindable(series){const valueFields=series_binder.current.valueFields(series);let result=!0;for(let i=0;i<valueFields.length;i++){let field=valueFields[i];if(field===VALUE?field=\"field\":field+=\"Field\",!defined(series[field])){result=!1;break}}return result}_noTransitionsRedraw(){const options=this.options;let transitionsState;!1!==options.transitions&&(options.transitions=!1,transitionsState=!0),this._redraw(),transitionsState&&(options.transitions=!0)}_legendItemHover(seriesIndex,pointIndex){const{_plotArea:plotArea,_highlight:highlight}=this,currentSeries=(plotArea.srcSeries||plotArea.series)[seriesIndex];let items;items=inArray(currentSeries.type,[PIE,\"donut\",\"funnel\"])?plotArea.findPoint(function(point){return point.series.index===seriesIndex&&point.index===pointIndex}):plotArea.pointsBySeriesIndex(seriesIndex),this._hasInactiveOpacity()&&currentSeries.visible&&items?this._displayInactiveOpacity(items.length?items[0]:items,plotArea.series.length>1,items):highlight.show(items)}_shouldAttachMouseMove(){return this._plotArea.crosshairs.length||this._tooltip&&this._sharedTooltip()||this.requiresHandlers([\"plotAreaHover\",\"plotAreaLeave\"])}updateMouseMoveHandler(){unbindEvents(this.element,{mousemove:this._mousemove}),this._shouldAttachMouseMove()&&bindEvents(this.element,{mousemove:this._mousemove})}applyOptions(options,theme){clearMissingValues(this._originalOptions,options),this._originalOptions=deepExtend(this._originalOptions,options),this.options=deepExtend({},this._originalOptions),theme&&(this._theme=theme,this.chartService.theme=theme),this._initTheme(this.options,this._theme),this._toggleDragZoomEvents()}setOptions(options,theme){this.applyOptions(options,theme),this.bindCategories(),this.redraw(),this.updateMouseMoveHandler()}setDirection(rtl){this.chartService.rtl=Boolean(rtl),this.surface&&\"svg\"===this.surface.type&&this._destroySurface()}setIntlService(intl){this.chartService.intl=intl}noTransitionsRedraw(){this._noTransitionsRedraw()}destroy(){this._destroyed=!0,unbindEvents(this.element,{contextmenu:this._clickHandler,[MOUSEWHEEL]:this._mousewheelHandler,mousemove:this._mousemove,mouseleave:this._mouseleaveHandler}),this.domEvents&&(this.domEvents.destroy(),delete this.domEvents),this._mouseMoveTrackHandler&&unbindEvents(document,{mousemove:this._mouseMoveTrackHandler}),this._destroyView(),this._destroySurface(),this._clearRedrawTimeout()}_destroySurface(){const surface=this.surface;surface&&(surface.unbind(\"mouseenter\",this._surfaceMouseenterHandler),surface.unbind(\"mouseleave\",this._surfaceMouseleaveHandler),surface.destroy(),this.surface=null)}_destroySelections(){const selections=this._selections;if(selections)for(;selections.length>0;)selections.shift().destroy()}_destroyView(){const model=this._model;model&&(model.destroy(),this._model=null),this._unsetActivePoint(),this._destroySelections(),this._tooltip&&this._tooltip.destroy(),this._highlight&&this._highlight.destroy(),this._zoomSelection&&(this._zoomSelection.destroy(),delete this._zoomSelection),this._pannable&&(this._pannable.destroy(),delete this._pannable),this._mousewheelZoom&&(this._mousewheelZoom.destroy(),delete this._mousewheelZoom)}}function pointByCategoryName(points,name){if(points)for(let idx=0;idx<points.length;idx++)if(points[idx].category===name)return[points[idx]]}function cleanupNestedSeriesDefaults(seriesDefaults){delete seriesDefaults.bar,delete seriesDefaults.column,delete seriesDefaults.rangeColumn,delete seriesDefaults.line,delete seriesDefaults.verticalLine,delete seriesDefaults.pie,delete seriesDefaults.donut,delete seriesDefaults.area,delete seriesDefaults.verticalArea,delete seriesDefaults.scatter,delete seriesDefaults.scatterLine,delete seriesDefaults.bubble,delete seriesDefaults.candlestick,delete seriesDefaults.ohlc,delete seriesDefaults.boxPlot,delete seriesDefaults.bullet,delete seriesDefaults.verticalBullet,delete seriesDefaults.polarArea,delete seriesDefaults.polarLine,delete seriesDefaults.radarArea,delete seriesDefaults.radarLine,delete seriesDefaults.waterfall}function chart_axisRanges(axes){const ranges={};for(let i=0;i<axes.length;i++){const axis=axes[i],axisName=axis.options.name;axisName&&(ranges[axisName]=axis.range())}return ranges}const DATA_FIELDS=[\"data\",\"categories\"];function clearMissingValues(originalOptions,options){for(let field in options)if(!inArray(field,DATA_FIELDS)&&options.hasOwnProperty(field)){const fieldValue=options[field],originalValue=originalOptions[field];if(defined(originalValue)){const nullValue=null===fieldValue;nullValue||!defined(fieldValue)?(delete originalOptions[field],nullValue&&delete options[field]):originalValue&&isObject(fieldValue)&&isObject(originalValue)&&clearMissingValues(originalValue,fieldValue)}}}function triggerPaneRender(panes){for(let idx=0;idx<panes.length;idx++)panes[idx].notifyRender()}setDefaultOptions(chart_Chart,{renderAs:\"\",chartArea:{},legend:{visible:!0,labels:{}},categoryAxis:{},seriesDefaults:{type:COLUMN,data:[],highlight:{visible:!0},labels:{},negativeValues:{visible:!1}},series:[],seriesColors:null,tooltip:{visible:!1},transitions:!0,valueAxis:{},plotArea:{},title:{},xAxis:{},yAxis:{},panes:[{}],pannable:!1,zoomable:!1});var chart_chart=chart_Chart,sparkline_shared_tooltip=class extends shared_tooltip{_slotAnchor(coords,slot){const vertical=this.plotArea.categoryAxis.options.vertical,align=vertical?{horizontal:\"left\",vertical:\"center\"}:{horizontal:\"center\",vertical:\"bottom\"};let point;return point=vertical?new core_point(this.plotArea.box.x2,slot.center().y):new core_point(slot.center().x,-2),{point:point,align:align}}_defaultAnchor(point,slot){return this._slotAnchor({},slot)}};const NO_CROSSHAIR=[BAR,\"bullet\"];function hide(children){const state=[];for(let idx=0;idx<children.length;idx++){const child=children[idx];state[idx]=child.style.display,child.style.display=\"none\"}return state}function sparkline_show(children,state){for(let idx=0;idx<children.length;idx++)children[idx].style.display=state[idx]}function wrapNumber(value){return isNumber(value)?[value]:value}setDefaultOptions(class extends chart_chart{_setElementClass(element){addClass(element,\"k-sparkline\")}_initElement(element){super._initElement(element),this._initialWidth=Math.floor(drawing_utils_elementSize(element).width)}_resize(){const element=this.element,state=hide(element.childNodes);this._initialWidth=Math.floor(drawing_utils_elementSize(element).width),sparkline_show(element.childNodes,state),super._resize()}_modelOptions(){const chartOptions=this.options,stage=this._surfaceWrap(),displayState=hide(stage.childNodes),space=document.createElement(\"span\");space.innerHTML=\"&nbsp;\",stage.appendChild(space);const options=deepExtend({width:this._autoWidth,height:drawing_utils_elementSize(stage).height,transitions:chartOptions.transitions},chartOptions.chartArea,{inline:!0,align:!1});return drawing_utils_elementSize(stage,{width:options.width,height:options.height}),stage.removeChild(space),sparkline_show(stage.childNodes,displayState),this.surface&&this.surface.resize(),options}_surfaceWrap(){if(!this.stage){const stage=this.stage=document.createElement(\"span\");this.element.appendChild(stage)}return this.stage}_createPlotArea(skipSeries){const plotArea=super._createPlotArea(skipSeries);return this._autoWidth=this._initialWidth||this._calculateWidth(plotArea),plotArea}_calculateWidth(plotArea){const options=this.options,margin=getSpacing(options.chartArea.margin),charts=plotArea.charts,stage=this._surfaceWrap();let total=0;for(let i=0;i<charts.length;i++){const currentChart=charts[i],firstSeries=(currentChart.options.series||[])[0];if(!firstSeries)continue;if(firstSeries.type===BAR)return 150;if(\"bullet\"===firstSeries.type)return 150;if(firstSeries.type===PIE)return drawing_utils_elementSize(stage).height;const categoryAxis=currentChart.categoryAxis;if(categoryAxis){const pointsCount=categoryAxis.categoriesCount()*(!currentChart.options.isStacked&&inArray(firstSeries.type,[COLUMN,\"verticalBullet\"])?currentChart.seriesOptions.length:1);total=Math.max(total,pointsCount)}}let size=total*options.pointWidth;return size>0&&(size+=margin.left+margin.right),size}_createSharedTooltip(options){return new sparkline_shared_tooltip(this._plotArea,options)}static normalizeOptions(userOptions){let options=wrapNumber(userOptions);return options=isArray(options)?{seriesDefaults:{data:options}}:deepExtend({},options),options.series||(options.series=[{data:wrapNumber(options.data)}]),deepExtend(options,{seriesDefaults:{type:options.type}}),(inArray(options.series[0].type,NO_CROSSHAIR)||inArray(options.seriesDefaults.type,NO_CROSSHAIR))&&(options=deepExtend({},{categoryAxis:{crosshair:{visible:!1}}},options)),options}},{chartArea:{margin:2},axisDefaults:{visible:!1,majorGridLines:{visible:!1},valueAxis:{narrowRange:!0}},seriesDefaults:{type:\"line\",area:{line:{width:.5}},bar:{stack:!0},padding:2,width:.5,overlay:{gradient:null},highlight:{visible:!1},border:{width:0},markers:{size:2,visible:!1}},tooltip:{visible:!0,shared:!0},categoryAxis:{crosshair:{visible:!0,tooltip:{visible:!1}}},legend:{visible:!1},transitions:!1,pointWidth:5,panes:[{clip:!1}]});var fade_out_animation=class extends main.a.Animation{setup(){this._initialOpacity=parseFloat(element_styles_elementStyles(this.element,\"opacity\").opacity)}step(pos){element_styles_elementStyles(this.element,{opacity:String(interpolateValue(this._initialOpacity,0,pos))})}abort(){super.abort(),element_styles_elementStyles(this.element,{display:\"none\",opacity:String(this._initialOpacity)})}cancel(){super.abort(),element_styles_elementStyles(this.element,{opacity:String(this._initialOpacity)})}};function navigator_hint_createDiv(className,style){const div=document.createElement(\"div\");return div.className=className,style&&(div.style.cssText=style),div}class navigator_hint_NavigatorHint extends common_class.a{constructor(container,chartService,options){super(),this.options=deepExtend({},this.options,options),this.container=container,this.chartService=chartService;const padding=element_styles_elementStyles(container,[\"paddingLeft\",\"paddingTop\"]);this.chartPadding={top:padding.paddingTop,left:padding.paddingLeft},this.createElements(),container.appendChild(this.element)}createElements(){const element=this.element=navigator_hint_createDiv(\"k-navigator-hint\",\"display: none; position: absolute; top: 1px; left: 1px;\"),tooltip=this.tooltip=navigator_hint_createDiv(\"k-tooltip k-chart-tooltip\"),scroll=this.scroll=navigator_hint_createDiv(\"k-scroll\");tooltip.innerHTML=\"&nbsp;\",element.appendChild(tooltip),element.appendChild(scroll)}show(from,to,bbox){const{element:element,options:options,scroll:scroll,tooltip:tooltip}=this,middle=toDate(toTime(from)+toTime(to-from)/2),scrollWidth=.4*bbox.width(),minPos=bbox.center().x-scrollWidth,scale=(bbox.center().x-minPos)/(options.max-options.min),offset=middle-options.min;let text=this.chartService.intl.format(options.format,from,to);const template=getTemplate(options);this.clearHideTimeout(),this._visible||(element_styles_elementStyles(element,{visibility:\"hidden\",display:\"block\"}),this._visible=!0),template&&(text=template({from:from,to:to})),tooltip.innerHTML=text,element_styles_elementStyles(tooltip,{left:bbox.center().x-tooltip.offsetWidth/2,top:bbox.y1});const tooltipStyle=element_styles_elementStyles(tooltip,[\"marginTop\",\"borderTopWidth\",\"height\"]);element_styles_elementStyles(scroll,{width:scrollWidth,left:minPos+offset*scale,top:bbox.y1+tooltipStyle.marginTop+tooltipStyle.borderTopWidth+tooltipStyle.height/2}),element_styles_elementStyles(element,{visibility:\"visible\"})}clearHideTimeout(){this._hideTimeout&&clearTimeout(this._hideTimeout),this._hideAnimation&&this._hideAnimation.cancel()}hide(){this.clearHideTimeout(),this._hideTimeout=setTimeout(()=>{this._visible=!1,this._hideAnimation=new fade_out_animation(this.element),this._hideAnimation.setup(),this._hideAnimation.play()},this.options.hideDelay)}destroy(){this.clearHideTimeout(),this.container&&this.container.removeChild(this.element),delete this.container,delete this.chartService,delete this.element,delete this.tooltip,delete this.scroll}}setDefaultOptions(navigator_hint_NavigatorHint,{format:\"{0:d} - {1:d}\",hideDelay:500});var navigator_hint=navigator_hint_NavigatorHint;class navigator_Navigator extends common_class.a{constructor(chart){super(),this.chart=chart;const options=this.options=deepExtend({},this.options,chart.options.navigator),select=options.select;select&&(select.from=this.parseDate(select.from),select.to=this.parseDate(select.to)),defined(options.hint.visible)||(options.hint.visible=options.visible),this.chartObserver=new instance_observer(this,{drag:\"_drag\",dragEnd:\"_dragEnd\",zoom:\"_zoom\",zoomEnd:\"_zoomEnd\"}),chart.addObserver(this.chartObserver)}parseDate(value){return parse_date_parseDate(this.chart.chartService.intl,value)}clean(){this.selection&&(this.selection.destroy(),this.selection=null),this.hint&&(this.hint.destroy(),this.hint=null)}destroy(){this.chart&&(this.chart.removeObserver(this.chartObserver),delete this.chart),this.clean()}redraw(){this._redrawSelf(),this.initSelection()}initSelection(){const{chart:chart,options:options}=this,axis=this.mainAxis(),{min:min,max:max}=axis.roundedRange(),{from:from,to:to,mousewheel:mousewheel}=options.select,axisClone=(ClonedObject.prototype=axis,new ClonedObject);0!==axis.categoriesCount()&&(this.clean(),axisClone.box=axis.box,this.selection=new chart_selection(chart,axisClone,{min:min,max:max,from:from||min,to:to||max,mousewheel:valueOrDefault(mousewheel,{zoom:\"left\"}),visible:options.visible},new instance_observer(this,{selectStart:\"_selectStart\",select:\"_select\",selectEnd:\"_selectEnd\"})),options.hint.visible&&(this.hint=new navigator_hint(chart.element,chart.chartService,{min:min,max:max,template:getTemplate(options.hint),format:options.hint.format})))}setRange(){const axis=this.chart._createPlotArea(!0).namedCategoryAxes._navigator,{min:min,max:max}=axis.roundedRange(),select=this.options.select||{};let from=select.from||min;from<min&&(from=min);let to=select.to||max;to>max&&(to=max),this.options.select=deepExtend({},select,{from:from,to:to}),this.filterAxes()}_redrawSelf(silent){const plotArea=this.chart._plotArea;plotArea&&plotArea.redraw(last(plotArea.panes),silent)}redrawSlaves(){const chart=this.chart,plotArea=chart._plotArea,slavePanes=plotArea.panes.slice(0,-1);plotArea.srcSeries=chart.options.series,plotArea.options.categoryAxis=chart.options.categoryAxis,plotArea.clearSeriesPointsCache(),plotArea.redraw(slavePanes)}_drag(e){const{chart:chart,selection:selection}=this,coords=chart._eventCoordinates(e.originalEvent),navigatorAxis=this.mainAxis(),naviRange=navigatorAxis.roundedRange(),inNavigator=navigatorAxis.pane.box.containsPoint(coords),range=e.axisRanges[chart._plotArea.categoryAxis.options.name],select=this.options.select;let duration;if(!range||inNavigator||!selection)return;duration=select.from&&select.to?toTime(select.to)-toTime(select.from):toTime(selection.options.to)-toTime(selection.options.from);const from=toDate(limitValue(toTime(range.min),naviRange.min,toTime(naviRange.max)-duration)),to=toDate(limitValue(toTime(from)+duration,toTime(naviRange.min)+duration,naviRange.max));this.options.select={from:from,to:to},this.options.liveDrag&&(this.filterAxes(),this.redrawSlaves()),selection.set(from,to),this.showHint(from,to)}_dragEnd(){this.filterAxes(),this.filter(),this.redrawSlaves(),this.hint&&this.hint.hide()}readSelection(){const{selection:{options:{from:from,to:to}},options:{select:select}}=this;select.from=from,select.to=to}filterAxes(){const{options:{select:select={}},chart:chart}=this,allAxes=chart.options.categoryAxis,{from:from,to:to}=select;for(let idx=0;idx<allAxes.length;idx++){const axis=allAxes[idx];\"_navigator\"!==axis.pane&&(axis.min=from,axis.max=to)}}filter(){const{chart:chart,options:{select:select}}=this;if(!chart.requiresHandlers([\"navigatorFilter\"]))return;const mainAxis=this.mainAxis(),args={from:select.from,to:select.to};if(\"category\"!==mainAxis.options.type){const axisOptions=new date_category_axis(deepExtend({baseUnit:\"fit\"},chart.options.categoryAxis[0],{categories:[select.from,select.to]}),chart.chartService).options;args.from=addDuration(axisOptions.min,-axisOptions.baseUnitStep,axisOptions.baseUnit),args.to=addDuration(axisOptions.max,axisOptions.baseUnitStep,axisOptions.baseUnit)}this.chart.trigger(\"navigatorFilter\",args)}_zoom(e){const{chart:{_plotArea:{categoryAxis:axis}},selection:selection,options:{select:select,liveDrag:liveDrag}}=this,mainAxis=this.mainAxis();let delta=e.delta;if(!selection)return;const fromIx=mainAxis.categoryIndex(selection.options.from),toIx=mainAxis.categoryIndex(selection.options.to);e.originalEvent.preventDefault(),Math.abs(delta)>1&&(delta*=3),toIx-fromIx>1?(selection.expand(delta),this.readSelection()):(axis.options.min=select.from,select.from=axis.scaleRange(-e.delta).min),liveDrag&&(this.filterAxes(),this.redrawSlaves()),selection.set(select.from,select.to),this.showHint(this.options.select.from,this.options.select.to)}_zoomEnd(e){this._dragEnd(e)}showHint(from,to){this.hint&&this.hint.show(from,to,this.chart._plotArea.backgroundBox())}_selectStart(e){return this.chart._selectStart(e)}_select(e){return this.showHint(e.from,e.to),this.chart._select(e)}_selectEnd(e){return this.hint&&this.hint.hide(),this.readSelection(),this.filterAxes(),this.filter(),this.redrawSlaves(),this.chart._selectEnd(e)}mainAxis(){const plotArea=this.chart._plotArea;if(plotArea)return plotArea.namedCategoryAxes._navigator}select(from,to){const select=this.options.select;return from&&to&&(select.from=this.parseDate(from),select.to=this.parseDate(to),this.filterAxes(),this.filter(),this.redrawSlaves(),this.selection.set(from,to)),{from:select.from,to:select.to}}static setup(options={},themeOptions={}){if(options.__navi)return;options.__navi=!0;const naviOptions=deepExtend({},themeOptions.navigator,options.navigator),panes=options.panes=[].concat(options.panes),paneOptions=deepExtend({},naviOptions.pane,{name:\"_navigator\"});naviOptions.visible||(paneOptions.visible=!1,paneOptions.height=.1),panes.push(paneOptions),navigator_Navigator.attachAxes(options,naviOptions),navigator_Navigator.attachSeries(options,naviOptions,themeOptions)}static attachAxes(options,naviOptions){const series=naviOptions.series||[],categoryAxes=options.categoryAxis=[].concat(options.categoryAxis),valueAxes=options.valueAxis=[].concat(options.valueAxis),justifyAxis=0===filterSeriesByType(series,EQUALLY_SPACED_SERIES).length,base=deepExtend({type:\"date\",pane:\"_navigator\",roundToBaseUnit:!justifyAxis,justified:justifyAxis,_collapse:!1,majorTicks:{visible:!0},tooltip:{visible:!1},labels:{step:1},autoBind:naviOptions.autoBindElements,autoBaseUnitSteps:{minutes:[1],hours:[1,2],days:[1,2],weeks:[],months:[1],years:[1]}}),user=naviOptions.categoryAxis;categoryAxes.push(deepExtend({},base,{maxDateGroups:200},user,{name:\"_navigator\",title:null,baseUnit:\"fit\",baseUnitStep:\"auto\",labels:{visible:!1},majorTicks:{visible:!1}}),deepExtend({},base,user,{name:\"_navigator_labels\",maxDateGroups:20,baseUnitStep:\"auto\",labels:{position:\"\"},plotBands:[],autoBaseUnitSteps:{minutes:[]},_overlap:!0}),deepExtend({},base,user,{name:\"_navigator_ticks\",maxDateGroups:200,majorTicks:{width:.5},plotBands:[],title:null,labels:{visible:!1,mirror:!0},_overlap:!0})),valueAxes.push(deepExtend({name:\"_navigator\",pane:\"_navigator\",majorGridLines:{visible:!1},visible:!1},naviOptions.valueAxis))}static attachSeries(options,naviOptions,themeOptions){const series=options.series=options.series||[],navigatorSeries=[].concat(naviOptions.series||[]),seriesColors=themeOptions.seriesColors,defaults=naviOptions.seriesDefaults;for(let idx=0;idx<navigatorSeries.length;idx++)series.push(deepExtend({color:seriesColors[idx%seriesColors.length],categoryField:naviOptions.dateField,visibleInLegend:!1,tooltip:{visible:!1}},defaults,navigatorSeries[idx],{axis:\"_navigator\",categoryAxis:\"_navigator\",autoBind:naviOptions.autoBindElements}))}}function ClonedObject(){}var stock_navigator=navigator_Navigator;setDefaultOptions(class extends chart_chart{applyDefaults(options,themeOptions){const width=drawing_utils_elementSize(this.element).width||600;let theme=themeOptions;const stockDefaults={seriesDefaults:{categoryField:options.dateField},axisDefaults:{categoryAxis:{name:\"default\",majorGridLines:{visible:!1},labels:{step:2},majorTicks:{visible:!1},maxDateGroups:Math.floor(width/28)}}};theme&&(theme=deepExtend({},theme,stockDefaults)),stock_navigator.setup(options,theme),super.applyDefaults(options,theme)}_setElementClass(element){addClass(element,\"k-chart k-stockchart\")}setOptions(options){this.destroyNavigator(),super.setOptions(options)}noTransitionsRedraw(){const transitions=this.options.transitions;this.options.transitions=!1,this._fullRedraw(),this.options.transitions=transitions}_resize(){this.noTransitionsRedraw()}_redraw(){const navigator=this.navigator;!this._dirty()&&navigator&&navigator.options.partialRedraw?navigator.redrawSlaves():this._fullRedraw()}_dirty(){const options=this.options,seriesCount=grep([].concat(options.series,options.navigator.series),function(s){return s&&s.visible}).length,dirty=this._seriesCount!==seriesCount;return this._seriesCount=seriesCount,dirty}_fullRedraw(){let navigator=this.navigator;navigator||(navigator=this.navigator=new stock_navigator(this),this.trigger(\"navigatorCreated\",{navigator:navigator})),navigator.clean(),navigator.setRange(),super._redraw(),navigator.initSelection()}_trackSharedTooltip(coords){const pane=this._plotArea.paneByPoint(coords);pane&&\"_navigator\"===pane.options.name?this._unsetActivePoint():super._trackSharedTooltip(coords)}bindCategories(){super.bindCategories(),this.copyNavigatorCategories()}copyNavigatorCategories(){const definitions=[].concat(this.options.categoryAxis);let categories;for(let axisIx=0;axisIx<definitions.length;axisIx++){const axis=definitions[axisIx];\"_navigator\"===axis.name?categories=axis.categories:categories&&\"_navigator\"===axis.pane&&(axis.categories=categories)}}destroyNavigator(){this.navigator&&(this.navigator.destroy(),this.navigator=null)}destroy(){this.destroyNavigator(),super.destroy()}_stopChartHandlers(e){const coords=this._eventCoordinates(e),pane=this._plotArea.paneByPoint(coords);return super._stopChartHandlers(e)||pane&&\"_navigator\"===pane.options.name}_toggleDragZoomEvents(){this._dragZoomEnabled||(this.element.style.touchAction=\"none\",this._dragZoomEnabled=!0)}},{dateField:\"date\",axisDefaults:{categoryAxis:{type:\"date\",baseUnit:\"fit\",justified:!0},valueAxis:{narrowRange:!0,labels:{format:\"C\"}}},navigator:{select:{},seriesDefaults:{markers:{visible:!1},tooltip:{visible:!0},line:{width:2}},hint:{},visible:!0},tooltip:{visible:!0},legend:{visible:!1}});const DEGREE=Math.PI/180;function pad(bbox,value){const origin=bbox.getOrigin(),size=bbox.getSize(),spacing=getSpacing(value);return bbox.setOrigin([origin.x-spacing.left,origin.y-spacing.top]),bbox.setSize([size.width+(spacing.left+spacing.right),size.height+(spacing.top+spacing.bottom)]),bbox}const{Group:Group,Path:Path,Text:build_label_element_Text}=main.a;function buildLabelElement(label,options){const labelBox=label.box,textBox=label.children[0].box,border=options.border||{},background=options.background||\"\",wrapper=Path.fromRect(new main.b.Rect([labelBox.x1,labelBox.y1],[labelBox.width(),labelBox.height()]),{stroke:{}}),text=new build_label_element_Text(label.text,new main.b.Point(textBox.x1,textBox.y1),{font:options.font,fill:{color:options.color}}),styleGeometry=pad(text.bbox().clone(),options.padding),styleBox=Path.fromRect(styleGeometry,{stroke:{color:border.width?border.color:\"\",width:border.width,opacity:border.opacity,dashType:border.dashType,lineJoin:\"round\",lineCap:\"round\"},fill:{color:background}}),elements=new Group;return elements.append(wrapper),elements.append(styleBox),elements.append(text),elements}function getRange(range,min,max){const from=defined(range.from)?range.from:MIN_VALUE,to=defined(range.to)?range.to:MAX_VALUE;return range.from=Math.max(Math.min(to,from),min),range.to=Math.min(Math.max(to,from),max),range}function unpad(bbox,value){const spacing=getSpacing(value);return spacing.left=-spacing.left,spacing.top=-spacing.top,spacing.right=-spacing.right,spacing.bottom=-spacing.bottom,pad(bbox,spacing)}const{Path:gauge_Path,Surface:Surface}=main.a;class gauge_Gauge extends common_class.a{constructor(element,userOptions,theme,context={}){super(),this.element=element,this.theme=theme,this.contextService=new chart_service(this,context),this._originalOptions=deepExtend({},this.options,userOptions),this.options=deepExtend({},this._originalOptions),this._initTheme(theme),this.redraw()}destroy(){this.surface&&(this.surface.destroy(),this.surface=null),delete this.element,delete this.surfaceElement}value(pointerValue){const pointer=this.pointers[0];if(0===arguments.length)return pointer.value();pointer.value(pointerValue),this._setValueOptions(pointerValue)}_draw(){const surface=this.surface;surface.clear(),surface.draw(this._visuals)}exportVisual(){return this._visuals}allValues(values){const pointers=this.pointers,allValues=[];if(0===arguments.length){for(let i=0;i<pointers.length;i++)allValues.push(pointers[i].value());return allValues}if(isArray(values))for(let i=0;i<values.length;i++)isNumber(values[i])&&pointers[i].value(values[i]);this._setValueOptions(values)}_setValueOptions(values){const pointers=[].concat(this.options.pointer),arrayValues=[].concat(values);for(let i=0;i<arrayValues.length;i++)pointers[i].value=arrayValues[i]}resize(){this.noTransitionsRedraw()}noTransitionsRedraw(){const transitions=this.options.transitions;this._toggleTransitions(!1),this.redraw(),this._toggleTransitions(transitions)}redraw(){const size=this._surfaceSize(),wrapper=new main.b.Rect([0,0],[size.width,size.height]);this._initSurface(),this.gaugeArea=this._createGaugeArea(),this._createModel();const bbox=unpad(wrapper.bbox(),this._gaugeAreaMargin);this.reflow(bbox)}setOptions(options,theme){this._originalOptions=deepExtend(this._originalOptions,options),this.options=deepExtend({},this._originalOptions),this._initTheme(theme),this.redraw()}setDirection(rtl){this.contextService.rtl=Boolean(rtl),this.surface&&\"svg\"===this.surface.type&&(this.surface.destroy(),this.surface=null)}setIntlService(intl){this.contextService.intl=intl}_initTheme(theme){let currentTheme=theme||this.theme||{};this.theme=currentTheme,this.options=deepExtend({},currentTheme,this.options);const options=this.options,pointer=options.pointer;if(isArray(pointer)){const pointers=[];for(let i=0;i<pointer.length;i++)pointers.push(deepExtend({},currentTheme.pointer,pointer[i]));options.pointer=pointers}}_createGaugeArea(){const options=this.options.gaugeArea,size=this.surface.size(),border=options.border||{};let areaGeometry=new main.b.Rect([0,0],[size.width,size.height]);return this._gaugeAreaMargin=options.margin||5,border.width>0&&(areaGeometry=unpad(areaGeometry,border.width)),gauge_Path.fromRect(areaGeometry,{stroke:{color:border.width?border.color:\"\",width:border.width,dashType:border.dashType,lineJoin:\"round\",lineCap:\"round\"},fill:{color:options.background}})}_initSurface(){const{options:options,surface:surface}=this,element=this._surfaceElement(),size=this._surfaceSize();drawing_utils_elementSize(element,size),surface&&surface.options.type===options.renderAs?(this.surface.clear(),this.surface.resize()):(surface&&surface.destroy(),this.surface=Surface.create(element,{type:options.renderAs}))}_surfaceSize(){const options=this.options,size=this._getSize();return options.gaugeArea&&deepExtend(size,options.gaugeArea),size}_surfaceElement(){return this.surfaceElement||(this.surfaceElement=document.createElement(\"div\"),this.element.appendChild(this.surfaceElement)),this.surfaceElement}getSize(){return this._getSize()}_getSize(){const element=this.element,defaultSize=this._defaultSize();let width=element.offsetWidth,height=element.offsetHeight;return width||(width=defaultSize.width),height||(height=defaultSize.height),{width:width,height:height}}_defaultSize(){return{width:200,height:200}}_toggleTransitions(value){this.options.transitions=value;for(let i=0;i<this.pointers.length;i++)this.pointers[i].options.animation.transitions=value}}setDefaultOptions(gauge_Gauge,{plotArea:{},theme:\"default\",renderAs:\"\",pointer:{},scale:{},gaugeArea:{}});var gauge=gauge_Gauge;const{Path:linear_scale_Path,Group:linear_scale_Group}=main.a,linear_scale_Point=main.b.Point;function renderAxisTick(tickRenderOptions,tickOptions){const{position:position,tickX:tickX,tickY:tickY}=tickRenderOptions;let start,end;return tickRenderOptions.vertical?(start=new linear_scale_Point(tickX,position),end=new linear_scale_Point(tickX+tickOptions.size,position)):(start=new linear_scale_Point(position,tickY),end=new linear_scale_Point(position,tickY+tickOptions.size)),new linear_scale_Path({stroke:{color:tickOptions.color,width:tickOptions.width}}).moveTo(start).lineTo(end)}function renderTicks(tickGroup,tickPositions,tickRenderOptions,tickOptions){const count=tickPositions.length;if(tickOptions.visible){const{mirror:mirror,lineBox:lineBox}=tickRenderOptions;for(let i=tickOptions.skip;i<count;i+=tickOptions.step)i%tickOptions.skipUnit!=0&&(tickRenderOptions.tickX=mirror?lineBox.x2:lineBox.x2-tickOptions.size,tickRenderOptions.tickY=mirror?lineBox.y1-tickOptions.size:lineBox.y1,tickRenderOptions.position=tickPositions[i],tickGroup.append(renderAxisTick(tickRenderOptions,tickOptions)))}}class linear_scale_LinearScale extends numeric_axis{constructor(options,service){let scaleOptions=options||{};!defined(scaleOptions.reverse)&&!1===scaleOptions.vertical&&(service||{}).rtl&&(scaleOptions=Object.assign({},scaleOptions,{reverse:!0})),super(0,1,scaleOptions,service),this.options.minorUnit=this.options.minorUnit||this.options.majorUnit/10}initUserOptions(options){let scaleOptions=deepExtend({},this.options,options);return scaleOptions=deepExtend({},scaleOptions,{labels:{mirror:scaleOptions.mirror}}),scaleOptions.majorUnit=scaleOptions.majorUnit||autoMajorUnit(scaleOptions.min,scaleOptions.max),scaleOptions}initFields(){}render(){const elements=this.elements=new linear_scale_Group,labels=this.renderLabels(),scaleLine=this.renderLine(),scaleTicks=this.renderTicks(),ranges=this.renderRanges();return elements.append(scaleLine,labels,scaleTicks,ranges),elements}renderRanges(){const options=this.options,{min:min,max:max,vertical:vertical,labels:{mirror:mirror}}=options,ranges=options.ranges||[],elements=new linear_scale_Group,count=ranges.length,rangeSize=options.rangeSize||options.minorTicks.size/2;for(let i=0;i<count;i++){const range=getRange(ranges[i],min,max),slot=this.getSlot(range.from,range.to),slotX=vertical?this.lineBox():slot,slotY=vertical?slot:this.lineBox();vertical?slotX.x1-=rangeSize*(mirror?-1:1):slotY.y2+=rangeSize*(mirror?-1:1),elements.append(linear_scale_Path.fromRect(new main.b.Rect([slotX.x1,slotY.y1],[slotX.x2-slotX.x1,slotY.y2-slotY.y1]),{fill:{color:range.color,opacity:range.opacity},stroke:{}}))}return elements}renderLabels(){const{labels:labels,options:options}=this,elements=new linear_scale_Group;for(let i=0;i<labels.length;i++)elements.append(buildLabelElement(labels[i],options.labels));return elements}renderLine(){const line=this.options.line,lineBox=this.lineBox(),elements=new linear_scale_Group;if(line.width>0&&line.visible){const linePath=new linear_scale_Path({stroke:{color:line.color,dashType:line.dashType,width:line.width}});linePath.moveTo(lineBox.x1,lineBox.y1).lineTo(lineBox.x2,lineBox.y2),elements.append(linePath)}return elements}renderTicks(){const ticks=new linear_scale_Group,options=this.options,majorUnit=options.majorTicks.visible?options.majorUnit:0,tickRenderOptions={vertical:options.vertical,mirror:options.labels.mirror,lineBox:this.lineBox()};return renderTicks(ticks,this.getMajorTickPositions(),tickRenderOptions,options.majorTicks),renderTicks(ticks,this.getMinorTickPositions(),tickRenderOptions,deepExtend({},{skipUnit:majorUnit/options.minorUnit},options.minorTicks)),ticks}}setDefaultOptions(linear_scale_LinearScale,{min:0,max:50,majorTicks:{size:15,align:\"inside\",color:BLACK,width:.5,visible:!0},minorTicks:{size:10,align:\"inside\",color:BLACK,width:.5,visible:!0},line:{width:.5},labels:{position:\"inside\",padding:2},mirror:!1,_alignLines:!1});var linear_scale=linear_scale_LinearScale;class pointer_Pointer extends common_class.a{constructor(scale,userOptions){super();const{min:min,max:max}=scale.options,options=this.options=deepExtend({},this.options,userOptions);options.fill=options.color,this.scale=scale,options.value=defined(options.value)?limitValue(options.value,min,max):min}value(newValue){const options=this.options;if(0===arguments.length)return options.value;const{min:min,max:max}=this.scale.options;options._oldValue=defined(options._oldValue)?options.value:min,options.value=limitValue(newValue,min,max),this.elements&&this.repaint()}}setDefaultOptions(pointer_Pointer,{color:BLACK});var gauges_pointer=pointer_Pointer;class linear_pointer_LinearPointer extends gauges_pointer{constructor(scale,options){super(scale,options),this.options=deepExtend({track:{visible:defined(options.track)}},this.options)}reflow(){const{options:options,scale:scale}=this,{mirror:mirror,vertical:vertical}=scale.options,scaleLine=scale.lineBox(),trackSize=options.track.size||options.size,pointerHalfSize=options.size/2,margin=getSpacing(options.margin);let pointerBox,pointerRangeBox,trackBox,space=vertical?margin[mirror?\"left\":\"right\"]:margin[mirror?\"bottom\":\"top\"];space=mirror?-space:space,vertical?(trackBox=new core_box(scaleLine.x1+space,scaleLine.y1,scaleLine.x1+space,scaleLine.y2),mirror?trackBox.x1-=trackSize:trackBox.x2+=trackSize,\"barPointer\"!==options.shape&&(pointerRangeBox=new core_box(scaleLine.x2+space,scaleLine.y1-pointerHalfSize,scaleLine.x2+space,scaleLine.y2+pointerHalfSize),pointerBox=pointerRangeBox)):(trackBox=new core_box(scaleLine.x1,scaleLine.y1-space,scaleLine.x2,scaleLine.y1-space),mirror?trackBox.y2+=trackSize:trackBox.y1-=trackSize,\"barPointer\"!==options.shape&&(pointerRangeBox=new core_box(scaleLine.x1-pointerHalfSize,scaleLine.y1-space,scaleLine.x2+pointerHalfSize,scaleLine.y1-space),pointerBox=pointerRangeBox)),this.trackBox=trackBox,this.pointerRangeBox=pointerRangeBox,this.box=pointerBox||trackBox.clone().pad(options.border.width)}getElementOptions(){const options=this.options;return{fill:{color:options.color,opacity:options.opacity},stroke:defined(options.border)?{color:options.border.width?options.border.color||options.color:\"\",width:options.border.width,dashType:options.border.dashType,opacity:options.opacity}:null}}_margin(){const{scale:scale,options:options}=this,{mirror:mirror,vertical:vertical}=scale.options,margin=getSpacing(options.margin);return vertical?margin[mirror?\"left\":\"right\"]:margin[mirror?\"bottom\":\"top\"]}}setDefaultOptions(linear_pointer_LinearPointer,{shape:\"barPointer\",track:{border:{width:1}},color:BLACK,border:{width:1},opacity:1,margin:getSpacing(3),animation:{type:\"barPointer\"},visible:!0});var linear_pointer=linear_pointer_LinearPointer;class arrow_linear_pointer_animation_ArrowLinearPointerAnimation extends main.a.Animation{setup(){const options=this.options,{margin:margin,from:from,to:to,vertical:vertical}=options,axis=vertical?\"x1\":\"y1\";options.mirror===vertical?(from[axis]-=margin,to[axis]-=margin):(from[axis]+=margin,to[axis]+=margin);const fromScale=this.fromScale=new main.b.Point(from.x1,from.y1),toScale=this.toScale=new main.b.Point(to.x1,to.y1);0!==options.duration&&(options.duration=Math.max(fromScale.distanceTo(toScale)/options.duration*1e3,1))}step(pos){const translateX=interpolateValue(this.fromScale.x,this.toScale.x,pos),translateY=interpolateValue(this.fromScale.y,this.toScale.y,pos);this.element.transform(main.b.transform().translate(translateX,translateY))}}setDefaultOptions(arrow_linear_pointer_animation_ArrowLinearPointerAnimation,{easing:\"linear\",duration:250}),main.a.AnimationFactory.current.register(\"arrowPointer\",arrow_linear_pointer_animation_ArrowLinearPointerAnimation);var arrow_linear_pointer_animation=arrow_linear_pointer_animation_ArrowLinearPointerAnimation;const arrow_linear_pointer_Point=main.b.Point,arrow_linear_pointer_Path=main.a.Path;var arrow_linear_pointer=class extends linear_pointer{constructor(scale,options){super(scale,options),defined(this.options.size)||(this.options.size=.6*this.scale.options.majorTicks.size)}pointerShape(){const{scale:scale,options:{size:size}}=this,halfSize=size/2,sign=scale.options.mirror?-1:1;let shape;return shape=scale.options.vertical?[new arrow_linear_pointer_Point(0,0-halfSize),new arrow_linear_pointer_Point(0-sign*size,0),new arrow_linear_pointer_Point(0,0+halfSize)]:[new arrow_linear_pointer_Point(0-halfSize,0),new arrow_linear_pointer_Point(0,0+sign*size),new arrow_linear_pointer_Point(0+halfSize,0)],shape}repaint(){const{scale:scale,options:options}=this,animation=new arrow_linear_pointer_animation(this.elements,deepExtend(options.animation,{vertical:scale.options.vertical,mirror:scale.options.mirror,margin:this._margin(options.margin),from:scale.getSlot(options._oldValue),to:scale.getSlot(options.value)}));!1===options.animation.transitions&&(animation.options.duration=0),animation.setup(),animation.play()}render(){const{scale:scale,options:options}=this,elementOptions=this.getElementOptions(),shape=this.pointerShape(options.value);options.animation.type=\"arrowPointer\";const elements=new arrow_linear_pointer_Path({stroke:elementOptions.stroke,fill:elementOptions.fill}).moveTo(shape[0]).lineTo(shape[1]).lineTo(shape[2]).close(),slot=scale.getSlot(options.value);return elements.transform(main.b.transform().translate(slot.x1,slot.y1)),this.elements=elements,elements}};class bar_linear_pointer_animation_BarLinearPointerAnimation extends main.a.Animation{setup(){const options=this.options,axis=this.axis=options.vertical?Y:X,to=this.to=options.newPoints[0][axis],from=this.from=options.oldPoints[0][axis];0!==options.duration&&(options.duration=Math.max(Math.abs(to-from)/options.speed*1e3,1)),this._set(from)}step(pos){const value=interpolateValue(this.from,this.to,pos);this._set(value)}_set(value){const setter=\"set\"+this.axis.toUpperCase(),points=this.options.newPoints;points[0][setter](value),points[1][setter](value)}}setDefaultOptions(bar_linear_pointer_animation_BarLinearPointerAnimation,{easing:\"linear\",speed:250}),main.a.AnimationFactory.current.register(\"barPointer\",bar_linear_pointer_animation_BarLinearPointerAnimation);var bar_linear_pointer_animation=bar_linear_pointer_animation_BarLinearPointerAnimation;const{Group:bar_linear_pointer_Group,Path:bar_linear_pointer_Path}=main.a;var bar_linear_pointer=class extends linear_pointer{constructor(scale,options){super(scale,options),defined(this.options.size)||(this.options.size=.3*this.scale.options.majorTicks.size)}pointerShape(value){const{scale:scale,options:options}=this,{mirror:mirror,vertical:vertical}=scale.options,dir=mirror===vertical?-1:1,size=options.size*dir,minSlot=scale.getSlot(scale.options.min),slot=scale.getSlot(value),axis=vertical?Y:X,sizeAxis=vertical?X:Y,margin=this._margin()*dir,p1=new main.b.Point;p1[axis]=minSlot[axis+\"1\"],p1[sizeAxis]=minSlot[sizeAxis+\"1\"];const p2=new main.b.Point;p2[axis]=slot[axis+\"1\"],p2[sizeAxis]=slot[sizeAxis+\"1\"],vertical?(p1.translate(margin,0),p2.translate(margin,0)):(p1.translate(0,margin),p2.translate(0,margin));const p3=p2.clone(),p4=p1.clone();return vertical?(p3.translate(size,0),p4.translate(size,0)):(p3.translate(0,size),p4.translate(0,size)),[p1,p2,p3,p4]}repaint(){const{scale:scale,options:options}=this,shape=this.pointerShape(options.value),pointerPath=this.pointerPath,oldShape=this.pointerShape(options._oldValue);pointerPath.moveTo(shape[0]).lineTo(shape[1]).lineTo(shape[2]).lineTo(shape[3]).close();const animation=new bar_linear_pointer_animation(pointerPath,deepExtend(options.animation,{reverse:scale.options.reverse,vertical:scale.options.vertical,oldPoints:[oldShape[1],oldShape[2]],newPoints:[shape[1],shape[2]]}));!1===options.animation.transitions&&(animation.options.duration=0),animation.setup(),animation.play()}render(){const group=new bar_linear_pointer_Group,elementOptions=this.getElementOptions();this.options.track.visible&&group.append(this.renderTrack());const pointer=this.pointerPath=new bar_linear_pointer_Path({stroke:elementOptions.stroke,fill:elementOptions.fill});return group.append(pointer),this.elements=group,group}renderTrack(){const trackOptions=this.options.track,border=trackOptions.border||{},trackBox=this.trackBox.clone().pad(border.width||0);return new bar_linear_pointer_Path.fromRect(trackBox.toRect(),{fill:{color:trackOptions.color,opacity:trackOptions.opacity},stroke:{color:border.width?border.color||trackOptions.color:\"\",width:border.width,dashType:border.dashType}})}};const linear_gauge_Group=main.a.Group;setDefaultOptions(class extends gauge{reflow(bbox){const pointers=this.pointers,bboxX=bbox.origin.x,bboxY=bbox.origin.y,box=new core_box(bboxX,bboxY,bboxX+bbox.width(),bboxY+bbox.height());this.scale.reflow(box),this._shrinkScaleWidth(box);for(let i=0;i<pointers.length;i++)pointers[i].reflow();this.bbox=this._getBox(box),this._alignElements(),this._shrinkElements(),this._buildVisual(),this._draw()}_buildVisual(){const visuals=new linear_gauge_Group,scaleElements=this.scale.render(),pointers=this.pointers;visuals.append(this.gaugeArea),visuals.append(scaleElements);for(let i=0;i<pointers.length;i++){const current=pointers[i];visuals.append(current.render()),current.value(current.options.value)}this._visuals=visuals}_createModel(){const options=this.options,scale=this.scale=new linear_scale(options.scale,this.contextService);this.pointers=[];let pointers=options.pointer;pointers=isArray(pointers)?pointers:[pointers];for(let i=0;i<pointers.length;i++){const currentOptions=deepExtend({},pointers[i],{animation:{transitions:options.transitions}});this.pointers.push(new(\"arrow\"===currentOptions.shape?arrow_linear_pointer:bar_linear_pointer)(scale,currentOptions))}}_defaultSize(){const vertical=this.options.scale.vertical;return{width:vertical?60:200,height:vertical?200:60}}_getBox(box){const{scale:scale,pointers:pointers}=this,boxCenter=box.center();let size,plotAreaBox=pointers[0].box.clone().wrap(scale.box);for(let i=0;i<pointers.length;i++)plotAreaBox.wrap(pointers[i].box.clone());return scale.options.vertical?(size=plotAreaBox.width()/2,plotAreaBox=new core_box(boxCenter.x-size,box.y1,boxCenter.x+size,box.y2)):(size=plotAreaBox.height()/2,plotAreaBox=new core_box(box.x1,boxCenter.y-size,box.x2,boxCenter.y+size)),plotAreaBox}_alignElements(){const{scale:scale,pointers:pointers}=this,scaleBox=scale.box,box=pointers[0].box.clone().wrap(scale.box),plotAreaBox=this.bbox;for(let i=0;i<pointers.length;i++)box.wrap(pointers[i].box.clone());let diff;scale.options.vertical?(diff=plotAreaBox.center().x-box.center().x,scale.reflow(new core_box(scaleBox.x1+diff,plotAreaBox.y1,scaleBox.x2+diff,plotAreaBox.y2))):(diff=plotAreaBox.center().y-box.center().y,scale.reflow(new core_box(scaleBox.x1,scaleBox.y1+diff,scaleBox.x2,scaleBox.y2+diff)));for(let i=0;i<pointers.length;i++)pointers[i].reflow(this.bbox)}_shrinkScaleWidth(bbox){const{scale:scale}=this;if(!scale.options.vertical){const overflow=scale.contentBox().width()-bbox.width();overflow>0&&(scale.box.shrink(overflow,0),scale.box.alignTo(bbox,\"center\"),scale.reflow(scale.box))}}_shrinkElements(){const{scale:scale,pointers:pointers}=this,scaleBox=scale.box.clone(),pos=scale.options.vertical?\"y\":\"x\",pointerBox=pointers[0].box;for(let i=0;i<pointers.length;i++)pointerBox.wrap(pointers[i].box.clone());scaleBox[pos+1]+=Math.max(scaleBox[pos+1]-pointerBox[pos+1],0),scaleBox[pos+2]-=Math.max(pointerBox[pos+2]-scaleBox[pos+2],0),scale.reflow(scaleBox);for(let i=0;i<pointers.length;i++)pointers[i].reflow(this.bbox)}},{transitions:!0,gaugeArea:{background:\"\"},scale:{vertical:!0}});const{Arc:Arc,Path:radial_scale_Path,Group:radial_scale_Group}=main.a;function drawTicks(arc,tickAngles,unit,tickOptions){const ticks=new radial_scale_Group,center=arc.center,radius=arc.getRadiusX();if(tickOptions.visible)for(let i=0;i<tickAngles.length;i++){const tickStart=arc.pointAt(tickAngles[i]),tickEnd=new main.b.Point(center.x+radius-tickOptions.size,center.y).rotate(tickAngles[i],center);ticks.append(new radial_scale_Path({stroke:{color:tickOptions.color,width:tickOptions.width}}).moveTo(tickStart).lineTo(tickEnd))}return ticks}function rangeSegment(from,to,color,opacity){return{from:from,to:to,color:color,opacity:opacity}}class radial_scale_RadialScale extends numeric_axis{constructor(options,service){super(0,1,options,service)}initUserOptions(options){const scaleOptions=deepExtend({},this.options,options);return scaleOptions.majorUnit=scaleOptions.majorUnit||autoMajorUnit(scaleOptions.min,scaleOptions.max),scaleOptions.minorUnit=scaleOptions.minorUnit||scaleOptions.majorUnit/10,scaleOptions}initFields(){}render(center,radius){const arc=this.renderArc(center,radius);this.bbox=arc.bbox(),this.labelElements=this.renderLabels(),this.ticks=this.renderTicks(),this.ranges=this.renderRanges()}reflow(bbox){const center=bbox.center(),radius=Math.min(bbox.height(),bbox.width())/2;if(!defined(this.bbox))return this.render(center,radius);this.bbox=this.arc.bbox(),this.radius(this.arc.getRadiusX()),this.repositionRanges(),this.renderLabels()}slotAngle(value){const{min:min,max:max,reverse:reverse,startAngle:startAngle,endAngle:endAngle}=this.options,angle=endAngle-startAngle;let result;return result=reverse?endAngle-(value-min)/(max-min)*angle:(value-min)/(max-min)*angle+startAngle,result+180}hasRanges(){const ranges=this.options.ranges;return ranges&&ranges.length}ticksSize(){const{majorTicks:majorTicks,minorTicks:minorTicks}=this.options;let size=0;return majorTicks.visible&&(size=majorTicks.size),minorTicks.visible&&(size=Math.max(minorTicks.size,size)),size}labelsCount(){let count=super.labelsCount();const options=this.options;return options.endAngle-options.startAngle>=360&&options.max%options.majorUnit==0&&(count-=1),count}renderLabels(){const options=this.options,arc=this.arc.clone();let radius=arc.getRadiusX();const tickAngles=this.tickAngles(arc,options.majorUnit),rangeSize=options.rangeSize=options.rangeSize||.1*radius,labelsGroup=new radial_scale_Group;let rangeDistance=.05*radius;defined(options.rangeDistance)?rangeDistance=options.rangeDistance:options.rangeDistance=rangeDistance;const labelsOptions=options.labels,isInside=\"inside\"===labelsOptions.position,hasLabelElements=defined(this.labelElements);isInside&&(radius-=this.ticksSize(),this.hasRanges()&&!hasLabelElements&&(radius-=rangeSize+rangeDistance),arc.setRadiusX(radius).setRadiusY(radius));const labels=this.labels,count=labels.length,padding=getSpacing(labelsOptions.padding),paddingWidth=(padding.left+padding.right)/2,paddingHeight=(padding.top+padding.bottom)/2;for(let i=0;i<count;i++){const label=labels[i],halfWidth=label.box.width()/2,halfHeight=label.box.height()/2,angle=tickAngles[i],labelAngle=(angle-180)*DEGREE,lp=arc.pointAt(angle),cx=lp.x+Math.cos(labelAngle)*(halfWidth+paddingWidth)*(isInside?1:-1),cy=lp.y+Math.sin(labelAngle)*(halfHeight+paddingHeight)*(isInside?1:-1);label.reflow(new core_box(cx-halfWidth,cy-halfHeight,cx+halfWidth,cy+halfHeight));const labelPos=new main.b.Point(label.box.x1,label.box.y1);let labelElement;if(hasLabelElements){labelElement=this.labelElements.children[i];const prevLabelPos=labelElement.bbox().origin,labelTransform=labelElement.transform()||main.b.transform();labelTransform.translate(labelPos.x-prevLabelPos.x,labelPos.y-prevLabelPos.y),labelElement.transform(labelTransform)}else labelElement=buildLabelElement(label,options.labels),labelsGroup.append(labelElement);this.bbox=main.b.Rect.union(this.bbox,labelElement.bbox())}return labelsGroup}repositionRanges(){const ranges=this.ranges.children;if(ranges.length>0){const{rangeDistance:rangeDistance,rangeSize:rangeSize}=this.options;let rangeRadius=this.getRangeRadius();\"inside\"===this.options.labels.position&&(rangeRadius+=rangeSize+rangeDistance);const newRadius=rangeRadius+rangeSize/2;for(let i=0;i<ranges.length;i++)ranges[i]._geometry.setRadiusX(newRadius).setRadiusY(newRadius);this.bbox=main.b.Rect.union(this.bbox,this.ranges.bbox())}}renderRanges(){const segments=this.rangeSegments(),segmentsCount=segments.length,result=new radial_scale_Group;if(segmentsCount){const{rangeSize:rangeSize,reverse:reverse,rangeDistance:rangeDistance}=this.options,rangeRadius=this.getRangeRadius();this.radius(this.radius()-rangeSize-rangeDistance);for(let i=0;i<segmentsCount;i++){const segment=segments[i],from=this.slotAngle(segment[reverse?\"to\":\"from\"]),to=this.slotAngle(segment[reverse?\"from\":\"to\"]);to-from!=0&&result.append(this.createRange(from,to,rangeRadius,segment))}}return result}createRange(startAngle,endAngle,rangeRadius,options){const rangeSize=this.options.rangeSize,rangeGeom=new main.b.Arc(this.arc.center,{radiusX:rangeRadius+rangeSize/2,radiusY:rangeRadius+rangeSize/2,startAngle:startAngle,endAngle:endAngle});return new Arc(rangeGeom,{stroke:{width:rangeSize,color:options.color,opacity:options.opacity,lineCap:options.lineCap}})}rangeSegments(){const options=this.options,ranges=options.ranges||[],count=ranges.length,segments=[];if(count){const{min:min,max:max,rangePlaceholderColor:defaultColor}=options;segments.push(rangeSegment(min,max,defaultColor));for(let i=0;i<count;i++){const range=getRange(ranges[i],min,max),segmentsCount=segments.length;for(let j=0;j<segmentsCount;j++){const segment=segments[j];if(segment.from<=range.from&&range.from<=segment.to){segments.push(rangeSegment(range.from,range.to,range.color,range.opacity)),segment.from<=range.to&&range.to<=segment.to&&segments.push(rangeSegment(range.to,segment.to,defaultColor,range.opacity)),segment.to=range.from;break}}}}return segments}getRangeRadius(){const{arc:arc,options:options}=this,{rangeSize:rangeSize,rangeDistance:rangeDistance,majorTicks:{size:majorTickSize}}=options;let radius;return radius=\"outside\"===options.labels.position?arc.getRadiusX()-majorTickSize-rangeDistance-rangeSize:arc.getRadiusX()-rangeSize,radius}renderArc(center,radius){const options=this.options;return this.arc=new main.b.Arc(center,{radiusX:radius,radiusY:radius,startAngle:options.startAngle+180,endAngle:options.endAngle+180})}renderTicks(){const{arc:arc,options:options}=this,tickArc=arc.clone();this.majorTickAngles=this.tickAngles(arc,options.majorUnit),this.majorTicks=drawTicks(tickArc,this.majorTickAngles,0,options.majorTicks);const allTicks=new radial_scale_Group;allTicks.append(this.majorTicks);const majorTickSize=options.majorTicks.size,minorTickSize=options.minorTicks.size;if(this._tickDifference=majorTickSize-minorTickSize,\"outside\"===options.labels.position){const radius=tickArc.getRadiusX();tickArc.setRadiusX(radius-majorTickSize+minorTickSize).setRadiusY(radius-majorTickSize+minorTickSize)}return this.minorTickAngles=this.normalizeTickAngles(this.tickAngles(arc,options.minorUnit)),this.minorTicks=drawTicks(tickArc,this.minorTickAngles,0,options.minorTicks),allTicks.append(this.minorTicks),allTicks}normalizeTickAngles(angles){const options=this.options,skip=options.majorUnit/options.minorUnit;for(let i=angles.length-1;i>=0;i--)i%skip==0&&angles.splice(i,1);return angles}tickAngles(ring,stepValue){const options=this.options,angle=ring.endAngle-ring.startAngle;let tickCount=(options.max-options.min)/stepValue,pos=ring.startAngle,step=angle/tickCount;options.reverse&&(pos+=angle,step=-step),angle>=360&&options.max%stepValue==0&&(tickCount-=1);const positions=[];for(let i=0;i<tickCount;i++)positions.push(round(pos,3)),pos+=step;return round(pos)<=ring.endAngle&&positions.push(pos),positions}radius(value){if(!value)return this.arc.getRadiusX();this.arc.setRadiusX(value).setRadiusY(value),this.repositionTicks(this.majorTicks.children,this.majorTickAngles),this.repositionTicks(this.minorTicks.children,this.minorTickAngles,!0)}repositionTicks(ticks,tickAngles,minor){const diff=minor&&this._tickDifference||0;let tickArc=this.arc;const radius=tickArc.getRadiusX();minor&&\"outside\"===this.options.labels.position&&0!==diff&&(tickArc=this.arc.clone(),tickArc.setRadiusX(radius-diff).setRadiusY(radius-diff));for(let i=0;i<ticks.length;i++){const newPoint=tickArc.pointAt(tickAngles[i]),segments=ticks[i].segments,xDiff=newPoint.x-segments[0].anchor().x,yDiff=newPoint.y-segments[0].anchor().y;ticks[i].transform((new main.b.transform).translate(xDiff,yDiff))}}}setDefaultOptions(radial_scale_RadialScale,{min:0,max:100,majorTicks:{size:15,align:\"inside\",color:BLACK,width:.5,visible:!0},minorTicks:{size:10,align:\"inside\",color:BLACK,width:.5,visible:!0},startAngle:-30,endAngle:210,labels:{position:\"inside\",padding:2}});var radial_scale=radial_scale_RadialScale;class radial_pointer_animation_RadialPointerAnimation extends main.a.Animation{constructor(element,options){super(element,options);const animationOptions=this.options;animationOptions.duration=Math.max(Math.abs(animationOptions.newAngle-animationOptions.oldAngle)/animationOptions.duration*1e3,1)}step(pos){const options=this.options,angle=interpolateValue(options.oldAngle,options.newAngle,pos);this.element.transform(main.b.transform().rotate(angle,options.center))}}setDefaultOptions(radial_pointer_animation_RadialPointerAnimation,{easing:\"linear\",duration:150}),main.a.AnimationFactory.current.register(\"radialPointer\",radial_pointer_animation_RadialPointerAnimation);var radial_pointer_animation=radial_pointer_animation_RadialPointerAnimation;const{Circle:Circle,Group:radial_pointer_Group,Path:radial_pointer_Path}=main.a;class radial_pointer_RadialPointer extends gauges_pointer{setAngle(angle){this.elements.transform(main.b.transform().rotate(angle,this.center))}repaint(){const{scale:scale,options:options}=this,oldAngle=scale.slotAngle(options._oldValue),newAngle=scale.slotAngle(options.value);!1===options.animation.transitions?this.setAngle(newAngle):new radial_pointer_animation(this.elements,deepExtend(options.animation,{oldAngle:oldAngle,newAngle:newAngle})).play()}render(){const{scale:scale,options:options}=this,elements=new radial_pointer_Group;return!1!==options.animation&&deepExtend(options.animation,{startAngle:0,center:scale.arc.center,reverse:scale.options.reverse}),elements.append(this._renderNeedle(),this._renderCap()),this.elements=elements,this.setAngle(DEGREE),elements}reflow(arc){const center=this.center=arc.center,length=limitValue(this.options.length||1,.1,1.5),radius=this.radius=arc.getRadiusX()*length,capSize=this.capSize=Math.round(radius*this.options.cap.size);this.bbox=main.b.Rect.fromPoints(new main.b.Point(center.x-capSize,center.y-capSize),new main.b.Point(center.x+capSize,center.y+capSize))}_renderNeedle(){const minorTickSize=this.scale.options.minorTicks.size,center=this.center,needleColor=this.options.color,needlePath=new radial_pointer_Path({fill:{color:needleColor},stroke:{color:needleColor,width:.5}});return needlePath.moveTo(center.x+this.radius-minorTickSize,center.y).lineTo(center.x,center.y-this.capSize/2).lineTo(center.x,center.y+this.capSize/2).close(),needlePath}_renderCap(){const options=this.options,capColor=options.cap.color||options.color,circle=new main.b.Circle(this.center,this.capSize);return new Circle(circle,{fill:{color:capColor},stroke:{color:capColor}})}}setDefaultOptions(radial_pointer_RadialPointer,{cap:{size:.05},arrow:{width:16,height:14},animation:{type:\"radialPointer\",duration:150}});var radial_pointer=radial_pointer_RadialPointer;const radial_gauge_Group=main.a.Group;setDefaultOptions(class extends gauge{reflow(bbox){const pointers=this.pointers;this.scale.reflow(bbox),this._initialPlotArea=this.scale.bbox;for(let i=0;i<pointers.length;i++)pointers[i].reflow(this.scale.arc),this._initialPlotArea=main.b.Rect.union(this._initialPlotArea,pointers[i].bbox);this.fitScale(bbox),this.alignScale(bbox),this._buildVisual(this.gaugeArea,pointers,this.scale),this._draw()}_buildVisual(gaugeArea,pointers,scale){const visuals=this._visuals=new radial_gauge_Group;visuals.append(gaugeArea),visuals.append(scale.ticks),visuals.append(scale.ranges),this._buildPointers(pointers),visuals.append(scale.labelElements)}_buildPointers(pointers){for(let i=0;i<pointers.length;i++){const current=pointers[i];current.render(),this._visuals.append(current.elements),current.value(current.options.value)}}fitScale(bbox){const arc=this.scale.arc,step=Math.abs(this.getDiff(this._initialPlotArea,bbox));let minDiff,midDiff,maxDiff,mid,oldDiff,min=round(step,3),max=round(-step,3),staleFlag=0,i=0;for(;!(!(i++<100)||(staleFlag=oldDiff===maxDiff?staleFlag+1:0,staleFlag>5)||min!==mid&&(minDiff=this.getPlotBox(min,bbox,arc),0<=minDiff&&minDiff<=2)||max!==mid&&(maxDiff=this.getPlotBox(max,bbox,arc),0<=maxDiff&&maxDiff<=2)||(mid=minDiff>0&&maxDiff>0?2*min:minDiff<0&&maxDiff<0?2*max:round((min+max)/2||1,3),midDiff=this.getPlotBox(mid,bbox,arc),0<=midDiff&&midDiff<=2));)oldDiff=maxDiff,midDiff>0?(max=mid,maxDiff=midDiff):(min=mid,minDiff=midDiff)}getPlotBox(step,bbox,arc){const scale=this.scale,pointers=this.pointers,radius=arc.getRadiusX(),scaleArc=arc.clone();scaleArc.setRadiusX(radius+step).setRadiusY(radius+step),scale.arc=scaleArc,scale.reflow(bbox),this.plotBbox=scale.bbox;for(let i=0;i<pointers.length;i++)pointers[i].reflow(scaleArc),this.plotBbox=main.b.Rect.union(this.plotBbox,pointers[i].bbox);return this.getDiff(this.plotBbox,bbox)}getDiff(plotBox,box){return Math.min(box.width()-plotBox.width(),box.height()-plotBox.height())}alignScale(bbox){const plotBoxCenter=this.plotBbox.center(),boxCenter=bbox.center(),paddingX=plotBoxCenter.x-boxCenter.x,paddingY=plotBoxCenter.y-boxCenter.y,{scale:scale,pointers:pointers}=this;scale.arc.center.x-=paddingX,scale.arc.center.y-=paddingY,scale.reflow(bbox);for(let i=0;i<pointers.length;i++)pointers[i].reflow(scale.arc),this.plotBbox=main.b.Rect.union(scale.bbox,pointers[i].bbox)}_createModel(){const options=this.options,pointers=options.pointer,scale=this.scale=new radial_scale(options.scale,this.contextService);this.pointers=[];const pointersArr=isArray(pointers)?pointers:[pointers];for(let i=0;i<pointersArr.length;i++){const current=new radial_pointer(scale,deepExtend({},pointersArr[i],{animation:{transitions:options.transitions}}));this.pointers.push(current)}}},{transitions:!0,gaugeArea:{background:\"\"}}),setDefaultOptions(class extends radial_scale{rangeSegments(){const{min:min,max:max,rangePlaceholderColor:rangePlaceholderColor,rangeLineCap:rangeLineCap}=this.options;return[{from:min,to:max,color:rangePlaceholderColor,lineCap:rangeLineCap}]}hasRanges(){return!0}placeholderRangeAngle(angle){const geometry=this.ranges.children[0].geometry();this.options.reverse?geometry.setEndAngle(angle):geometry.setStartAngle(angle)}addRange(from,to,options){const reverse=this.options.reverse,startAngle=this.slotAngle(reverse?to:from),endAngle=this.slotAngle(reverse?from:to),range=this.createRange(startAngle,endAngle,this.getRangeRadius(),options);return this.ranges.append(range),range}},{min:0,max:100,majorTicks:{visible:!1},minorTicks:{visible:!1},labels:{visible:!1},startAngle:0,endAngle:180,rangeLineCap:\"round\"});class range_pointer_animation_RangePointerAnimation extends main.a.Animation{constructor(element,options){super(element,options);const animationOptions=this.options,duration=Math.abs(animationOptions.newAngle-animationOptions.oldAngle)/animationOptions.duration*1e3;animationOptions.duration=limitValue(duration,150,800);const startColor=element.elements.options.get(\"stroke.color\"),color=element.currentColor();startColor!==color&&(this.startColor=new color_color.a(startColor),this.color=new color_color.a(color))}step(pos){const{options:options,startColor:startColor,color:color}=this,angle=interpolateValue(options.oldAngle,options.newAngle,pos);if(this.element.angle(angle),color){const r=round(interpolateValue(startColor.r,color.r,pos)),g=round(interpolateValue(startColor.g,color.g,pos)),b=round(interpolateValue(startColor.b,color.b,pos));this.element.stroke(new color_color.a(r,g,b).toHex())}}}setDefaultOptions(range_pointer_animation_RangePointerAnimation,{easing:\"linear\",duration:150}),main.a.AnimationFactory.current.register(\"radialRangePointer\",range_pointer_animation_RangePointerAnimation);var range_pointer_animation=range_pointer_animation_RangePointerAnimation;setDefaultOptions(class extends gauges_pointer{repaint(){const{scale:scale,options:options}=this,oldAngle=scale.slotAngle(options._oldValue),newAngle=scale.slotAngle(options.value);this.animation&&this.animation.abort(),!1===options.animation.transitions?(this.angle(newAngle),this.stroke(this.currentColor())):(this.animation=new range_pointer_animation(this,deepExtend(options.animation,{oldAngle:oldAngle,newAngle:newAngle})),this.animation.play())}angle(value){const geometry=this.elements.geometry();this.scale.options.reverse?geometry.setStartAngle(value):geometry.setEndAngle(value),this.scale.placeholderRangeAngle(value)}stroke(value){this.elements.stroke(value)}render(){if(this.elements)return;const{scale:scale,options:options}=this;!1!==options.animation&&deepExtend(options.animation,{startAngle:0,center:scale.arc.center,reverse:scale.options.reverse}),this.elements=scale.addRange(scale.options.min,this.options.value,{color:this.currentColor(),opacity:options.opacity,lineCap:scale.options.rangeLineCap})}currentColor(){const{min:min,max:max}=this.scale.options,{colors:colors,color:color,value:value}=this.options,currentValue=isNumber(value)?value:min;if(colors)for(let idx=0;idx<colors.length;idx++){const{color:rangeColor,from:from=min,to:to=max}=colors[idx];if(from<=currentValue&&currentValue<=to)return rangeColor}return color}reflow(){this.render(),this.bbox=this.elements.bbox()}},{animation:{type:\"radialRangePointer\",duration:150}});const SANS=\"Arial, Helvetica, sans-serif\",SANS12=\"12px \"+SANS,SANS16=\"16px \"+SANS,base_theme_notes=()=>({icon:{border:{width:1}},label:{font:SANS12,padding:3},line:{length:10,width:2},visible:!0}),base_theme_seriesDefaults=options=>({visible:!0,labels:{font:\"11px Arial, Helvetica, sans-serif\"},overlay:options.gradients?{}:{gradient:\"none\"},area:{highlight:{markers:{border:{}}},line:{opacity:1,width:0},markers:{size:6,visible:!1},opacity:.4},rangeArea:{highlight:{markers:{border:{}}},line:{opacity:1,width:0},markers:{size:6,visible:!1},opacity:.4},verticalRangeArea:{highlight:{markers:{border:{}}},line:{opacity:1,width:0},markers:{size:6,visible:!1},opacity:.4},bar:{gap:1.5,spacing:.4},boxPlot:{outliersField:\"\",meanField:\"\",border:{_brightness:.8,width:1},downColor:\"#fff\",gap:1,highlight:{border:{opacity:1,width:2},whiskers:{width:3},mean:{width:2},median:{width:2}},mean:{width:2},median:{width:2},spacing:.3,whiskers:{width:2}},bubble:{border:{width:0},labels:{background:\"transparent\"},opacity:.6},bullet:{gap:1.5,spacing:.4,target:{color:\"#ff0000\"}},candlestick:{border:{_brightness:.8,width:1},downColor:\"#fff\",gap:1,highlight:{border:{opacity:1,width:2},line:{width:2}},line:{color:\"#000\",width:1},spacing:.3},column:{gap:1.5,spacing:.4},pie:{labels:{background:\"\",color:\"\",padding:{top:5,bottom:5,left:7,right:7}}},donut:{margin:1},funnel:{labels:{background:\"\",color:\"\",padding:{top:5,bottom:5,left:7,right:7}}},horizontalWaterfall:{gap:.5,line:{color:\"#000\",width:1},spacing:.4},line:{width:2},notes:base_theme_notes(),ohlc:{gap:1,highlight:{line:{opacity:1,width:3}},line:{width:1},spacing:.3},radarArea:{line:{opacity:1,width:0},markers:{size:6,visible:!1},opacity:.5},radarLine:{markers:{visible:!1},width:2},polarArea:{line:{opacity:1,width:0},markers:{size:6,visible:!1},opacity:.5},polarLine:{markers:{visible:!1},width:2},rangeBar:{gap:1.5,spacing:.4},rangeColumn:{gap:1.5,spacing:.4},scatterLine:{width:1},verticalArea:{highlight:{markers:{border:{}}},line:{opacity:1,width:0},markers:{size:6,visible:!1},opacity:.4},verticalBoxPlot:{outliersField:\"\",meanField:\"\",border:{_brightness:.8,width:1},downColor:\"#fff\",gap:1,highlight:{border:{opacity:1,width:2},whiskers:{width:3},mean:{width:2},median:{width:2}},mean:{width:2},median:{width:2},spacing:.3,whiskers:{width:2}},verticalBullet:{gap:1.5,spacing:.4,target:{color:\"#ff0000\"}},verticalLine:{width:2},waterfall:{gap:.5,line:{color:\"#000\",width:1},spacing:.4}}),baseTheme=(options={})=>({axisDefaults:{labels:{font:SANS12},notes:base_theme_notes(),title:{font:SANS16,margin:5}},categoryAxis:{majorGridLines:{visible:!0}},navigator:{pane:{height:90,margin:{top:10}}},seriesDefaults:base_theme_seriesDefaults(options),title:{font:SANS16},legend:{labels:{font:SANS12}}});var common=__webpack_require__(\"ofXK\"),merge=__webpack_require__(\"VRyK\"),fromEvent=__webpack_require__(\"xgIS\"),observable_from=__webpack_require__(\"Cfvw\");const isDocumentAvailable=()=>\"undefined\"!=typeof document,hasObservers=emitter=>emitter&&emitter.observers.length>0;class fesm2015_ResizeService{constructor(resizeBatchService){this.resizeBatchService=resizeBatchService,this.resize=new core.o,this.acceptedSize=!1,this.state=0}acceptSize(size=this.measure()){this.lastWidth=size.width,this.lastHeight=size.height,this.acceptedSize=!0}checkChanges(){isDocumentAvailable()&&0===this.state&&(this.state=1,this.resizeBatchService.schedule(this,this.init))}destroy(){this.resizeBatchService.cancel(this)}checkSize(){if(!this.parentElement)return;const{width:width,height:height}=this.measure();return width===this.lastWidth&&height===this.lastHeight?void 0:(this.lastWidth=width,this.lastHeight=height,this.acceptedSize=!1,this.resize.emit(),!0)}initSize(){const size=this.measure();this.lastWidth=size.width,this.lastHeight=size.height}measure(){let width=0,height=0;return this.parentElement&&(height=this.parentElement.offsetHeight,width=this.parentElement.offsetWidth),{height:height,width:width}}}const div=style=>{const el=document.createElement(\"div\");return el.style.cssText=style,el},WRAP_STYLE=\"position: absolute; display: block; left: 0; top: 0; right: 0; bottom: 0; z-index: -1;overflow: hidden; visibility: hidden;\";class fesm2015_ResizeCompatService extends fesm2015_ResizeService{constructor(resizeBatchService,element,ngZone){super(resizeBatchService),this.element=element,this.ngZone=ngZone}checkChanges(){2!==this.state?super.checkChanges():this.resizeBatchService.isScheduled(this)||this.resizeBatchService.schedule(this,this.checkSize)}destroy(){if(super.destroy(),this.subscription&&this.subscription.unsubscribe(),this.expand){const element=this.element.nativeElement;element.removeChild(this.expand),element.removeChild(this.shrink),this.expand.removeChild(this.expandChild),this.expand=this.expandChild=this.shrink=this.element=null}}checkSize(){if(super.checkSize())return this.reset(),!0}init(){const parentElement=this.parentElement=this.element.nativeElement.parentElement;\"static\"===getComputedStyle(parentElement,null).getPropertyValue(\"position\")&&(parentElement.style.position=\"relative\"),this.state=2,this.render(),this.reset(),this.initSize(),this.subscribe()}render(){const element=this.element.nativeElement;element.style.cssText=WRAP_STYLE,element.setAttribute(\"dir\",\"ltr\"),this.expand=div(WRAP_STYLE),this.expandChild=div(\"position: absolute; left: 0; top: 0; transition: 0s;\"),this.expand.appendChild(this.expandChild),element.appendChild(this.expand),this.shrink=div(WRAP_STYLE);const shrinkChild=div(\"position: absolute; left: 0; top: 0; transition: 0s;width: 200%; height: 200%;\");this.shrink.appendChild(shrinkChild),element.appendChild(this.shrink)}reset(){const expandChild=this.expandChild;expandChild.style.width=\"100000px\",expandChild.style.height=\"100000px\";const expand=this.expand;expand.scrollLeft=1e5,expand.scrollTop=1e5;const shrink=this.shrink;shrink.scrollLeft=1e5,shrink.scrollTop=1e5}subscribe(){this.ngZone.runOutsideAngular(()=>{this.subscription=Object(merge.a)(Object(fromEvent.a)(this.shrink,\"scroll\"),Object(fromEvent.a)(this.expand,\"scroll\")).subscribe(()=>{this.checkSize()})})}}const HAS_OBSERVER=\"undefined\"!=typeof ResizeObserver;class ResizeObserverService extends fesm2015_ResizeService{constructor(resizeBatchService,element,ngZone){super(resizeBatchService),this.element=element,this.ngZone=ngZone}static supported(){return HAS_OBSERVER}destroy(){super.destroy(),this.resizeObserver&&(this.resizeObserver.disconnect(),this.resizeObserver=null),this.parentElement=null}init(){this.parentElement=this.element.nativeElement.parentElement,this.initSize(),this.state=2,this.ngZone.runOutsideAngular(()=>{this.resizeObserver=new ResizeObserver(()=>{this.checkSize()}),this.resizeObserver.observe(this.parentElement)})}}let fesm2015_ResizeBatchService=(()=>{let ResizeBatchService=class{constructor(ngZone){this.ngZone=ngZone,this.scheduled=[],this.resolvedPromise=Promise.resolve(null),this.flush=this.flush.bind(this)}schedule(instance,method){this.scheduled.push({instance:instance,method:method}),this.subscription||this.ngZone.runOutsideAngular(()=>{this.subscription=Object(observable_from.a)(this.resolvedPromise).subscribe(this.flush)})}isScheduled(instance){return Boolean(this.scheduled.find(item=>item.instance===instance))}cancel(instance){const scheduled=this.scheduled,count=scheduled.length;for(let idx=0;idx<count;idx++)if(scheduled[idx].instance===instance)return scheduled.splice(idx,1),void(scheduled.length||this.unsubscribe())}ngOnDestroy(){this.unsubscribe()}unsubscribe(){this.subscription&&(this.subscription.unsubscribe(),this.subscription=null)}flush(){this.scheduled.forEach(item=>{item.method.call(item.instance)}),this.scheduled=[],this.unsubscribe()}};return ResizeBatchService.ɵfac=function(t){return new(t||ResizeBatchService)(core.cc(core.B))},ResizeBatchService.ɵprov=core.Lb({token:ResizeBatchService,factory:function(t){return ResizeBatchService.ɵfac(t)}}),ResizeBatchService=__decorate([__metadata(\"design:paramtypes\",[core.B])],ResizeBatchService),ResizeBatchService})(),fesm2015_ResizeSensorComponent=(()=>{let ResizeSensorComponent=class{constructor(resizeBatchService,element,ngZone){this.rateLimit=10,this.resize=new core.o;const serviceType=ResizeObserverService.supported()?ResizeObserverService:fesm2015_ResizeCompatService;this.resizeService=new serviceType(resizeBatchService,element,ngZone);const throttleTime=1e3/(this.rateLimit||10);this.subscription=this.resizeService.resize.pipe(Object(auditTime.a)(throttleTime)).subscribe(()=>{this.resizeService.acceptedSize||this.resize.emit()})}ngAfterViewChecked(){this.resizeService.checkChanges()}ngOnDestroy(){this.subscription.unsubscribe(),this.resizeService.destroy()}acceptSize(size){this.resizeService.acceptSize(size)}};return ResizeSensorComponent.ɵfac=function(t){return new(t||ResizeSensorComponent)(core.Pb(fesm2015_ResizeBatchService),core.Pb(core.l),core.Pb(core.B))},ResizeSensorComponent.ɵcmp=core.Jb({type:ResizeSensorComponent,selectors:[[\"kendo-resize-sensor\"]],inputs:{rateLimit:\"rateLimit\"},outputs:{resize:\"resize\"},decls:0,vars:0,template:function(rf,ctx){},encapsulation:2}),ResizeSensorComponent=__decorate([__metadata(\"design:paramtypes\",[fesm2015_ResizeBatchService,core.l,core.B])],ResizeSensorComponent),ResizeSensorComponent})(),fesm2015_ResizeSensorModule=(()=>{let ResizeSensorModule=class{};return ResizeSensorModule.ɵmod=core.Nb({type:ResizeSensorModule}),ResizeSensorModule.ɵinj=core.Mb({factory:function(t){return new(t||ResizeSensorModule)},providers:[fesm2015_ResizeBatchService]}),ResizeSensorModule})();function owner_document_ownerDocument(element){return element.ownerDocument||element.document||element}var es2015_window=element=>owner_document_ownerDocument(element).defaultView,es2015_document=element=>owner_document_ownerDocument(element).documentElement;let cachedWidth=0;function scrollbarWidth(){if(!cachedWidth&&\"undefined\"!=typeof document){const div=document.createElement(\"div\");div.style.cssText=\"overflow:scroll;overflow-x:hidden;zoom:1;clear:both;display:block\",div.innerHTML=\"&nbsp;\",document.body.appendChild(div),cachedWidth=div.offsetWidth-div.scrollWidth,document.body.removeChild(div)}return cachedWidth}function windowViewport(element){const win=es2015_window(element),document=es2015_document(element),result={height:win.innerHeight,width:win.innerWidth};return document.scrollHeight-document.clientHeight>0&&(result.width-=scrollbarWidth()),result}var offset_parent=element=>{let offsetParent=element.offsetParent;for(;offsetParent&&\"static\"===offsetParent.style.position;)offsetParent=offsetParent.offsetParent;return offsetParent||es2015_document(element)},es2015_offset=element=>{let rect=element.getBoundingClientRect(),{left:left,top:top}=rect;return rect.height||rect.width||(rect=(element=>{const{display:display,left:left,position:position}=element.style;element.style.display=\"\",element.style.left=\"-10000px\",element.style.position=\"absolute\";const rect=element.getBoundingClientRect();return element.style.display=display,element.style.left=left,element.style.position=position,rect})(element)),{top:top,left:left,height:rect.height,width:rect.width}},parents=(element,until)=>{const result=[];let next=element.parentNode;for(;next&&(result.push(next),next!==until);)next=next.parentNode;return result};function scrollPosition(element){const documentElement=es2015_document(element),win=es2015_window(element);return{x:win.pageXOffset||documentElement.scrollLeft||0,y:win.pageYOffset||documentElement.scrollTop||0}}var element_scroll_position=element=>element===(element.ownerDocument||{}).body?scrollPosition(element):{x:element.scrollLeft,y:element.scrollTop};const restrict_to_view_fit=function(position,size,viewPortSize){let output=0;return position+size>viewPortSize&&(output=viewPortSize-(position+size)),position<0&&(output=-position),output},restrict_to_view_flip=function({offset:offset,size:size,anchorSize:anchorSize,viewPortSize:viewPortSize,anchorAlignPoint:anchorAlignPoint,elementAlignPoint:elementAlignPoint,margin:margin}){let output=0;const marginToAdd=2*margin;if(elementAlignPoint!==anchorAlignPoint&&\"center\"!==elementAlignPoint&&\"middle\"!==elementAlignPoint&&\"center\"!==anchorAlignPoint&&\"middle\"!==anchorAlignPoint){const isBeforeAnchor=\"top\"===anchorAlignPoint||\"left\"===anchorAlignPoint;offset<0&&isBeforeAnchor?(output=size+anchorSize+marginToAdd,offset+output+size>viewPortSize&&(output=0)):offset>=0&&!isBeforeAnchor&&(offset+size>viewPortSize&&(output+=-(anchorSize+size+marginToAdd)),offset+output<0&&(output=0))}return output};var siblings=element=>{const result=[];let sibling=element.parentNode.firstElementChild;for(;sibling;)sibling!==element&&result.push(sibling),sibling=sibling.nextElementSibling;return result},animations=__webpack_require__(\"R0Ic\");const _c0=[\"container\"];function PopupComponent_ng_template_3_Template(rf,ctx){}const _c1=[\"*\"],eitherRect=(rect,offset$$1)=>rect||{height:0,left:offset$$1.left,top:offset$$1.top,width:0},isWindowAvailable=()=>\"undefined\"!=typeof window,OVERFLOW_REGEXP=/auto|scroll/,overflowStyle=element=>(element=>`${element.style.overflow}${element.style.overflowX}${element.style.overflowY}`)(element)||(element=>{const styles=window.getComputedStyle(element);return`${styles.overflow}${styles.overflowX}${styles.overflowY}`})(element),hasRelativeStackingContext=function(fun){let result,called=!1;return(...args)=>(called||(result=(()=>{if(!isDocumentAvailable()&&null!==document.body)return!1;const parent=document.createElement(\"div\");parent.style.transform=\"matrix(10, 0, 0, 10, 0, 0)\",parent.innerHTML='<div style=\"position: fixed; top: 10px;\">child</div>',document.body.appendChild(parent);const isDifferent=10!==parent.children[0].getBoundingClientRect().top;return document.body.removeChild(parent),isDifferent})(...args),called=!0),result)}(),scaleRect=(rect,scale)=>rect&&1!==scale?{height:rect.height/scale,left:rect.left/scale,top:rect.top/scale,width:rect.width/scale}:rect,STYLES=[\"font-size\",\"font-family\",\"font-stretch\",\"font-style\",\"font-weight\",\"line-height\"];let fesm2015_DOMService=(()=>{let DOMService=class{addOffset(current,addition){return{left:current.left+addition.left,top:current.top+addition.top}}addScroll(rect,scroll){return function(rect,scroll){return{top:rect.top+scroll.y,left:rect.left+scroll.x,height:rect.height,width:rect.width}}(rect,scroll)}align(settings){return(options=>{const{anchorRect:anchorRect,anchorAlign:anchorAlign,elementRect:elementRect,elementAlign:elementAlign,margin:margin={}}=options,anchorHorizontal=anchorAlign.horizontal,anchorVertical=anchorAlign.vertical,elementHorizontal=elementAlign.horizontal,elementVertical=elementAlign.vertical;let horizontalMargin=margin.horizontal||0,verticalMargin=margin.vertical||0,top=anchorRect.top,left=anchorRect.left;return\"bottom\"===anchorVertical&&(top+=anchorRect.height),\"center\"!==anchorVertical&&\"middle\"!==anchorVertical||(top+=Math.round(anchorRect.height/2)),\"bottom\"===elementVertical&&(top-=elementRect.height,verticalMargin*=-1),\"center\"!==elementVertical&&\"middle\"!==elementVertical||(top-=Math.round(elementRect.height/2),verticalMargin*=-1),\"right\"===anchorHorizontal&&(left+=anchorRect.width),\"center\"!==anchorHorizontal&&\"middle\"!==anchorHorizontal||(left+=Math.round(anchorRect.width/2)),\"right\"===elementHorizontal&&(left-=elementRect.width,horizontalMargin*=-1),\"center\"!==elementHorizontal&&\"middle\"!==elementHorizontal||(left-=Math.round(elementRect.width/2),horizontalMargin*=-1),{top:top+verticalMargin,left:left+horizontalMargin}})(settings)}boundingOffset(el){return(element=>{if(!element.getBoundingClientRect){const viewport=windowViewport(element);return{bottom:viewport.height,left:0,right:viewport.width,top:0}}const{bottom:bottom,left:left,right:right,top:top}=element.getBoundingClientRect();return{bottom:bottom,left:left,right:right,top:top}})(this.nativeElement(el))}getFontStyles(el){const window=this.getWindow();if(!window||!el)return[];const computedStyles=window.getComputedStyle(this.nativeElement(el));return STYLES.map(font=>({key:font,value:computedStyles[font]}))}getWindow(){return isWindowAvailable()?window:null}hasOffsetParent(el){return!!el&&!!this.nativeElement(el).offsetParent}offset(el){return el?es2015_offset(this.nativeElement(el)):null}offsetAtPoint(el,currentLocation){if(!el)return null;const element=this.nativeElement(el),{left:left,top:top,transition:transition}=element.style;element.style.transition=\"none\",element.style.left=currentLocation.left+\"px\",element.style.top=currentLocation.top+\"px\";const currentOffset=es2015_offset(element);return element.style.left=left,element.style.top=top,element.style.transition=transition,currentOffset}nativeElement(el){return el?el.nativeElement||el:null}position(element,popup,scale=1){return element&&popup?((element,parent,scale=1)=>{const offsetParentElement=parent?offset_parent(parent):null,{top:top,left:left,height:height,width:width}=((element,parent)=>{const win=es2015_window(element),elementStyles=win.getComputedStyle(element),offset=es2015_offset(element),parentElement=parent||offset_parent(element),ownerDocument=element.ownerDocument;let parentOffset={top:0,left:0};if(\"fixed\"!==elementStyles.position&&parentElement!==ownerDocument.body&&parentElement!==ownerDocument.documentElement){const parentStyles=win.getComputedStyle(parentElement);parentOffset=es2015_offset(parentElement),parentOffset.top+=parseInt(parentStyles.borderTopWidth,10),parentOffset.left+=parseInt(parentStyles.borderLeftWidth,10)}return{top:offset.top-parentOffset.top,left:offset.left-parentOffset.left,height:offset.height,width:offset.width}})(element,offsetParentElement),{x:x,y:y}=((offsetParentElement,element)=>offsetParentElement?element_scroll_position(offsetParentElement):function(element){const parent=offset_parent(element);return parent?element_scroll_position(parent):{x:0,y:0}}(element))(offsetParentElement,element),ownerDocument=element.ownerDocument,positionScale=offsetParentElement===ownerDocument.body||offsetParentElement===ownerDocument.documentElement?1:scale;return{top:top+y*positionScale,left:left+x*positionScale,height:height,width:width}})(this.nativeElement(element),this.nativeElement(popup),scale):null}removeScroll(rect,scroll){return function(rect,scroll){return{top:rect.top-scroll.y,left:rect.left-scroll.x,height:rect.height,width:rect.width}}(rect,scroll)}restrictToView(settings){return(options=>{const{anchorRect:anchorRect,anchorAlign:anchorAlign,elementRect:elementRect,elementAlign:elementAlign,collisions:collisions,viewPort:viewPort,margin:margin={}}=options,{top:elementTop,left:elementLeft,height:elementHeight,width:elementWidth}=elementRect,{height:viewPortHeight,width:viewPortWidth}=viewPort,horizontalMargin=margin.horizontal||0,verticalMargin=margin.vertical||0;let left=0,top=0;const isHorizontalFlip=\"flip\"===collisions.horizontal,isVerticalFlip=\"flip\"===collisions.vertical;\"fit\"===collisions.vertical&&(top+=restrict_to_view_fit(elementTop,elementHeight,viewPortHeight)),\"fit\"===collisions.horizontal&&(left+=restrict_to_view_fit(elementLeft,elementWidth,viewPortWidth)),isVerticalFlip&&(top+=restrict_to_view_flip({margin:verticalMargin,offset:elementTop,size:elementHeight,anchorSize:anchorRect.height,viewPortSize:viewPortHeight,anchorAlignPoint:anchorAlign.vertical,elementAlignPoint:elementAlign.vertical})),isHorizontalFlip&&(left+=restrict_to_view_flip({margin:horizontalMargin,offset:elementLeft,size:elementWidth,anchorSize:anchorRect.width,viewPortSize:viewPortWidth,anchorAlignPoint:anchorAlign.horizontal,elementAlignPoint:elementAlign.horizontal}));const flippedHorizontal=isHorizontalFlip&&0!==left,flippedVertical=isVerticalFlip&&0!==top;return{flipped:flippedHorizontal||flippedVertical,flip:{horizontal:flippedHorizontal,vertical:flippedVertical},offset:{left:left,top:top}}})(settings)}scrollPosition(el){return scrollPosition(this.nativeElement(el))}scrollableParents(el){return(element=>{const parentElements=[];if(!isDocumentAvailable()||!isWindowAvailable())return parentElements;let parent=element.parentElement;for(;parent;)(OVERFLOW_REGEXP.test(overflowStyle(parent))||parent.hasAttribute(\"data-scrollable\"))&&parentElements.push(parent),parent=parent.parentElement;return parentElements.push(window),parentElements})(this.nativeElement(el))}stackingElementOffset(el){const relativeContextElement=this.getRelativeContextElement(el);return relativeContextElement?es2015_offset(relativeContextElement):null}stackingElementScroll(el){const relativeContextElement=this.getRelativeContextElement(el);return relativeContextElement?{x:relativeContextElement.scrollLeft,y:relativeContextElement.scrollTop}:{x:0,y:0}}getRelativeContextElement(el){if(!el||!hasRelativeStackingContext())return null;let parent=this.nativeElement(el).parentElement;for(;parent;){if(\"none\"!==window.getComputedStyle(parent).transform)return parent;parent=parent.parentElement}return null}useRelativePosition(el){return!!this.getRelativeContextElement(el)}windowViewPort(el){return windowViewport(this.nativeElement(el))}zIndex(anchor,container){return((anchor,container)=>{if(!anchor||!isDocumentAvailable()||!isWindowAvailable())return null;const sibling=((anchor,container)=>{const parentElements=parents(anchor);let siblingElements,result,containerElement=container;for(;containerElement&&(siblingElements=siblings(containerElement),result=parentElements.reduce((list,p)=>list.concat(siblingElements.filter(s=>s===p)),[])[0],!result);)containerElement=containerElement.parentElement;return result})(anchor,container);if(!sibling)return null;const result=[anchor].concat(parents(anchor,sibling)).reduce((index,p)=>{const zIndexStyle=p.style.zIndex||window.getComputedStyle(p).zIndex,current=parseInt(zIndexStyle,10);return current>index?current:index},0);return result?result+1:null})(this.nativeElement(anchor),this.nativeElement(container))}zoomLevel(){return isDocumentAvailable()&&isWindowAvailable()&&parseFloat((document.documentElement.clientWidth/window.innerWidth).toFixed(2))||1}isZoomed(){return this.zoomLevel()>1}};return DOMService.ɵfac=function(t){return new(t||DOMService)},DOMService.ɵprov=core.Lb({token:DOMService,factory:function(t){return DOMService.ɵfac(t)}}),DOMService})();const SCALE=new core.s(\"Popup Document Scale\");let fesm2015_AlignService=(()=>{let AlignService=class{constructor(_dom,scale=1){this._dom=_dom,this.scale=scale}alignElement(settings){const{anchor:anchor,element:element,anchorAlign:anchorAlign,elementAlign:elementAlign,margin:margin,offset:offset$$1,positionMode:positionMode}=settings,scale=this.scale||1,anchorRect=\"fixed\"!==positionMode&&this._dom.hasOffsetParent(element)?this.relativeRect(anchor,element,offset$$1,scale):this.absoluteRect(anchor,element,offset$$1,scale),elementRect=scaleRect(this._dom.offset(element),scale);return this._dom.align({anchorAlign:anchorAlign,anchorRect:anchorRect,elementAlign:elementAlign,elementRect:elementRect,margin:margin})}absoluteRect(anchor,element,offset$$1,scale){const scrollPos=this.elementScrollPosition(anchor,element),rect=eitherRect(this._dom.offset(anchor),offset$$1),stackScale=2*scale,stackScroll=this._dom.stackingElementScroll(element);1!==scale&&stackScroll&&(stackScroll.x/=stackScale,stackScroll.y/=stackScale);const stackOffset=this._dom.stackingElementOffset(element);return 1!==scale&&stackOffset&&(stackOffset.left/=stackScale,stackOffset.top/=stackScale),this._dom.removeScroll(this._dom.addScroll(((rect,stackingOffset)=>stackingOffset?{height:rect.height,left:rect.left-stackingOffset.left,top:rect.top-stackingOffset.top,width:rect.width}:rect)(scaleRect(rect,scale),stackOffset),stackScroll),scrollPos)}elementScrollPosition(anchor,element){return anchor?{x:0,y:0}:this._dom.scrollPosition(element)}relativeRect(anchor,element,offset$$1,scale){const rect=eitherRect(this._dom.position(anchor,element,scale),offset$$1);return scaleRect(rect,scale)}};return AlignService.ɵfac=function(t){return new(t||AlignService)(core.cc(fesm2015_DOMService),core.cc(SCALE,8))},AlignService.ɵprov=core.Lb({token:AlignService,factory:function(t){return AlignService.ɵfac(t)}}),AlignService=__decorate([__param(1,Object(core.q)(SCALE)),__param(1,Object(core.C)()),__metadata(\"design:paramtypes\",[fesm2015_DOMService,Number])],AlignService),AlignService})(),fesm2015_PositionService=(()=>{let PositionService=class{constructor(_dom,scale=1){this._dom=_dom,this.scale=scale}positionElement(settings){const{anchor:anchor,currentLocation:currentLocation,element:element,anchorAlign:anchorAlign,elementAlign:elementAlign,collisions:collisions,margin:margin}=settings,dom=this._dom,scale=this.scale||1,elementOffset=dom.offsetAtPoint(element,currentLocation),elementRect=scaleRect(elementOffset,scale),anchorOffset=scaleRect(dom.offset(anchor),scale),anchorRect=eitherRect(anchorOffset,currentLocation),viewPort=settings.viewPort||dom.windowViewPort(element);viewPort.width=viewPort.width/scale,viewPort.height=viewPort.height/scale;const result=dom.restrictToView({anchorAlign:anchorAlign,anchorRect:anchorRect,collisions:collisions,elementAlign:elementAlign,elementRect:elementRect,margin:margin,viewPort:viewPort}),offset$$1=dom.addOffset(currentLocation,result.offset);return{flip:result.flip,flipped:result.flipped,offset:offset$$1}}};return PositionService.ɵfac=function(t){return new(t||PositionService)(core.cc(fesm2015_DOMService),core.cc(SCALE,8))},PositionService.ɵprov=core.Lb({token:PositionService,factory:function(t){return PositionService.ɵfac(t)}}),PositionService=__decorate([__param(1,Object(core.q)(SCALE)),__param(1,Object(core.C)()),__metadata(\"design:paramtypes\",[fesm2015_DOMService,Number])],PositionService),PositionService})(),dist_fesm2015_ResizeService=(()=>{let ResizeService=class{constructor(_dom,_zone){this._dom=_dom,this._zone=_zone}subscribe(callback){isDocumentAvailable()&&this._zone.runOutsideAngular(()=>{this.subscription=Object(fromEvent.a)(this._dom.getWindow(),\"resize\").pipe(Object(auditTime.a)(16.666666666666668)).subscribe(()=>callback())})}unsubscribe(){this.subscription&&this.subscription.unsubscribe()}isUnsubscribed(){return this.subscription&&this.subscription.closed}};return ResizeService.ɵfac=function(t){return new(t||ResizeService)(core.cc(fesm2015_DOMService),core.cc(core.B))},ResizeService.ɵprov=core.Lb({token:ResizeService,factory:function(t){return ResizeService.ɵfac(t)}}),ResizeService=__decorate([__metadata(\"design:paramtypes\",[fesm2015_DOMService,core.B])],ResizeService),ResizeService})(),fesm2015_ScrollableService=(()=>{let ScrollableService=class{constructor(_dom,_zone){this._dom=_dom,this._zone=_zone}forElement(element){return this.unsubscribe(),this.element=element,this}subscribe(callback){if(!callback||!isDocumentAvailable()||!this.element)return;const nativeElement=this._dom.nativeElement(this.element),parents$$1=this._dom.scrollableParents(this.element);this._zone.runOutsideAngular(()=>{const observables=parents$$1.map(p=>Object(fromEvent.a)(p,\"scroll\").pipe(Object(auditTime.a)(16.666666666666668)));this.subscription=Object(merge.a)(...observables).subscribe(e=>{const target=e.target,isParent=parents$$1.filter(p=>p===target).length>0,isDocument=target===document,isWindow=target===window;(isParent||isDocument||isWindow)&&callback(this.isVisible(nativeElement,target))})})}unsubscribe(){this.subscription&&this.subscription.unsubscribe()}isVisible(elem,container){const elemRect=this._dom.boundingOffset(elem),containerRect=this._dom.boundingOffset(container);return!(1<containerRect.top-elemRect.bottom||1<elemRect.top-containerRect.bottom||1<elemRect.left-containerRect.right||1<containerRect.left-elemRect.right)}};return ScrollableService.ɵfac=function(t){return new(t||ScrollableService)(core.cc(fesm2015_DOMService),core.cc(core.B))},ScrollableService.ɵprov=core.Lb({token:ScrollableService,factory:function(t){return ScrollableService.ɵfac(t)}}),ScrollableService=__decorate([__metadata(\"design:paramtypes\",[fesm2015_DOMService,core.B])],ScrollableService),ScrollableService})();const animationTypes={expand:direction=>{const scale=\"up\"===direction||\"down\"===direction?\"scaleY\":\"scaleX\";let origin;return origin=\"down\"===direction?\"top\":\"left\"===direction?\"right\":\"right\"===direction?\"left\":\"bottom\",{start:{transform:scale+\"(0)\",transformOrigin:origin},end:{transform:scale+\"(1)\"}}},slide:direction=>{const translate=\"left\"===direction||\"right\"===direction?\"translateX\":\"translateY\";return{start:{transform:`${translate}(${\"right\"===direction||\"down\"===direction?-100:100}%)`},end:{transform:translate+\"(0%)\"}}},fade:()=>({start:{opacity:0},end:{opacity:1}}),zoom:()=>({start:{transform:\"scale(0)\"},end:{transform:\"scale(1)\"}})};let fesm2015_AnimationService=(()=>{let AnimationService=class{constructor(animationBuilder){this.animationBuilder=animationBuilder,this.start=new core.o,this.end=new core.o}play(element,options,flip){if(!this.flip||this.flip.horizontal!==flip.horizontal||this.flip.vertical!==flip.vertical){this.flip=flip;const type=options.type||\"slide\",statesFn=animationTypes[type];if(statesFn){const states=statesFn(this.getDirection(flip,options));this.playStates(element,states,options)}else if(Object(core.Y)())throw new Error(`Unsupported animation type: \"${type}\". The supported types are slide, expand, fade and zoom.`)}}ngOnDestroy(){this.stopPlayer()}playStates(element,states,options){this.stopPlayer();const duration=options.duration||100,factory=this.animationBuilder.build([Object(animations.k)(states.start),Object(animations.e)(duration+\"ms ease-in\",Object(animations.k)(states.end))]),player=this.player=factory.create(element);player.onDone(()=>{this.end.emit(),this.stopPlayer()}),this.start.emit(),player.play()}getDirection(flip,options){let direction=options.direction||\"down\";return flip.horizontal&&(\"left\"===direction?direction=\"right\":\"right\"===direction&&(direction=\"left\")),flip.vertical&&(\"down\"===direction?direction=\"up\":\"up\"===direction&&(direction=\"down\")),direction}stopPlayer(){this.player&&(this.player.destroy(),this.player=null)}};return AnimationService.ɵfac=function(t){return new(t||AnimationService)(core.cc(animations.b))},AnimationService.ɵprov=core.Lb({token:AnimationService,factory:function(t){return AnimationService.ɵfac(t)}}),AnimationService=__decorate([__metadata(\"design:paramtypes\",[animations.b])],AnimationService),AnimationService})();const packageMetadata={name:\"@progress/kendo-angular-popup\",productName:\"Kendo UI for Angular\",productCodes:[\"KENDOUIANGULAR\",\"KENDOUICOMPLETE\"],publishDate:1620213546,version:\"\",licensingDocsUrl:\"https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning\"},DEFAULT_OFFSET={left:-1e4,top:0};let fesm2015_PopupComponent=(()=>{let PopupComponent=class{constructor(container,_alignService,domService,_positionService,_resizeService,_scrollableService,animationService,_renderer,_zone){this.container=container,this._alignService=_alignService,this.domService=domService,this._positionService=_positionService,this._resizeService=_resizeService,this._scrollableService=_scrollableService,this.animationService=animationService,this._renderer=_renderer,this._zone=_zone,this.animate=!0,this.anchorAlign={horizontal:\"left\",vertical:\"bottom\"},this.collision={horizontal:\"fit\",vertical:\"flip\"},this.popupAlign={horizontal:\"left\",vertical:\"top\"},this.copyAnchorStyles=!1,this.positionMode=\"fixed\",this.offset=DEFAULT_OFFSET,this.anchorViewportLeave=new core.o,this.close=new core.o,this.open=new core.o,this.positionChange=new core.o,this.resolvedPromise=Promise.resolve(null),this.initialCheck=!0,validatePackage(packageMetadata),this._renderer.addClass(container.nativeElement,\"k-animation-container\"),this.updateFixedClass()}ngOnInit(){this.reposition=this.reposition.bind(this),this._resizeService.subscribe(this.reposition),this.animationSubscriptions=this.animationService.start.subscribe(this.onAnimationStart.bind(this)),this.animationSubscriptions.add(this.animationService.end.subscribe(this.onAnimationEnd.bind(this))),this._scrollableService.forElement(this.anchor||this.container).subscribe(this.onScroll.bind(this)),this.currentOffset=DEFAULT_OFFSET,this.setZIndex(),this.copyFontStyles(),this.updateFixedClass()}ngOnChanges(changes){changes.copyAnchorStyles&&this.copyFontStyles(),changes.positionMode&&this.updateFixedClass()}ngAfterViewInit(){this.reposition(),this.animate||this.resolvedPromise.then(()=>{this.onAnimationEnd()})}ngAfterViewChecked(){this.initialCheck?this.initialCheck=!1:this._zone.runOutsideAngular(()=>{this.unsubscribeReposition(),this.repositionSubscription=Object(observable_from.a)(this.resolvedPromise).subscribe(this.reposition)})}ngOnDestroy(){this.anchorViewportLeave.complete(),this.positionChange.complete(),this.close.emit(),this.close.complete(),this._resizeService.unsubscribe(),this._scrollableService.unsubscribe(),this.animationSubscriptions.unsubscribe(),this.unsubscribeReposition()}onResize(){this.reposition()}onAnimationStart(){this._renderer.removeClass(this.container.nativeElement,\"k-animation-container-shown\")}onAnimationEnd(){this._renderer.addClass(this.container.nativeElement,\"k-animation-container-shown\"),this.open.emit(),this.open.complete()}get currentOffset(){return this._currentOffset}set currentOffset(offset$$1){this.setContainerStyle(\"left\",offset$$1.left+\"px\"),this.setContainerStyle(\"top\",offset$$1.top+\"px\"),this._currentOffset=offset$$1}setZIndex(){this.anchor&&this.setContainerStyle(\"z-index\",String(this.domService.zIndex(this.anchor,this.container)))}reposition(){if(!isDocumentAvailable())return;const{flip:flip,offset:offset$$1}=this.position();this.currentOffset&&!((oldOffset,newOffset)=>{const{left:oldLeft,top:oldTop}=oldOffset,{left:newLeft,top:newTop}=newOffset;return Math.abs(oldLeft-newLeft)>=1||Math.abs(oldTop-newTop)>=1})(this.currentOffset,offset$$1)||(this.currentOffset=offset$$1,hasObservers(this.positionChange)&&this._zone.run(()=>this.positionChange.emit({offset:offset$$1,flip:flip}))),this.animate&&this.animationService.play(this.contentContainer.nativeElement,this.animate,flip),this.resizeSensor.acceptSize()}position(){const alignedOffset=this._alignService.alignElement({anchor:this.anchor,anchorAlign:this.anchorAlign,element:this.container,elementAlign:this.popupAlign,margin:this.margin,offset:this.offset,positionMode:this.positionMode});return this._positionService.positionElement({anchor:this.anchor,anchorAlign:this.anchorAlign,collisions:this.collision,currentLocation:alignedOffset,element:this.container,elementAlign:this.popupAlign,margin:this.margin})}onScroll(isInViewPort){const hasLeaveObservers=hasObservers(this.anchorViewportLeave);isInViewPort||!hasLeaveObservers?this.reposition():hasLeaveObservers&&this._zone.run(()=>{this.anchorViewportLeave.emit()})}copyFontStyles(){this.anchor&&this.copyAnchorStyles&&this.domService.getFontStyles(this.anchor).forEach(s=>this.setContainerStyle(s.key,s.value))}updateFixedClass(){this._renderer[\"fixed\"===this.positionMode?\"addClass\":\"removeClass\"](this.container.nativeElement,\"k-animation-container-fixed\")}setContainerStyle(name,value){this._renderer.setStyle(this.container.nativeElement,name,value)}unsubscribeReposition(){this.repositionSubscription&&this.repositionSubscription.unsubscribe()}};return PopupComponent.ɵfac=function(t){return new(t||PopupComponent)(core.Pb(core.l),core.Pb(fesm2015_AlignService),core.Pb(fesm2015_DOMService),core.Pb(fesm2015_PositionService),core.Pb(dist_fesm2015_ResizeService),core.Pb(fesm2015_ScrollableService),core.Pb(fesm2015_AnimationService),core.Pb(core.G),core.Pb(core.B))},PopupComponent.ɵcmp=core.Jb({type:PopupComponent,selectors:[[\"kendo-popup\"]],viewQuery:function(rf,ctx){if(1&rf&&(core.Gc(_c0,!0),core.Gc(fesm2015_ResizeSensorComponent,!0)),2&rf){let _t;core.wc(_t=core.hc())&&(ctx.contentContainer=_t.first),core.wc(_t=core.hc())&&(ctx.resizeSensor=_t.first)}},inputs:{animate:\"animate\",anchorAlign:\"anchorAlign\",collision:\"collision\",popupAlign:\"popupAlign\",copyAnchorStyles:\"copyAnchorStyles\",positionMode:\"positionMode\",offset:\"offset\",anchor:\"anchor\",popupClass:\"popupClass\",margin:\"margin\"},outputs:{anchorViewportLeave:\"anchorViewportLeave\",close:\"close\",open:\"open\",positionChange:\"positionChange\"},exportAs:[\"kendo-popup\"],features:[core.Bb([fesm2015_AlignService,fesm2015_AnimationService,fesm2015_DOMService,fesm2015_PositionService,dist_fesm2015_ResizeService,fesm2015_ScrollableService]),core.Ab],ngContentSelectors:_c1,decls:5,vars:4,consts:[[1,\"k-popup\",3,\"ngClass\"],[\"container\",\"\"],[3,\"ngTemplateOutlet\",\"ngIf\"],[3,\"rateLimit\",\"resize\"]],template:function(rf,ctx){1&rf&&(core.oc(),core.Vb(0,\"div\",0,1),core.nc(2),core.Kc(3,PopupComponent_ng_template_3_Template,0,0,\"ng-template\",2),core.Vb(4,\"kendo-resize-sensor\",3),core.gc(\"resize\",function(){return ctx.onResize()}),core.Ub(),core.Ub()),2&rf&&(core.pc(\"ngClass\",ctx.popupClass),core.Cb(3),core.pc(\"ngTemplateOutlet\",ctx.content)(\"ngIf\",ctx.content),core.Cb(1),core.pc(\"rateLimit\",100))},directives:[common.j,common.q,common.l,fesm2015_ResizeSensorComponent],encapsulation:2}),PopupComponent=__decorate([__metadata(\"design:paramtypes\",[core.l,fesm2015_AlignService,fesm2015_DOMService,fesm2015_PositionService,dist_fesm2015_ResizeService,fesm2015_ScrollableService,fesm2015_AnimationService,core.G,core.B])],PopupComponent),PopupComponent})();const POPUP_CONTAINER=new core.s(\"Popup Container\");let fesm2015_PopupService=(()=>{let PopupService=class{constructor(applicationRef,componentFactoryResolver,injector,container){this.applicationRef=applicationRef,this.componentFactoryResolver=componentFactoryResolver,this.injector=injector,this.container=container}get rootViewContainer(){const rootComponents=this.applicationRef.components||[];if(rootComponents[0])return rootComponents[0];throw new Error(\"\\n            View Container not found! Inject the POPUP_CONTAINER or define a specific ViewContainerRef via the appendTo option.\\n            See http://www.telerik.com/kendo-angular-ui/components/popup/api/POPUP_CONTAINER/ for more details.\\n        \")}get rootViewContainerNode(){return this.container?this.container.nativeElement:this.getComponentRootNode(this.rootViewContainer)}open(options={}){const{component:component,nodes:nodes}=this.contentFrom(options.content),popupComponentRef=this.appendPopup(nodes,options.appendTo),popupInstance=popupComponentRef.instance;this.projectComponentInputs(popupComponentRef,options),popupComponentRef.changeDetectorRef.detectChanges(),component&&component.changeDetectorRef.detectChanges();const popupElement=this.getComponentRootNode(popupComponentRef);return{close:()=>{var element;component&&component.destroy(),popupComponentRef.destroy(),(element=popupElement)&&element.parentNode&&element.parentNode.removeChild(element)},content:component,popup:popupComponentRef,popupAnchorViewportLeave:popupInstance.anchorViewportLeave,popupClose:popupInstance.close,popupElement:popupElement,popupOpen:popupInstance.open,popupPositionChange:popupInstance.positionChange}}appendPopup(nodes,container){const popupComponentRef=this.createComponent(fesm2015_PopupComponent,nodes,container);return container||this.rootViewContainerNode.appendChild(this.getComponentRootNode(popupComponentRef)),popupComponentRef}getComponentRootNode(componentRef){return componentRef.location.nativeElement}getComponentFactory(componentClass){return this.componentFactoryResolver.resolveComponentFactory(componentClass)}createComponent(componentClass,nodes,container){const factory=this.getComponentFactory(componentClass);if(container)return container.createComponent(factory,void 0,this.injector,nodes);{const component=factory.create(this.injector,nodes);return this.applicationRef.attachView(component.hostView),component}}projectComponentInputs(component,options){return Object.getOwnPropertyNames(options).filter(prop=>\"content\"!==prop||options.content instanceof core.O).map(prop=>{component.instance[prop]=options[prop]}),component}contentFrom(content){if(!content||content instanceof core.O)return{component:null,nodes:[[]]};const component=this.createComponent(content);return{component:component,nodes:[component?[component.location.nativeElement]:[]]}}};return PopupService.ɵfac=function(t){return new(t||PopupService)(core.cc(core.g),core.cc(core.j),core.cc(core.t),core.cc(POPUP_CONTAINER,8))},PopupService.ɵprov=core.Lb({token:PopupService,factory:function(t){return PopupService.ɵfac(t)}}),PopupService=__decorate([__param(3,Object(core.q)(POPUP_CONTAINER)),__param(3,Object(core.C)()),__metadata(\"design:paramtypes\",[core.g,core.j,core.t,core.l])],PopupService),PopupService})(),fesm2015_PopupModule=(()=>{let PopupModule=class{};return PopupModule.ɵmod=core.Nb({type:PopupModule}),PopupModule.ɵinj=core.Mb({factory:function(t){return new(t||PopupModule)},providers:[fesm2015_PopupService],imports:[[common.c,fesm2015_ResizeSensorModule]]}),PopupModule})();__webpack_require__(\"zP0r\");var operators_map=__webpack_require__(\"lJxs\");let fesm2015_MessageService=(()=>{let MessageService=class{constructor(){this.changes=new Subject.a}notify(rtl){this.changes.next({rtl:rtl})}get(key){}};return MessageService.ɵfac=function(t){return new(t||MessageService)},MessageService.ɵprov=core.Lb({token:MessageService,factory:function(t){return MessageService.ɵfac(t)}}),MessageService})();const RTL=new core.s(\"Kendo UI Right-to-Left token\"),L10N_PREFIX=new core.s(\"Localization key prefix\");let fesm2015_LocalizationService=(()=>{let LocalizationService=class{constructor(prefix,messageService,_rtl){this.prefix=prefix,this.messageService=messageService,this._rtl=_rtl,this.changes=new BehaviorSubject.a({rtl:this._rtl}),this.dictionary={},messageService&&(this.subscription=messageService.changes.pipe(Object(operators_map.a)(({rtl:rtl})=>void 0!==rtl?rtl:this._rtl),Object(tap.a)(rtl=>this._rtl=rtl)).subscribe(rtl=>{this.dictionary={},this.changes.next({rtl:rtl})}))}get rtl(){return this._rtl}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}get(shortKey){const key=this.key(shortKey);return this.dictionary[key]}register(shortKey,value,override=!1){const key=this.key(shortKey);let message=value;if(!override){if(this.dictionary.hasOwnProperty(key))return;message=this.defaultValue(key,value)}this.dictionary[key]=message}notifyChanges(){this.changes.next({rtl:this.rtl})}key(shortKey){return this.prefix+\".\"+shortKey}defaultValue(key,value){if(!this.messageService)return value;const alt=this.messageService.get(key);return void 0===alt?value:alt}};return LocalizationService.ɵfac=function(t){return new(t||LocalizationService)(core.cc(L10N_PREFIX),core.cc(fesm2015_MessageService,8),core.cc(RTL,8))},LocalizationService.ɵprov=core.Lb({token:LocalizationService,factory:function(t){return LocalizationService.ɵfac(t)}}),LocalizationService=__decorate([__param(0,Object(core.q)(L10N_PREFIX)),__param(1,Object(core.C)()),__param(2,Object(core.C)()),__param(2,Object(core.q)(RTL)),__metadata(\"design:paramtypes\",[String,fesm2015_MessageService,Boolean])],LocalizationService),LocalizationService})();function is_string_isString(value){return\"string\"==typeof value}const formatRegExp=/\\{(\\d+)}?\\}/g;class IntlError{constructor({name:name,message:message}){if(!name||!message)throw new Error(\"{ name: string, message: string } object is required!\");this.name=name,this.message=message}formatMessage(...values){const flattenValues=flatten(values),formattedMessage=this.message.replace(formatRegExp,function(match,index){return flattenValues[parseInt(index,10)]});return`${this.name}: ${formattedMessage}`}error(...values){return new Error(this.formatMessage(values))}}const flatten=function(arr){return arr.reduce((a,b)=>a.concat(b),[])},errors=function(errors){return Object.keys(errors).reduce(function(prev,name){return prev[name]=new IntlError({name:name,message:errors[name]}),prev},{})}({NoLocale:\"Missing locale info for '{0}'\",NoCurrency:\"Cannot determine currency information. Please load the locale currencies data.\",NoSupplementalCurrency:\"Cannot determine currency. Please load the supplemental currencyData.\",NoCurrencyRegion:\"No currency data for region '{0}'\",NoCurrencyDisplay:\"Cannot determine currency display information. Please load the locale currencies data. The default culture does not include the all currencies data.\",NoGMTInfo:\"Cannot determine locale GMT format. Please load the locale timeZoneNames data.\",NoWeekData:\"Cannot determine locale first day of week. Please load the supplemental weekData.\",NoFirstDay:\"Cannot determine locale first day of week. Please load the supplemental weekData. The default culture includes only the 'en-US' first day info.\",NoValidCurrency:\"Cannot determine a default currency for the {0} locale. Please specify explicitly the currency with the format options.\",NoDateFieldNames:\"Cannot determine the locale date field names. Please load the locale dateFields data.\"}),cldr={en:{name:\"en\",identity:{version:{_number:\"$Revision: 12418 $\",_cldrVersion:\"29\"},language:\"en\"},territory:\"US\",numbers:{symbols:{decimal:\".\",group:\",\",list:\";\",percentSign:\"%\",plusSign:\"+\",minusSign:\"-\",exponential:\"E\",superscriptingExponent:\"×\",perMille:\"‰\",infinity:\"∞\",nan:\"NaN\",timeSeparator:\":\"},decimal:{patterns:[\"n\"],groupSize:[3]},scientific:{patterns:[\"nEn\"],groupSize:[]},percent:{patterns:[\"n%\"],groupSize:[3]},currency:{patterns:[\"$n\"],groupSize:[3],\"unitPattern-count-one\":\"n $\",\"unitPattern-count-other\":\"n $\"},currencies:{BGN:{displayName:\"Bulgarian Lev\",\"displayName-count-one\":\"Bulgarian lev\",\"displayName-count-other\":\"Bulgarian leva\",symbol:\"BGN\"},EUR:{displayName:\"Euro\",\"displayName-count-one\":\"euro\",\"displayName-count-other\":\"euros\",symbol:\"€\",\"symbol-alt-narrow\":\"€\"},USD:{displayName:\"US Dollar\",\"displayName-count-one\":\"US dollar\",\"displayName-count-other\":\"US dollars\",symbol:\"$\",\"symbol-alt-narrow\":\"$\"}},localeCurrency:\"USD\",accounting:{patterns:[\"$n\",\"($n)\"],groupSize:[3]}},calendar:{gmtFormat:\"GMT{0}\",gmtZeroFormat:\"GMT\",patterns:{d:\"M/d/y\",D:\"EEEE, MMMM d, y\",m:\"MMM d\",M:\"MMMM d\",y:\"MMM y\",Y:\"MMMM y\",F:\"EEEE, MMMM d, y h:mm:ss a\",g:\"M/d/y h:mm a\",G:\"M/d/y h:mm:ss a\",t:\"h:mm a\",T:\"h:mm:ss a\",s:\"yyyy'-'MM'-'dd'T'HH':'mm':'ss\",u:\"yyyy'-'MM'-'dd HH':'mm':'ss'Z'\"},dateTimeFormats:{full:\"{1} 'at' {0}\",long:\"{1} 'at' {0}\",medium:\"{1}, {0}\",short:\"{1}, {0}\",availableFormats:{Bh:\"h B\",Bhm:\"h:mm B\",Bhms:\"h:mm:ss B\",d:\"d\",E:\"ccc\",EBhm:\"E h:mm B\",EBhms:\"E h:mm:ss B\",Ed:\"d E\",Ehm:\"E h:mm a\",EHm:\"E HH:mm\",Ehms:\"E h:mm:ss a\",EHms:\"E HH:mm:ss\",Gy:\"y G\",GyMMM:\"MMM y G\",GyMMMd:\"MMM d, y G\",GyMMMEd:\"E, MMM d, y G\",h:\"h a\",H:\"HH\",hm:\"h:mm a\",Hm:\"HH:mm\",hms:\"h:mm:ss a\",Hms:\"HH:mm:ss\",hmsv:\"h:mm:ss a v\",Hmsv:\"HH:mm:ss v\",hmv:\"h:mm a v\",Hmv:\"HH:mm v\",M:\"L\",Md:\"M/d\",MEd:\"E, M/d\",MMM:\"LLL\",MMMd:\"MMM d\",MMMEd:\"E, MMM d\",MMMMd:\"MMMM d\",\"MMMMW-count-one\":\"'week' W 'of' MMMM\",\"MMMMW-count-other\":\"'week' W 'of' MMMM\",ms:\"mm:ss\",y:\"y\",yM:\"M/y\",yMd:\"M/d/y\",yMEd:\"E, M/d/y\",yMMM:\"MMM y\",yMMMd:\"MMM d, y\",yMMMEd:\"E, MMM d, y\",yMMMM:\"MMMM y\",yQQQ:\"QQQ y\",yQQQQ:\"QQQQ y\",\"yw-count-one\":\"'week' w 'of' Y\",\"yw-count-other\":\"'week' w 'of' Y\"}},timeFormats:{full:\"h:mm:ss a zzzz\",long:\"h:mm:ss a z\",medium:\"h:mm:ss a\",short:\"h:mm a\"},dateFormats:{full:\"EEEE, MMMM d, y\",long:\"MMMM d, y\",medium:\"MMM d, y\",short:\"M/d/yy\"},days:{format:{abbreviated:[\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\"],narrow:[\"S\",\"M\",\"T\",\"W\",\"T\",\"F\",\"S\"],short:[\"Su\",\"Mo\",\"Tu\",\"We\",\"Th\",\"Fr\",\"Sa\"],wide:[\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"]},\"stand-alone\":{abbreviated:[\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\"],narrow:[\"S\",\"M\",\"T\",\"W\",\"T\",\"F\",\"S\"],short:[\"Su\",\"Mo\",\"Tu\",\"We\",\"Th\",\"Fr\",\"Sa\"],wide:[\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"]}},months:{format:{abbreviated:[\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"],narrow:[\"J\",\"F\",\"M\",\"A\",\"M\",\"J\",\"J\",\"A\",\"S\",\"O\",\"N\",\"D\"],wide:[\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"]},\"stand-alone\":{abbreviated:[\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"],narrow:[\"J\",\"F\",\"M\",\"A\",\"M\",\"J\",\"J\",\"A\",\"S\",\"O\",\"N\",\"D\"],wide:[\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"]}},quarters:{format:{abbreviated:[\"Q1\",\"Q2\",\"Q3\",\"Q4\"],narrow:[\"1\",\"2\",\"3\",\"4\"],wide:[\"1st quarter\",\"2nd quarter\",\"3rd quarter\",\"4th quarter\"]},\"stand-alone\":{abbreviated:[\"Q1\",\"Q2\",\"Q3\",\"Q4\"],narrow:[\"1\",\"2\",\"3\",\"4\"],wide:[\"1st quarter\",\"2nd quarter\",\"3rd quarter\",\"4th quarter\"]}},dayPeriods:{format:{abbreviated:{midnight:\"midnight\",am:\"AM\",\"am-alt-variant\":\"am\",noon:\"noon\",pm:\"PM\",\"pm-alt-variant\":\"pm\",morning1:\"in the morning\",afternoon1:\"in the afternoon\",evening1:\"in the evening\",night1:\"at night\"},narrow:{midnight:\"mi\",am:\"a\",\"am-alt-variant\":\"am\",noon:\"n\",pm:\"p\",\"pm-alt-variant\":\"pm\",morning1:\"in the morning\",afternoon1:\"in the afternoon\",evening1:\"in the evening\",night1:\"at night\"},wide:{midnight:\"midnight\",am:\"AM\",\"am-alt-variant\":\"am\",noon:\"noon\",pm:\"PM\",\"pm-alt-variant\":\"pm\",morning1:\"in the morning\",afternoon1:\"in the afternoon\",evening1:\"in the evening\",night1:\"at night\"}},\"stand-alone\":{abbreviated:{midnight:\"midnight\",am:\"AM\",\"am-alt-variant\":\"am\",noon:\"noon\",pm:\"PM\",\"pm-alt-variant\":\"pm\",morning1:\"morning\",afternoon1:\"afternoon\",evening1:\"evening\",night1:\"night\"},narrow:{midnight:\"midnight\",am:\"AM\",\"am-alt-variant\":\"am\",noon:\"noon\",pm:\"PM\",\"pm-alt-variant\":\"pm\",morning1:\"morning\",afternoon1:\"afternoon\",evening1:\"evening\",night1:\"night\"},wide:{midnight:\"midnight\",am:\"AM\",\"am-alt-variant\":\"am\",noon:\"noon\",pm:\"PM\",\"pm-alt-variant\":\"pm\",morning1:\"morning\",afternoon1:\"afternoon\",evening1:\"evening\",night1:\"night\"}}},eras:{format:{wide:{0:\"Before Christ\",1:\"Anno Domini\",\"0-alt-variant\":\"Before Common Era\",\"1-alt-variant\":\"Common Era\"},abbreviated:{0:\"BC\",1:\"AD\",\"0-alt-variant\":\"BCE\",\"1-alt-variant\":\"CE\"},narrow:{0:\"B\",1:\"A\",\"0-alt-variant\":\"BCE\",\"1-alt-variant\":\"CE\"}}},dateFields:{era:{wide:\"era\"},year:{wide:\"year\",short:\"yr.\",narrow:\"yr.\"},quarter:{wide:\"quarter\",short:\"qtr.\",narrow:\"qtr.\"},month:{wide:\"month\",short:\"mo.\",narrow:\"mo.\"},week:{wide:\"week\",short:\"wk.\",narrow:\"wk.\"},day:{wide:\"day\",short:\"day\",narrow:\"day\"},weekday:{wide:\"day of the week\"},dayperiod:{wide:\"AM/PM\"},hour:{wide:\"hour\",short:\"hr.\",narrow:\"hr.\"},minute:{wide:\"minute\",short:\"min.\",narrow:\"min.\"},second:{wide:\"second\",short:\"sec.\",narrow:\"sec.\"},millisecond:{wide:\"millisecond\",short:\"ms\",narrow:\"ms\"},zone:{wide:\"time zone\"}}}},supplemental:{likelySubtags:{en:\"en-Latn-US\"},currencyData:{region:{US:[{USD:{_from:\"1792-01-01\"}}]}},weekData:{firstDay:{US:\"sun\"},weekendStart:{\"001\":\"sat\"},weekendEnd:{\"001\":\"sun\"}}}};function getLocaleInfo(locale){let info;return info=is_string_isString(locale)?info_localeInfo(locale):locale,info}function info_localeInfo(locale){if(cldr[locale])return cldr[locale];if(cldr.supplemental.likelySubtags){const parts=locale.split(\"-\"),language=parts[0],suffixes=parts.slice(1),fullName=function(language,suffixes){const likelySubtags=cldr.supplemental.likelySubtags;for(let idx=0;idx<suffixes.length;idx++){let name=likelySubtags[language+\"-\"+suffixes[idx]];if(name)return name}if(likelySubtags[language])return likelySubtags[language]}(language,suffixes),info=fullName?function(fullName,suffixes){const parts=fullName.split(\"-\"),language=parts[0],script=parts[1],territory=parts[2];return cldr[fullName]||-1!==suffixes.indexOf(territory)&&cldr[language+\"-\"+territory]||-1!==suffixes.indexOf(script)&&cldr[language+\"-\"+script]||cldr[language]}(fullName,suffixes):null;if(info)return info}throw errors.NoLocale.error(locale)}const patternRegExp=/([#,0.]+)/g,cldrCurrencyRegExp=/¤/g;function getPatterns(pattern){return patternRegExp.lastIndex=0,pattern.replace(cldrCurrencyRegExp,\"$\").replace(patternRegExp,\"n\").split(\";\")}function getGroupSize(pattern){return patternRegExp.lastIndex=0,patternRegExp.exec(pattern.split(\";\")[0])[0].split(\".\")[0].split(\",\").slice(1).map(function(group){return group.length}).reverse()}function loadCurrencyUnitPatterns(currencyInfo,currencyFormats){for(let field in currencyFormats)field.startsWith(\"unitPattern\")&&(currencyInfo[field]=currencyFormats[field].replace(\"{0}\",\"n\").replace(\"{1}\",\"$\"))}function loadNumbersInfo(locale,info){const localeInfo=cldr[locale],numbers=localeInfo.numbers=localeInfo.numbers||{};numbers.symbols=numbers.symbols||{};for(let field in info)if(\"symbols-numberSystem-latn\"===field)Object.assign(numbers.symbols,info[field]);else if(field.includes(\"Formats-numberSystem-latn\")){const style=field.substr(0,field.indexOf(\"Formats-numberSystem-latn\")),pattern=info[field].standard;numbers[style]={patterns:getPatterns(pattern)},\"currency\"===style?(numbers[style].groupSize=getGroupSize((info[\"decimalFormats-numberSystem-latn\"]||info[field]).standard),loadCurrencyUnitPatterns(numbers[style],info[field]),numbers.accounting={patterns:getPatterns(info[field].accounting),groupSize:numbers[style].groupSize}):numbers[style].groupSize=getGroupSize(pattern)}else\"currencies\"===field&&(numbers.currencies=info[field])}const predefinedDatePatterns={s:\"yyyy'-'MM'-'dd'T'HH':'mm':'ss\",u:\"yyyy'-'MM'-'dd HH':'mm':'ss'Z'\"},YEAR_REGEX=/y+/g,SHORT_DATE=[[\"dateFormats\",\"short\"]],datePatterns={D:[[\"dateFormats\",\"full\"]],m:[[\"dateTimeFormats\",\"availableFormats\",\"MMMd\"]],M:[[\"dateTimeFormats\",\"availableFormats\",\"MMMMd\"]],y:[[\"dateTimeFormats\",\"availableFormats\",\"yMMM\"]],Y:[[\"dateTimeFormats\",\"availableFormats\",\"yMMMM\"]],F:[[\"dateFormats\",\"full\"],[\"timeFormats\",\"medium\"]],g:[[\"dateTimeFormats\",\"availableFormats\",\"yMd\"],[\"timeFormats\",\"short\"]],G:[[\"dateTimeFormats\",\"availableFormats\",\"yMd\"],[\"timeFormats\",\"medium\"]],t:[[\"timeFormats\",\"short\"]],T:[[\"timeFormats\",\"medium\"]]};function toArray(obj){let result=[],names=Object.getOwnPropertyNames(obj);for(let idx=0;idx<names.length;idx++)result.push(obj[names[idx]]);return result}function getCalendarNames(info,isObj){const result={};for(let formatType in info){let names=result[formatType]={};for(let format in info[formatType]){let formats=info[formatType][format];names[format]=isObj?formats:toArray(formats)}}return result}function loadCalendarNames(locale,calendar){const localeCalendar=cldr[locale].calendar;localeCalendar.days=getCalendarNames(calendar.days),localeCalendar.months=getCalendarNames(calendar.months),localeCalendar.quarters=getCalendarNames(calendar.quarters),localeCalendar.dayPeriods=getCalendarNames(calendar.dayPeriods,!0),localeCalendar.eras=function(eras){const result={},format=result.format={},eraNameMap={eraAbbr:\"abbreviated\",eraNames:\"wide\",eraNarrow:\"narrow\"};for(let eraFormatName in eras)format[eraNameMap[eraFormatName]]=eras[eraFormatName];return result}(calendar.eras)}function loadCalendarDateFields(locale,fields){const localeCalendar=cldr[locale].calendar,dateFields={};for(let field in fields){const[fieldName,formatType=\"wide\"]=field.split(\"-\"),fieldInfo=dateFields[fieldName]||{},displayName=fields[field].displayName;displayName&&(fieldInfo[formatType]=displayName,dateFields[fieldName]=fieldInfo)}localeCalendar.dateFields=dateFields}function getPredefinedFormat(paths,calendar){const result=[];for(let pathIdx=0;pathIdx<paths.length;pathIdx++){let fields=paths[pathIdx],pattern=calendar;for(let idx=0;idx<fields.length;idx++)pattern=pattern[fields[idx]];result.push(pattern)}return result.join(\" \")}function loadCalendarPatterns(locale,calendar){const cldrCalendar=cldr[locale].calendar,patterns=cldrCalendar.patterns={};patterns.d=getPredefinedFormat(SHORT_DATE,calendar).replace(YEAR_REGEX,\"y\");for(let pattern in datePatterns)patterns[pattern]=getPredefinedFormat(datePatterns[pattern],calendar);for(let pattern in predefinedDatePatterns)patterns[pattern]=predefinedDatePatterns[pattern];const dateTimeFormats=calendar.dateTimeFormats;cldrCalendar.dateTimeFormats={full:dateTimeFormats.full,long:dateTimeFormats.long,medium:dateTimeFormats.medium,short:dateTimeFormats.short,availableFormats:dateTimeFormats.availableFormats},cldrCalendar.timeFormats=calendar.timeFormats,cldrCalendar.dateFormats=calendar.dateFormats}function loadCalendarInfo(locale,info){const calendar=cldr[locale].calendar=cldr[locale].calendar||{};for(let field in info)\"timeZoneNames\"===field?(calendar.gmtFormat=info[field].gmtFormat,calendar.gmtZeroFormat=info[field].gmtZeroFormat):\"calendars\"===field&&info[field].gregorian?(loadCalendarPatterns(locale,info[field].gregorian),loadCalendarNames(locale,info[field].gregorian)):\"fields\"===field&&loadCalendarDateFields(locale,info.fields)}function localeTerritory(info){if(info.territory)return info.territory;const identity=info.identity;let territory;return territory=identity&&identity.territory?identity.territory:function(name,identity){const likelySubtags=cldr.supplemental.likelySubtags;let parts=name.split(\"-\");if(likelySubtags){const likelyName=likelySubtags[name]||likelySubtags[parts[0]];likelyName&&(parts=likelyName.split(\"-\"))}if(identity)for(let idx=parts.length-1;idx>=1;idx--){const part=parts[idx];part!==identity.variant&&part!==identity.script||parts.splice(idx,1)}const length=parts.length;if(length>1)return parts[length-1].toUpperCase()}(info.name,identity),info.territory=territory,territory}function loadLocale(locale,info){for(let field in info)\"numbers\"===field?loadNumbersInfo(locale,info[field]):\"dates\"===field&&loadCalendarInfo(locale,info[field])}function dateFormatNames(locale,options){const{type:type,nameType:nameType,standAlone:standAlone,lower:lower}=options,lowerNameType=(lower?\"lower-\":\"\")+nameType,formatNames=getLocaleInfo(locale).calendar[type][standAlone?\"stand-alone\":\"format\"];let result=formatNames[lowerNameType];var obj;return!result&&lower&&(result=formatNames[lowerNameType]=(obj=formatNames[nameType],Array.isArray(obj)?function(arr){const result=[];for(let idx=0;idx<arr.length;idx++)result.push(arr[idx].toLowerCase());return result}(obj):function(obj){const result={};for(let field in obj)result[field]=obj[field].toLowerCase();return result}(obj))),result}function parseRangeDate(value){const parts=value.split(\"-\"),year=parseInt(parts[0],10),month=parseInt(parts[1],10)-1,day=parseInt(parts[2],10);return new Date(year,month,day)}const{NoCurrency:NoCurrency,NoCurrencyDisplay:NoCurrencyDisplay,NoSupplementalCurrency:NoSupplementalCurrency,NoCurrencyRegion:NoCurrencyRegion,NoValidCurrency:NoValidCurrency}=errors,SYMBOL=\"symbol\",GLOBAL_CURRENCIES={\"001\":\"USD\",150:\"EUR\"};function getCurrencyInfo(locale,currency,throwIfNoValid){const currencies=getLocaleInfo(locale).numbers.currencies;if(!currencies){if(throwIfNoValid)throw NoCurrency.error();return}const currencyDisplayInfo=currencies[currency];if(currencyDisplayInfo)return currencyDisplayInfo;if(throwIfNoValid)throw NoCurrencyDisplay.error()}function lengthComparer(a,b){return b.length-a.length}function localeCurrency(locale,throwIfNoValid){const info=getLocaleInfo(locale),numbers=info.numbers;if(!numbers.localeCurrency){const currency=function(territory,throwIfNoValid=!0){if(GLOBAL_CURRENCIES[territory])return GLOBAL_CURRENCIES[territory];const currencyData=cldr.supplemental.currencyData;if(!currencyData){if(throwIfNoValid)throw NoSupplementalCurrency.error();return}const regionCurrencies=currencyData.region[territory];if(regionCurrencies)return function(regionCurrencies){let latestValidUntil,latestValidUntilRange,latestStillValid,latestStillValidDate;for(let idx=0;idx<regionCurrencies.length;idx++){const currency=regionCurrencies[idx],code=Object.keys(currency)[0],info=currency[code];if(\"XXX\"!==code&&\"false\"!==info._tender&&info._from)if(info._to){if(!latestStillValid){const validFrom=parseRangeDate(info._from),validTo=parseRangeDate(info._to);(!latestValidUntilRange||latestValidUntilRange.to<validTo||latestValidUntilRange.from<validFrom)&&(latestValidUntil=code,latestValidUntilRange={from:validFrom,to:validTo})}}else{const stillValidDate=parseRangeDate(info._from);(!latestStillValidDate||latestStillValidDate<stillValidDate)&&(latestStillValid=code,latestStillValidDate=stillValidDate)}}return latestStillValid||latestValidUntil}(regionCurrencies);if(throwIfNoValid)throw NoCurrencyRegion.error(territory)}(localeTerritory(info),throwIfNoValid);if(!currency&&throwIfNoValid)throw NoValidCurrency.error(info.name);numbers.localeCurrency=currency}return numbers.localeCurrency}const DAYS_OF_WEEK=[\"sun\",\"mon\",\"tue\",\"wed\",\"thu\",\"fri\",\"sat\"],{NoWeekData:NoWeekData,NoFirstDay:NoFirstDay}=errors;function cldr_first_day_firstDay(locale){const info=getLocaleInfo(locale);if(!isNaN(info.firstDay))return info.firstDay;const weekData=cldr.supplemental.weekData;if(!weekData)throw NoWeekData.error();const firstDay=weekData.firstDay[localeTerritory(info)]||weekData.firstDay[\"001\"];if(!firstDay)throw NoFirstDay.error();return info.firstDay=DAYS_OF_WEEK.indexOf(firstDay),info.firstDay}const{NoWeekData:weekend_range_NoWeekData}=errors;function isNegativeZero(value){return 1/value==-1/0}function formatCurrencySymbol(info,options={}){return options.currency||(options.currency=localeCurrency(info,!0)),function(locale,options){const{value:value,currency:currency,currencyDisplay:currencyDisplay=SYMBOL}=options;if(\"code\"===currencyDisplay)return currency;const currencyInfo=getCurrencyInfo(locale,currency,!0);let result;return result=currencyDisplay===SYMBOL?currencyInfo[\"symbol-alt-narrow\"]||currencyInfo[SYMBOL]:void 0===typeof value||1!==value?currencyInfo[\"displayName-count-other\"]:currencyInfo[\"displayName-count-one\"],result}(info,options)}function groupInteger(number,start,end,options,info){const symbols=info.numbers.symbols,decimalIndex=number.indexOf(symbols.decimal),groupSizes=options.groupSize.slice();let groupSize=groupSizes.shift(),integerEnd=-1!==decimalIndex?decimalIndex:end+1,integer=number.substring(start,integerEnd),result=number;const integerLength=integer.length;if(integerLength>=groupSize){let idx=integerLength,parts=[];for(;idx>-1;){let value=integer.substring(idx-groupSize,idx);value&&parts.push(value),idx-=groupSize;let newGroupSize=groupSizes.shift();if(groupSize=void 0!==newGroupSize?newGroupSize:groupSize,0===groupSize){value=integer.substring(0,idx),value&&parts.push(value);break}}integer=parts.reverse().join(symbols.group),result=number.substring(0,start)+integer+number.substring(integerEnd)}return result}function isCurrencyStyle(style){return\"currency\"===style||\"accounting\"===style}function pad_pad(number,digits=2,right=!1){const count=digits-String(number).length;let result=number;if(count>0){const padString=new Array(count+1).join(\"0\");result=right?number+padString:padString+number}return result}function round_round(value,precision){let result=value,decimals=precision||0;return result=result.toString().split(\"e\"),result=Math.round(Number(result[0]+\"e\"+(result[1]?Number(result[1])+decimals:decimals))),result=result.toString().split(\"e\"),result=Number(result[0]+\"e\"+(result[1]?Number(result[1])-decimals:-decimals)),result.toFixed(Math.min(decimals,20))}const trailingZeroRegex=/0+$/,literalRegExp=/(\\\\.)|(['][^']*[']?)|([\"][^\"]*[\"]?)/g;function setStyleOptions(formatOptions,info){const format=formatOptions.format;-1!==format.indexOf(\"%\")&&(formatOptions.style=\"percent\",formatOptions.symbol=info.numbers.symbols.percentSign,formatOptions.number*=100),-1!==format.indexOf(\"$\")&&(formatOptions.style=\"currency\",formatOptions.symbol=formatCurrencySymbol(info))}function setFormatLiterals(formatOptions){let format=formatOptions.format;if(format.indexOf(\"'\")>-1||format.indexOf('\"')>-1||format.indexOf(\"\\\\\")>-1){const literals=formatOptions.literals=[];formatOptions.format=format.replace(literalRegExp,function(match){const quoteChar=match.charAt(0).replace(\"\\\\\",\"\"),literal=match.slice(1).replace(quoteChar,\"\");return literals.push(literal),\"__??__\"})}}const trailingZerosRegExp=/(\\.(?:[0-9]*[1-9])?)0+$/g,trailingPointRegExp=/\\.$/,commaRegExp=/\\,/g;function placeholderIndex(index1,index2,start){let index;return index=-1===index1&&-1!==index2?index2:-1!==index1&&-1===index2?index1:start?Math.min(index1,index2):Math.max(index1,index2),index}const standardFormatRegExp=/^(n|c|p|e|a)(\\d*)$/i;function format_options_formatOptions(format){let options;return options=is_string_isString(format)?function(format){const formatAndPrecision=standardFormatRegExp.exec(format);if(formatAndPrecision){const options={style:\"decimal\"};let style=formatAndPrecision[1].toLowerCase();return\"c\"===style?options.style=\"currency\":\"a\"===style?options.style=\"accounting\":\"p\"===style?options.style=\"percent\":\"e\"===style&&(options.style=\"scientific\"),formatAndPrecision[2]&&(options.minimumFractionDigits=options.maximumFractionDigits=parseInt(formatAndPrecision[2],10)),options}}(format):format,options}function formatNumber(number,format=\"n\",locale=\"en\"){if(null==number)return\"\";if(!isFinite(number))return String(number);const info=info_localeInfo(locale),options=format_options_formatOptions(format);let result;return result=options?function(number,options,info){const symbols=info.numbers.symbols,{style:style}=options,isCurrency=isCurrencyStyle(style);if(\"scientific\"===style)return(void 0!==options.minimumFractionDigits?number.toExponential(options.minimumFractionDigits):number.toExponential()).replace(\".\",symbols.decimal);let symbol,value=number;isCurrency&&(options.value=value,symbol=formatCurrencySymbol(info,options)),\"percent\"===style&&(value*=100,symbol=symbols.percentSign);const{minimumFractionDigits:minimumFractionDigits,maximumFractionDigits:maximumFractionDigits}=function(options){let{minimumFractionDigits:minimumFractionDigits,maximumFractionDigits:maximumFractionDigits,style:style}=options;const isCurrency=isCurrencyStyle(style);let currencyFractions;return isCurrency&&(currencyFractions=function(code){let minimumFractionDigits=2,maximumFractionDigits=2;const fractions=((cldr.supplemental.currencyData||{}).fractions||{})[code];return fractions&&fractions._digits&&(maximumFractionDigits=minimumFractionDigits=parseInt(fractions._digits,10)),{minimumFractionDigits:minimumFractionDigits,maximumFractionDigits:maximumFractionDigits}}(options.currency)),void 0===minimumFractionDigits&&(minimumFractionDigits=isCurrency?currencyFractions.minimumFractionDigits:0),void 0===maximumFractionDigits&&(maximumFractionDigits=\"percent\"===style?Math.max(minimumFractionDigits,0):isCurrency?Math.max(minimumFractionDigits,currencyFractions.maximumFractionDigits):Math.max(minimumFractionDigits,3)),{minimumFractionDigits:minimumFractionDigits,maximumFractionDigits:maximumFractionDigits}}(options);value=round_round(value,maximumFractionDigits);const negative=value<0,negativeZero=isNegativeZero(number),parts=value.split(\".\");let integer=parts[0],fraction=pad_pad(parts[1]?parts[1].replace(trailingZeroRegex,\"\"):\"\",minimumFractionDigits,!0);negative&&(integer=integer.substring(1)),options.minimumIntegerDigits&&(integer=pad_pad(integer,options.minimumIntegerDigits));let pattern,formattedValue=!1!==options.useGrouping?groupInteger(integer,0,integer.length,options,info):integer;if(fraction&&(formattedValue+=symbols.decimal+fraction),isCurrency&&\"name\"===options.currencyDisplay)pattern=function(info,value){const currencyInfo=info.numbers.currency;let pattern=1!==value?currencyInfo[\"unitPattern-count-other\"]:currencyInfo[\"unitPattern-count-one\"];return value<0&&(pattern=pattern.replace(\"n\",\"-n\")),pattern}(info,number);else{const patterns=options.patterns;pattern=negative||negativeZero?patterns[1]||\"-\"+patterns[0]:patterns[0]}return\"n\"!==pattern||negative?function(value,pattern,symbol){let result=\"\";for(let idx=0,length=pattern.length;idx<length;idx++){let ch=pattern.charAt(idx);result+=\"n\"===ch?value:\"$\"===ch||\"%\"===ch?symbol:ch}return result}(formattedValue,pattern,symbol):formattedValue}(number,Object.assign({},info.numbers[options.style||\"decimal\"],options),info):function(number,format,info){const formatOptions={negative:number<0,number:Math.abs(number),negativeZero:isNegativeZero(number),format:format};return function(formatOptions){let{number:number,format:format}=formatOptions;if(format=format.split(\";\"),(formatOptions.negative||formatOptions.negativeZero)&&format[1])format=format[1],formatOptions.hasNegativeFormat=!0;else if(0===number){const zeroFormat=format[2];format=zeroFormat||format[0],zeroFormat&&function(format){return-1===format.indexOf(\"#\")&&-1===format.indexOf(\"0\")}(zeroFormat)&&(formatOptions.constant=zeroFormat)}else format=format[0];formatOptions.format=format}(formatOptions),formatOptions.constant?formatOptions.constant:(setFormatLiterals(formatOptions),setStyleOptions(formatOptions,info),function(formatOptions){formatOptions.hasGroup=formatOptions.format.indexOf(\",\")>-1,formatOptions.hasGroup&&(formatOptions.format=formatOptions.format.replace(commaRegExp,\"\"))}(formatOptions),function(formatOptions){let{number:number,format:format}=formatOptions,decimalIndex=format.indexOf(\".\");if(-1!==decimalIndex){const zeroIndex=format.lastIndexOf(\"0\")-decimalIndex,sharpIndex=format.lastIndexOf(\"#\")-decimalIndex,hasZero=zeroIndex>-1,hasSharp=sharpIndex>-1;let fraction=number.toString().split(\"e\");fraction=fraction[1]?round_round(number,Math.abs(fraction[1])):fraction[0],fraction=fraction.split(\".\")[1]||\"\";let precision=fraction.length,trailingZeros=-1;hasZero||hasSharp?hasZero&&zeroIndex>sharpIndex?precision=zeroIndex:sharpIndex>zeroIndex&&(hasSharp&&precision>sharpIndex?precision=sharpIndex:hasZero&&precision<zeroIndex&&(precision=zeroIndex),trailingZeros=hasZero?zeroIndex:0):(formatOptions.format=format.substring(0,decimalIndex)+format.substring(decimalIndex+1),decimalIndex=-1,precision=0),precision>-1&&(number=round_round(number,precision),trailingZeros>-1&&(number=function(value,lastZero){let trimRegex;return trimRegex=0===lastZero?trailingZerosRegExp:new RegExp(`(\\\\.[0-9]{${lastZero}}[1-9]*)0+$`,\"g\"),value.replace(trimRegex,\"$1\").replace(trailingPointRegExp,\"\")}(number,trailingZeros)))}else number=round_round(number);formatOptions.negative&&-1*number>=0&&!formatOptions.negativeZero&&(formatOptions.negative=!1),formatOptions.number=number,formatOptions.decimalIndex=decimalIndex}(formatOptions),function(formatOptions){const format=formatOptions.format;let sharpIndex=format.indexOf(\"#\"),zeroIndex=format.indexOf(\"0\"),start=placeholderIndex(sharpIndex,zeroIndex,!0);sharpIndex=format.lastIndexOf(\"#\"),zeroIndex=format.lastIndexOf(\"0\");let end=placeholderIndex(sharpIndex,zeroIndex);start===format.length&&(end=start),formatOptions.start=start,formatOptions.end=end,formatOptions.lastZeroIndex=zeroIndex}(formatOptions),function(formatOptions,info){let number=formatOptions.number;return-1!==formatOptions.start&&(number=function(formatOptions,info){const{start:start,end:end,negative:negative,negativeZero:negativeZero,format:format,decimalIndex:decimalIndex,lastZeroIndex:lastZeroIndex,hasNegativeFormat:hasNegativeFormat,hasGroup:hasGroup}=formatOptions;let number=formatOptions.number;const value=number.toString().split(\".\"),length=format.length,integer=value[0],fraction=value[1]||\"\",integerLength=integer.length;let replacement=\"\";number=format.substring(0,start),!negative&&!negativeZero||hasNegativeFormat||(number+=\"-\");for(let idx=start;idx<length;idx++){let ch=format.charAt(idx);if(-1===decimalIndex){if(end-idx<integerLength){number+=integer;break}}else if(-1!==lastZeroIndex&&lastZeroIndex<idx&&(replacement=\"\"),decimalIndex-idx<=integerLength&&decimalIndex-idx>-1&&(number+=integer,idx=decimalIndex),decimalIndex===idx){number+=(fraction?info.numbers.symbols.decimal:\"\")+fraction,idx+=end-decimalIndex+1;continue}\"0\"===ch?(number+=ch,replacement=ch):\"#\"===ch&&(number+=replacement)}return hasGroup&&(number=groupInteger(number,start+(negative&&!hasNegativeFormat?1:0),Math.max(end,integerLength+start),info.numbers.decimal,info)),end>=start&&(number+=format.substring(end+1)),number}(formatOptions,info),number=function(number,style,symbol){let result=number;if(\"currency\"===style||\"percent\"===style){result=\"\";for(let idx=0,length=number.length;idx<length;idx++){let ch=number.charAt(idx);result+=\"$\"===ch||\"%\"===ch?symbol:ch}}return result}(number,formatOptions.style,formatOptions.symbol),number=function(number,literals){let result=number;if(literals){const length=literals.length;for(let idx=0;idx<length;idx++)result=result.replace(\"__??__\",literals[idx])}return result}(number,formatOptions.literals)),number}(formatOptions,info))}(number,format,info),result}function is_number_isNumber(value){return\"number\"==typeof value}const exponentRegExp=/[eE][\\-+]?[0-9]+/,nonBreakingSpaceRegExp=/\\u00A0/g;function cleanNegativePattern(number,patterns){if(patterns.length>1){const parts=(patterns[1]||\"\").replace(\"$\",\"\").split(\"n\");if(number.indexOf(parts[0])>-1&&number.indexOf(parts[1])>-1)return number.replace(parts[0],\"\").replace(parts[1],\"\")}}const format_string_formatRegExp=/\\{(\\d+)}/g;function format_string_formatString(format){const values=arguments;return format.replace(format_string_formatRegExp,(match,index)=>values[parseInt(index,10)+1])}const LENGHT_DELTA=[2,1,5,3,4],PENALTIES={[(-2).toString()]:8,[(-1).toString()]:6,[2..toString()]:6,[1..toString()]:3},VALUE_FORMAT_LENGTH={numeric:1,\"2-digit\":2,short:3,long:4,narrow:5},TIME_SPECIFIERS_REGEX=/[hHmsSzZoOvVxX]/,DATE_OPTIONS_MAP=[{key:\"era\",specifier:\"G\"},{key:\"year\",specifier:\"y\"},{key:\"month\",specifier:\"M\"},{key:\"day\",specifier:\"d\"},{key:\"weekday\",specifier:\"E\"},{key:\"hour\",getSpecifier:function(options){return options.hour12?\"h\":\"H\"}},{key:\"minute\",specifier:\"m\"},{key:\"second\",specifier:\"s\"},{key:\"timeZoneName\",specifier:\"z\"}],STAND_ALONE_SPECIFIERS={e:\"c\",E:\"c\",M:\"L\",Q:\"q\"},specifiersRegex={},resolvedFormats={};function getSpecifierRegex(specifier){return specifiersRegex[specifier]||(specifiersRegex[specifier]=new RegExp(specifier+\"+\")),specifiersRegex[specifier]}function skeletonSpecifiers(skeleton){const result=[];let current=skeleton.charAt(0),specifier=current;for(let idx=1;idx<skeleton.length;idx++){let character=skeleton.charAt(idx);character===specifier?current+=character:(result.push(current),current=specifier=character)}return result.push(current),result}function findBestMatch(specifiers,availableFormats){const specifiersLength=specifiers.length;let bestMatches,result,maxScore=-Number.MAX_VALUE;for(let format in availableFormats){const matches=[];let currentFormat=format.replace(\"v\",\"z\"),score=0;for(let idx=0;idx<specifiersLength;idx++){const specifier=specifiers[idx];let match=(getSpecifierRegex(specifier[0]).exec(currentFormat)||[])[0];if(match){if(currentFormat=currentFormat.replace(match,\"\"),match.length!==specifier.length){let delta=Math.max(Math.min(LENGHT_DELTA[match.length]-LENGHT_DELTA[specifier.length],2),-2);score-=PENALTIES[delta]}}else score-=120;if(matches.push(match),score<maxScore)break}currentFormat.length&&(score-=20*skeletonSpecifiers(currentFormat).length),score>maxScore&&(maxScore=score,bestMatches=matches,result=availableFormats[format])}result=result.replace(\"v\",\"z\");for(let idx=0;idx<specifiersLength;idx++){const bestMatch=bestMatches[idx];if(bestMatch&&bestMatch!==specifiers[idx]){const matchSpecifier=bestMatches[idx][0];result=result.replace(getSpecifierRegex(matchSpecifier),specifiers[idx]),STAND_ALONE_SPECIFIERS[matchSpecifier]&&(result=result.replace(getSpecifierRegex(STAND_ALONE_SPECIFIERS[matchSpecifier]),specifiers[idx]))}}return result}function datePattern(format,info){const calendar=info.calendar;let result;if(is_string_isString(format))result=calendar.patterns[format]?calendar.patterns[format]:format;else if(format){if(format.pattern)return format.pattern;let skeleton=format.skeleton;skeleton||(format.datetime?result=format_string_formatString(calendar.dateTimeFormats[format.datetime],calendar.timeFormats[format.datetime],calendar.dateFormats[format.datetime]):format.date?result=calendar.dateFormats[format.date]:format.time?result=calendar.timeFormats[format.time]:skeleton=function(options){let result=[];for(let idx=0;idx<DATE_OPTIONS_MAP.length;idx++){let option=DATE_OPTIONS_MAP[idx],value=options[option.key];if(value){let spcifier=option.specifier||option.getSpecifier(options);result.push(spcifier.repeat(VALUE_FORMAT_LENGTH[value]))}}return result.join(\"\")}(format)),skeleton&&(result=function(skeleton,info){const availableFormats=info.calendar.dateTimeFormats.availableFormats;if(availableFormats[skeleton])return availableFormats[skeleton];if(resolvedFormats[info.name]&&resolvedFormats[info.name][skeleton])return resolvedFormats[info.name][skeleton];const timeStartIndex=skeleton.search(TIME_SPECIFIERS_REGEX);let result;if(timeStartIndex>0){const dateSkeleton=skeleton.substr(0,timeStartIndex),timeSkeleton=skeleton.substr(timeStartIndex);result=format_string_formatString(info.calendar.dateTimeFormats.short,availableFormats[timeSkeleton]||findBestMatch(skeletonSpecifiers(timeSkeleton),availableFormats),availableFormats[dateSkeleton]||findBestMatch(skeletonSpecifiers(dateSkeleton),availableFormats))}else result=findBestMatch(skeletonSpecifiers(skeleton),availableFormats);return function(skeleton,format,locale){resolvedFormats[locale]||(resolvedFormats[locale]={}),resolvedFormats[locale][skeleton]=format}(skeleton,result,info.name),result}(skeleton,info))}return result||(result=calendar.patterns.d),result}function dateNameType(formatLength){let nameType;return formatLength<=3?nameType=\"abbreviated\":4===formatLength?nameType=\"wide\":5===formatLength?nameType=\"narrow\":6===formatLength&&(nameType=\"short\"),nameType}function format_names_formatNames(locale,type,formatLength,standAlone,lower){return dateFormatNames(locale,{type:type,nameType:dateNameType(formatLength),standAlone:standAlone,lower:lower})}function is_date_isFunction(fun){return\"function\"==typeof fun}function isDate(value){return Boolean(value)&&is_date_isFunction(value.getTime)&&is_date_isFunction(value.getMonth)}const DATE_FIELD_MAP={G:\"era\",y:\"year\",q:\"quarter\",Q:\"quarter\",M:\"month\",L:\"month\",d:\"day\",E:\"weekday\",c:\"weekday\",e:\"weekday\",h:\"hour\",H:\"hour\",k:\"hour\",K:\"hour\",m:\"minute\",s:\"second\",S:\"millisecond\",a:\"dayperiod\",x:\"zone\",X:\"zone\",z:\"zone\",Z:\"zone\"},dateFormatRegExp=/d{1,2}|E{1,6}|e{1,6}|c{3,6}|c{1}|M{1,5}|L{1,5}|y{1,4}|H{1,2}|h{1,2}|k{1,2}|K{1,2}|m{1,2}|a{1,5}|s{1,2}|S{1,3}|z{1,4}|Z{1,5}|x{1,5}|X{1,5}|G{1,5}|q{1,5}|Q{1,5}|\"[^\"]*\"|'[^']*'/g;function formatMonth(month,formatLength,info,standAlone){return formatLength<=2?pad_pad(month+1,formatLength):format_names_formatNames(info,\"months\",formatLength,standAlone)[month]}function formatQuarter(date,formatLength,info,standAlone){const quarter=Math.floor(date.getMonth()/3);return formatLength<3?quarter+1:format_names_formatNames(info,\"quarters\",formatLength,standAlone)[quarter]}function formatTimeZone(date,info,options){const{shortHours:shortHours,optionalMinutes:optionalMinutes,separator:separator,localizedName:localizedName,zZeroOffset:zZeroOffset}=options,offset=date.getTimezoneOffset()/60;if(0===offset&&zZeroOffset)return\"Z\";const sign=offset<=0?\"+\":\"-\",hoursMinutes=Math.abs(offset).toString().split(\".\"),minutes=hoursMinutes[1]||0;let result=sign+(shortHours?hoursMinutes[0]:pad_pad(hoursMinutes[0],2));return!minutes&&optionalMinutes||(result+=(separator?\":\":\"\")+pad_pad(minutes,2)),localizedName&&(result=format_string_formatString(0===offset?info.calendar.gmtZeroFormat:info.calendar.gmtFormat,result)),result}function formatDayOfWeek(date,formatLength,info,standAlone){let result;return result=formatLength<3?function(day,formatLength,localeInfo){const firstDayIndex=cldr_first_day_firstDay(localeInfo);let dayIndex;return dayIndex=day<firstDayIndex?7-firstDayIndex+day:day-firstDayIndex,dayIndex+1}(date.getDay(),0,info):format_names_formatNames(info,\"days\",formatLength,standAlone)[date.getDay()],result}const formatters={};function formatDate(date,format,locale=\"en\"){if(!isDate(date))return null==date?\"\":date;const info=info_localeInfo(locale);return datePattern(format,info).replace(dateFormatRegExp,function(match){let result,formatLength=match.length;return result=match.includes(\"'\")||match.includes('\"')?match.slice(1,formatLength-1):formatters[match[0]](date,formatLength,info),result})}function convertTimeZone(date,fromOffset,toOffset){const fromLocalOffset=date.getTimezoneOffset(),offsetDate=new Date(date.getTime()+6e4*(fromOffset-toOffset)),toLocalOffset=offsetDate.getTimezoneOffset();return new Date(offsetDate.getTime()+6e4*(toLocalOffset-fromLocalOffset))}formatters.d=function(date,formatLength){return pad_pad(date.getDate(),formatLength)},formatters.E=function(date,formatLength,info){return format_names_formatNames(info,\"days\",formatLength)[date.getDay()]},formatters.M=function(date,formatLength,info){return formatMonth(date.getMonth(),formatLength,info,!1)},formatters.L=function(date,formatLength,info){return formatMonth(date.getMonth(),formatLength,info,!0)},formatters.y=function(date,formatLength){let year=date.getFullYear();return 2===formatLength&&(year%=100),pad_pad(year,formatLength)},formatters.h=function(date,formatLength){return pad_pad(date.getHours()%12||12,formatLength)},formatters.H=function(date,formatLength){return pad_pad(date.getHours(),formatLength)},formatters.k=function(date,formatLength){return pad_pad(date.getHours()||24,formatLength)},formatters.K=function(date,formatLength){return pad_pad(date.getHours()%12,formatLength)},formatters.m=function(date,formatLength){return pad_pad(date.getMinutes(),formatLength)},formatters.s=function(date,formatLength){return pad_pad(date.getSeconds(),formatLength)},formatters.S=function(date,formatLength){const milliseconds=date.getMilliseconds();let result;return result=0!==milliseconds?pad_pad(String(milliseconds/1e3).split(\".\")[1].substr(0,formatLength),formatLength,!0):pad_pad(\"\",formatLength),result},formatters.a=function(date,formatLength,info){return format_names_formatNames(info,\"dayPeriods\",formatLength)[date.getHours()<12?\"am\":\"pm\"]},formatters.z=function(date,formatLength,info){return formatTimeZone(date,info,{shortHours:formatLength<4,optionalMinutes:formatLength<4,separator:!0,localizedName:!0})},formatters.Z=function(date,formatLength,info){return formatTimeZone(date,info,{separator:formatLength>3,localizedName:4===formatLength,zZeroOffset:5===formatLength})},formatters.x=function(date,formatLength,info){return formatTimeZone(date,info,{optionalMinutes:1===formatLength,separator:3===formatLength||5===formatLength})},formatters.X=function(date,formatLength,info){return formatTimeZone(date,info,{optionalMinutes:1===formatLength,separator:3===formatLength||5===formatLength,zZeroOffset:!0})},formatters.G=function(date,formatLength,info){let era=date.getFullYear()>=0?1:0;return format_names_formatNames(info,\"eras\",formatLength)[era]},formatters.e=formatDayOfWeek,formatters.c=function(date,formatLength,info){return formatDayOfWeek(date,formatLength,info,!0)},formatters.q=function(date,formatLength,info){return formatQuarter(date,formatLength,info,!0)},formatters.Q=formatQuarter;const timeZoneOffsetRegExp=/([+|\\-]\\d{1,2})(:?)(\\d{2})?/,dateRegExp=/^\\/Date\\((.*?)\\)\\/$/,offsetRegExp=/[+-]\\d*/,numberRegExp={2:/^\\d{1,2}/,3:/^\\d{1,3}/,4:/^\\d{4}/},numberRegex=/\\d+/,leadingSpacesRegex=/^ */,trailingSpacesRegex=/ *$/,standardDateFormats=[\"yyyy/MM/dd HH:mm:ss\",\"yyyy/MM/dd HH:mm\",\"yyyy/MM/dd\",\"E MMM dd yyyy HH:mm:ss\",\"yyyy-MM-ddTHH:mm:ss.SSSSSSSXXX\",\"yyyy-MM-ddTHH:mm:ss.SSSXXX\",\"yyyy-MM-ddTHH:mm:ss.SSXXX\",\"yyyy-MM-ddTHH:mm:ssXXX\",\"yyyy-MM-ddTHH:mm:ss.SSSSSSS\",\"yyyy-MM-ddTHH:mm:ss.SSS\",\"yyyy-MM-ddTHH:mmXXX\",\"yyyy-MM-ddTHH:mmX\",\"yyyy-MM-ddTHH:mm:ss\",\"yyyy-MM-ddTHH:mm\",\"yyyy-MM-dd HH:mm:ss\",\"yyyy-MM-dd HH:mm\",\"yyyy-MM-dd\",\"HH:mm:ss\",\"HH:mm\"],FORMATS_SEQUENCE=[\"G\",\"g\",\"F\",\"Y\",\"y\",\"M\",\"m\",\"D\",\"d\",\"y\",\"T\",\"t\"];function outOfRange(value,start,end){return!(value>=start&&value<=end)}function lookAhead(match,state){let{format:format,idx:idx}=state,i=0;for(;format[idx]===match;)i++,idx++;return i>0&&(idx-=1),state.idx=idx,i}function getNumber(size,state){let regex=size?numberRegExp[size]||new RegExp(\"^\\\\d{1,\"+size+\"}\"):numberRegex,match=state.value.substr(state.valueIdx,size).match(regex);return match?(match=match[0],state.valueIdx+=match.length,parseInt(match,10)):null}function getIndexByName(names,state,lower){let name,nameLength,subValue,i=0,length=names.length,matchLength=0,matchIdx=0;for(;i<length;i++)name=names[i],nameLength=name.length,subValue=state.value.substr(state.valueIdx,nameLength),lower&&(subValue=subValue.toLowerCase()),subValue===name&&nameLength>matchLength&&(matchLength=nameLength,matchIdx=i);return matchLength?(state.valueIdx+=matchLength,matchIdx+1):null}function checkLiteral(state){let result=!1;return state.value.charAt(state.valueIdx)===state.format[state.idx]&&(state.valueIdx++,result=!0),result}function parseTimeZoneOffset(state,info,options){const{shortHours:shortHours,noSeparator:noSeparator,optionalMinutes:optionalMinutes,localizedName:localizedName,zLiteral:zLiteral}=options;if(state.UTC=!0,zLiteral&&\"Z\"===state.value.charAt(state.valueIdx))return state.valueIdx++,!1;if(localizedName&&!getIndexByName(function(calendar){const{gmtFormat:gmtFormat,gmtZeroFormat:gmtZeroFormat}=calendar;if(!gmtFormat)throw errors.NoGMTInfo.error();return[gmtFormat.replace(\"{0}\",\"\").toLowerCase(),gmtZeroFormat.replace(\"{0}\",\"\").toLowerCase()]}(info.calendar),state,!0))return!0;const matches=timeZoneOffsetRegExp.exec(state.value.substr(state.valueIdx,6));if(!matches)return!localizedName;const hoursMatch=matches[1],minutesMatch=matches[3],hoursOffset=parseInt(hoursMatch,10),separator=matches[2];let minutesOffset=parseInt(minutesMatch,10);return!!(isNaN(hoursOffset)||!shortHours&&3!==hoursMatch.length||!optionalMinutes&&isNaN(minutesOffset)||noSeparator&&separator)||(isNaN(minutesOffset)&&(minutesOffset=null),!!(outOfRange(hoursOffset,-12,13)||minutesOffset&&outOfRange(minutesOffset,0,59))||(state.valueIdx+=matches[0].length,state.hoursOffset=hoursOffset,void(state.minutesOffset=minutesOffset)))}function parseMonth(ch,state,info){const count=lookAhead(ch,state),names=format_names_formatNames(info,\"months\",count,\"L\"===ch,!0),month=count<3?getNumber(2,state):getIndexByName(names,state,!0);if(null===month||outOfRange(month,1,12))return!0;state.month=month-1}function parseDayOfWeek(ch,state,info){const count=lookAhead(ch,state),names=format_names_formatNames(info,\"days\",count,\"c\"===ch,!0);let dayOfWeek=count<3?getNumber(1,state):getIndexByName(names,state,!0);if(!dayOfWeek&&0!==dayOfWeek||outOfRange(dayOfWeek,1,7))return!0}const parsers={};function addFormatSpaces(value,format){return`${leadingSpacesRegex.exec(format)[0]}${value}${trailingSpacesRegex.exec(format)[0]}`}function parseExact(value,format,info){let pattern=datePattern(format,info).split(\"\");const state={format:pattern,idx:0,value:addFormatSpaces(value,format),valueIdx:0,year:null,month:null,day:null,hours:null,minutes:null,seconds:null,milliseconds:null},length=pattern.length;let literal=!1;for(;state.idx<length;state.idx++){let ch=pattern[state.idx];if(literal)\"'\"===ch&&(literal=!1),checkLiteral(state);else if(parsers[ch]){if(parsers[ch](state,info))return null}else if(\"'\"===ch)literal=!0,checkLiteral(state);else if(!checkLiteral(state))return null}return state.valueIdx<value.length?null:function(state){let{year:year,month:month,day:day,hours:hours,minutes:minutes,seconds:seconds,milliseconds:milliseconds,pmHour:pmHour,UTC:UTC,hoursOffset:hoursOffset,minutesOffset:minutesOffset}=state;const hasTime=null!==hours||null!==minutes||seconds||null,date=new Date;let result;return null===year&&null===month&&null===day&&hasTime?(year=date.getFullYear(),month=date.getMonth(),day=date.getDate()):(null===year&&(year=date.getFullYear()),null===day&&(day=1)),pmHour&&hours<12&&(hours+=12),UTC?(hoursOffset&&(hours+=-hoursOffset),minutesOffset&&(minutes+=-minutesOffset*(hoursOffset<0?-1:1)),result=new Date(Date.UTC(year,month,day,hours,minutes,seconds,milliseconds))):(result=new Date(year,month,day,hours,minutes,seconds,milliseconds),function(date,hours){hours||23!==date.getHours()||date.setHours(date.getHours()+2)}(result,hours)),year<100&&result.setFullYear(year),result.getDate()!==day&&void 0===UTC?null:result}(state)||null}parsers.d=function(state){lookAhead(\"d\",state);const day=getNumber(2,state);if(null===day||outOfRange(day,1,31))return!0;null===state.day&&(state.day=day)},parsers.E=function(state,info){if(null===getIndexByName(format_names_formatNames(info,\"days\",lookAhead(\"E\",state),!1,!0),state,!0))return!0},parsers.M=function(state,info){return parseMonth(\"M\",state,info)},parsers.L=function(state,info){return parseMonth(\"L\",state,info)},parsers.y=function(state){const count=lookAhead(\"y\",state);let year=getNumber(1===count?void 0:count,state);if(null===year)return!0;if(2===count){const currentYear=(new Date).getFullYear();year=currentYear-currentYear%100+year,year>2029&&(year-=100)}state.year=year},parsers.h=function(state){lookAhead(\"h\",state);let hours=getNumber(2,state);if(12===hours&&(hours=0),null===hours||outOfRange(hours,0,11))return!0;state.hours=hours},parsers.K=function(state){lookAhead(\"K\",state);let hours=getNumber(2,state);if(null===hours||outOfRange(hours,0,11))return!0;state.hours=hours},parsers.a=function(state,info){let periodFormats=format_names_formatNames(info,\"dayPeriods\",lookAhead(\"a\",state),!1,!0);const pmHour=getIndexByName([periodFormats.pm],state,!0);if(!pmHour&&!getIndexByName([periodFormats.am],state,!0))return!0;state.pmHour=pmHour},parsers.H=function(state){lookAhead(\"H\",state);const hours=getNumber(2,state);if(null===hours||outOfRange(hours,0,23))return!0;state.hours=hours},parsers.k=function(state){lookAhead(\"k\",state);let hours=getNumber(2,state);if(null===hours||outOfRange(hours,1,24))return!0;state.hours=24===hours?0:hours},parsers.m=function(state){lookAhead(\"m\",state);const minutes=getNumber(2,state);if(null===minutes||outOfRange(minutes,0,59))return!0;state.minutes=minutes},parsers.s=function(state){lookAhead(\"s\",state);const seconds=getNumber(2,state);if(null===seconds||outOfRange(seconds,0,59))return!0;state.seconds=seconds},parsers.S=function(state){const count=lookAhead(\"S\",state),match=state.value.substr(state.valueIdx,count);let milliseconds=null;if(isNaN(parseInt(match,10))||(milliseconds=parseFloat(\"0.\"+match,10),milliseconds=round_round(milliseconds,3),milliseconds*=1e3,state.valueIdx+=count),null===milliseconds||outOfRange(milliseconds,0,999))return!0;state.milliseconds=milliseconds},parsers.z=function(state,info){const shortFormat=lookAhead(\"z\",state)<4,invalid=parseTimeZoneOffset(state,info,{shortHours:shortFormat,optionalMinutes:shortFormat,localizedName:!0});if(invalid)return invalid},parsers.Z=function(state,info){const count=lookAhead(\"Z\",state),invalid=parseTimeZoneOffset(state,info,{noSeparator:count<4,zLiteral:5===count,localizedName:4===count});if(invalid)return invalid},parsers.x=function(state,info){const count=lookAhead(\"x\",state),invalid=parseTimeZoneOffset(state,info,{noSeparator:3!==count&&5!==count,optionalMinutes:1===count});if(invalid)return invalid},parsers.X=function(state,info){const count=lookAhead(\"X\",state),invalid=parseTimeZoneOffset(state,info,{noSeparator:3!==count&&5!==count,optionalMinutes:1===count,zLiteral:!0});if(invalid)return invalid},parsers.G=function(state,info){const eras=format_names_formatNames(info,\"eras\",lookAhead(\"G\",state),!1,!0);if(null===getIndexByName([eras[0],eras[1]],state,!0))return!0},parsers.e=function(state,info){return parseDayOfWeek(\"e\",state,info)},parsers.c=function(state,info){return parseDayOfWeek(\"c\",state,info)};const NAME_TYPES={month:{type:\"months\",minLength:3,standAlone:\"L\"},quarter:{type:\"quarters\",minLength:3,standAlone:\"q\"},weekday:{type:\"days\",minLength:{E:0,c:3,e:3},standAlone:\"c\"},dayperiod:{type:\"dayPeriods\",minLength:0},era:{type:\"eras\",minLength:0}};function addLiteral(parts,value){const lastPart=parts[parts.length-1];lastPart&&\"literal\"===lastPart.type?lastPart.pattern+=value:parts.push({type:\"literal\",pattern:value})}function isHour12(pattern){return\"h\"===pattern||\"K\"===pattern}const format_formatRegExp=/\\{(\\d+)(:[^\\}]+)?\\}/g;function format_toString(value,format,locale){if(format){if(isDate(value))return formatDate(value,format,locale);if(is_number_isNumber(value))return formatNumber(value,format,locale)}return null!=value?value:\"\"}const fesm2015_packageMetadata={name:\"@progress/kendo-angular-intl\",productName:\"Kendo UI for Angular\",productCodes:[\"KENDOUIANGULAR\",\"KENDOUICOMPLETE\"],publishDate:1620213344,version:\"\",licensingDocsUrl:\"https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning\"},DOCS_URL=\"http://www.telerik.com/kendo-angular-ui/components/internationalization/troubleshooting/\",errorSolutions={NoCurrency:`Solution: ${DOCS_URL}#toc-no-currency`,NoCurrencyDisplay:`Solution: ${DOCS_URL}#toc-no-currency-display`,NoCurrencyRegion:`Solution: ${DOCS_URL}#toc-no-currency-region`,NoDateFieldNames:`Solution: ${DOCS_URL}#toc-no-date-filed-names`,NoFirstDay:`Solution: ${DOCS_URL}#toc-no-first-day`,NoGMTInfo:`Solution: ${DOCS_URL}#toc-no-gmt-info`,NoLocale:`Solution: ${DOCS_URL}#toc-no-locale`,NoValidCurrency:`Solution: ${DOCS_URL}#toc-no-valid-currency`,NoWeekData:`Solution: ${DOCS_URL}#toc-no-week-data`};function intlMethod(fn){return function(...values){try{return fn.apply(null,values)}catch(error){throw error.message=function(error){const message=error.message,errorSolution=errorSolutions[Object.keys(errorSolutions).filter(key=>0===message.indexOf(key))[0]];return errorSolution?`${message} ${errorSolution}`:message}(error),error}}}const dateFormatNames$1=intlMethod(dateFormatNames),dateFieldName$1=intlMethod(function(options,locale=\"en\"){const dateFields=info_localeInfo(locale).calendar.dateFields;if(!dateFields)throw errors.NoDateFieldNames.error();const fieldNameInfo=dateFields[options.type]||{};return fieldNameInfo[options.nameType]||fieldNameInfo.wide}),firstDay$1=intlMethod(cldr_first_day_firstDay),format$1=intlMethod(function(format,values,locale){return format.replace(format_formatRegExp,function(match,index,placeholderFormat){return format_toString(values[parseInt(index,10)],placeholderFormat?placeholderFormat.substring(1):\"\",locale)})}),formatDate$1=intlMethod(formatDate),formatNumber$1=intlMethod(formatNumber),numberSymbols$1=(intlMethod(function(){const length=arguments.length;for(let idx=0;idx<length;idx++){let entry=arguments[idx];if(entry.main){let locale=Object.keys(entry.main)[0],info=entry.main[locale],localeInfo=cldr[locale]=cldr[locale]||{};localeInfo.name=localeInfo.name||locale,localeInfo.identity=localeInfo.identity||info.identity,localeTerritory(localeInfo),loadLocale(locale,info)}else if(entry.supplemental)if(entry.supplemental.weekData)cldr.supplemental.weekData={firstDay:entry.supplemental.weekData.firstDay,weekendStart:entry.supplemental.weekData.weekendStart,weekendEnd:entry.supplemental.weekData.weekendEnd};else if(entry.supplemental.likelySubtags)cldr.supplemental.likelySubtags=Object.assign(cldr.supplemental.likelySubtags,entry.supplemental.likelySubtags);else if(entry.supplemental.currencyData){const currencyData=cldr.supplemental.currencyData;currencyData.region=Object.assign(currencyData.region||{},entry.supplemental.currencyData.region),currencyData.fractions=Object.assign(currencyData.fractions||{},entry.supplemental.currencyData.fractions)}}}),intlMethod(function(locale){return getLocaleInfo(locale).numbers.symbols})),parseDate$1=intlMethod(function(value,formats,locale=\"en\"){if(!value)return null;if(isDate(value))return value;let parseValue=String(value).trim(),date=function(value){if(value&&0===value.indexOf(\"/D\")){let date=dateRegExp.exec(value);if(date){date=date[1];let tzoffset=offsetRegExp.exec(date.substring(1));return date=new Date(parseInt(date,10)),tzoffset&&(tzoffset=function(offset){const sign=\"-\"===offset.substr(0,1)?-1:1;let result=offset.substring(1);return result=60*parseInt(result.substr(0,2),10)+parseInt(result.substring(2),10),sign*result}(tzoffset[0]),date=convertTimeZone(date,date.getTimezoneOffset(),0),date=convertTimeZone(date,0,-1*tzoffset)),date}}}(parseValue);if(date)return date;const info=info_localeInfo(locale);let parseFormats=formats||function(calendar){const formats=[],patterns=calendar.patterns,length=FORMATS_SEQUENCE.length;for(let idx=0;idx<length;idx++)formats.push(patterns[FORMATS_SEQUENCE[idx]]);return formats.concat(standardDateFormats)}(info.calendar);parseFormats=Array.isArray(parseFormats)?parseFormats:[parseFormats];const length=parseFormats.length;for(let idx=0;idx<length;idx++)if(date=parseExact(parseValue,parseFormats[idx],info),date)return date;return date}),parseNumber$1=intlMethod(function(value,locale=\"en\",format={}){if(!value&&0!==value)return null;if(is_number_isNumber(value))return value;const info=info_localeInfo(locale),symbols=info.numbers.symbols;let isPercent,number=value.toString(),formatOptions=format||{};if(is_string_isString(format)&&(formatOptions={format:format},setFormatLiterals(formatOptions),number=function(number,formatOptions){const literals=formatOptions.literals;let result=number;if(literals)for(let idx=0;idx<literals.length;idx++)result=result.replace(literals[idx],\"\");return result}(number,formatOptions),setStyleOptions(formatOptions,info)),(\"percent\"===formatOptions.style||number.indexOf(symbols.percentSign)>-1)&&(number=number.replace(symbols.percentSign,\"\"),isPercent=!0),exponentRegExp.test(number))return number=parseFloat(number.replace(symbols.decimal,\".\")),isNaN(number)?null:number;const{negative:negativeCurrency,number:currencyNumber}=function(value,info,format){const options=format_options_formatOptions(format)||{};let negative,isCurrency=isCurrencyStyle(options.style),number=value;const currency=options.currency||localeCurrency(info,isCurrency);if(currency){const displays=function(locale,currency,throwIfNoValid=!0){const currencyInfo=getCurrencyInfo(locale,currency,throwIfNoValid);if(currencyInfo){if(!currencyInfo.displays){const displays=[currency];for(let field in currencyInfo)displays.push(currencyInfo[field]);displays.sort(lengthComparer),currencyInfo.displays=displays}return currencyInfo.displays}}(info,currency,isCurrency);if(displays)for(let idx=0;idx<displays.length;idx++){let display=displays[idx];if(number.includes(display)){number=number.replace(display,\"\"),isCurrency=!0;break}}if(isCurrency){const cleanNumber=cleanNegativePattern(number,info.numbers.currency.patterns)||cleanNegativePattern(number,info.numbers.accounting.patterns);cleanNumber&&(negative=!0,number=cleanNumber)}}return{number:number,negative:negative}}(number,info,formatOptions);number=String(currencyNumber).trim();const negativeSignIndex=number.indexOf(\"-\");if(negativeSignIndex>0)return null;let isNegative=negativeSignIndex>-1;return isNegative=void 0!==negativeCurrency?negativeCurrency:isNegative,number=number.replace(\"-\",\"\").replace(nonBreakingSpaceRegExp,\" \").split(symbols.group.replace(nonBreakingSpaceRegExp,\" \")).join(\"\").replace(symbols.decimal,\".\"),number=parseFloat(number),isNaN(number)?number=null:isNegative&&(number*=-1),number&&isPercent&&(number/=100),number}),splitDateFormat$1=intlMethod(function(format,locale=\"en\"){const pattern=datePattern(format,info_localeInfo(locale)),parts=[];let lastIndex=dateFormatRegExp.lastIndex=0,match=dateFormatRegExp.exec(pattern);for(;match;){let value=match[0];if(lastIndex<match.index&&addLiteral(parts,pattern.substring(lastIndex,match.index)),value.startsWith('\"')||value.startsWith(\"'\"))addLiteral(parts,value);else{const specifier=value[0],type=DATE_FIELD_MAP[specifier],part={type:type,pattern:value};\"hour\"===type&&(part.hour12=isHour12(value));const names=NAME_TYPES[type];if(names){const minLength=is_number_isNumber(names.minLength)?names.minLength:names.minLength[specifier],patternLength=value.length;patternLength>=minLength&&(part.names={type:names.type,nameType:dateNameType(patternLength),standAlone:names.standAlone===specifier})}parts.push(part)}lastIndex=dateFormatRegExp.lastIndex,match=dateFormatRegExp.exec(pattern)}return lastIndex<pattern.length&&addLiteral(parts,pattern.substring(lastIndex)),parts}),toString$1=intlMethod(format_toString),weekendRange$1=intlMethod(function(locale){const info=getLocaleInfo(locale);if(info.weekendRange)return info.weekendRange;const weekData=cldr.supplemental.weekData;if(!weekData)throw weekend_range_NoWeekData.error();const territory=localeTerritory(info),end=weekData.weekendEnd[territory]||weekData.weekendEnd[\"001\"];return info.weekendRange={start:DAYS_OF_WEEK.indexOf(weekData.weekendStart[territory]||weekData.weekendStart[\"001\"]),end:DAYS_OF_WEEK.indexOf(end)},info.weekendRange}),LOCALE_REGEX=/_/g;function cldrServiceFactory(localeId){return new fesm2015_CldrIntlService(localeId)}let fesm2015_IntlService=(()=>{let IntlService=class{constructor(){this.changes=new core.o,validatePackage(fesm2015_packageMetadata)}notify(){this.changes.emit()}};return IntlService.ɵfac=function(t){return new(t||IntlService)},IntlService.ɵprov=core.Lb({token:IntlService,factory:function(t){let r=null;return r=t?new t:cldrServiceFactory(core.cc(core.w)),r},providedIn:\"root\"}),IntlService.ngInjectableDef=Object(core.Lb)({factory:function(){return cldrServiceFactory(Object(core.cc)(core.w))},token:IntlService,providedIn:\"root\"}),IntlService=__decorate([__metadata(\"design:paramtypes\",[])],IntlService),IntlService})(),fesm2015_CldrIntlService=(()=>{let CldrIntlService=class extends fesm2015_IntlService{constructor(localeId){super(),this.localeId=localeId}get localeId(){return this.locale}set localeId(value){const locale=value.replace(LOCALE_REGEX,\"-\");locale!==this.locale&&(this.locale=locale,this.notify())}format(format$$1,...values){return format$1(format$$1,values,this.localeId)}toString(value,format$$1,localeId){return toString$1(value,format$$1,localeId||this.localeId)}formatDate(value,format$$1,localeId){return formatDate$1(value,format$$1,localeId||this.localeId)}parseDate(value,format$$1,localeId){return parseDate$1(value,format$$1,localeId||this.localeId)}parseNumber(value,format$$1,localeId){return parseNumber$1(value,localeId||this.localeId,format$$1)}formatNumber(value,format$$1,localeId){return formatNumber$1(value,format$$1,localeId||this.localeId)}dateFieldName(options,localeId){return dateFieldName$1(options,localeId||this.localeId)}dateFormatNames(options,localeId){return dateFormatNames$1(localeId||this.localeId,options)}splitDateFormat(format$$1,localeId){return splitDateFormat$1(format$$1,localeId||this.localeId)}numberSymbols(localeId){return numberSymbols$1(localeId||this.localeId)}firstDay(localeId){return firstDay$1(localeId||this.localeId)}weekendRange(localeId){return weekendRange$1(localeId||this.localeId)}};return CldrIntlService.ɵfac=function(t){return new(t||CldrIntlService)(core.cc(core.w))},CldrIntlService.ɵprov=core.Lb({token:CldrIntlService,factory:function(t){return CldrIntlService.ɵfac(t)}}),CldrIntlService=__decorate([__param(0,Object(core.q)(core.w)),__metadata(\"design:paramtypes\",[String])],CldrIntlService),CldrIntlService})();var export_image=__webpack_require__(\"uekK\"),export_svg=__webpack_require__(\"eO0B\");const fesm2015_c0=[\"content\"];function TooltipPopupComponent_ng_template_0_1_ng_template_0_Template(rf,ctx){}function TooltipPopupComponent_ng_template_0_1_Template(rf,ctx){if(1&rf&&core.Kc(0,TooltipPopupComponent_ng_template_0_1_ng_template_0_Template,0,0,\"ng-template\",5),2&rf){const ctx_r4=core.kc(2);core.pc(\"ngTemplateOutlet\",ctx_r4.seriesTooltipTemplateRef)(\"ngTemplateOutletContext\",ctx_r4.seriesTooltipContext)}}function TooltipPopupComponent_ng_template_0_2_ng_template_0_Template(rf,ctx){}function TooltipPopupComponent_ng_template_0_2_Template(rf,ctx){if(1&rf&&core.Kc(0,TooltipPopupComponent_ng_template_0_2_ng_template_0_Template,0,0,\"ng-template\",5),2&rf){const ctx_r5=core.kc(2);core.pc(\"ngTemplateOutlet\",ctx_r5.seriesSharedTooltipTemplateRef)(\"ngTemplateOutletContext\",ctx_r5.seriesSharedTooltipContext)}}function TooltipPopupComponent_ng_template_0_Template(rf,ctx){if(1&rf&&(core.Vb(0,\"div\",3),core.Kc(1,TooltipPopupComponent_ng_template_0_1_Template,1,2,void 0,4),core.Kc(2,TooltipPopupComponent_ng_template_0_2_Template,1,2,void 0,4),core.Ub()),2&rf){const ctx_r1=core.kc();core.pc(\"ngClass\",ctx_r1.popupClasses)(\"ngStyle\",ctx_r1.style),core.Cb(1),core.pc(\"ngIf\",!ctx_r1.shared),core.Cb(1),core.pc(\"ngIf\",ctx_r1.shared)}}function TooltipPopupComponent_ng_template_2_Template(rf,ctx){1&rf&&core.Qb(0,\"span\",6),2&rf&&core.pc(\"innerHTML\",ctx.formattedValue,core.Bc)}function TooltipPopupComponent_ng_template_3_tr_4_td_1_Template(rf,ctx){if(1&rf&&(core.Vb(0,\"td\"),core.Qb(1,\"span\",8),core.Ub()),2&rf){const point_r15=core.kc().$implicit;core.Cb(1),core.Hc(\"background-color\",point_r15.series.color)}}function TooltipPopupComponent_ng_template_3_tr_4_td_2_ng_container_1_Template(rf,ctx){if(1&rf&&(core.Tb(0),core.Mc(1),core.Sb()),2&rf){const point_r15=core.kc(2).$implicit;core.Cb(1),core.Nc(point_r15.series.name)}}function TooltipPopupComponent_ng_template_3_tr_4_td_2_ng_container_2_Template(rf,ctx){1&rf&&(core.Tb(0),core.Mc(1,\" \"),core.Sb())}function TooltipPopupComponent_ng_template_3_tr_4_td_2_Template(rf,ctx){if(1&rf&&(core.Vb(0,\"td\"),core.Kc(1,TooltipPopupComponent_ng_template_3_tr_4_td_2_ng_container_1_Template,2,1,\"ng-container\",4),core.Kc(2,TooltipPopupComponent_ng_template_3_tr_4_td_2_ng_container_2_Template,2,0,\"ng-container\",4),core.Ub()),2&rf){const point_r15=core.kc().$implicit;core.Cb(1),core.pc(\"ngIf\",void 0!==point_r15.series.name),core.Cb(1),core.pc(\"ngIf\",void 0===point_r15.series.name)}}function TooltipPopupComponent_ng_template_3_tr_4_ng_template_4_Template(rf,ctx){}function TooltipPopupComponent_ng_template_3_tr_4_Template(rf,ctx){if(1&rf&&(core.Vb(0,\"tr\"),core.Kc(1,TooltipPopupComponent_ng_template_3_tr_4_td_1_Template,2,2,\"td\",4),core.Kc(2,TooltipPopupComponent_ng_template_3_tr_4_td_2_Template,3,2,\"td\",4),core.Vb(3,\"td\"),core.Kc(4,TooltipPopupComponent_ng_template_3_tr_4_ng_template_4_Template,0,0,\"ng-template\",5),core.Ub(),core.Ub()),2&rf){const point_r15=ctx.$implicit,ctx_r24=core.kc(),colorMarker_r12=ctx_r24.colorMarker,nameColumn_r13=ctx_r24.nameColumn;core.Cb(1),core.pc(\"ngIf\",colorMarker_r12),core.Cb(1),core.pc(\"ngIf\",nameColumn_r13),core.Cb(2),core.pc(\"ngTemplateOutlet\",point_r15.template)(\"ngTemplateOutletContext\",point_r15)}}function TooltipPopupComponent_ng_template_3_Template(rf,ctx){if(1&rf&&(core.Vb(0,\"table\"),core.Vb(1,\"tr\"),core.Vb(2,\"th\"),core.Mc(3),core.Ub(),core.Ub(),core.Kc(4,TooltipPopupComponent_ng_template_3_tr_4_Template,5,4,\"tr\",7),core.Ub()),2&rf){const points_r9=ctx.points,categoryText_r10=ctx.categoryText,colspan_r11=ctx.colspan;core.Cb(2),core.Db(\"colspan\",colspan_r11),core.Cb(1),core.Oc(\" \",categoryText_r10,\" \"),core.Cb(1),core.pc(\"ngForOf\",points_r9)}}function CrosshairTooltipComponent_ng_template_0_Template(rf,ctx){if(1&rf&&(core.Vb(0,\"div\",1),core.Mc(1),core.Ub()),2&rf){const ctx_r1=core.kc();core.pc(\"ngStyle\",ctx_r1.style),core.Cb(1),core.Oc(\" \",ctx_r1.value,\" \")}}function CrosshairTooltipsContainerComponent_kendo_chart_crosshair_tooltip_0_Template(rf,ctx){if(1&rf&&core.Qb(0,\"kendo-chart-crosshair-tooltip\",1),2&rf){const key_r1=ctx.$implicit,ctx_r0=core.kc();core.pc(\"key\",key_r1)(\"popupSettings\",ctx_r0.popupSettings)}}const fesm2015_c1=[\"surface\"];function ChartComponent_div_5_ng_template_1_Template(rf,ctx){}function ChartComponent_div_5_Template(rf,ctx){if(1&rf&&(core.Vb(0,\"div\",6),core.Kc(1,ChartComponent_div_5_ng_template_1_Template,0,0,\"ng-template\",7),core.Ub()),2&rf){const ctx_r1=core.kc();core.pc(\"ngStyle\",ctx_r1.donutCenterStyle),core.Cb(1),core.pc(\"ngTemplateOutlet\",ctx_r1.donutCenterTemplate.templateRef)}}const dist_fesm2015_packageMetadata={name:\"@progress/kendo-angular-charts\",productName:\"Kendo UI for Angular\",productCodes:[\"KENDOUIANGULAR\",\"KENDOUICOMPLETE\"],publishDate:1620213099,version:\"\",licensingDocsUrl:\"https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning\"};let fesm2015_ChartComponentGenerated=(()=>{class ChartComponentGenerated{constructor(configurationService){this.configurationService=configurationService,this.axisLabelClick=new core.o,this.drag=new core.o,this.dragEnd=new core.o,this.dragStart=new core.o,this.legendItemHover=new core.o,this.legendItemLeave=new core.o,this.noteClick=new core.o,this.noteHover=new core.o,this.noteLeave=new core.o,this.paneRender=new core.o,this.plotAreaClick=new core.o,this.plotAreaHover=new core.o,this.plotAreaLeave=new core.o,this.render=new core.o,this.select=new core.o,this.selectEnd=new core.o,this.selectStart=new core.o,this.seriesClick=new core.o,this.seriesHover=new core.o,this.seriesOver=new core.o,this.seriesLeave=new core.o,this.zoom=new core.o,this.zoomEnd=new core.o,this.zoomStart=new core.o}}return ChartComponentGenerated.ɵfac=function(t){core.fc()},ChartComponentGenerated.ɵdir=core.Kb({type:ChartComponentGenerated,inputs:{pannable:\"pannable\",renderAs:\"renderAs\",seriesColors:\"seriesColors\",title:\"title\",transitions:\"transitions\",zoomable:\"zoomable\",axisDefaults:\"axisDefaults\",categoryAxis:\"categoryAxis\",chartArea:\"chartArea\",legend:\"legend\",panes:\"panes\",paneDefaults:\"paneDefaults\",plotArea:\"plotArea\",series:\"series\",seriesDefaults:\"seriesDefaults\",tooltip:\"tooltip\",valueAxis:\"valueAxis\",xAxis:\"xAxis\",yAxis:\"yAxis\"},outputs:{axisLabelClick:\"axisLabelClick\",drag:\"drag\",dragEnd:\"dragEnd\",dragStart:\"dragStart\",legendItemHover:\"legendItemHover\",legendItemLeave:\"legendItemLeave\",noteClick:\"noteClick\",noteHover:\"noteHover\",noteLeave:\"noteLeave\",paneRender:\"paneRender\",plotAreaClick:\"plotAreaClick\",plotAreaHover:\"plotAreaHover\",plotAreaLeave:\"plotAreaLeave\",render:\"render\",select:\"select\",selectEnd:\"selectEnd\",selectStart:\"selectStart\",seriesClick:\"seriesClick\",seriesHover:\"seriesHover\",seriesOver:\"seriesOver\",seriesLeave:\"seriesLeave\",zoom:\"zoom\",zoomEnd:\"zoomEnd\",zoomStart:\"zoomStart\"}}),ChartComponentGenerated})();class Change{constructor(key,value){this.key=key,this.value=value}}let fesm2015_ConfigurationService=(()=>{let ConfigurationService=class{constructor(ngZone){this.ngZone=ngZone,this.store={},this.source=new BehaviorSubject.a({}),this.initSource()}initSource(){this.onFastChange$=this.source.asObservable(),this.onChange$=this.onFastChange$.pipe(Object(auditTime.a)(16.666666666666668))}push(store){this.store=store,this.next()}notify(change){this.set(change.key,change.value),this.next()}set(field,value){let store=this.store;const parts=field.split(\".\");let key=parts.shift();for(;parts.length>0;)store=store[key]=store[key]||{},key=parts.shift();store[key]=value}next(){this.ngZone.runOutsideAngular(()=>{this.source.next(this.store)})}};return ConfigurationService.ɵfac=function(t){return new(t||ConfigurationService)(core.cc(core.B))},ConfigurationService.ɵprov=core.Lb({token:ConfigurationService,factory:function(t){return ConfigurationService.ɵfac(t)}}),ConfigurationService=__decorate([__metadata(\"design:paramtypes\",[core.B])],ConfigurationService),ConfigurationService})();class BaseEvent{constructor(sender){this.sender=sender}}class fesm2015_PreventableEvent extends BaseEvent{constructor(){super(...arguments),this.prevented=!1}preventDefault(){this.prevented=!0}isDefaultPrevented(){return this.prevented}}class LegendEvent extends fesm2015_PreventableEvent{constructor(e,sender){super(sender),this.series=e.series,this.seriesIndex=e.seriesIndex,this.pointIndex=e.pointIndex,this.text=e.text}}class LegendItemClickEvent extends LegendEvent{preventDefault(){super.preventDefault()}}class NoteEvent extends BaseEvent{constructor(e,sender){super(sender),this.category=e.category,this.dataItem=e.dataItem,this.series=e.series,this.value=e.value,this.visual=e.visual}}class RenderEvent extends BaseEvent{constructor(_e,sender){super(sender)}}class SeriesEvent extends fesm2015_PreventableEvent{constructor(e,sender){super(sender),this.category=e.category,this.dataItem=e.dataItem,this.originalEvent=e.originalEvent,this.percentage=e.percentage,this.point=e.point,this.series=e.series,this.stackValue=e.stackValue,this.value=e.value}}const EVENT_MAP={axisLabelClick:class extends BaseEvent{constructor(e,sender){super(sender),this.axis=e.axis,this.dataItem=e.dataItem,this.index=e.index,this.text=e.text,this.value=e.value}},drag:class extends fesm2015_PreventableEvent{constructor(e,sender){super(sender),this.axisRanges=e.axisRanges,this.originalEvent=e.originalEvent}},dragEnd:class extends BaseEvent{constructor(e,sender){super(sender),this.axisRanges=e.axisRanges,this.originalEvent=e.originalEvent}},dragStart:class extends fesm2015_PreventableEvent{constructor(e,sender){super(sender),this.axisRanges=e.axisRanges,this.originalEvent=e.originalEvent}},legendItemHover:class extends LegendEvent{preventDefault(){super.preventDefault()}},legendItemLeave:class extends LegendEvent{preventDefault(){}isDefaultPrevented(){return!1}},noteClick:class extends NoteEvent{},noteHover:class extends NoteEvent{},noteLeave:class extends NoteEvent{},paneRender:class extends BaseEvent{constructor(args,sender){super(sender),Object.assign(this,args)}},plotAreaClick:class extends BaseEvent{constructor(e,sender){super(sender),this.category=e.category,this.originalEvent=e.originalEvent,this.value=e.value,this.x=e.x,this.y=e.y}},plotAreaHover:class extends BaseEvent{constructor(e,sender){super(sender),this.category=e.category,this.originalEvent=e.originalEvent,this.value=e.value,this.x=e.x,this.y=e.y}},plotAreaLeave:class extends BaseEvent{},render:RenderEvent,select:class extends fesm2015_PreventableEvent{constructor(e,sender){super(sender),this.axis=e.axis,this.from=e.from,this.to=e.to}},selectEnd:class extends BaseEvent{constructor(e,sender){super(sender),this.axis=e.axis,this.from=e.from,this.to=e.to}},selectStart:class extends fesm2015_PreventableEvent{constructor(e,sender){super(sender),this.axis=e.axis,this.from=e.from,this.to=e.to}},seriesClick:class extends BaseEvent{constructor(e,sender){super(sender),this.category=e.category,this.dataItem=e.dataItem,this.originalEvent=e.originalEvent,this.percentage=e.percentage,this.point=e.point,this.series=e.series,this.stackValue=e.stackValue,this.value=e.value}},seriesHover:class extends SeriesEvent{},seriesOver:class extends SeriesEvent{},seriesLeave:class extends SeriesEvent{},zoom:class extends fesm2015_PreventableEvent{constructor(e,sender){super(sender),this.axisRanges=e.axisRanges,this.delta=e.delta,this.originalEvent=e.originalEvent}},zoomEnd:class extends BaseEvent{constructor(e,sender){super(sender),this.axisRanges=e.axisRanges,this.originalEvent=e.originalEvent}},zoomStart:class extends fesm2015_PreventableEvent{constructor(e,sender){super(sender),this.axisRanges=e.axisRanges,this.originalEvent=e.originalEvent}}};let fesm2015_InstanceEventService=(()=>{class InstanceEventService{create(name,args,sender){if(EVENT_MAP[name])return new EVENT_MAP[name](args,sender)}}return InstanceEventService.ɵfac=function(t){return new(t||InstanceEventService)},InstanceEventService.ɵprov=core.Lb({token:InstanceEventService,factory:InstanceEventService.ɵfac}),InstanceEventService})(),fesm2015_DonutCenterTemplateDirective=(()=>{let DonutCenterTemplateDirective=class{constructor(templateRef){this.templateRef=templateRef}};return DonutCenterTemplateDirective.ɵfac=function(t){return new(t||DonutCenterTemplateDirective)(core.Pb(core.O,8))},DonutCenterTemplateDirective.ɵdir=core.Kb({type:DonutCenterTemplateDirective,selectors:[[\"\",\"kendoChartDonutCenterTemplate\",\"\"]]}),DonutCenterTemplateDirective=__decorate([__param(0,Object(core.C)()),__metadata(\"design:paramtypes\",[core.O])],DonutCenterTemplateDirective),DonutCenterTemplateDirective})();class ItemChange{constructor(sender,options){this.sender=sender,this.options=options}}let fesm2015_CollectionService=(()=>{let CollectionService=class{constructor(){this.source=new Subject.a,this.onItemChange$=this.source.asObservable()}notify(change){this.source.next(change)}};return CollectionService.ɵfac=function(t){return new(t||CollectionService)},CollectionService.ɵprov=core.Lb({token:CollectionService,factory:function(t){return CollectionService.ɵfac(t)}}),CollectionService=__decorate([__metadata(\"design:paramtypes\",[])],CollectionService),CollectionService})();function copyChanges(changes,options){for(const propertyName in changes){if(!changes.hasOwnProperty(propertyName))continue;const value=changes[propertyName].currentValue;void 0===value?delete options[propertyName]:options[propertyName]=value}}function toSimpleChanges(changes){const result={};for(const propertyName in changes)changes.hasOwnProperty(propertyName)&&(result[propertyName]=new core.L(null,changes[propertyName],!1));return result}let fesm2015_CollectionItemComponent=(()=>{class CollectionItemComponent{constructor(configurationService,collectionService){this.configurationService=configurationService,this.collectionService=collectionService,this.options={},this.subscription=configurationService.onFastChange$.subscribe(store=>{this.options=store,this.notify()})}ngOnChanges(changes){const store=this.configurationService.store;copyChanges(changes,store),this.configurationService.push(store)}notifyChanges(changes){this.ngOnChanges(toSimpleChanges(changes))}ngOnDestroy(){this.subscription.unsubscribe()}notify(){this.collectionService&&this.collectionService.notify(new ItemChange(this,this.options))}}return CollectionItemComponent.ɵfac=function(t){core.fc()},CollectionItemComponent.ɵdir=core.Kb({type:CollectionItemComponent,features:[core.Ab]}),CollectionItemComponent})(),fesm2015_SeriesItemComponentGenerated=(()=>{class SeriesItemComponentGenerated extends fesm2015_CollectionItemComponent{constructor(configurationService,collectionService){super(configurationService,collectionService),this.configurationService=configurationService,this.collectionService=collectionService}}return SeriesItemComponentGenerated.ɵfac=function(t){core.fc()},SeriesItemComponentGenerated.ɵdir=core.Kb({type:SeriesItemComponentGenerated,inputs:{aggregate:\"aggregate\",autoFit:\"autoFit\",axis:\"axis\",border:\"border\",categoryAxis:\"categoryAxis\",categoryField:\"categoryField\",closeField:\"closeField\",color:\"color\",colorField:\"colorField\",connectors:\"connectors\",currentField:\"currentField\",dashType:\"dashType\",data:\"data\",downColor:\"downColor\",downColorField:\"downColorField\",dynamicHeight:\"dynamicHeight\",dynamicSlope:\"dynamicSlope\",errorHighField:\"errorHighField\",errorLowField:\"errorLowField\",explodeField:\"explodeField\",field:\"field\",fromField:\"fromField\",gap:\"gap\",highField:\"highField\",holeSize:\"holeSize\",line:\"line\",lowField:\"lowField\",lowerField:\"lowerField\",margin:\"margin\",maxSize:\"maxSize\",mean:\"mean\",meanField:\"meanField\",median:\"median\",medianField:\"medianField\",minSize:\"minSize\",missingValues:\"missingValues\",name:\"name\",neckRatio:\"neckRatio\",negativeColor:\"negativeColor\",negativeValues:\"negativeValues\",noteTextField:\"noteTextField\",opacity:\"opacity\",openField:\"openField\",outliersField:\"outliersField\",overlay:\"overlay\",padding:\"padding\",q1Field:\"q1Field\",q3Field:\"q3Field\",segmentSpacing:\"segmentSpacing\",size:\"size\",sizeField:\"sizeField\",spacing:\"spacing\",stack:\"stack\",startAngle:\"startAngle\",style:\"style\",summaryField:\"summaryField\",target:\"target\",toField:\"toField\",type:\"type\",upperField:\"upperField\",visible:\"visible\",visibleInLegend:\"visibleInLegend\",visibleInLegendField:\"visibleInLegendField\",visual:\"visual\",width:\"width\",whiskers:\"whiskers\",xAxis:\"xAxis\",xErrorHighField:\"xErrorHighField\",xErrorLowField:\"xErrorLowField\",xField:\"xField\",yAxis:\"yAxis\",yErrorHighField:\"yErrorHighField\",yErrorLowField:\"yErrorLowField\",yField:\"yField\",zIndex:\"zIndex\",errorBars:\"errorBars\",extremes:\"extremes\",highlight:\"highlight\",labels:\"labels\",markers:\"markers\",notes:\"notes\",outliers:\"outliers\",tooltip:\"tooltip\"},features:[core.zb]}),SeriesItemComponentGenerated})(),fesm2015_SettingsComponent=(()=>{class SettingsComponent{constructor(configKey,configurationService){if(this.configKey=configKey,this.configurationService=configurationService,this.store={},void 0===configKey)throw new Error(\"Configuration key not set\")}ngOnDestroy(){this.store=void 0,this.notify()}ngOnChanges(changes){copyChanges(changes,this.store),this.notify()}notifyChanges(changes){this.ngOnChanges(toSimpleChanges(changes))}markAsVisible(){this.store.visible=!0,this.notify()}notify(){this.configurationService.notify(new Change(this.configKey,this.store))}}return SettingsComponent.ɵfac=function(t){core.fc()},SettingsComponent.ɵdir=core.Kb({type:SettingsComponent,features:[core.Ab]}),SettingsComponent})(),fesm2015_SeriesTooltipComponentGenerated=(()=>{class SeriesTooltipComponentGenerated extends fesm2015_SettingsComponent{constructor(configurationService){super(\"tooltip\",configurationService),this.configurationService=configurationService}}return SeriesTooltipComponentGenerated.ɵfac=function(t){core.fc()},SeriesTooltipComponentGenerated.ɵdir=core.Kb({type:SeriesTooltipComponentGenerated,inputs:{background:\"background\",border:\"border\",color:\"color\",font:\"font\",format:\"format\",padding:\"padding\",visible:\"visible\"},features:[core.zb]}),SeriesTooltipComponentGenerated})(),fesm2015_SeriesTooltipComponent=(()=>{let SeriesTooltipComponent=class extends fesm2015_SeriesTooltipComponentGenerated{constructor(configurationService){super(configurationService),this.configurationService=configurationService,this.markAsVisible()}get seriesTooltipTemplateRef(){return this.seriesTooltipTemplate}};return SeriesTooltipComponent.ɵfac=function(t){return new(t||SeriesTooltipComponent)(core.Pb(fesm2015_ConfigurationService))},SeriesTooltipComponent.ɵcmp=core.Jb({type:SeriesTooltipComponent,selectors:[[\"kendo-chart-series-item-tooltip\"]],contentQueries:function(rf,ctx,dirIndex){if(1&rf&&core.Ib(dirIndex,core.O,!0),2&rf){let _t;core.wc(_t=core.hc())&&(ctx.seriesTooltipTemplate=_t.first)}},features:[core.zb],decls:0,vars:0,template:function(rf,ctx){},encapsulation:2,changeDetection:0}),SeriesTooltipComponent=__decorate([__metadata(\"design:paramtypes\",[fesm2015_ConfigurationService])],SeriesTooltipComponent),SeriesTooltipComponent})();const fesm2015_toggle=flag=>void 0!==flag&&!flag;let fesm2015_SeriesItemComponent=(()=>{let SeriesItemComponent=class extends fesm2015_SeriesItemComponentGenerated{constructor(configurationService,collectionService){super(configurationService,collectionService),this.configurationService=configurationService,this.collectionService=collectionService}toggleVisibility(){this.options.visible=fesm2015_toggle(this.options.visible),this.notify()}togglePointVisibility(pointIndex){const pv=this.options.pointVisibility=this.options.pointVisibility||{};pv[pointIndex]=fesm2015_toggle(pv[pointIndex]),this.notify()}get seriesTooltipTemplateRef(){if(this.seriesTooltip)return this.seriesTooltip.seriesTooltipTemplateRef}};return SeriesItemComponent.ɵfac=function(t){return new(t||SeriesItemComponent)(core.Pb(fesm2015_ConfigurationService),core.Pb(fesm2015_CollectionService))},SeriesItemComponent.ɵcmp=core.Jb({type:SeriesItemComponent,selectors:[[\"kendo-chart-series-item\"]],contentQueries:function(rf,ctx,dirIndex){if(1&rf&&core.Ib(dirIndex,fesm2015_SeriesTooltipComponent,!0),2&rf){let _t;core.wc(_t=core.hc())&&(ctx.seriesTooltip=_t.first)}},features:[core.Bb([fesm2015_ConfigurationService]),core.zb],decls:0,vars:0,template:function(rf,ctx){},encapsulation:2,changeDetection:0}),SeriesItemComponent=__decorate([__metadata(\"design:paramtypes\",[fesm2015_ConfigurationService,fesm2015_CollectionService])],SeriesItemComponent),SeriesItemComponent})();const font=style=>`${style.fontWeight} ${style.fontSize} ${style.fontFamily}`,computedBackgroundColor=element=>window.getComputedStyle(element).backgroundColor;let fesm2015_ThemeService=(()=>{let ThemeService=class extends fesm2015_ConfigurationService{constructor(ngZone){super(ngZone),this.loaded=!1}loadTheme(){!this.loaded&&isDocumentAvailable()&&(this.readTheme()||this.readDefaultTheme(),this.loaded=!0,this.next())}readTheme(){this.createElement();const available=this.queryColor(\"accent\")!==this.queryColor(\"accent-contrast\");try{available&&(this.push(baseTheme()),this.setColors(),this.setFonts(),this.setSeriesColors())}finally{this.destroyElement()}return available}readDefaultTheme(){this.push(Object.assign({},baseTheme(),{axisDefaults:{crosshair:{color:\"rgba(0, 0, 0, 0.5)\"},labels:{color:\"rgb(101, 101, 101)\",font:\"12px serif\"},line:{color:\"rgba(0, 0, 0, 0.08)\"},majorGridLines:{color:\"rgba(0, 0, 0, 0.08)\"},minorGridLines:{color:\"rgba(0, 0, 0, 0.04)\"},notes:{icon:{background:\"rgba(0, 0, 0, 0.5)\",border:{color:\"rgba(0, 0, 0, 0.5)\"}},line:{color:\"rgba(0, 0, 0, 0.5)\"},label:{font:\"14px serif\"}},title:{color:\"rgb(101, 101, 101)\",font:\"14px serif\"}},chartArea:{background:\"rgb(255, 255, 255)\"},legend:{inactiveItems:{labels:{color:\"rgba(102, 102, 102, 0.5)\"},markers:{color:\"rgba(102, 102, 102, 0.5)\"}},labels:{color:\"rgb(101, 101, 101)\",font:\"14px serif\"}},seriesDefaults:{boxPlot:{downColor:\"rgba(0, 0, 0, 0.08)\",mean:{color:\"rgb(246, 246, 246)\"},median:{color:\"rgb(246, 246, 246)\"},whiskers:{color:\"rgb(255, 99, 88)\"}},bullet:{target:{color:\"rgb(101, 101, 101)\"}},candlestick:{downColor:\"rgb(101, 101, 101)\",line:{color:\"rgb(101, 101, 101)\"}},errorBars:{color:\"rgba(0, 0, 0, 0.5)\"},horizontalWaterfall:{line:{color:\"rgba(0, 0, 0, 0.08)\"}},icon:{border:{color:\"rgba(0, 0, 0, 0.08)\"}},labels:{background:\"rgb(255, 255, 255)\",color:\"rgb(101, 101, 101)\",opacity:.8,font:\"12px serif\"},notes:{icon:{background:\"rgba(0, 0, 0, 0.5)\",border:{color:\"rgba(0, 0, 0, 0.5)\"}},line:{color:\"rgba(0, 0, 0, 0.5)\"},label:{font:\"14px serif\"}},overlay:{gradient:\"none\"},verticalBoxPlot:{downColor:\"rgba(0, 0, 0, 0.08)\",mean:{color:\"rgb(246, 246, 246)\"},median:{color:\"rgb(246, 246, 246)\"},whiskers:{color:\"rgb(255, 99, 88)\"}},verticalBullet:{target:{color:\"rgb(101, 101, 101)\"}},waterfall:{line:{color:\"rgba(0, 0, 0, 0.08)\"}},area:{opacity:.8}},title:{color:\"rgb(101, 101, 101)\",font:\"16px serif\"},seriesColors:[\"rgb(255, 99, 88)\",\"rgb(255, 210, 70)\",\"rgb(120, 210, 55)\",\"rgb(40, 180, 200)\",\"rgb(45, 115, 245)\",\"rgb(170, 70, 190)\"]}))}createElement(){const container=this.element=document.createElement(\"div\");container.style.display=\"none\",container.innerHTML=`\\n    <div class=\"k-var--accent\"></div>\\n    <div class=\"k-var--accent-contrast\"></div>\\n    <div class=\"k-var--base\"></div>\\n    <div class=\"k-var--background\"></div>\\n\\n    <div class=\"k-var--normal-background\"></div>\\n    <div class=\"k-var--normal-text-color\"></div>\\n    <div class=\"k-var--hover-background\"></div>\\n    <div class=\"k-var--hover-text-color\"></div>\\n    <div class=\"k-var--selected-background\"></div>\\n    <div class=\"k-var--selected-text-color\"></div>\\n    <div class=\"k-var--chart-error-bars-background\"></div>\\n    <div class=\"k-var--chart-notes-background\"></div>\\n    <div class=\"k-var--chart-notes-border\"></div>\\n    <div class=\"k-var--chart-notes-lines\"></div>\\n    <div class=\"k-var--chart-crosshair-background\"></div>\\n\\n    <div class=\"k-var--chart-inactive\"></div>\\n    <div class=\"k-var--chart-major-lines\"></div>\\n    <div class=\"k-var--chart-minor-lines\"></div>\\n    <div class=\"k-var--chart-area-opacity\"></div>\\n    <div class=\"k-var--chart-area-inactive-opacity\"></div>\\n    <div class=\"k-var--chart-line-inactive-opacity\"></div>\\n\\n    <div class=\"k-widget k-chart\">\\n        <div class=\"k-var--chart-font\"></div>\\n        <div class=\"k-var--chart-title-font\"></div>\\n        <div class=\"k-var--chart-pane-title-font\"></div>\\n        <div class=\"k-var--chart-label-font\"></div>\\n    </div>\\n\\n    <div class=\"k-var--series-unset\"></div>\\n    <div class=\"k-var--series\">\\n      ${(()=>{let template='\\n      <div class=\"k-var--series-a\"></div>\\n      <div class=\"k-var--series-b\"></div>\\n      <div class=\"k-var--series-c\"></div>\\n      <div class=\"k-var--series-d\"></div>\\n      <div class=\"k-var--series-e\"></div>\\n      <div class=\"k-var--series-f\"></div>\\n  ';for(let i=0;i<30;i++)template+=`\\n      <div class=\"k-var--series-${i+1}\"></div>`;return template})()}\\n    </div>\\n`,document.body.appendChild(container)}destroyElement(){this.element&&(document.body.removeChild(this.element),this.element=void 0)}setStyle(key,value){this.set(key,value)}setColors(){this.mapColor(\"axisDefaults.crosshair.color\",\"chart-crosshair-background\"),this.mapColor(\"axisDefaults.labels.color\",\"normal-text-color\"),this.mapColor(\"axisDefaults.line.color\",\"chart-major-lines\"),this.mapColor(\"axisDefaults.majorGridLines.color\",\"chart-major-lines\"),this.mapColor(\"axisDefaults.minorGridLines.color\",\"chart-minor-lines\"),this.mapColor(\"axisDefaults.notes.icon.background\",\"chart-notes-background\"),this.mapColor(\"axisDefaults.notes.icon.border.color\",\"chart-notes-border\"),this.mapColor(\"axisDefaults.notes.line.color\",\"chart-notes-lines\"),this.mapColor(\"axisDefaults.title.color\",\"normal-text-color\"),this.mapColor(\"chartArea.background\",\"background\"),this.mapColor(\"legend.inactiveItems.labels.color\",\"chart-inactive\"),this.mapColor(\"legend.inactiveItems.markers.color\",\"chart-inactive\"),this.mapColor(\"legend.labels.color\",\"normal-text-color\"),this.mapColor(\"seriesDefaults.boxPlot.downColor\",\"chart-major-lines\"),this.mapColor(\"seriesDefaults.boxPlot.mean.color\",\"base\"),this.mapColor(\"seriesDefaults.boxPlot.median.color\",\"base\"),this.mapColor(\"seriesDefaults.boxPlot.whiskers.color\",\"accent\"),this.mapColor(\"seriesDefaults.bullet.target.color\",\"normal-text-color\"),this.mapColor(\"seriesDefaults.candlestick.downColor\",\"normal-text-color\"),this.mapColor(\"seriesDefaults.candlestick.line.color\",\"normal-text-color\"),this.mapColor(\"seriesDefaults.errorBars.color\",\"chart-error-bars-background\"),this.mapColor(\"seriesDefaults.horizontalWaterfall.line.color\",\"chart-major-lines\"),this.mapColor(\"seriesDefaults.icon.border.color\",\"chart-major-lines\"),this.mapColor(\"seriesDefaults.labels.background\",\"background\"),this.mapColor(\"seriesDefaults.labels.color\",\"normal-text-color\"),this.mapColor(\"seriesDefaults.notes.icon.background\",\"chart-notes-background\"),this.mapColor(\"seriesDefaults.notes.icon.border.color\",\"chart-notes-border\"),this.mapColor(\"seriesDefaults.notes.line.color\",\"chart-notes-lines\"),this.mapColor(\"seriesDefaults.verticalBoxPlot.downColor\",\"chart-major-lines\"),this.mapColor(\"seriesDefaults.verticalBoxPlot.mean.color\",\"base\"),this.mapColor(\"seriesDefaults.verticalBoxPlot.median.color\",\"base\"),this.mapColor(\"seriesDefaults.verticalBoxPlot.whiskers.color\",\"accent\"),this.mapColor(\"seriesDefaults.verticalBullet.target.color\",\"normal-text-color\"),this.mapColor(\"seriesDefaults.waterfall.line.color\",\"chart-major-lines\"),this.mapColor(\"title.color\",\"normal-text-color\");const opacity=parseFloat(this.queryStyle(\"chart-area-opacity\").opacity);isNaN(opacity)||(this.setStyle(\"seriesDefaults.area.opacity\",opacity),this.setStyle(\"seriesDefaults.radarArea.opacity\",opacity),this.setStyle(\"seriesDefaults.verticalArea.opacity\",opacity),this.setStyle(\"seriesDefaults.labels.opacity\",opacity)),this.setInactiveOpacity([\"area\",\"verticalArea\"],\"chart-area-inactive-opacity\"),this.setInactiveOpacity([\"line\",\"verticalLine\"],\"chart-line-inactive-opacity\")}setInactiveOpacity(seriesTypes,selector){const inactiveOpacity=parseFloat(this.queryStyle(selector).opacity);!isNaN(inactiveOpacity)&&inactiveOpacity<1&&seriesTypes.forEach(type=>this.setStyle(`seriesDefaults.${type}.highlight.inactiveOpacity`,inactiveOpacity))}setFonts(){const defaultFont=font(this.queryStyle(\"chart-font\")),titleFont=font(this.queryStyle(\"chart-title-font\")),paneTitleFont=font(this.queryStyle(\"chart-pane-title-font\")),labelFont=font(this.queryStyle(\"chart-label-font\"));this.setStyle(\"axisDefaults.labels.font\",labelFont),this.setStyle(\"axisDefaults.notes.label.font\",defaultFont),this.setStyle(\"axisDefaults.title.font\",defaultFont),this.setStyle(\"legend.labels.font\",defaultFont),this.setStyle(\"seriesDefaults.labels.font\",labelFont),this.setStyle(\"seriesDefaults.notes.label.font\",defaultFont),this.setStyle(\"title.font\",titleFont),this.setStyle(\"paneDefaults.title.font\",paneTitleFont)}setSeriesColors(){const element=this.element,series=[].slice.call(element.querySelectorAll(\".k-var--series div\")),unsetColor=computedBackgroundColor(element.querySelector(\".k-var--series-unset\")),seriesColors=series.reduce((arr,el)=>{const pos=(name=>{const alpha=name.match(/series-([a-z])$/);if(null!==alpha)return alpha[1].toLowerCase().charCodeAt(0)-\"a\".charCodeAt(0);const num=name.split(\"--series-\")[1];return parseInt(num,10)-1})(el.className),color=computedBackgroundColor(el);return color!==unsetColor&&(arr[pos]=color),arr},[]);this.setStyle(\"seriesColors\",seriesColors)}mapColor(key,varName){this.setStyle(key,this.queryColor(varName))}queryColor(varName){return this.queryStyle(varName).backgroundColor}queryStyle(varName){const element=this.element.querySelector(\".k-var--\"+varName);return window.getComputedStyle(element)}};return ThemeService.ɵfac=function(t){return new(t||ThemeService)(core.cc(core.B))},ThemeService.ɵprov=core.Lb({token:ThemeService,factory:function(t){return ThemeService.ɵfac(t)}}),ThemeService=__decorate([__metadata(\"design:paramtypes\",[core.B])],ThemeService),ThemeService})();class fesm2015_ChartInstanceObserver extends instance_observer{constructor(instance){super(instance),this.handlerMap={hideTooltip:\"onHideTooltip\",legendItemClick:\"onLegendItemClick\",render:\"onRender\",showTooltip:\"onShowTooltip\",init:\"onInit\"}}}let fesm2015_TooltipTemplateService=(()=>{let TooltipTemplateService=class{setTemplate(template){this.template=template}getTemplate(seriesIndex){return this.seriesTemplates&&this.seriesTemplates[seriesIndex]?this.seriesTemplates[seriesIndex]:this.template}setSeriesTemplates(seriesTemplates){this.seriesTemplates=seriesTemplates}setSharedTemplate(sharedTemplate){this.sharedTemplate=sharedTemplate}getSharedTemplate(){return this.sharedTemplate}};return TooltipTemplateService.ɵfac=function(t){return new(t||TooltipTemplateService)},TooltipTemplateService.ɵprov=core.Lb({token:TooltipTemplateService,factory:function(t){return TooltipTemplateService.ɵfac(t)}}),TooltipTemplateService})(),fesm2015_SeriesTooltipTemplateDirective=(()=>{let SeriesTooltipTemplateDirective=class{constructor(templateRef){this.templateRef=templateRef}};return SeriesTooltipTemplateDirective.ɵfac=function(t){return new(t||SeriesTooltipTemplateDirective)(core.Pb(core.O,8))},SeriesTooltipTemplateDirective.ɵdir=core.Kb({type:SeriesTooltipTemplateDirective,selectors:[[\"\",\"kendoChartSeriesTooltipTemplate\",\"\"]]}),SeriesTooltipTemplateDirective=__decorate([__param(0,Object(core.C)()),__metadata(\"design:paramtypes\",[core.O])],SeriesTooltipTemplateDirective),SeriesTooltipTemplateDirective})(),fesm2015_SharedTooltipTemplateDirective=(()=>{let SharedTooltipTemplateDirective=class{constructor(templateRef){this.templateRef=templateRef}};return SharedTooltipTemplateDirective.ɵfac=function(t){return new(t||SharedTooltipTemplateDirective)(core.Pb(core.O,8))},SharedTooltipTemplateDirective.ɵdir=core.Kb({type:SharedTooltipTemplateDirective,selectors:[[\"\",\"kendoChartSharedTooltipTemplate\",\"\"]]}),SharedTooltipTemplateDirective=__decorate([__param(0,Object(core.C)()),__metadata(\"design:paramtypes\",[core.O])],SharedTooltipTemplateDirective),SharedTooltipTemplateDirective})();class TooltipTemplatePoint{constructor(point,format,template){this.value=point.value,this.category=point.category,this.categoryIndex=point.categoryIx,this.series=point.series,this.dataItem=point.dataItem,this.percentage=point.percentage,this.runningTotal=point.runningTotal,this.total=point.total,this.low=point.low,this.high=point.high,this.xLow=point.xLow,this.xHigh=point.xHigh,this.yLow=point.yLow,this.yHigh=point.yHigh,this.template=template,this.point=point,this.format=format}get formattedValue(){return this.format?this.point.formatValue(this.format):String(this.value)}}const COLLISION={horizontal:\"fit\",vertical:\"fit\"};let fesm2015_BaseTooltip=(()=>{class BaseTooltip{constructor(popupService,localizationService){this.popupService=popupService,this.localizationService=localizationService,this.style={},this.popupRef=null}get active(){return null!==this.popupRef}show(e){const align=e.anchor.align,offset=this.position(e.anchor.point);if(this.style=e.style,this.popupRef){const popup=this.popupRef.popup.instance;popup.offset=offset,popup.popupAlign=align}else this.popupRef=this.popupService.open(Object.assign({offset:offset,popupAlign:align,animate:this.animate,content:this.templateRef,collision:COLLISION,positionMode:\"absolute\"},this.popupSettings)),this.localizationService.rtl&&this.popupRef.popupElement.setAttribute(\"dir\",\"rtl\"),this.onInit()}hide(){this.popupRef&&(this.popupRef.close(),this.popupRef=null)}onInit(){}ngOnDestroy(){this.hide()}position(offset){if(!this.popupSettings||!this.popupSettings.appendTo)return offset;const appendTo=this.popupSettings.appendTo.element.nativeElement;console.log(\"appendTo\",appendTo);const bbox=appendTo.getBoundingClientRect(),{scrollLeft:scrollLeft,scrollTop:scrollTop}=this.scrollOffset(appendTo);return{left:offset.left-bbox.left-scrollLeft,top:offset.top-bbox.top-scrollTop}}scrollOffset(element){if(!element)return null;let scrollLeft=element.scrollLeft,scrollTop=element.scrollTop,parent=element.parentElement;for(;parent;)scrollLeft+=parent.scrollLeft,scrollTop+=parent.scrollTop,parent=parent.parentElement;return{scrollLeft:scrollLeft,scrollTop:scrollTop}}}return BaseTooltip.ɵfac=function(t){core.fc()},BaseTooltip.ɵdir=core.Kb({type:BaseTooltip}),BaseTooltip})();function hasParent(element,parent){let current=element;for(;current&&current!==parent;)current=current.parentNode;return!!current}function bodyFactory(){if(isDocumentAvailable())return new core.l(document.body)}const ɵ0$2=bodyFactory;let fesm2015_TooltipPopupComponent=(()=>{let TooltipPopupComponent=class extends fesm2015_BaseTooltip{constructor(popupService,templateService,localizationService,ngZone){super(popupService,localizationService),this.popupService=popupService,this.templateService=templateService,this.localizationService=localizationService,this.ngZone=ngZone,this.seriesTooltipContext={},this.seriesSharedTooltipContext={},this.animate=!0,this.wrapperClass=\"k-chart-tooltip-wrapper\",this.leave=new core.o,this.popupClasses={}}show(e){this.shared=e.shared,this.popupClasses=Object.assign({\"k-chart-shared-tooltip\":e.shared,\"k-chart-tooltip\":!0,[e.className]:!!e.className},this.classNames),e.shared?(this.seriesSharedTooltipTemplateRef=this.templateService.getSharedTemplate()||this.defaultSharedTooltipTemplate.templateRef,this.seriesSharedTooltipContext=this.sharedTemplateContext(e)):(this.seriesTooltipContext=new TooltipTemplatePoint(e.point,e.format),this.seriesTooltipTemplateRef=this.pointTemplateRef(e.point)),super.show(e)}containsElement(element){if(this.popupRef)return hasParent(element,this.popupRef.popupElement)}sharedTemplateContext(e){const nameColumn=e.points.filter(point=>void 0!==point.series.name).length>0,colorMarker=e.series.length>1;let colspan=1;return nameColumn&&colspan++,colorMarker&&colspan++,{category:e.category,categoryText:e.categoryText,colorMarker:colorMarker,colspan:colspan,nameColumn:nameColumn,points:this.wrapPoints(e.points,e.format)}}pointTemplateRef(point){return this.templateService.getTemplate(point.series.index)||this.defaultSeriesTooltipTemplate.templateRef}wrapPoints(points,format){const result=[];for(let idx=0;idx<points.length;idx++){const point=points[idx],template=this.pointTemplateRef(point);result.push(new TooltipTemplatePoint(point,((point.options||{}).tooltip||{}).format||format,template))}return result}onInit(){this.ngZone.runOutsideAngular(()=>{this.mouseleaveSubscription=this.popupRef.popupElement.addEventListener(\"mouseleave\",args=>{this.leave.emit(args)})}),this.popupRef.popupElement.className+=\" \"+this.wrapperClass}hide(){this.mouseleaveSubscription&&(this.mouseleaveSubscription(),this.mouseleaveSubscription=null),super.hide()}};return TooltipPopupComponent.ɵfac=function(t){return new(t||TooltipPopupComponent)(core.Pb(fesm2015_PopupService),core.Pb(fesm2015_TooltipTemplateService),core.Pb(fesm2015_LocalizationService),core.Pb(core.B))},TooltipPopupComponent.ɵcmp=core.Jb({type:TooltipPopupComponent,selectors:[[\"kendo-chart-tooltip-popup\"]],viewQuery:function(rf,ctx){if(1&rf&&(core.Rc(fesm2015_SeriesTooltipTemplateDirective,!0),core.Rc(fesm2015_SharedTooltipTemplateDirective,!0),core.Gc(fesm2015_c0,!0)),2&rf){let _t;core.wc(_t=core.hc())&&(ctx.defaultSeriesTooltipTemplate=_t.first),core.wc(_t=core.hc())&&(ctx.defaultSharedTooltipTemplate=_t.first),core.wc(_t=core.hc())&&(ctx.templateRef=_t.first)}},inputs:{animate:\"animate\",wrapperClass:\"wrapperClass\",classNames:\"classNames\",popupSettings:\"popupSettings\"},outputs:{leave:\"leave\"},features:[core.Bb([fesm2015_PopupService,{provide:POPUP_CONTAINER,useFactory:ɵ0$2}]),core.zb],decls:4,vars:0,consts:[[\"content\",\"\"],[\"kendoChartSeriesTooltipTemplate\",\"\"],[\"kendoChartSharedTooltipTemplate\",\"\"],[3,\"ngClass\",\"ngStyle\"],[4,\"ngIf\"],[3,\"ngTemplateOutlet\",\"ngTemplateOutletContext\"],[3,\"innerHTML\"],[4,\"ngFor\",\"ngForOf\"],[1,\"k-chart-shared-tooltip-marker\"]],template:function(rf,ctx){1&rf&&(core.Kc(0,TooltipPopupComponent_ng_template_0_Template,3,4,\"ng-template\",null,0,core.Lc),core.Kc(2,TooltipPopupComponent_ng_template_2_Template,1,1,\"ng-template\",1),core.Kc(3,TooltipPopupComponent_ng_template_3_Template,5,3,\"ng-template\",2))},directives:[fesm2015_SeriesTooltipTemplateDirective,fesm2015_SharedTooltipTemplateDirective,common.j,common.m,common.l,common.q,common.k],encapsulation:2}),TooltipPopupComponent=__decorate([__metadata(\"design:paramtypes\",[fesm2015_PopupService,fesm2015_TooltipTemplateService,fesm2015_LocalizationService,core.B])],TooltipPopupComponent),TooltipPopupComponent})();const ɵ0$3=bodyFactory;let fesm2015_CrosshairTooltipComponent=(()=>{let CrosshairTooltipComponent=class extends fesm2015_BaseTooltip{constructor(popupService,localizationService){super(popupService,localizationService),this.animate=!1}show(e){super.show(e),this.value=e.value,this.popupRef.popup.changeDetectorRef.detectChanges()}};return CrosshairTooltipComponent.ɵfac=function(t){return new(t||CrosshairTooltipComponent)(core.Pb(fesm2015_PopupService),core.Pb(fesm2015_LocalizationService))},CrosshairTooltipComponent.ɵcmp=core.Jb({type:CrosshairTooltipComponent,selectors:[[\"kendo-chart-crosshair-tooltip\"]],viewQuery:function(rf,ctx){if(1&rf&&core.Gc(fesm2015_c0,!0),2&rf){let _t;core.wc(_t=core.hc())&&(ctx.templateRef=_t.first)}},inputs:{key:\"key\",popupSettings:\"popupSettings\"},features:[core.Bb([fesm2015_PopupService,{provide:POPUP_CONTAINER,useFactory:ɵ0$3}]),core.zb],decls:2,vars:0,consts:[[\"content\",\"\"],[1,\"k-chart-tooltip\",\"k-chart-crosshair-tooltip\",3,\"ngStyle\"]],template:function(rf,ctx){1&rf&&core.Kc(0,CrosshairTooltipComponent_ng_template_0_Template,2,2,\"ng-template\",null,0,core.Lc)},directives:[common.m],encapsulation:2}),CrosshairTooltipComponent=__decorate([__metadata(\"design:paramtypes\",[fesm2015_PopupService,fesm2015_LocalizationService])],CrosshairTooltipComponent),CrosshairTooltipComponent})();const AXES=[\"categoryAxis\",\"valueAxis\",\"xAxis\",\"yAxis\"];let fesm2015_CrosshairTooltipsContainerComponent=(()=>{let CrosshairTooltipsContainerComponent=class{constructor(){this.tooltipKeys=[],this.tooltipsMap={}}show(e){const tooltipComponents=this.crossahirTooltipComponents.toArray(),axisName=e.axisName,axisIndex=e.axisIndex;for(let idx=0;idx<tooltipComponents.length;idx++)if(tooltipComponents[idx].key===axisName+axisIndex){tooltipComponents[idx].show(e);break}}hide(){const tooltipComponents=this.crossahirTooltipComponents.toArray();for(let idx=0;idx<tooltipComponents.length;idx++)tooltipComponents[idx].hide()}get active(){return this.tooltipKeys.length>0}createCrosshairTooltips(options){const newMap=this.mapTooltips(options),map=this.tooltipsMap;for(let key in map)newMap[key]||(this.removeTooltip(key),delete map[key]);for(let key in newMap)map[key]||(map[key]=newMap[key],this.tooltipKeys.push(key))}removeTooltip(key){const keys=this.tooltipKeys;for(let idx=0;idx<keys.length;idx++)if(keys[idx]===key){keys.splice(idx,1);break}}mapTooltips(options){const map={};for(let idx=0;idx<AXES.length;idx++){const tooltips=this.axesCrosshairTooltipOptions(options,AXES[idx]);for(let tooltipIdx=0;tooltipIdx<tooltips.length;tooltipIdx++){const tooltip=tooltips[tooltipIdx];map[tooltip.name+tooltip.index]=tooltip}}return map}axesCrosshairTooltipOptions(options,name){const result=[];if(options[name]){const axes=[].concat(options[name]);for(let idx=0;idx<axes.length;idx++){const tooltip=(axes[idx].crosshair||{}).tooltip;tooltip&&tooltip.visible&&result.push({index:idx,name:name})}}return result}};return CrosshairTooltipsContainerComponent.ɵfac=function(t){return new(t||CrosshairTooltipsContainerComponent)},CrosshairTooltipsContainerComponent.ɵcmp=core.Jb({type:CrosshairTooltipsContainerComponent,selectors:[[\"kendo-chart-crosshair-tooltips-container\"]],viewQuery:function(rf,ctx){if(1&rf&&core.Rc(fesm2015_CrosshairTooltipComponent,!0),2&rf){let _t;core.wc(_t=core.hc())&&(ctx.crossahirTooltipComponents=_t)}},inputs:{popupSettings:\"popupSettings\"},decls:1,vars:1,consts:[[3,\"key\",\"popupSettings\",4,\"ngFor\",\"ngForOf\"],[3,\"key\",\"popupSettings\"]],template:function(rf,ctx){1&rf&&core.Kc(0,CrosshairTooltipsContainerComponent_kendo_chart_crosshair_tooltip_0_Template,1,2,\"kendo-chart-crosshair-tooltip\",0),2&rf&&core.pc(\"ngForOf\",ctx.tooltipKeys)},directives:[common.k,fesm2015_CrosshairTooltipComponent],encapsulation:2}),CrosshairTooltipsContainerComponent})();const getTouch=domEvent=>({x:{location:domEvent.pageX},y:{location:domEvent.pageY}});function shouldBindGroup(groupNames,events){for(let idx=0;idx<groupNames.length;idx++)if(events[groupNames[idx]])return!0;return!1}const eventGroups=[{end:\"panend\",move:\"panmove\",start:\"panstart\"},{gesturechange:\"pinchmove\",gestureend:\"pinchend\",gesturestart:\"pinchstart\"},{press:\"press\"},{tap:\"tap\"}];class DomEvents{constructor(hammerInstance,events){this.hammerInstance=hammerInstance,this.eventHandlers={},this.tap=this.tap.bind(this),this.press=this.press.bind(this),this.panstart=this.panstart.bind(this),this.panmove=this.panmove.bind(this),this.panend=this.panend.bind(this),this.pinchstart=this.pinchstart.bind(this),this.pinchmove=this.pinchmove.bind(this),this.pinchend=this.pinchend.bind(this),events&&this.bind(events)}tap(e){this.trigger(\"tap\",e)}press(e){this.trigger(\"press\",e)}panstart(e){delete this.previous,this.previous=this.trigger(\"start\",e)}panmove(e){this.previous=this.trigger(\"move\",e)}panend(e){this.trigger(\"end\",e),delete this.previous}pinchstart(e){this.trigger(\"gesturestart\",e)}pinchmove(e){this.trigger(\"gesturechange\",e)}pinchend(e){this.trigger(\"gestureend\",e)}trigger(name,e){const args=((e,previousArgs)=>{const pointers=e.pointers,pointer=pointers[0],xLocation=pointer.pageX,yLocation=pointer.pageY;let distance=0;if(pointers.length>1){const pointer1=pointers[0],pointer2=pointers[1];distance=Math.sqrt(Math.pow(pointer1.pageX-pointer2.pageX,2)+Math.pow(pointer1.pageY-pointer2.pageY,2))}return{distance:distance,event:e.srcEvent,preventDefault:function(){e.preventDefault()},target:e.target,touches:pointers.map(getTouch),type:e.type,x:{delta:previousArgs?xLocation-previousArgs.x.location:0,initialDelta:e.deltaX,location:xLocation,startLocation:xLocation-e.deltaX},y:{delta:previousArgs?yLocation-previousArgs.y.location:0,initialDelta:e.deltaY,location:yLocation,startLocation:yLocation-e.deltaY}}})(e,this.previous);return this.eventHandlers[name]&&this.eventHandlers[name](args),args}bind(events={}){this.unbind(),this.eventHandlers=events;for(let idx=0;idx<eventGroups.length;idx++){const eventGroup=eventGroups[idx],groupNames=Object.keys(eventGroup);if(shouldBindGroup(groupNames,events))for(let nameIdx=0;nameIdx<groupNames.length;nameIdx++){const name=eventGroup[groupNames[nameIdx]];this.hammerInstance.on(name,this[name])}}}unbind(){this.hammerInstance&&this.hammerInstance.off(),this.eventHandlers={}}destroy(){this.hammerInstance&&(this.hammerInstance.destroy(),delete this.hammerInstance),delete this.eventHandlers}toggleDrag(enable){this.toggle(\"pan\",enable)}toggleZoom(enable){this.toggle(\"pinch\",enable)}toggle(recognizer,enable){this.hammerInstance&&this.hammerInstance.get(recognizer).set({enable:enable})}}const dateValueAxisFormats=date_value_axis.prototype.options.labels.dateFormats,dateFormats={milliseconds:\"HH:mm:ss.SSS\",seconds:{time:\"medium\"},minutes:{time:\"short\"},hours:{time:\"short\"},days:{skeleton:\"Md\"},weeks:{skeleton:\"Md\"},months:{skeleton:\"yyMMM\"},years:{skeleton:\"y\"}};function fesm2015_hasObservers(emitter){return emitter.observers.length>0}Object.assign(date_category_axis.prototype.options.labels.dateFormats,dateFormats),Object.assign(dateValueAxisFormats,dateFormats),dom_events_builder.register(class{static create(element,events){if(\"undefined\"!=typeof window){const HAMMER=window.Hammer;if(!HAMMER){if(Object(core.Y)())throw new Error(\"Hammerjs is not loaded.Solution: http://www.telerik.com/kendo-angular-ui/components/charts/troubleshooting/#toc-hammerjs-is-not-loaded\");return}const hammerInstance=new HAMMER(element,{recognizers:[[HAMMER.Tap],[HAMMER.Pan],[HAMMER.Pinch],[HAMMER.Press,{time:0}]]});return new DomEvents(hammerInstance,events)}}});let fesm2015_ChartComponent=(()=>{let ChartComponent=class extends fesm2015_ChartComponentGenerated{constructor(configurationService,themeService,element,intl,localizationService,ngZone,instanceEventService,changeDetector,renderer){super(configurationService),this.configurationService=configurationService,this.themeService=themeService,this.element=element,this.intl=intl,this.localizationService=localizationService,this.ngZone=ngZone,this.instanceEventService=instanceEventService,this.changeDetector=changeDetector,this.renderer=renderer,this.legendItemClick=new core.o,this.resizeRateLimit=10,this.theme=null,this.suppressTransitions=!1,this.rtl=!1,this.hostClasses=[\"k-chart\",\"k-widget\"],validatePackage(dist_fesm2015_packageMetadata),this.themeService.loadTheme(),this.refreshWait()}ngOnInit(){this.element&&(this.hostClasses.forEach(name=>{this.renderer.addClass(this.element.nativeElement,name)}),this.renderer.setStyle(this.element.nativeElement,\"position\",\"relative\"))}ngAfterViewInit(){this.canRender&&this.ngZone.runOutsideAngular(()=>{const chartMouseleave=this.renderer.listen(this.surfaceElement.nativeElement,\"mouseleave\",this.chartMouseleave.bind(this));this.domSubscriptions=()=>{chartMouseleave()}}),this.setDirection(),this.subscriptions=this.intl.changes.subscribe(this.intlChange.bind(this)),this.subscriptions.add(this.localizationService.changes.subscribe(this.rtlChange.bind(this)))}ngAfterViewChecked(){this.instance&&this.autoResize&&this.ngZone.runOutsideAngular(()=>{clearTimeout(this.resizeTimeout),this.resizeTimeout=setTimeout(()=>{this.resize()},0)})}ngOnChanges(changes){const store=this.configurationService.store;copyChanges(changes,store),store.popupSettings=null,this.configurationService.push(store)}notifyChanges(changes){this.ngOnChanges(toSimpleChanges(changes))}ngOnDestroy(){this.destroyed=!0,this.subscription.unsubscribe(),this.domSubscriptions&&(this.domSubscriptions(),this.domSubscriptions=null),this.instance&&(this.instance.destroy(),this.instance=null),this.subscriptions&&this.subscriptions.unsubscribe(),clearTimeout(this.resizeTimeout),clearTimeout(this.redrawTimeout)}createInstance(element,observer){this.instance=new chart_chart(element,this.options,this.theme,{intlService:this.intl,observer:observer,rtl:this.rtl,sender:this})}exportImage(options={}){return Object(export_image.a)(this.exportVisual(options),options)}exportSVG(options={}){return Object(export_svg.a)(this.exportVisual(options),options)}exportVisual(options={}){return this.instance.exportVisual(options)}findAxisByName(name){if(this.instance)return this.instance.findAxisByName(name)}findPaneByIndex(index){if(this.instance)return this.instance.findPaneByIndex(index)}findPaneByName(name){if(this.instance)return this.instance.findPaneByName(name)}getPlotArea(){if(this.instance)return this.instance.plotArea()}toggleHighlight(show,filter){this.instance&&this.instance.toggleHighlight(show,filter)}hideTooltip(){this.instance&&this.instance.hideTooltip()}showTooltip(filter){this.instance&&this.instance.showTooltip(filter)}init(){if(!this.canRender)return;const element=this.surfaceElement.nativeElement,instanceObserver=new fesm2015_ChartInstanceObserver(this);this.createInstance(element,instanceObserver)}resize(){this.instance&&this.instance.resize()}onResize(_event){this.autoResize&&this.resize()}onLegendItemClick(e){this.run(()=>{const args=new LegendItemClickEvent(e,this);if(this.legendItemClick.emit(args),!args.isDefaultPrevented()){const series=this.seriesComponents.toArray()[e.series.index];if(!series)return;void 0===e.pointIndex?series.toggleVisibility():series.togglePointVisibility(e.pointIndex),this.suppressTransitions=!0}},fesm2015_hasObservers(this.legendItemClick),this.seriesComponents.length>0)}onInit(e){this.instance=e.sender}onRender(e){const donutCenterStyle=this.getDonutCenterStyle();this.run(()=>{const args=new RenderEvent(e,this);this.surface=e.sender.surface,this.render.emit(args),this.donutCenterStyle=donutCenterStyle},fesm2015_hasObservers(this.render),this.donutCenterStyle!==donutCenterStyle)}onShowTooltip(e){this.run(()=>{e.crosshair?this.crossahirTooltips.show(e):this.tooltipInstance.show(e)},!e.crosshair,!0)}onHideTooltip(e){e.crosshair?this.crossahirTooltips.active&&(this.crossahirTooltips.hide(),this.detectChanges()):this.tooltipInstance.active&&(this.tooltipInstance.hide(),this.detectChanges())}trigger(name,e){if(\"resize\"===name)return;const emitter=this.activeEmitter(name);if(emitter){const args=this.instanceEventService.create(name,e,this);return this.run(()=>{emitter.emit(args)}),args.isDefaultPrevented&&args.isDefaultPrevented()}}requiresHandlers(names){for(let idx=0;idx<names.length;idx++)if(this.activeEmitter(names[idx]))return!0;return!1}refresh(){if(clearTimeout(this.redrawTimeout),this.updateDirection(),this.crossahirTooltips.createCrosshairTooltips(this.options),this.setChartAreaSize(),!this.instance)return void this.init();const transitions=this.options.transitions;this.suppressTransitions&&(this.options.transitions=!1),this.updateOptions(),this.suppressTransitions&&(this.options.transitions=transitions,this.suppressTransitions=!1)}setChartAreaSize(){if(!this.element)return;const element=this.element.nativeElement,chartArea=this.options.chartArea||{};chartArea.width&&(element.style.width=chartArea.width+\"px\"),chartArea.height&&(element.style.height=chartArea.height+\"px\")}updateOptions(){this.instance.setOptions(this.options)}tooltipMouseleave(e){const relatedTarget=e.relatedTarget;!this.instance||relatedTarget&&hasParent(relatedTarget,this.element.nativeElement)||this.instance.hideElements()}chartMouseleave(e){const relatedTarget=e.relatedTarget,chartElement=this.element.nativeElement;!this.instance||relatedTarget&&(this.tooltipInstance.containsElement(relatedTarget)||hasParent(relatedTarget,chartElement))||this.instance.handlingTap||this.instance.hideElements()}get canRender(){return isDocumentAvailable()&&Boolean(this.surfaceElement)}get autoResize(){return this.resizeRateLimit>0}activeEmitter(name){const emitter=this[name];if(emitter&&emitter.emit&&fesm2015_hasObservers(emitter))return emitter}getDonutCenterStyle(){if(!this.instance||!this.options||!this.options.series)return;const firstSeries=this.options.series[0],charts=this.instance._plotArea.charts;if(!firstSeries||\"donut\"!==firstSeries.type||0===charts[0].points.length)return;const firstPoint=charts[0].points[0],center=firstPoint.box.center(),radius=firstPoint.sector.innerRadius,size=2*radius;return{height:size+\"px\",left:center.x-radius+\"px\",top:center.y-radius+\"px\",width:size+\"px\"}}refreshWait(){this.ngZone.runOutsideAngular(()=>{this.subscription=Object(combineLatest.b)(this.configurationService.onChange$,this.themeService.onChange$).pipe(Object(tap.a)(result=>{this.options=result[0],this.theme=result[1]}),Object(auditTime.a)(16.666666666666668)).subscribe(()=>{this.refresh()})})}run(callback,inZone=!0,detectChanges){inZone?(detectChanges&&this.changeDetector.markForCheck(),this.ngZone.run(callback)):(callback(),detectChanges&&this.detectChanges())}detectChanges(){this.destroyed||this.changeDetector.detectChanges()}intlChange(){this.instance&&this.deferredRedraw()}rtlChange(){this.instance&&this.rtl!==this.isRTL&&this.deferredRedraw()}deferredRedraw(){this.ngZone.runOutsideAngular(()=>{clearTimeout(this.redrawTimeout),this.redrawTimeout=setTimeout(()=>{this.updateDirection(),this.instance.noTransitionsRedraw()},0)})}updateDirection(){const current=this.isRTL;this.rtl!==current&&(this.setDirection(),this.instance&&this.instance.setDirection(current))}setDirection(){this.rtl=this.isRTL,this.element&&this.renderer.setAttribute(this.element.nativeElement,\"dir\",this.rtl?\"rtl\":\"ltr\")}get isRTL(){return Boolean(this.localizationService.rtl)}};return ChartComponent.ɵfac=function(t){return new(t||ChartComponent)(core.Pb(fesm2015_ConfigurationService),core.Pb(fesm2015_ThemeService),core.Pb(core.l),core.Pb(fesm2015_IntlService),core.Pb(fesm2015_LocalizationService),core.Pb(core.B),core.Pb(fesm2015_InstanceEventService),core.Pb(core.h),core.Pb(core.G))},ChartComponent.ɵcmp=core.Jb({type:ChartComponent,selectors:[[\"kendo-chart\"]],contentQueries:function(rf,ctx,dirIndex){if(1&rf&&(core.Ib(dirIndex,fesm2015_DonutCenterTemplateDirective,!0),core.Ib(dirIndex,fesm2015_SeriesItemComponent,!0)),2&rf){let _t;core.wc(_t=core.hc())&&(ctx.donutCenterTemplate=_t.first),core.wc(_t=core.hc())&&(ctx.seriesComponents=_t)}},viewQuery:function(rf,ctx){if(1&rf&&(core.Gc(fesm2015_TooltipPopupComponent,!0),core.Gc(fesm2015_CrosshairTooltipsContainerComponent,!0),core.Gc(fesm2015_c1,!0)),2&rf){let _t;core.wc(_t=core.hc())&&(ctx.tooltipInstance=_t.first),core.wc(_t=core.hc())&&(ctx.crossahirTooltips=_t.first),core.wc(_t=core.hc())&&(ctx.surfaceElement=_t.first)}},inputs:{resizeRateLimit:\"resizeRateLimit\",popupSettings:\"popupSettings\"},outputs:{legendItemClick:\"legendItemClick\"},exportAs:[\"kendoChart\"],features:[core.Bb([fesm2015_ConfigurationService,fesm2015_TooltipTemplateService,fesm2015_InstanceEventService,fesm2015_LocalizationService,{provide:L10N_PREFIX,useValue:\"kendo.chart\"}]),core.zb,core.Ab],decls:6,vars:4,consts:[[1,\"k-chart-surface\"],[\"surface\",\"\"],[3,\"popupSettings\"],[3,\"popupSettings\",\"leave\"],[3,\"rateLimit\",\"resize\"],[\"class\",\"k-chart-donut-center\",3,\"ngStyle\",4,\"ngIf\"],[1,\"k-chart-donut-center\",3,\"ngStyle\"],[3,\"ngTemplateOutlet\"]],template:function(rf,ctx){1&rf&&(core.Qb(0,\"div\",0,1),core.Qb(2,\"kendo-chart-crosshair-tooltips-container\",2),core.Vb(3,\"kendo-chart-tooltip-popup\",3),core.gc(\"leave\",function($event){return ctx.tooltipMouseleave($event)}),core.Ub(),core.Vb(4,\"kendo-resize-sensor\",4),core.gc(\"resize\",function($event){return ctx.onResize($event)}),core.Ub(),core.Kc(5,ChartComponent_div_5_Template,2,2,\"div\",5)),2&rf&&(core.Cb(2),core.pc(\"popupSettings\",ctx.popupSettings),core.Cb(1),core.pc(\"popupSettings\",ctx.popupSettings),core.Cb(1),core.pc(\"rateLimit\",ctx.resizeRateLimit),core.Cb(1),core.pc(\"ngIf\",ctx.donutCenterStyle&&ctx.donutCenterTemplate))},directives:[fesm2015_CrosshairTooltipsContainerComponent,fesm2015_TooltipPopupComponent,fesm2015_ResizeSensorComponent,common.l,common.m,common.q],encapsulation:2,changeDetection:0}),ChartComponent=__decorate([__metadata(\"design:paramtypes\",[fesm2015_ConfigurationService,fesm2015_ThemeService,core.l,fesm2015_IntlService,fesm2015_LocalizationService,core.B,fesm2015_InstanceEventService,core.h,core.G])],ChartComponent),ChartComponent})(),fesm2015_CollectionComponent=(()=>{class CollectionComponent{constructor(configKey,configurationService,collectionService){this.configKey=configKey,this.configurationService=configurationService,this.collectionService=collectionService,this.items=[],this.subscription=collectionService.onItemChange$.subscribe(changes=>this.processChanges(changes))}ngOnDestroy(){this.subscription.unsubscribe()}ngAfterContentInit(){this.readItems(),this.children.changes.subscribe(()=>this.readItems())}processChanges(changes){if(!this.children)return;const index=this.children.toArray().indexOf(changes.sender);index<0||(this.items[index]=changes.options,this.change())}readItems(){this.items=this.children.map(s=>s.options),this.change()}change(){this.configurationService.notify(new Change(this.configKey,this.items))}}return CollectionComponent.ɵfac=function(t){core.fc()},CollectionComponent.ɵdir=core.Kb({type:CollectionComponent}),CollectionComponent})(),fesm2015_CategoryAxisItemComponentGenerated=(()=>{class CategoryAxisItemComponentGenerated extends fesm2015_CollectionItemComponent{constructor(configurationService,collectionService,intl,localeId){super(configurationService,collectionService),this.configurationService=configurationService,this.collectionService=collectionService,this.notifyChanges({weekStartDay:intl.firstDay(localeId)})}}return CategoryAxisItemComponentGenerated.ɵfac=function(t){core.fc()},CategoryAxisItemComponentGenerated.ɵdir=core.Kb({type:CategoryAxisItemComponentGenerated,inputs:{autoBaseUnitSteps:\"autoBaseUnitSteps\",axisCrossingValue:\"axisCrossingValue\",background:\"background\",baseUnit:\"baseUnit\",baseUnitStep:\"baseUnitStep\",categories:\"categories\",color:\"color\",justified:\"justified\",line:\"line\",majorGridLines:\"majorGridLines\",majorTicks:\"majorTicks\",max:\"max\",maxDateGroups:\"maxDateGroups\",maxDivisions:\"maxDivisions\",min:\"min\",minorGridLines:\"minorGridLines\",minorTicks:\"minorTicks\",name:\"name\",pane:\"pane\",plotBands:\"plotBands\",reverse:\"reverse\",roundToBaseUnit:\"roundToBaseUnit\",startAngle:\"startAngle\",type:\"type\",visible:\"visible\",weekStartDay:\"weekStartDay\",crosshair:\"crosshair\",labels:\"labels\",notes:\"notes\",select:\"select\",title:\"title\"},features:[core.zb]}),CategoryAxisItemComponentGenerated})(),fesm2015_CategoryAxisItemComponent=(()=>{let CategoryAxisItemComponent=class extends fesm2015_CategoryAxisItemComponentGenerated{constructor(configurationService,collectionService,intl,localeId){super(configurationService,collectionService,intl,localeId),this.configurationService=configurationService,this.collectionService=collectionService}};return CategoryAxisItemComponent.ɵfac=function(t){return new(t||CategoryAxisItemComponent)(core.Pb(fesm2015_ConfigurationService),core.Pb(fesm2015_CollectionService),core.Pb(fesm2015_IntlService),core.Pb(core.w))},CategoryAxisItemComponent.ɵcmp=core.Jb({type:CategoryAxisItemComponent,selectors:[[\"kendo-chart-category-axis-item\"]],inputs:{rangeLabels:\"rangeLabels\"},features:[core.Bb([fesm2015_ConfigurationService]),core.zb],decls:0,vars:0,template:function(rf,ctx){},encapsulation:2,changeDetection:0}),CategoryAxisItemComponent=__decorate([__param(3,Object(core.q)(core.w)),__metadata(\"design:paramtypes\",[fesm2015_ConfigurationService,fesm2015_CollectionService,fesm2015_IntlService,String])],CategoryAxisItemComponent),CategoryAxisItemComponent})(),fesm2015_CategoryAxisComponentGenerated=(()=>{class CategoryAxisComponentGenerated extends fesm2015_CollectionComponent{constructor(configurationService,collectionService){super(\"categoryAxis\",configurationService,collectionService),this.configurationService=configurationService,this.collectionService=collectionService}}return CategoryAxisComponentGenerated.ɵfac=function(t){core.fc()},CategoryAxisComponentGenerated.ɵdir=core.Kb({type:CategoryAxisComponentGenerated,contentQueries:function(rf,ctx,dirIndex){if(1&rf&&core.Ib(dirIndex,fesm2015_CategoryAxisItemComponent,!1),2&rf){let _t;core.wc(_t=core.hc())&&(ctx.children=_t)}},features:[core.zb]}),CategoryAxisComponentGenerated})(),fesm2015_CategoryAxisComponent=(()=>{let CategoryAxisComponent=class extends fesm2015_CategoryAxisComponentGenerated{constructor(configurationService,collectionService){super(configurationService,collectionService),this.configurationService=configurationService,this.collectionService=collectionService}};return CategoryAxisComponent.ɵfac=function(t){return new(t||CategoryAxisComponent)(core.Pb(fesm2015_ConfigurationService),core.Pb(fesm2015_CollectionService))},CategoryAxisComponent.ɵcmp=core.Jb({type:CategoryAxisComponent,selectors:[[\"kendo-chart-category-axis\"]],features:[core.Bb([fesm2015_CollectionService]),core.zb],decls:0,vars:0,template:function(rf,ctx){},encapsulation:2,changeDetection:0}),CategoryAxisComponent=__decorate([__metadata(\"design:paramtypes\",[fesm2015_ConfigurationService,fesm2015_CollectionService])],CategoryAxisComponent),CategoryAxisComponent})(),fesm2015_ChartAreaComponentGenerated=(()=>{class ChartAreaComponentGenerated extends fesm2015_SettingsComponent{constructor(configurationService){super(\"chartArea\",configurationService),this.configurationService=configurationService}}return ChartAreaComponentGenerated.ɵfac=function(t){core.fc()},ChartAreaComponentGenerated.ɵdir=core.Kb({type:ChartAreaComponentGenerated,inputs:{background:\"background\",border:\"border\",height:\"height\",margin:\"margin\",opacity:\"opacity\",width:\"width\"},features:[core.zb]}),ChartAreaComponentGenerated})(),fesm2015_ChartAreaComponent=(()=>{let ChartAreaComponent=class extends fesm2015_ChartAreaComponentGenerated{constructor(configurationService){super(configurationService),this.configurationService=configurationService}};return ChartAreaComponent.ɵfac=function(t){return new(t||ChartAreaComponent)(core.Pb(fesm2015_ConfigurationService))},ChartAreaComponent.ɵcmp=core.Jb({type:ChartAreaComponent,selectors:[[\"kendo-chart-area\"]],features:[core.zb],decls:0,vars:0,template:function(rf,ctx){},encapsulation:2,changeDetection:0}),ChartAreaComponent=__decorate([__metadata(\"design:paramtypes\",[fesm2015_ConfigurationService])],ChartAreaComponent),ChartAreaComponent})(),fesm2015_LegendComponentGenerated=(()=>{class LegendComponentGenerated extends fesm2015_SettingsComponent{constructor(configurationService){super(\"legend\",configurationService),this.configurationService=configurationService}}return LegendComponentGenerated.ɵfac=function(t){core.fc()},LegendComponentGenerated.ɵdir=core.Kb({type:LegendComponentGenerated,inputs:{align:\"align\",background:\"background\",border:\"border\",height:\"height\",labels:\"labels\",margin:\"margin\",offsetX:\"offsetX\",offsetY:\"offsetY\",orientation:\"orientation\",padding:\"padding\",position:\"position\",reverse:\"reverse\",visible:\"visible\",width:\"width\",markers:\"markers\",spacing:\"spacing\",inactiveItems:\"inactiveItems\",item:\"item\",title:\"title\"},features:[core.zb]}),LegendComponentGenerated})(),fesm2015_LegendComponent=(()=>{let LegendComponent=class extends fesm2015_LegendComponentGenerated{constructor(configurationService){super(configurationService),this.configurationService=configurationService,this.markAsVisible()}};return LegendComponent.ɵfac=function(t){return new(t||LegendComponent)(core.Pb(fesm2015_ConfigurationService))},LegendComponent.ɵcmp=core.Jb({type:LegendComponent,selectors:[[\"kendo-chart-legend\"]],features:[core.zb],decls:0,vars:0,template:function(rf,ctx){},encapsulation:2,changeDetection:0}),LegendComponent=__decorate([__metadata(\"design:paramtypes\",[fesm2015_ConfigurationService])],LegendComponent),LegendComponent})(),fesm2015_SeriesComponentGenerated=(()=>{class SeriesComponentGenerated extends fesm2015_CollectionComponent{constructor(configurationService,collectionService){super(\"series\",configurationService,collectionService),this.configurationService=configurationService,this.collectionService=collectionService}}return SeriesComponentGenerated.ɵfac=function(t){core.fc()},SeriesComponentGenerated.ɵdir=core.Kb({type:SeriesComponentGenerated,contentQueries:function(rf,ctx,dirIndex){if(1&rf&&core.Ib(dirIndex,fesm2015_SeriesItemComponent,!1),2&rf){let _t;core.wc(_t=core.hc())&&(ctx.children=_t)}},features:[core.zb]}),SeriesComponentGenerated})(),fesm2015_SeriesComponent=(()=>{let SeriesComponent=class extends fesm2015_SeriesComponentGenerated{constructor(configurationService,collectionService,tooltipTemplateService){super(configurationService,collectionService),this.configurationService=configurationService,this.collectionService=collectionService,this.tooltipTemplateService=tooltipTemplateService}ngAfterContentChecked(){this.readTooltipTemplates()}readTooltipTemplates(){const templates=this.children.map(item=>item.seriesTooltipTemplateRef);this.tooltipTemplateService.setSeriesTemplates(templates)}};return SeriesComponent.ɵfac=function(t){return new(t||SeriesComponent)(core.Pb(fesm2015_ConfigurationService),core.Pb(fesm2015_CollectionService),core.Pb(fesm2015_TooltipTemplateService))},SeriesComponent.ɵcmp=core.Jb({type:SeriesComponent,selectors:[[\"kendo-chart-series\"]],features:[core.Bb([fesm2015_CollectionService]),core.zb],decls:0,vars:0,template:function(rf,ctx){},encapsulation:2,changeDetection:0}),SeriesComponent=__decorate([__metadata(\"design:paramtypes\",[fesm2015_ConfigurationService,fesm2015_CollectionService,fesm2015_TooltipTemplateService])],SeriesComponent),SeriesComponent})(),fesm2015_SeriesLabelsComponentGenerated=(()=>{class SeriesLabelsComponentGenerated extends fesm2015_SettingsComponent{constructor(configurationService){super(\"labels\",configurationService),this.configurationService=configurationService}}return SeriesLabelsComponentGenerated.ɵfac=function(t){core.fc()},SeriesLabelsComponentGenerated.ɵdir=core.Kb({type:SeriesLabelsComponentGenerated,inputs:{align:\"align\",background:\"background\",border:\"border\",color:\"color\",content:\"content\",distance:\"distance\",font:\"font\",format:\"format\",margin:\"margin\",padding:\"padding\",position:\"position\",rotation:\"rotation\",visible:\"visible\",visual:\"visual\",from:\"from\",to:\"to\"},features:[core.zb]}),SeriesLabelsComponentGenerated})(),fesm2015_SeriesLabelsComponent=(()=>{let SeriesLabelsComponent=class extends fesm2015_SeriesLabelsComponentGenerated{constructor(configurationService){super(configurationService),this.configurationService=configurationService,this.markAsVisible()}};return SeriesLabelsComponent.ɵfac=function(t){return new(t||SeriesLabelsComponent)(core.Pb(fesm2015_ConfigurationService))},SeriesLabelsComponent.ɵcmp=core.Jb({type:SeriesLabelsComponent,selectors:[[\"kendo-chart-series-item-labels\"]],features:[core.zb],decls:0,vars:0,template:function(rf,ctx){},encapsulation:2,changeDetection:0}),SeriesLabelsComponent=__decorate([__metadata(\"design:paramtypes\",[fesm2015_ConfigurationService])],SeriesLabelsComponent),SeriesLabelsComponent})(),fesm2015_ValueAxisItemComponentGenerated=(()=>{class ValueAxisItemComponentGenerated extends fesm2015_CollectionItemComponent{constructor(configurationService,collectionService){super(configurationService,collectionService),this.configurationService=configurationService,this.collectionService=collectionService}}return ValueAxisItemComponentGenerated.ɵfac=function(t){core.fc()},ValueAxisItemComponentGenerated.ɵdir=core.Kb({type:ValueAxisItemComponentGenerated,inputs:{axisCrossingValue:\"axisCrossingValue\",background:\"background\",color:\"color\",line:\"line\",majorGridLines:\"majorGridLines\",majorTicks:\"majorTicks\",majorUnit:\"majorUnit\",max:\"max\",min:\"min\",minorGridLines:\"minorGridLines\",minorTicks:\"minorTicks\",minorUnit:\"minorUnit\",name:\"name\",narrowRange:\"narrowRange\",pane:\"pane\",plotBands:\"plotBands\",reverse:\"reverse\",type:\"type\",visible:\"visible\",crosshair:\"crosshair\",labels:\"labels\",notes:\"notes\",title:\"title\"},features:[core.zb]}),ValueAxisItemComponentGenerated})(),fesm2015_ValueAxisItemComponent=(()=>{let ValueAxisItemComponent=class extends fesm2015_ValueAxisItemComponentGenerated{constructor(configurationService,collectionService){super(configurationService,collectionService),this.configurationService=configurationService,this.collectionService=collectionService}};return ValueAxisItemComponent.ɵfac=function(t){return new(t||ValueAxisItemComponent)(core.Pb(fesm2015_ConfigurationService),core.Pb(fesm2015_CollectionService))},ValueAxisItemComponent.ɵcmp=core.Jb({type:ValueAxisItemComponent,selectors:[[\"kendo-chart-value-axis-item\"]],features:[core.Bb([fesm2015_ConfigurationService]),core.zb],decls:0,vars:0,template:function(rf,ctx){},encapsulation:2,changeDetection:0}),ValueAxisItemComponent=__decorate([__metadata(\"design:paramtypes\",[fesm2015_ConfigurationService,fesm2015_CollectionService])],ValueAxisItemComponent),ValueAxisItemComponent})(),fesm2015_ValueAxisComponentGenerated=(()=>{class ValueAxisComponentGenerated extends fesm2015_CollectionComponent{constructor(configurationService,collectionService){super(\"valueAxis\",configurationService,collectionService),this.configurationService=configurationService,this.collectionService=collectionService}}return ValueAxisComponentGenerated.ɵfac=function(t){core.fc()},ValueAxisComponentGenerated.ɵdir=core.Kb({type:ValueAxisComponentGenerated,contentQueries:function(rf,ctx,dirIndex){if(1&rf&&core.Ib(dirIndex,fesm2015_ValueAxisItemComponent,!1),2&rf){let _t;core.wc(_t=core.hc())&&(ctx.children=_t)}},features:[core.zb]}),ValueAxisComponentGenerated})(),fesm2015_ValueAxisComponent=(()=>{let ValueAxisComponent=class extends fesm2015_ValueAxisComponentGenerated{constructor(configurationService,collectionService){super(configurationService,collectionService),this.configurationService=configurationService,this.collectionService=collectionService}};return ValueAxisComponent.ɵfac=function(t){return new(t||ValueAxisComponent)(core.Pb(fesm2015_ConfigurationService),core.Pb(fesm2015_CollectionService))},ValueAxisComponent.ɵcmp=core.Jb({type:ValueAxisComponent,selectors:[[\"kendo-chart-value-axis\"]],features:[core.Bb([fesm2015_CollectionService]),core.zb],decls:0,vars:0,template:function(rf,ctx){},encapsulation:2,changeDetection:0}),ValueAxisComponent=__decorate([__metadata(\"design:paramtypes\",[fesm2015_ConfigurationService,fesm2015_CollectionService])],ValueAxisComponent),ValueAxisComponent})();new core.s(\"configuration prefix\");let fesm2015_ChartModule=(()=>{let ChartModule=class{};return ChartModule.ɵmod=core.Nb({type:ChartModule}),ChartModule.ɵinj=core.Mb({factory:function(t){return new(t||ChartModule)},providers:[fesm2015_ThemeService],imports:[[common.c,fesm2015_PopupModule,fesm2015_ResizeSensorModule]]}),ChartModule})(),fesm2015_StockChartModule=(()=>{let StockChartModule=class{};return StockChartModule.ɵmod=core.Nb({type:StockChartModule}),StockChartModule.ɵinj=core.Mb({factory:function(t){return new(t||StockChartModule)},imports:[[fesm2015_ChartModule,common.c,fesm2015_PopupModule,fesm2015_ResizeSensorModule],fesm2015_ChartModule]}),StockChartModule})(),fesm2015_SparklineModule=(()=>{let SparklineModule=class{};return SparklineModule.ɵmod=core.Nb({type:SparklineModule}),SparklineModule.ɵinj=core.Mb({factory:function(t){return new(t||SparklineModule)},imports:[[fesm2015_ChartModule,common.c,fesm2015_PopupModule,fesm2015_ResizeSensorModule],fesm2015_ChartModule]}),SparklineModule})(),fesm2015_ChartsModule=(()=>{let ChartsModule=class{};return ChartsModule.ɵmod=core.Nb({type:ChartsModule}),ChartsModule.ɵinj=core.Mb({factory:function(t){return new(t||ChartsModule)},imports:[fesm2015_ChartModule,fesm2015_SparklineModule,fesm2015_StockChartModule]}),ChartsModule})()},tZVE:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _constants__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"V34t\");let renderSVG=function(container,svg){container.innerHTML=svg};if(\"undefined\"!=typeof document){const testFragment=\"<svg xmlns='\"+_constants__WEBPACK_IMPORTED_MODULE_0__.b+\"'></svg>\",testContainer=document.createElement(\"div\"),hasParser=\"undefined\"!=typeof DOMParser;testContainer.innerHTML=testFragment,hasParser&&testContainer.firstChild.namespaceURI!==_constants__WEBPACK_IMPORTED_MODULE_0__.b&&(renderSVG=function(container,svg){const chartDoc=(new DOMParser).parseFromString(svg,\"text/xml\"),importedDoc=document.adoptNode(chartDoc.documentElement);container.innerHTML=\"\",container.appendChild(importedDoc)})}__webpack_exports__.a=renderSVG},uBxF:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return transform});var _transformation__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"gofQ\");function transform(matrix){return null===matrix?null:matrix instanceof _transformation__WEBPACK_IMPORTED_MODULE_0__.a?matrix:new _transformation__WEBPACK_IMPORTED_MODULE_0__.a(matrix)}},uNz1:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_exports__.a={}},uekK:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return exportImage});var _surface__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"kGoT\"),_geometry__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"uBxF\"),_shapes_group__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"qUqW\");function exportImage(group,options){const defaults={width:\"800px\",height:\"600px\",cors:\"Anonymous\"};let exportRoot=group;const bbox=group.clippedBBox();if(bbox){const origin=bbox.getOrigin();exportRoot=new _shapes_group__WEBPACK_IMPORTED_MODULE_2__.a,exportRoot.transform(Object(_geometry__WEBPACK_IMPORTED_MODULE_1__.a)().translate(-origin.x,-origin.y)),exportRoot.children.push(group);const size=bbox.getSize();defaults.width=size.width+\"px\",defaults.height=size.height+\"px\"}const surfaceOptions=Object.assign(defaults,options),container=document.createElement(\"div\"),style=container.style;style.display=\"none\",style.width=surfaceOptions.width,style.height=surfaceOptions.height,document.body.appendChild(container);const surface=new _surface__WEBPACK_IMPORTED_MODULE_0__.a(container,surfaceOptions);surface.suspendTracking(),surface.draw(exportRoot);const promise=surface.image(),destroy=()=>{surface.destroy(),document.body.removeChild(container)};return promise.then(destroy,destroy),promise}},wBpk:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _text_metrics_lru_cache__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"kTcp\");__webpack_require__.d(__webpack_exports__,\"a\",function(){return _text_metrics_lru_cache__WEBPACK_IMPORTED_MODULE_0__.a});var _text_metrics_text_metrics__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"jQ5i\");__webpack_require__.d(__webpack_exports__,\"b\",function(){return _text_metrics_text_metrics__WEBPACK_IMPORTED_MODULE_1__.a});var _text_metrics_measure_text__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"ouFi\");__webpack_require__.d(__webpack_exports__,\"d\",function(){return _text_metrics_measure_text__WEBPACK_IMPORTED_MODULE_2__.a});var _text_metrics_util__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(\"C91f\");__webpack_require__.d(__webpack_exports__,\"c\",function(){return _text_metrics_util__WEBPACK_IMPORTED_MODULE_3__.a}),__webpack_require__.d(__webpack_exports__,\"e\",function(){return _text_metrics_util__WEBPACK_IMPORTED_MODULE_3__.b}),__webpack_require__.d(__webpack_exports__,\"f\",function(){return _text_metrics_util__WEBPACK_IMPORTED_MODULE_3__.c})},wJcK:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _core_base_node__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"ztN+\"),_node__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"7Prh\"),_definition_node__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"7WKN\");__webpack_exports__.a=class extends _node__WEBPACK_IMPORTED_MODULE_1__.a{constructor(options){super(),this.options=options,this.defs=new _definition_node__WEBPACK_IMPORTED_MODULE_2__.a}attachTo(domElement){this.element=domElement,this.defs.attachTo(domElement.firstElementChild)}clear(){_core_base_node__WEBPACK_IMPORTED_MODULE_0__.a.prototype.clear.call(this)}template(){return this.defs.render()+this.renderChildren()}definitionChange(e){this.defs.definitionChange(e)}}},wbRH:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return elementsClippedBoundingBox});var _geometry_rect__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"XJRY\");function elementsClippedBoundingBox(elements,transformation){let boundingBox;for(let i=0;i<elements.length;i++){let element=elements[i];if(element.visible()){let elementBoundingBox=element.clippedBBox(transformation);elementBoundingBox&&(boundingBox=boundingBox?_geometry_rect__WEBPACK_IMPORTED_MODULE_0__.a.union(boundingBox,elementBoundingBox):elementBoundingBox)}}return boundingBox}},wd4i:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return elementSize});var _element_styles__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"oY8A\"),_defined__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"VqL+\");function getPixels(value){return isNaN(value)?value:value+\"px\"}function elementSize(element,size){if(!size){const size=Object(_element_styles__WEBPACK_IMPORTED_MODULE_0__.a)(element,[\"width\",\"height\"]);return{width:parseInt(size.width,10),height:parseInt(size.height,10)}}{const{width:width,height:height}=size;Object(_defined__WEBPACK_IMPORTED_MODULE_1__.a)(width)&&(element.style.width=getPixels(width)),Object(_defined__WEBPACK_IMPORTED_MODULE_1__.a)(height)&&(element.style.height=getPixels(height))}}},wfnd:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _geometry_arc__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"HKF7\"),_element__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"XdXH\"),_path__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"Ah4p\"),_mixins_paintable__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(\"T3aN\"),_mixins_measurable__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(\"qNx/\"),_mixins_with_geometry__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__(\"O6F+\"),_util__WEBPACK_IMPORTED_MODULE_6__=__webpack_require__(\"VqL+\");class Arc extends(Object(_mixins_paintable__WEBPACK_IMPORTED_MODULE_3__.a)(Object(_mixins_measurable__WEBPACK_IMPORTED_MODULE_4__.a)(Object(_mixins_with_geometry__WEBPACK_IMPORTED_MODULE_5__.a)(_element__WEBPACK_IMPORTED_MODULE_1__.a)))){get nodeType(){return\"Arc\"}constructor(geometry=new _geometry_arc__WEBPACK_IMPORTED_MODULE_0__.a,options={}){super(options),this.geometry(geometry),Object(_util__WEBPACK_IMPORTED_MODULE_6__.a)(this.options.stroke)||this.stroke(\"#000\")}_bbox(matrix){return this._geometry.bbox(matrix)}rawBBox(){return this.geometry().bbox()}toPath(){const path=new _path__WEBPACK_IMPORTED_MODULE_2__.b,curvePoints=this.geometry().curvePoints();if(curvePoints.length>0){path.moveTo(curvePoints[0].x,curvePoints[0].y);for(let i=1;i<curvePoints.length;i+=3)path.curveTo(curvePoints[i],curvePoints[i+1],curvePoints[i+2])}return path}_containsPoint(point){return this.geometry().containsPoint(point)}_isOnPath(point){return this.geometry()._isOnPath(point,this.options.stroke.width/2)}}__webpack_exports__.a=Arc},\"wm+B\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _shapes_element__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"XdXH\");__webpack_require__.d(__webpack_exports__,\"c\",function(){return _shapes_element__WEBPACK_IMPORTED_MODULE_0__.a});var _shapes_circle__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"Ual8\");__webpack_require__.d(__webpack_exports__,\"b\",function(){return _shapes_circle__WEBPACK_IMPORTED_MODULE_1__.a});var _shapes_arc__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"wfnd\");__webpack_require__.d(__webpack_exports__,\"a\",function(){return _shapes_arc__WEBPACK_IMPORTED_MODULE_2__.a});var _shapes_path__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(\"Ah4p\");__webpack_require__.d(__webpack_exports__,\"h\",function(){return _shapes_path__WEBPACK_IMPORTED_MODULE_3__.b}),__webpack_require__.d(__webpack_exports__,\"g\",function(){return _shapes_path__WEBPACK_IMPORTED_MODULE_3__.a});var _shapes_text__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(\"r0sM\");__webpack_require__.d(__webpack_exports__,\"j\",function(){return _shapes_text__WEBPACK_IMPORTED_MODULE_4__.a});var _shapes_image__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__(\"BK/f\");__webpack_require__.d(__webpack_exports__,\"e\",function(){return _shapes_image__WEBPACK_IMPORTED_MODULE_5__.a});var _shapes_group__WEBPACK_IMPORTED_MODULE_6__=__webpack_require__(\"qUqW\");__webpack_require__.d(__webpack_exports__,\"d\",function(){return _shapes_group__WEBPACK_IMPORTED_MODULE_6__.a});var _shapes_layout__WEBPACK_IMPORTED_MODULE_7__=__webpack_require__(\"e5dn\");__webpack_require__.d(__webpack_exports__,\"f\",function(){return _shapes_layout__WEBPACK_IMPORTED_MODULE_7__.a});var _shapes_rect__WEBPACK_IMPORTED_MODULE_8__=__webpack_require__(\"K3Ik\");__webpack_require__.d(__webpack_exports__,\"i\",function(){return _shapes_rect__WEBPACK_IMPORTED_MODULE_8__.a})},\"x/GK\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";function toMatrix(transformation){return transformation&&\"function\"==typeof transformation.matrix?transformation.matrix():transformation}__webpack_require__.d(__webpack_exports__,\"a\",function(){return toMatrix})},\"x/aw\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return elementsBoundingBox});var _geometry_rect__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"XJRY\");function elementsBoundingBox(elements,applyTransform,transformation){let boundingBox;for(let i=0;i<elements.length;i++){let element=elements[i];if(element.visible()){let elementBoundingBox=applyTransform?element.bbox(transformation):element.rawBBox();elementBoundingBox&&(boundingBox=boundingBox?_geometry_rect__WEBPACK_IMPORTED_MODULE_0__.a.union(boundingBox,elementBoundingBox):elementBoundingBox)}}return boundingBox}},xYjD:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _node__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"o+K8\"),_mixins_traversable__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"fdcc\");class GroupNode extends(Object(_mixins_traversable__WEBPACK_IMPORTED_MODULE_1__.a)(_node__WEBPACK_IMPORTED_MODULE_0__.a,\"childNodes\")){renderTo(ctx){if(!this.visible())return;ctx.save(),this.setTransform(ctx),this.setClip(ctx),this.setOpacity(ctx);const childNodes=this.childNodes;for(let i=0;i<childNodes.length;i++){let child=childNodes[i];child.visible()&&child.renderTo(ctx)}ctx.restore()}}__webpack_exports__.a=GroupNode},yhXd:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _mixins_with_points__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"zZ53\"),_geometry_point__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"lRJa\"),_gradient__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"4DQW\"),_util__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(\"VqL+\");class RadialGradient extends(Object(_mixins_with_points__WEBPACK_IMPORTED_MODULE_0__.a)(_gradient__WEBPACK_IMPORTED_MODULE_2__.a,[\"center\"])){constructor(options={}){super(options),this.center(options.center||new _geometry_point__WEBPACK_IMPORTED_MODULE_1__.a),this._radius=Object(_util__WEBPACK_IMPORTED_MODULE_3__.a)(options.radius)?options.radius:1,this._fallbackFill=options.fallbackFill}radius(value){return Object(_util__WEBPACK_IMPORTED_MODULE_3__.a)(value)?(this._radius=value,this.geometryChange(),this):this._radius}fallbackFill(value){return Object(_util__WEBPACK_IMPORTED_MODULE_3__.a)(value)?(this._fallbackFill=value,this.optionsChange(),this):this._fallbackFill}}__webpack_exports__.a=RadialGradient},zZ53:function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _util__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"VqL+\"),_geometry_point__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"lRJa\");function pointAccessor(name){const fieldName=\"_\"+name;return function(value){return Object(_util__WEBPACK_IMPORTED_MODULE_0__.a)(value)?(this._observerField(fieldName,_geometry_point__WEBPACK_IMPORTED_MODULE_1__.a.create(value)),this.geometryChange(),this):this[fieldName]}}__webpack_exports__.a=(TBase,names)=>{const result=class extends TBase{};return function(fn,names){for(let i=0;i<names.length;i++)fn[names[i]]=pointAccessor(names[i])}(result.prototype,names),result}},\"ztN+\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";var _common__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"LHUb\");__webpack_exports__.a=class extends _common__WEBPACK_IMPORTED_MODULE_0__.a{constructor(srcElement){super(),this.childNodes=[],this.parent=null,srcElement&&(this.srcElement=srcElement,this.observe())}destroy(){this.srcElement&&this.srcElement.removeObserver(this);const children=this.childNodes;for(let i=0;i<children.length;i++)this.childNodes[i].destroy();this.parent=null}load(){}observe(){this.srcElement&&this.srcElement.addObserver(this)}append(node){this.childNodes.push(node),node.parent=this}insertAt(node,pos){this.childNodes.splice(pos,0,node),node.parent=this}remove(index,count){const end=index+count;for(let i=index;i<end;i++)this.childNodes[i].removeSelf();this.childNodes.splice(index,count)}removeSelf(){this.clear(),this.destroy()}clear(){this.remove(0,this.childNodes.length)}invalidate(){this.parent&&this.parent.invalidate()}geometryChange(){this.invalidate()}optionsChange(){this.invalidate()}childrenChange(e){\"add\"===e.action?this.load(e.items,e.index):\"remove\"===e.action&&this.remove(e.index,e.items.length),this.invalidate()}}}}]);","name":"14-es2015.2e1aea88d00d740ffb6d.js","input":"(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[14],{\n\n/***/ \"+8QG\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"append\", function() { return /* reexport */ append[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"arabicToRoman\", function() { return /* reexport */ arabicToRoman; });\n__webpack_require__.d(__webpack_exports__, \"createPromise\", function() { return /* reexport */ create_promise[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"defined\", function() { return /* reexport */ defined[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"definitionId\", function() { return /* reexport */ definition_id[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"deg\", function() { return /* reexport */ deg[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"encodeBase64\", function() { return /* reexport */ encode_base64[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"eventCoordinates\", function() { return /* reexport */ event_coordinates[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"eventElement\", function() { return /* reexport */ event_element[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"isTransparent\", function() { return /* reexport */ is_transparent[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"last\", function() { return /* reexport */ last[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"limitValue\", function() { return /* reexport */ limit_value[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"mergeSort\", function() { return /* reexport */ mergeSort; });\n__webpack_require__.d(__webpack_exports__, \"now\", function() { return /* reexport */ now[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"promiseAll\", function() { return /* reexport */ promise_all[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"rad\", function() { return /* reexport */ rad[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"round\", function() { return /* reexport */ round[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"valueOrDefault\", function() { return /* reexport */ value_or_default[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"bindEvents\", function() { return /* reexport */ bind_events[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"elementOffset\", function() { return /* reexport */ element_offset[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"elementSize\", function() { return /* reexport */ element_size[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"elementStyles\", function() { return /* reexport */ element_styles[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"unbindEvents\", function() { return /* reexport */ unbind_events[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"elementPadding\", function() { return /* reexport */ element_padding[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"elementScale\", function() { return /* reexport */ element_scale[\"a\" /* default */]; });\n__webpack_require__.d(__webpack_exports__, \"DEG_TO_RAD\", function() { return /* reexport */ constants[\"a\" /* DEG_TO_RAD */]; });\n__webpack_require__.d(__webpack_exports__, \"MAX_NUM\", function() { return /* reexport */ constants[\"b\" /* MAX_NUM */]; });\n__webpack_require__.d(__webpack_exports__, \"MIN_NUM\", function() { return /* reexport */ constants[\"c\" /* MIN_NUM */]; });\n__webpack_require__.d(__webpack_exports__, \"LRUCache\", function() { return /* reexport */ text_metrics[\"a\" /* LRUCache */]; });\n__webpack_require__.d(__webpack_exports__, \"TextMetrics\", function() { return /* reexport */ text_metrics[\"b\" /* TextMetrics */]; });\n__webpack_require__.d(__webpack_exports__, \"measureText\", function() { return /* reexport */ text_metrics[\"d\" /* measureText */]; });\n__webpack_require__.d(__webpack_exports__, \"objectKey\", function() { return /* reexport */ text_metrics[\"f\" /* objectKey */]; });\n__webpack_require__.d(__webpack_exports__, \"hashKey\", function() { return /* reexport */ text_metrics[\"c\" /* hashKey */]; });\n__webpack_require__.d(__webpack_exports__, \"normalizeText\", function() { return /* reexport */ text_metrics[\"e\" /* normalizeText */]; });\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/append.js\nvar append = __webpack_require__(\"i9ZU\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/arabic-to-roman.js\n/* eslint-disable key-spacing,no-multi-spaces,no-param-reassign */\n\nconst literals = {\n    1    : \"i\",       10   : \"x\",       100  : \"c\",\n    2    : \"ii\",      20   : \"xx\",      200  : \"cc\",\n    3    : \"iii\",     30   : \"xxx\",     300  : \"ccc\",\n    4    : \"iv\",      40   : \"xl\",      400  : \"cd\",\n    5    : \"v\",       50   : \"l\",       500  : \"d\",\n    6    : \"vi\",      60   : \"lx\",      600  : \"dc\",\n    7    : \"vii\",     70   : \"lxx\",     700  : \"dcc\",\n    8    : \"viii\",    80   : \"lxxx\",    800  : \"dccc\",\n    9    : \"ix\",      90   : \"xc\",      900  : \"cm\",\n    1000 : \"m\"\n};\n\nfunction arabicToRoman(n) {\n    const values = [ 1000,\n                   900 , 800, 700, 600, 500, 400, 300, 200, 100,\n                   90  , 80 , 70 , 60 , 50 , 40 , 30 , 20 , 10 ,\n                   9   , 8  , 7  , 6  , 5  , 4  , 3  , 2  , 1 ];\n\n    let roman = \"\";\n    while (n > 0) {\n        if (n < values[0]) {\n            values.shift();\n        } else {\n            roman += literals[values[0]];\n            n -= values[0];\n        }\n    }\n    return roman;\n}\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/create-promise.js\nvar create_promise = __webpack_require__(\"dsTk\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/defined.js\nvar defined = __webpack_require__(\"VqL+\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/definition-id.js\nvar definition_id = __webpack_require__(\"E7ME\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/deg.js\nvar deg = __webpack_require__(\"9rnm\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/encode-base64.js + 1 modules\nvar encode_base64 = __webpack_require__(\"iYt6\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/event-coordinates.js\nvar event_coordinates = __webpack_require__(\"dH2W\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/event-element.js\nvar event_element = __webpack_require__(\"IU+O\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/is-transparent.js\nvar is_transparent = __webpack_require__(\"3Quq\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/last.js\nvar last = __webpack_require__(\"Eu+R\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/limit-value.js\nvar limit_value = __webpack_require__(\"1UyF\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/merge-sort.js\n/* eslint-disable no-multi-spaces, key-spacing, indent, camelcase, space-before-blocks, eqeqeq, brace-style */\n/* eslint-disable space-infix-ops, space-before-function-paren, array-bracket-spacing, object-curly-spacing */\n/* eslint-disable no-nested-ternary, max-params, default-case, no-else-return, no-empty */\n/* eslint-disable no-param-reassign, no-var, block-scoped-var */\n\n// mergeSort is stable.\nfunction mergeSort(a, cmp) {\n    if (a.length < 2) {\n        return a.slice();\n    }\n    function merge(a, b) {\n        var r = [], ai = 0, bi = 0, i = 0;\n        while (ai < a.length && bi < b.length) {\n            if (cmp(a[ai], b[bi]) <= 0) {\n                r[i++] = a[ai++];\n            } else {\n                r[i++] = b[bi++];\n            }\n        }\n        if (ai < a.length) {\n            r.push.apply(r, a.slice(ai));\n        }\n        if (bi < b.length) {\n            r.push.apply(r, b.slice(bi));\n        }\n        return r;\n    }\n    return (function sort(a) {\n        if (a.length <= 1) {\n            return a;\n        }\n        var m = Math.floor(a.length / 2);\n        var left = a.slice(0, m);\n        var right = a.slice(m);\n        left = sort(left);\n        right = sort(right);\n        return merge(left, right);\n    })(a);\n}\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/now.js\nvar now = __webpack_require__(\"hSuW\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/promise-all.js\nvar promise_all = __webpack_require__(\"Z3TV\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/rad.js\nvar rad = __webpack_require__(\"6USk\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/round.js\nvar round = __webpack_require__(\"RlWg\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/value-or-default.js\nvar value_or_default = __webpack_require__(\"9uUv\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/bind-events.js\nvar bind_events = __webpack_require__(\"APnZ\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/element-offset.js\nvar element_offset = __webpack_require__(\"IsCa\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/element-size.js\nvar element_size = __webpack_require__(\"wd4i\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/element-styles.js\nvar element_styles = __webpack_require__(\"oY8A\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/unbind-events.js\nvar unbind_events = __webpack_require__(\"Aie7\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/element-padding.js\nvar element_padding = __webpack_require__(\"DPs4\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/element-scale.js\nvar element_scale = __webpack_require__(\"JZGi\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/constants.js\nvar constants = __webpack_require__(\"2Ic7\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/text-metrics.js\nvar text_metrics = __webpack_require__(\"wBpk\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/***/ }),\n\n/***/ \"/EQf\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nfunction matchUserAgent(userAgent) {\n    const browserRxs = {\n        edge: /(edge)[ \\/]([\\w.]+)/i,\n        webkit: /(chrome)[ \\/]([\\w.]+)/i,\n        safari: /(webkit)[ \\/]([\\w.]+)/i,\n        opera: /(opera)(?:.*version|)[ \\/]([\\w.]+)/i,\n        msie: /(msie\\s|trident.*? rv:)([\\w.]+)/i,\n        mozilla: /(mozilla)(?:.*? rv:([\\w.]+)|)/i\n    };\n\n    let browser;\n\n    for (let agent in browserRxs) {\n        if (browserRxs.hasOwnProperty(agent)) {\n            const match = userAgent.match(browserRxs[agent]);\n            if (match) {\n                browser = {};\n                browser[agent] = true;\n                browser[match[1].toLowerCase().split(\" \")[0].split(\"/\")[0]] = true;\n                browser.version = parseInt(document.documentMode || match[2], 10);\n\n                break;\n            }\n        }\n    }\n\n    return browser;\n}\n\nlet browser = {};\n\nconst support = {\n    get browser() {\n        if (typeof window === 'undefined' || browser) {\n            return browser;\n        }\n\n        browser = matchUserAgent(window.navigator.userAgent);\n        return browser;\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (support);\n\n\n/***/ }),\n\n/***/ \"08A6\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return renderAttr; });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"VqL+\");\n\n\nfunction renderAttr(name, value) {\n    return (Object(_util__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(value) && value !== null) ? ` ${ name }=\"${ value }\" ` : \"\";\n}\n\n/***/ }),\n\n/***/ \"16KE\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* reexport */ drawing_namespaceObject; });\n__webpack_require__.d(__webpack_exports__, \"b\", function() { return /* reexport */ geometry; });\n\n// UNUSED EXPORTS: drawDOM, drawText, getFontFaces, exportPDF, exportImage, exportSVG, animationFrame, Class, Color, htmlEncode, logToConsole, Observable, saveAs, support, template, throttle, parseColor, namedColors, Animation, AnimationFactory, Arc, BaseNode, Circle, Element, Gradient, GradientStop, Group, Image, Layout, LinearGradient, MultiPath, HasObservers, OptionsStore, Path, PathParser, QuadNode, RadialGradient, Rect, ShapesQuadTree, Surface, SurfaceFactory, Text, align, fit, stack, vAlign, vStack, vWrap, wrap, pdf\n\n// NAMESPACE OBJECT: ./node_modules/@progress/kendo-drawing/dist/es2015/animations/easing-functions.js\nvar easing_functions_namespaceObject = {};\n__webpack_require__.r(easing_functions_namespaceObject);\n__webpack_require__.d(easing_functions_namespaceObject, \"swing\", function() { return swing; });\n__webpack_require__.d(easing_functions_namespaceObject, \"linear\", function() { return linear; });\n__webpack_require__.d(easing_functions_namespaceObject, \"easeOutElastic\", function() { return easeOutElastic; });\n\n// NAMESPACE OBJECT: ./node_modules/@progress/kendo-drawing/dist/es2015/svg.js\nvar svg_namespaceObject = {};\n__webpack_require__.r(svg_namespaceObject);\n__webpack_require__.d(svg_namespaceObject, \"Surface\", function() { return svg_surface; });\n__webpack_require__.d(svg_namespaceObject, \"RootNode\", function() { return root_node[\"a\" /* default */]; });\n__webpack_require__.d(svg_namespaceObject, \"Node\", function() { return node[\"a\" /* default */]; });\n__webpack_require__.d(svg_namespaceObject, \"GroupNode\", function() { return group_node; });\n__webpack_require__.d(svg_namespaceObject, \"ArcNode\", function() { return arc_node; });\n__webpack_require__.d(svg_namespaceObject, \"CircleNode\", function() { return circle_node; });\n__webpack_require__.d(svg_namespaceObject, \"RectNode\", function() { return rect_node; });\n__webpack_require__.d(svg_namespaceObject, \"ImageNode\", function() { return image_node; });\n__webpack_require__.d(svg_namespaceObject, \"TextNode\", function() { return text_node; });\n__webpack_require__.d(svg_namespaceObject, \"PathNode\", function() { return path_node; });\n__webpack_require__.d(svg_namespaceObject, \"MultiPathNode\", function() { return multi_path_node; });\n__webpack_require__.d(svg_namespaceObject, \"DefinitionNode\", function() { return definition_node[\"a\" /* default */]; });\n__webpack_require__.d(svg_namespaceObject, \"ClipNode\", function() { return clip_node[\"a\" /* default */]; });\n__webpack_require__.d(svg_namespaceObject, \"GradientStopNode\", function() { return gradient_stop_node[\"a\" /* default */]; });\n__webpack_require__.d(svg_namespaceObject, \"LinearGradientNode\", function() { return linear_gradient_node[\"a\" /* default */]; });\n__webpack_require__.d(svg_namespaceObject, \"RadialGradientNode\", function() { return radial_gradient_node[\"a\" /* default */]; });\n__webpack_require__.d(svg_namespaceObject, \"exportGroup\", function() { return export_group[\"a\" /* default */]; });\n\n// NAMESPACE OBJECT: ./node_modules/@progress/kendo-drawing/dist/es2015/canvas.js\nvar canvas_namespaceObject = {};\n__webpack_require__.r(canvas_namespaceObject);\n__webpack_require__.d(canvas_namespaceObject, \"Surface\", function() { return canvas_surface[\"a\" /* default */]; });\n__webpack_require__.d(canvas_namespaceObject, \"RootNode\", function() { return canvas_root_node[\"a\" /* default */]; });\n__webpack_require__.d(canvas_namespaceObject, \"Node\", function() { return canvas_node[\"a\" /* default */]; });\n__webpack_require__.d(canvas_namespaceObject, \"GroupNode\", function() { return canvas_group_node[\"a\" /* default */]; });\n__webpack_require__.d(canvas_namespaceObject, \"ArcNode\", function() { return canvas_arc_node[\"a\" /* default */]; });\n__webpack_require__.d(canvas_namespaceObject, \"CircleNode\", function() { return canvas_circle_node[\"a\" /* default */]; });\n__webpack_require__.d(canvas_namespaceObject, \"RectNode\", function() { return canvas_rect_node[\"a\" /* default */]; });\n__webpack_require__.d(canvas_namespaceObject, \"ImageNode\", function() { return canvas_image_node[\"a\" /* default */]; });\n__webpack_require__.d(canvas_namespaceObject, \"TextNode\", function() { return canvas_text_node[\"a\" /* default */]; });\n__webpack_require__.d(canvas_namespaceObject, \"PathNode\", function() { return canvas_path_node[\"a\" /* default */]; });\n__webpack_require__.d(canvas_namespaceObject, \"MultiPathNode\", function() { return canvas_multi_path_node[\"a\" /* default */]; });\n\n// NAMESPACE OBJECT: ./node_modules/@progress/kendo-drawing/dist/es2015/drawing.js\nvar drawing_namespaceObject = {};\n__webpack_require__.r(drawing_namespaceObject);\n__webpack_require__.d(drawing_namespaceObject, \"HasObservers\", function() { return has_observers[\"a\" /* default */]; });\n__webpack_require__.d(drawing_namespaceObject, \"Element\", function() { return shapes[\"c\" /* Element */]; });\n__webpack_require__.d(drawing_namespaceObject, \"Circle\", function() { return shapes[\"b\" /* Circle */]; });\n__webpack_require__.d(drawing_namespaceObject, \"Arc\", function() { return shapes[\"a\" /* Arc */]; });\n__webpack_require__.d(drawing_namespaceObject, \"Path\", function() { return shapes[\"h\" /* Path */]; });\n__webpack_require__.d(drawing_namespaceObject, \"MultiPath\", function() { return shapes[\"g\" /* MultiPath */]; });\n__webpack_require__.d(drawing_namespaceObject, \"Text\", function() { return shapes[\"j\" /* Text */]; });\n__webpack_require__.d(drawing_namespaceObject, \"Image\", function() { return shapes[\"e\" /* Image */]; });\n__webpack_require__.d(drawing_namespaceObject, \"Group\", function() { return shapes[\"d\" /* Group */]; });\n__webpack_require__.d(drawing_namespaceObject, \"Layout\", function() { return shapes[\"f\" /* Layout */]; });\n__webpack_require__.d(drawing_namespaceObject, \"Rect\", function() { return shapes[\"i\" /* Rect */]; });\n__webpack_require__.d(drawing_namespaceObject, \"align\", function() { return align; });\n__webpack_require__.d(drawing_namespaceObject, \"vAlign\", function() { return vAlign; });\n__webpack_require__.d(drawing_namespaceObject, \"stack\", function() { return stack_stack; });\n__webpack_require__.d(drawing_namespaceObject, \"vStack\", function() { return vStack; });\n__webpack_require__.d(drawing_namespaceObject, \"wrap\", function() { return wrap_wrap; });\n__webpack_require__.d(drawing_namespaceObject, \"vWrap\", function() { return vWrap; });\n__webpack_require__.d(drawing_namespaceObject, \"fit\", function() { return fit; });\n__webpack_require__.d(drawing_namespaceObject, \"LinearGradient\", function() { return linear_gradient[\"a\" /* default */]; });\n__webpack_require__.d(drawing_namespaceObject, \"RadialGradient\", function() { return radial_gradient[\"a\" /* default */]; });\n__webpack_require__.d(drawing_namespaceObject, \"GradientStop\", function() { return gradient_stop[\"a\" /* default */]; });\n__webpack_require__.d(drawing_namespaceObject, \"Gradient\", function() { return gradient[\"a\" /* default */]; });\n__webpack_require__.d(drawing_namespaceObject, \"Animation\", function() { return animation; });\n__webpack_require__.d(drawing_namespaceObject, \"AnimationFactory\", function() { return animation_factory; });\n__webpack_require__.d(drawing_namespaceObject, \"PathParser\", function() { return path_parser; });\n__webpack_require__.d(drawing_namespaceObject, \"parsePath\", function() { return parse_path[\"a\" /* default */]; });\n__webpack_require__.d(drawing_namespaceObject, \"BaseNode\", function() { return base_node[\"a\" /* default */]; });\n__webpack_require__.d(drawing_namespaceObject, \"OptionsStore\", function() { return options_store[\"a\" /* default */]; });\n__webpack_require__.d(drawing_namespaceObject, \"Surface\", function() { return es2015_surface; });\n__webpack_require__.d(drawing_namespaceObject, \"SurfaceFactory\", function() { return surface_factory; });\n__webpack_require__.d(drawing_namespaceObject, \"exportImage\", function() { return export_image[\"a\" /* default */]; });\n__webpack_require__.d(drawing_namespaceObject, \"exportSVG\", function() { return export_svg[\"a\" /* default */]; });\n__webpack_require__.d(drawing_namespaceObject, \"QuadNode\", function() { return quad_node[\"a\" /* default */]; });\n__webpack_require__.d(drawing_namespaceObject, \"ShapesQuadTree\", function() { return shapes_quad_tree[\"a\" /* default */]; });\n__webpack_require__.d(drawing_namespaceObject, \"svg\", function() { return svg_namespaceObject; });\n__webpack_require__.d(drawing_namespaceObject, \"canvas\", function() { return canvas_namespaceObject; });\n__webpack_require__.d(drawing_namespaceObject, \"util\", function() { return es2015_util; });\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/core/has-observers.js\nvar has_observers = __webpack_require__(\"7joe\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/shapes.js\nvar shapes = __webpack_require__(\"wm+B\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/alignment/translate-to-point.js\nvar translate_to_point = __webpack_require__(\"pVqk\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/alignment/align-start.js\nvar align_start = __webpack_require__(\"5Jba\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/alignment/align-elements.js\n\n\n\nfunction alignElements(elements, rect, alignment, axis, sizeField) {\n    for (let idx = 0; idx < elements.length; idx++) {\n        const bbox = elements[idx].clippedBBox();\n        if (bbox) {\n            const point = bbox.origin.clone();\n            point[axis] = Object(align_start[\"a\" /* default */])(bbox.size[sizeField], rect, alignment || \"start\", axis, sizeField);\n            Object(translate_to_point[\"a\" /* default */])(point, bbox, elements[idx]);\n        }\n    }\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/alignment/align.js\n\n\n\nfunction align(elements, rect, alignment) {\n    alignElements(elements, rect, alignment, \"x\", \"width\");\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/alignment/v-align.js\n\n\nfunction vAlign(elements, rect, alignment) {\n    alignElements(elements, rect, alignment, \"y\", \"height\");\n}\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/point.js\nvar geometry_point = __webpack_require__(\"lRJa\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/alignment/stack-elements.js\n\n\n\nfunction stackElements(elements, stackAxis, otherAxis, sizeField) {\n    if (elements.length > 1) {\n        const origin = new geometry_point[\"a\" /* default */]();\n        let previousBBox = elements[0].bbox;\n\n        for (let idx = 1; idx < elements.length; idx++) {\n            let element = elements[idx].element;\n            let bbox = elements[idx].bbox;\n            origin[stackAxis] = previousBBox.origin[stackAxis] + previousBBox.size[sizeField];\n            origin[otherAxis] = bbox.origin[otherAxis];\n            Object(translate_to_point[\"a\" /* default */])(origin, bbox, element);\n            bbox.origin[stackAxis] = origin[stackAxis];\n            previousBBox = bbox;\n        }\n    }\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/alignment/create-stack-elements.js\nfunction createStackElements(elements) {\n    const stackElements = [];\n\n    for (let idx = 0; idx < elements.length; idx++) {\n        let element = elements[idx];\n        let bbox = element.clippedBBox();\n        if (bbox) {\n            stackElements.push({\n                element: element,\n                bbox: bbox\n            });\n        }\n    }\n\n    return stackElements;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/alignment/stack.js\n\n\n\nfunction stack_stack(elements) {\n    stackElements(createStackElements(elements), \"x\", \"y\", \"width\");\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/alignment/v-stack.js\n\n\n\nfunction vStack(elements) {\n    stackElements(createStackElements(elements), \"y\", \"x\", \"height\");\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/alignment/wrap-elements.js\n\n\n\nfunction getStacks(elements, rect, sizeField) {\n    const maxSize = rect.size[sizeField];\n    const stacks = [];\n    let stack = [];\n    let stackSize = 0;\n    let element, bbox;\n\n    const addElementToStack = function() {\n        stack.push({\n            element: element,\n            bbox: bbox\n        });\n    };\n\n    for (let idx = 0; idx < elements.length; idx++) {\n        element = elements[idx];\n\n        bbox = element.clippedBBox();\n        if (bbox) {\n            let size = bbox.size[sizeField];\n            if (stackSize + size > maxSize) {\n                if (stack.length) {\n                    stacks.push(stack);\n                    stack = [];\n                    addElementToStack();\n                    stackSize = size;\n                } else {\n                    addElementToStack();\n                    stacks.push(stack);\n                    stack = [];\n                    stackSize = 0;\n                }\n            } else {\n                addElementToStack();\n                stackSize += size;\n            }\n        }\n    }\n\n    if (stack.length) {\n        stacks.push(stack);\n    }\n\n    return stacks;\n}\n\nfunction wrapElements(elements, rect, axis, otherAxis, sizeField) {\n    const stacks = getStacks(elements, rect, sizeField);\n    const origin = rect.origin.clone();\n    const result = [];\n\n    for (let idx = 0; idx < stacks.length; idx++) {\n        let stack = stacks[idx];\n        let startElement = stack[0];\n        origin[otherAxis] = startElement.bbox.origin[otherAxis];\n        Object(translate_to_point[\"a\" /* default */])(origin, startElement.bbox, startElement.element);\n        startElement.bbox.origin[axis] = origin[axis];\n        stackElements(stack, axis, otherAxis, sizeField);\n        result.push([]);\n        for (let elementIdx = 0; elementIdx < stack.length; elementIdx++) {\n            result[idx].push(stack[elementIdx].element);\n        }\n    }\n    return result;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/alignment/wrap.js\n\n\nfunction wrap_wrap(elements, rect) {\n    return wrapElements(elements, rect, \"x\", \"y\", \"width\");\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/alignment/v-wrap.js\n\n\nfunction vWrap(elements, rect) {\n    return wrapElements(elements, rect, \"y\", \"x\", \"height\");\n}\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/transform.js\nvar geometry_transform = __webpack_require__(\"uBxF\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/alignment/fit.js\n\n\nfunction fit(element, rect) {\n    const bbox = element.clippedBBox();\n    if (bbox) {\n        const elementSize = bbox.size;\n        const rectSize = rect.size;\n        if (rectSize.width < elementSize.width || rectSize.height < elementSize.height) {\n            const scale = Math.min(rectSize.width / elementSize.width, rectSize.height / elementSize.height);\n            const transform = element.transform() || Object(geometry_transform[\"a\" /* default */])();\n            transform.scale(scale, scale);\n            element.transform(transform);\n        }\n    }\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/alignment.js\n\n\n\n\n\n\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/gradients/linear-gradient.js\nvar linear_gradient = __webpack_require__(\"7Jhm\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/gradients/radial-gradient.js\nvar radial_gradient = __webpack_require__(\"yhXd\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/gradients/gradient-stop.js + 1 modules\nvar gradient_stop = __webpack_require__(\"QPDK\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/gradients/gradient.js + 1 modules\nvar gradient = __webpack_require__(\"4DQW\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/gradients.js\n\n\n\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/animations/easing-functions.js\nfunction swing(position) {\n    return 0.5 - Math.cos(position * Math.PI) / 2;\n}\n\nfunction linear(position) {\n    return position;\n}\n\nfunction easeOutElastic(position, time, start, diff) {\n    let s = 1.70158,\n        p = 0,\n        a = diff;\n\n    if (position === 0) {\n        return start;\n    }\n\n    if (position === 1) {\n        return start + diff;\n    }\n\n    if (!p) {\n        p = 0.5;\n    }\n\n    if (a < Math.abs(diff)) {\n        a = diff;\n        s = p / 4;\n    } else {\n        s = p / (2 * Math.PI) * Math.asin(diff / a);\n    }\n\n    return a * Math.pow(2, -10 * position) *\n           Math.sin((Number(position) - s) * (1.1 * Math.PI) / p) + diff + start;\n}\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/now.js\nvar now = __webpack_require__(\"hSuW\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/limit-value.js\nvar limit_value = __webpack_require__(\"1UyF\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/common/class.js\nvar common_class = __webpack_require__(\"LHUb\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/common/animation-frame.js\nvar animation_frame = __webpack_require__(\"FRnV\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/animations/animation-factory.js\n\n\nlet instance;\n\nclass animation_factory_AnimationFactory extends common_class[\"a\" /* default */] {\n    static get current() {\n        if (!instance) {\n            instance = new animation_factory_AnimationFactory();\n        }\n\n        return instance;\n    }\n\n    constructor() {\n        super();\n\n        this._items = [];\n    }\n\n    register(name, type) {\n        this._items.push({\n            name: name,\n            type: type\n        });\n    }\n\n    create(element, options) {\n        const items = this._items;\n        let match;\n\n        if (options && options.type) {\n            const type = options.type.toLowerCase();\n            for (let i = 0; i < items.length; i++) {\n                if (items[i].name.toLowerCase() === type) {\n                    match = items[i];\n                    break;\n                }\n            }\n        }\n\n        if (match) {\n            return new match.type(element, options);\n        }\n    }\n}\n\n/* harmony default export */ var animation_factory = (animation_factory_AnimationFactory);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/animations/animation.js\n\n\n\n\n\nclass animation_Animation extends common_class[\"a\" /* default */] {\n    static create(type, element, options) {\n        return animation_factory.current.create(type, element, options);\n    }\n\n    get options() {\n        return this._options || {\n            duration: 500,\n            easing: \"swing\"\n        };\n    }\n\n    set options(value) {\n        this._options = value;\n    }\n\n    constructor(element, options) {\n        super();\n\n        this.options = Object.assign({}, this.options, options);\n        this.element = element;\n    }\n\n    setup() {}\n    step() {}\n\n    play() {\n        const options = this.options;\n        const { duration, delay = 0 } = options;\n        const easing = easing_functions_namespaceObject[options.easing];\n        const start = Object(now[\"a\" /* default */])() + delay;\n        const finish = start + duration;\n\n        if (duration === 0) {\n            this.step(1);\n            this.abort();\n        } else {\n            setTimeout(() => {\n                const loop = () => {\n                    if (this._stopped) {\n                        return;\n                    }\n\n                    const wallTime = Object(now[\"a\" /* default */])();\n\n                    const time = Object(limit_value[\"a\" /* default */])(wallTime - start, 0, duration);\n                    const position = time / duration;\n                    const easingPosition = easing(position, time, 0, 1, duration);\n\n                    this.step(easingPosition);\n\n                    if (wallTime < finish) {\n                        Object(animation_frame[\"a\" /* default */])(loop);\n                    } else {\n                        this.abort();\n                    }\n                };\n\n                loop();\n            }, delay);\n        }\n    }\n\n    abort() {\n        this._stopped = true;\n    }\n\n    destroy() {\n        this.abort();\n    }\n}\n\n/* harmony default export */ var animation = (animation_Animation);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/animations.js\n\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/shapes/path.js + 1 modules\nvar path = __webpack_require__(\"Ah4p\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/parsing/parse-path.js + 1 modules\nvar parse_path = __webpack_require__(\"sK2o\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/parsing/path-parser.js\n\n\n\n\nlet path_parser_instance;\n\nclass path_parser_PathParser extends common_class[\"a\" /* default */] {\n    static get current() {\n        if (!path_parser_instance) {\n            path_parser_instance = new path_parser_PathParser();\n        }\n\n        return path_parser_instance;\n    }\n\n    parse(str, options) {\n        const multiPath = new path[\"a\" /* MultiPath */](options);\n        return Object(parse_path[\"a\" /* default */])(multiPath, str);\n    }\n}\n\n/* harmony default export */ var path_parser = (path_parser_PathParser);\n\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/core/base-node.js\nvar base_node = __webpack_require__(\"ztN+\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/core/options-store.js\nvar options_store = __webpack_require__(\"Ptn1\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/core/surface.js\nvar surface = __webpack_require__(\"mcME\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/common/log-to-console.js\nvar log_to_console = __webpack_require__(\"l/PP\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/svg/root-node.js\nvar root_node = __webpack_require__(\"wJcK\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/shapes/group.js\nvar group = __webpack_require__(\"qUqW\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/svg/utils/render-svg.js\nvar render_svg = __webpack_require__(\"tZVE\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/svg/constants.js\nvar constants = __webpack_require__(\"V34t\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/element-styles.js\nvar element_styles = __webpack_require__(\"oY8A\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/bind-events.js\nvar bind_events = __webpack_require__(\"APnZ\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/unbind-events.js\nvar unbind_events = __webpack_require__(\"Aie7\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/svg/node.js\nvar node = __webpack_require__(\"7Prh\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/is-transparent.js\nvar is_transparent = __webpack_require__(\"3Quq\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/defined.js\nvar defined = __webpack_require__(\"VqL+\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/core/constants.js\nvar core_constants = __webpack_require__(\"OOjv\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/svg/utils/render-all-attributes.js\nvar render_all_attributes = __webpack_require__(\"YDM/\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/svg/utils/render-attribute.js\nvar render_attribute = __webpack_require__(\"08A6\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/svg/path-node.js\n\n\n\n\n\n\n\nconst ATTRIBUTE_MAP = {\n    \"fill.opacity\": \"fill-opacity\",\n    \"stroke.color\": \"stroke\",\n    \"stroke.width\": \"stroke-width\",\n    \"stroke.opacity\": \"stroke-opacity\"\n};\nconst SPACE = \" \";\n\nclass path_node_PathNode extends node[\"a\" /* default */] {\n\n    geometryChange() {\n        this.attr(\"d\", this.renderData());\n        this.invalidate();\n    }\n\n    optionsChange(e) {\n        switch (e.field) {\n            case \"fill\":\n                if (e.value) {\n                    this.allAttr(this.mapFill(e.value));\n                } else {\n                    this.removeAttr(\"fill\");\n                }\n                break;\n\n            case \"fill.color\":\n                this.allAttr(this.mapFill({ color: e.value }));\n                break;\n\n            case \"stroke\":\n                if (e.value) {\n                    this.allAttr(this.mapStroke(e.value));\n                } else {\n                    this.removeAttr(\"stroke\");\n                }\n                break;\n\n            case \"transform\":\n                this.transformChange(e.value);\n                break;\n\n            default:\n                const name = ATTRIBUTE_MAP[e.field];\n                if (name) {\n                    this.attr(name, e.value);\n                }\n                break;\n        }\n\n        super.optionsChange(e);\n    }\n\n    content() {\n        if (this.element) {\n            this.element.textContent = this.srcElement.content();\n        }\n    }\n\n    renderData() {\n        return this.printPath(this.srcElement);\n    }\n\n    printPath(path) {\n        const segments = path.segments;\n        const length = segments.length;\n        if (length > 0) {\n            const parts = [];\n            let output, currentType;\n\n            for (let i = 1; i < length; i++) {\n                let segmentType = this.segmentType(segments[i - 1], segments[i]);\n                if (segmentType !== currentType) {\n                    currentType = segmentType;\n                    parts.push(segmentType);\n                }\n\n                if (segmentType === \"L\") {\n                    parts.push(this.printPoints(segments[i].anchor()));\n                } else {\n                    parts.push(this.printPoints(segments[i - 1].controlOut(), segments[i].controlIn(), segments[i].anchor()));\n                }\n            }\n\n            output = \"M\" + this.printPoints(segments[0].anchor()) + SPACE + parts.join(SPACE);\n            if (path.options.closed) {\n                output += \"Z\";\n            }\n\n            return output;\n        }\n    }\n\n    printPoints() {\n        const points = arguments;\n        const length = points.length;\n        const result = [];\n\n        for (let i = 0; i < length; i++) {\n            result.push(points[i].toString(3));\n        }\n\n        return result.join(\" \");\n    }\n\n    segmentType(segmentStart, segmentEnd) {\n        return segmentStart.controlOut() && segmentEnd.controlIn() ? \"C\" : \"L\";\n    }\n\n    mapStroke(stroke) {\n        const attrs = [];\n\n        if (stroke && !Object(is_transparent[\"a\" /* default */])(stroke.color)) {\n            attrs.push([ \"stroke\", stroke.color ]);\n            attrs.push([ \"stroke-width\", stroke.width ]);\n            attrs.push([ \"stroke-linecap\", this.renderLinecap(stroke) ]);\n            attrs.push([ \"stroke-linejoin\", stroke.lineJoin ]);\n\n            if (Object(defined[\"a\" /* default */])(stroke.opacity)) {\n                attrs.push([ \"stroke-opacity\", stroke.opacity ]);\n            }\n\n            if (Object(defined[\"a\" /* default */])(stroke.dashType)) {\n                attrs.push([ \"stroke-dasharray\", this.renderDashType(stroke) ]);\n            }\n        } else {\n            attrs.push([ \"stroke\", constants[\"a\" /* NONE */] ]);\n        }\n\n        return attrs;\n    }\n\n    renderStroke() {\n        return Object(render_all_attributes[\"a\" /* default */])(\n            this.mapStroke(this.srcElement.options.stroke)\n        );\n    }\n\n    renderDashType(stroke) {\n        const { dashType, width = 1 } = stroke;\n\n        if (dashType && dashType !== core_constants[\"c\" /* SOLID */]) {\n            const dashArray = core_constants[\"b\" /* DASH_ARRAYS */][dashType.toLowerCase()];\n            const result = [];\n\n            for (let i = 0; i < dashArray.length; i++) {\n                result.push(dashArray[i] * width);\n            }\n\n            return result.join(\" \");\n        }\n    }\n\n    renderLinecap(stroke) {\n        const { dashType, lineCap } = stroke;\n\n        return (dashType && dashType !== \"solid\") ? core_constants[\"a\" /* BUTT */] : lineCap;\n    }\n\n    mapFill(fill) {\n        const attrs = [];\n        if (!(fill && fill.nodeType === \"Gradient\")) {\n            if (fill && !Object(is_transparent[\"a\" /* default */])(fill.color)) {\n                attrs.push([ \"fill\", fill.color ]);\n\n                if (Object(defined[\"a\" /* default */])(fill.opacity)) {\n                    attrs.push([ \"fill-opacity\", fill.opacity ]);\n                }\n            } else {\n                attrs.push([ \"fill\", constants[\"a\" /* NONE */] ]);\n            }\n        }\n\n        return attrs;\n    }\n\n    renderFill() {\n        return Object(render_all_attributes[\"a\" /* default */])(\n            this.mapFill(this.srcElement.options.fill)\n        );\n    }\n\n    template() {\n        return `<path ${ this.renderId() } ${ this.renderStyle() } ${ this.renderOpacity() } ${ Object(render_attribute[\"a\" /* default */])('d', this.renderData()) }` +\n                    `${ this.renderStroke() }${ this.renderFill() }${ this.renderDefinitions() }${ this.renderTransform() }></path>`;\n    }\n}\n\n/* harmony default export */ var path_node = (path_node_PathNode);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/svg/arc-node.js\n\n\nclass arc_node_ArcNode extends path_node {\n    renderData() {\n        return this.printPath(this.srcElement.toPath());\n    }\n}\n\n/* harmony default export */ var arc_node = (arc_node_ArcNode);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/svg/circle-node.js\n\n\nclass circle_node_CircleNode extends path_node {\n\n    geometryChange() {\n        const center = this.center();\n        this.attr(\"cx\", center.x);\n        this.attr(\"cy\", center.y);\n        this.attr(\"r\", this.radius());\n        this.invalidate();\n    }\n\n    center() {\n        return this.srcElement.geometry().center;\n    }\n\n    radius() {\n        return this.srcElement.geometry().radius;\n    }\n\n    template() {\n        return `<circle ${ this.renderId() } ${ this.renderStyle() } ${ this.renderOpacity() }` +\n                    `cx='${ this.center().x }' cy='${ this.center().y }' r='${ this.radius() }'` +\n                    `${ this.renderStroke() } ${ this.renderFill() } ${ this.renderDefinitions() }` +\n                    `${ this.renderTransform() } ></circle>`;\n    }\n}\n\n/* harmony default export */ var circle_node = (circle_node_CircleNode);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/svg/group-node.js\n\n\nclass group_node_GroupNode extends node[\"a\" /* default */] {\n    template() {\n        return `<g${ this.renderId() + this.renderTransform() + this.renderStyle() + this.renderOpacity() + this.renderDefinitions() }>${ this.renderChildren() }</g>`;\n    }\n\n    optionsChange(e) {\n        if (e.field === \"transform\") {\n            this.transformChange(e.value);\n        }\n\n        super.optionsChange(e);\n    }\n}\n\n/* harmony default export */ var group_node = (group_node_GroupNode);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/common/html-encode.js\nconst ampRegExp = /&/g;\nconst ltRegExp = /</g;\nconst quoteRegExp = /\"/g;\nconst aposRegExp = /'/g;\nconst gtRegExp = />/g;\n\nfunction htmlEncode(value) {\n    return String(value).replace(ampRegExp, \"&amp;\").replace(ltRegExp, \"&lt;\").replace(gtRegExp, \"&gt;\").replace(quoteRegExp, \"&quot;\").replace(aposRegExp, \"&#39;\");\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/svg/image-node.js\n\n\n\n\nclass image_node_ImageNode extends path_node {\n\n    geometryChange() {\n        this.allAttr(this.mapPosition());\n        this.invalidate();\n    }\n\n    optionsChange(e) {\n        if (e.field === \"src\") {\n            this.allAttr(this.mapSource());\n        }\n\n        super.optionsChange(e);\n    }\n\n    mapPosition() {\n        const rect = this.srcElement.rect();\n        const tl = rect.topLeft();\n\n        return [\n            [ \"x\", tl.x ],\n            [ \"y\", tl.y ],\n            [ \"width\", rect.width() + \"px\" ],\n            [ \"height\", rect.height() + \"px\" ]\n        ];\n    }\n\n    renderPosition() {\n        return Object(render_all_attributes[\"a\" /* default */])(this.mapPosition());\n    }\n\n    mapSource(encode) {\n        let src = this.srcElement.src();\n\n        if (encode) {\n            src = htmlEncode(src);\n        }\n\n        return [ [ \"xlink:href\", src ] ];\n    }\n\n    renderSource() {\n        return Object(render_all_attributes[\"a\" /* default */])(this.mapSource(true));\n    }\n\n    template() {\n        return `<image preserveAspectRatio='none' ${ this.renderId() } ${ this.renderStyle() } ${ this.renderTransform()} ${ this.renderOpacity() }` +\n               `${ this.renderPosition() } ${ this.renderSource() } ${ this.renderDefinitions()}>` +\n               `</image>`;\n    }\n}\n\n/* harmony default export */ var image_node = (image_node_ImageNode);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/svg/multi-path-node.js\n\n\nclass multi_path_node_MultiPathNode extends path_node {\n    renderData() {\n        const paths = this.srcElement.paths;\n\n        if (paths.length > 0) {\n            const result = [];\n\n            for (let i = 0; i < paths.length; i++) {\n                result.push(this.printPath(paths[i]));\n            }\n\n            return result.join(\" \");\n        }\n    }\n}\n\n/* harmony default export */ var multi_path_node = (multi_path_node_MultiPathNode);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/svg/rect-node.js\n\n\nclass rect_node_RectNode extends path_node {\n\n    geometryChange() {\n        const geometry = this.srcElement.geometry();\n        this.attr(\"x\", geometry.origin.x);\n        this.attr(\"y\", geometry.origin.y);\n        this.attr(\"width\", geometry.size.width);\n        this.attr(\"height\", geometry.size.height);\n        this.invalidate();\n    }\n\n    size() {\n        return this.srcElement.geometry().size;\n    }\n\n    origin() {\n        return this.srcElement.geometry().origin;\n    }\n\n    template() {\n        return `<rect ${ this.renderId() } ${ this.renderStyle() } ${ this.renderOpacity() } x='${ this.origin().x }' y='${ this.origin().y }' ` +\n                    `width='${ this.size().width }' height='${ this.size().height }' ${ this.renderStroke() } ` +\n                    `${ this.renderFill() } ${ this.renderDefinitions() } ${ this.renderTransform() } />`;\n    }\n}\n\n/* harmony default export */ var rect_node = (rect_node_RectNode);\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/svg/utils/render-style.js\nvar render_style = __webpack_require__(\"8tN3\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/common/support.js\nvar support = __webpack_require__(\"/EQf\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/text-metrics/util.js\nvar util = __webpack_require__(\"C91f\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/svg/text-node.js\n\n\n\n\n\n\nconst ENTITY_REGEX = /&(?:[a-zA-Z]+|#\\d+);/g;\n\nfunction decodeEntities(text) {\n    if (!text || typeof text !== \"string\" || !ENTITY_REGEX.test(text)) {\n        return text;\n    }\n\n    const element = decodeEntities._element;\n    ENTITY_REGEX.lastIndex = 0;\n\n    return text.replace(ENTITY_REGEX, (match) => {\n        element.innerHTML = match;\n\n        return element.textContent || element.innerText;\n    });\n}\n\nif (typeof document !== \"undefined\") {\n    decodeEntities._element = document.createElement(\"span\");\n}\n\nclass text_node_TextNode extends path_node {\n\n    geometryChange() {\n        const pos = this.pos();\n        this.attr(\"x\", pos.x);\n        this.attr(\"y\", pos.y);\n        this.invalidate();\n    }\n\n    optionsChange(e) {\n        if (e.field === \"font\") {\n            this.attr(\"style\", Object(render_style[\"a\" /* default */])(this.mapStyle()));\n            this.geometryChange();\n        } else if (e.field === \"content\") {\n            super.content(this.srcElement.content());\n        }\n\n        super.optionsChange(e);\n    }\n\n    mapStyle(encode) {\n        const style = super.mapStyle(encode);\n        let font = this.srcElement.options.font;\n\n        if (encode) {\n            font = htmlEncode(font);\n        }\n\n        style.push([ \"font\", font ], [ \"white-space\", \"pre\" ]);\n\n        return style;\n    }\n\n    pos() {\n        const pos = this.srcElement.position();\n        const size = this.srcElement.measure();\n        return pos.clone().setY(pos.y + size.baseline);\n    }\n\n    renderContent() {\n        let content = this.srcElement.content();\n        content = decodeEntities(content);\n        content = htmlEncode(content);\n\n        return Object(util[\"b\" /* normalizeText */])(content);\n    }\n\n    renderTextAnchor() {\n        let anchor;\n\n        if ((this.options || {}).rtl && !(support[\"a\" /* default */].browser.msie || support[\"a\" /* default */].browser.edge)) {\n            anchor = 'end';\n        }\n\n        return Object(render_attribute[\"a\" /* default */])(\"text-anchor\", anchor);\n    }\n\n    template() {\n        return `<text ${ this.renderId() } ${ this.renderTextAnchor() } ${ this.renderStyle() } ${ this.renderOpacity() }` +\n                    `x='${ this.pos().x }' y='${ this.pos().y }' ${ this.renderStroke() } ${ this.renderTransform() } ${ this.renderDefinitions() }` +\n                    `${ this.renderFill() }>${ this.renderContent() }</text>`;\n    }\n}\n\n/* harmony default export */ var text_node = (text_node_TextNode);\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/svg/node-map.js\nvar node_map = __webpack_require__(\"uNz1\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/svg/surface.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nnode_map[\"a\" /* default */].Arc = arc_node;\nnode_map[\"a\" /* default */].Circle = circle_node;\nnode_map[\"a\" /* default */].Group = group_node;\nnode_map[\"a\" /* default */].Image = image_node;\nnode_map[\"a\" /* default */].MultiPath = multi_path_node;\nnode_map[\"a\" /* default */].Path = path_node;\nnode_map[\"a\" /* default */].Rect = rect_node;\nnode_map[\"a\" /* default */].Text = text_node;\n\nconst RTL = 'rtl';\n\nfunction alignToScreen(element) {\n    let ctm;\n\n    try {\n        ctm = element.getScreenCTM ? element.getScreenCTM() : null;\n    } catch (e) { } // eslint-disable-line no-empty\n\n    if (ctm) {\n        const left = - ctm.e % 1;\n        const top = - ctm.f % 1;\n        const style = element.style;\n\n        if (left !== 0 || top !== 0) {\n            style.left = left + \"px\";\n            style.top = top + \"px\";\n        }\n    }\n}\n\nclass surface_Surface extends surface[\"a\" /* default */] {\n    get type() {\n        return \"svg\";\n    }\n\n    constructor(element, options) {\n        super(element, options);\n\n        this._root = new root_node[\"a\" /* default */](Object.assign({\n            rtl: Object(element_styles[\"a\" /* default */])(element, 'direction').direction === RTL\n        }, this.options));\n\n        Object(render_svg[\"a\" /* default */])(this.element, this._template());\n\n        this._rootElement = this.element.firstElementChild;\n\n        alignToScreen(this._rootElement);\n\n        this._root.attachTo(this._rootElement);\n\n        Object(bind_events[\"a\" /* default */])(this.element, {\n            click: this._click,\n            mouseover: this._mouseenter,\n            mouseout: this._mouseleave,\n            mousemove: this._mousemove\n        });\n\n        this.resize();\n    }\n\n    destroy() {\n        if (this._root) {\n            this._root.destroy();\n            this._root = null;\n            this._rootElement = null;\n            Object(unbind_events[\"a\" /* default */])(this.element, {\n                click: this._click,\n                mouseover: this._mouseenter,\n                mouseout: this._mouseleave,\n                mousemove: this._mousemove\n            });\n        }\n\n        super.destroy();\n    }\n\n    translate(offset) {\n        const viewBox = `${ Math.round(offset.x) } ${ Math.round(offset.y) } ${ this._size.width } ${ this._size.height }`;\n\n        this._offset = offset;\n        this._rootElement.setAttribute(\"viewBox\", viewBox);\n    }\n\n    draw(element) {\n        super.draw(element);\n        this._root.load([ element ]);\n    }\n\n    clear() {\n        super.clear();\n        this._root.clear();\n    }\n\n    svg() {\n        return \"<?xml version='1.0' ?>\" + this._template();\n    }\n\n    exportVisual() {\n        let { _visual: visual, _offset: offset } = this;\n\n        if (offset) {\n            const wrap = new group[\"a\" /* default */]();\n            wrap.children.push(visual);\n\n            wrap.transform(\n                Object(geometry_transform[\"a\" /* default */])().translate(-offset.x, -offset.y)\n            );\n\n            visual = wrap;\n        }\n\n        return visual;\n    }\n\n    _resize() {\n        if (this._offset) {\n            this.translate(this._offset);\n        }\n    }\n\n    _template() {\n        return `<svg style='width: 100%; height: 100%; overflow: hidden;' xmlns='${ constants[\"b\" /* SVG_NS */] }' xmlns:xlink='http://www.w3.org/1999/xlink' version='1.1'>${ this._root.render() }</svg>`;\n    }\n}\n\n/* harmony default export */ var svg_surface = (surface_Surface);\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/canvas/surface.js + 1 modules\nvar canvas_surface = __webpack_require__(\"kGoT\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/surface-factory.js\n\n\n\n\nlet surface_factory_instance;\nlet surface_factory_support;\n\nconst hasDocument = () => typeof document !== \"undefined\";\n\nconst supportsCanvas = () => hasDocument() &&\n    document.createElement(\"canvas\").getContext;\n\nconst supportsSVG = () => hasDocument() &&\n    document.implementation.hasFeature(\"http://www.w3.org/TR/SVG11/feature#BasicStructure\", \"1.1\");\n\nclass surface_factory_SurfaceFactory extends common_class[\"a\" /* default */] {\n    static get support() {\n        if (!surface_factory_support) {\n            surface_factory_support = {\n                canvas: supportsCanvas(),\n                svg: supportsSVG()\n            };\n        }\n\n        return surface_factory_support;\n    }\n\n    static get current() {\n        if (!surface_factory_instance) {\n            surface_factory_instance = new surface_factory_SurfaceFactory();\n        }\n\n        return surface_factory_instance;\n    }\n\n    constructor() {\n        super();\n\n        this._items = [ {\n            name: \"svg\",\n            type: svg_surface\n        }, {\n            name: \"canvas\",\n            type: canvas_surface[\"a\" /* default */]\n        } ];\n    }\n\n    create(element, options) {\n        const items = this._items;\n        let match = items[0];\n\n        if (options && options.type) {\n            const preferred = options.type.toLowerCase();\n            for (let i = 0; i < items.length; i++) {\n                if (items[i].name === preferred) {\n                    match = items[i];\n                    break;\n                }\n            }\n        }\n\n        if (match) {\n            return new match.type(element, options);\n        }\n\n        Object(log_to_console[\"a\" /* default */])(\n            \"Warning: Unable to create Kendo UI Drawing Surface. Possible causes:\\n\" +\n            `- The browser does not support SVG and Canvas. User agent: ${ navigator.userAgent }`);\n    }\n}\n\n/* harmony default export */ var surface_factory = (surface_factory_SurfaceFactory);\n\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/surface.js\n\n\n\nclass es2015_surface_Surface extends surface[\"a\" /* default */] {\n    static get support() {\n        return surface_factory.support;\n    }\n\n    static create(element, options) {\n        return surface_factory.current.create(element, options);\n    }\n}\n\n/* harmony default export */ var es2015_surface = (es2015_surface_Surface);\n\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/svg/definition-node.js\nvar definition_node = __webpack_require__(\"7WKN\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/svg/clip-node.js\nvar clip_node = __webpack_require__(\"gNPy\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/svg/gradient-stop-node.js\nvar gradient_stop_node = __webpack_require__(\"Fs4b\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/svg/linear-gradient-node.js\nvar linear_gradient_node = __webpack_require__(\"4U2A\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/svg/radial-gradient-node.js\nvar radial_gradient_node = __webpack_require__(\"inPS\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/svg/export-group.js\nvar export_group = __webpack_require__(\"eMc0\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/svg.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/canvas/root-node.js\nvar canvas_root_node = __webpack_require__(\"Ytya\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/canvas/node.js\nvar canvas_node = __webpack_require__(\"o+K8\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/canvas/group-node.js\nvar canvas_group_node = __webpack_require__(\"xYjD\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/canvas/arc-node.js\nvar canvas_arc_node = __webpack_require__(\"bRfn\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/canvas/circle-node.js\nvar canvas_circle_node = __webpack_require__(\"FSED\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/canvas/rect-node.js\nvar canvas_rect_node = __webpack_require__(\"SMq3\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/canvas/image-node.js\nvar canvas_image_node = __webpack_require__(\"ijzS\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/canvas/text-node.js\nvar canvas_text_node = __webpack_require__(\"G/KS\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/canvas/path-node.js\nvar canvas_path_node = __webpack_require__(\"UzJa\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/canvas/multi-path-node.js\nvar canvas_multi_path_node = __webpack_require__(\"5HPa\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/canvas.js\n\n\n\n\n\n\n\n\n\n\n\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util.js + 2 modules\nvar es2015_util = __webpack_require__(\"+8QG\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/canvas/export-image.js\nvar export_image = __webpack_require__(\"uekK\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/svg/export-svg.js\nvar export_svg = __webpack_require__(\"eO0B\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/search/quad-node.js\nvar quad_node = __webpack_require__(\"R/Fs\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/search/shapes-quad-tree.js\nvar shapes_quad_tree = __webpack_require__(\"5FN0\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/drawing.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry.js\nvar geometry = __webpack_require__(\"mjA8\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/main.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/***/ }),\n\n/***/ \"1UyF\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return limitValue; });\nfunction limitValue(value, min, max) {\n    return Math.max(Math.min(value, max), min);\n}\n\n/***/ }),\n\n/***/ \"2Ic7\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return DEG_TO_RAD; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return MAX_NUM; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return MIN_NUM; });\nconst DEG_TO_RAD = Math.PI / 180;\nconst MAX_NUM = Number.MAX_VALUE;\nconst MIN_NUM = -Number.MAX_VALUE;\n\n\n\n/***/ }),\n\n/***/ \"2smt\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"LHUb\");\n\n\nclass QuadRoot extends _common__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"] {\n    constructor() {\n        super();\n\n        this.shapes = [];\n    }\n\n    _add(shape, bbox) {\n        this.shapes.push({\n            bbox: bbox,\n            shape: shape\n        });\n        shape._quadNode = this;\n    }\n\n    pointShapes(point) {\n        const shapes = this.shapes;\n        const length = shapes.length;\n        const result = [];\n        for (let idx = 0; idx < length; idx++) {\n            if (shapes[idx].bbox.containsPoint(point)) {\n                result.push(shapes[idx].shape);\n            }\n        }\n        return result;\n    }\n\n    insert(shape, bbox) {\n        this._add(shape, bbox);\n    }\n\n    remove(shape) {\n        const shapes = this.shapes;\n        const length = shapes.length;\n\n        for (let idx = 0; idx < length; idx++) {\n            if (shapes[idx].shape === shape) {\n                shapes.splice(idx, 1);\n                break;\n            }\n        }\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (QuadRoot);\n\n/***/ }),\n\n/***/ \"3Quq\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return isTransparent; });\n/* harmony import */ var _defined__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"VqL+\");\n\n\nfunction isTransparent(color) {\n    return color === \"\" || color === null || color === \"none\" || color === \"transparent\" || !Object(_defined__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(color);\n}\n\n/***/ }),\n\n/***/ \"4DQW\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/shapes/elements-array.js\nvar elements_array = __webpack_require__(\"Vvtp\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/gradients/stops-array.js\n\n\nclass stops_array_StopsArray extends elements_array[\"a\" /* default */] {\n    _change() {\n        this.optionsChange({\n            field: \"stops\"\n        });\n    }\n}\n\n/* harmony default export */ var stops_array = (stops_array_StopsArray);\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/gradients/gradient-stop.js + 1 modules\nvar gradient_stop = __webpack_require__(\"QPDK\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/core/has-observers.js\nvar has_observers = __webpack_require__(\"7joe\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/definition-id.js\nvar definition_id = __webpack_require__(\"E7ME\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/defined.js\nvar defined = __webpack_require__(\"VqL+\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/gradients/gradient.js\n\n\n\n\n\nclass gradient_Gradient extends has_observers[\"a\" /* default */] {\n    get nodeType() {\n        return \"Gradient\";\n    }\n\n    constructor(options = {}) {\n        super();\n\n        this.stops = new stops_array(this._createStops(options.stops));\n        this.stops.addObserver(this);\n        this._userSpace = options.userSpace;\n        this.id = Object(definition_id[\"a\" /* default */])();\n    }\n\n    userSpace(value) {\n        if (Object(defined[\"a\" /* default */])(value)) {\n            this._userSpace = value;\n            this.optionsChange();\n            return this;\n        }\n\n        return this._userSpace;\n    }\n\n    _createStops(stops = []) {\n        const result = [];\n        for (let idx = 0; idx < stops.length; idx++) {\n            result.push(gradient_stop[\"a\" /* default */].create(stops[idx]));\n        }\n\n        return result;\n    }\n\n    addStop(offset, color, opacity) {\n        this.stops.push(new gradient_stop[\"a\" /* default */](offset, color, opacity));\n    }\n\n    removeStop(stop) {\n        const index = this.stops.indexOf(stop);\n        if (index >= 0) {\n            this.stops.splice(index, 1);\n        }\n    }\n\n    optionsChange(e) {\n        this.trigger(\"optionsChange\", {\n            field: \"gradient\" + (e ? \".\" + e.field : \"\"),\n            value: this\n        });\n    }\n\n    geometryChange() {\n        this.optionsChange();\n    }\n}\n\n/* harmony default export */ var gradient = __webpack_exports__[\"a\"] = (gradient_Gradient);\n\n\n/***/ }),\n\n/***/ \"4U2A\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _gradient_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"7PhV\");\n\n\nclass LinearGradientNode extends _gradient_node__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"] {\n    template() {\n        return `<linearGradient id='${ this.id }' ${ this.renderCoordinates() }>${ this.renderChildren() }</linearGradient>`;\n    }\n\n    mapCoordinates() {\n        const srcElement = this.srcElement;\n        const start = srcElement.start();\n        const end = srcElement.end();\n        const attrs = [\n            [ \"x1\", start.x ],\n            [ \"y1\", start.y ],\n            [ \"x2\", end.x ],\n            [ \"y2\", end.y ],\n            this.mapSpace()\n        ];\n\n        return attrs;\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (LinearGradientNode);\n\n/***/ }),\n\n/***/ \"4rzP\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return lineIntersectionsCount; });\nfunction lineIntersectionsCount(a, b, point) {\n    let intersects;\n    if (a.x !== b.x) {\n        const minX = Math.min(a.x, b.x);\n        const maxX = Math.max(a.x, b.x);\n        const minY = Math.min(a.y, b.y);\n        const maxY = Math.max(a.y, b.y);\n        const inRange = minX <= point.x && point.x < maxX;\n\n        if (minY === maxY) {\n            intersects = point.y <= minY && inRange;\n        } else {\n            intersects = inRange && (((maxY - minY) * ((a.x - b.x) * (a.y - b.y) > 0 ? point.x - minX : maxX - point.x)) / (maxX - minX) + minY - point.y) >= 0;\n        }\n    }\n\n    return intersects ? 1 : 0;\n}\n\n/***/ }),\n\n/***/ \"5FN0\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _quad_root__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"2smt\");\n/* harmony import */ var _quad_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"R/Fs\");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"XJRY\");\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"LHUb\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"i9ZU\");\n\n\n\n\n\n\nconst ROOT_SIZE = 3000;\nconst LEVEL_STEP = 10000;\nconst MAX_LEVEL = 75;\n\nclass ShapesQuadTree extends _common__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"] {\n\n    constructor() {\n        super();\n\n        this.initRoots();\n    }\n\n    initRoots() {\n        this.rootMap = {};\n        this.root = new _quad_root__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"]();\n        this.rootElements = [];\n    }\n\n    clear() {\n        const rootElements = this.rootElements;\n        for (let idx = 0; idx < rootElements.length; idx++) {\n            this.remove(rootElements[idx]);\n        }\n        this.initRoots();\n    }\n\n    pointShape(point) {\n        const sectorRoot = ( this.rootMap[ Math.floor( point.x / ROOT_SIZE ) ] || {} )[ Math.floor( point.y / ROOT_SIZE ) ];\n        let result = this.root.pointShapes(point);\n\n        if (sectorRoot) {\n            result = result.concat(sectorRoot.pointShapes(point));\n        }\n\n        this.assignZindex(result);\n\n        result.sort(zIndexComparer);\n        for (let idx = 0; idx < result.length; idx++) {\n            if (result[idx].containsPoint(point)) {\n                return result[idx];\n            }\n        }\n    }\n\n    assignZindex(elements) {\n        for (let idx = 0; idx < elements.length; idx++) {\n            let element = elements[idx];\n            let zIndex = 0;\n            let levelWeight = Math.pow(LEVEL_STEP, MAX_LEVEL);\n            let parents = [];\n\n            while (element) {\n                parents.push(element);\n                element = element.parent;\n            }\n\n            while (parents.length) {\n                element = parents.pop();\n                zIndex += ((element.parent ? element.parent.children : this.rootElements).indexOf(element) + 1) * levelWeight;\n                levelWeight /= LEVEL_STEP;\n            }\n\n            elements[idx]._zIndex = zIndex;\n        }\n    }\n\n    optionsChange(e) {\n        if (e.field === \"transform\" || e.field === \"stroke.width\") {\n            this.bboxChange(e.element);\n        }\n    }\n\n    geometryChange(e) {\n        this.bboxChange(e.element);\n    }\n\n    bboxChange(element) {\n        if (element.nodeType === \"Group\") {\n            for (let idx = 0; idx < element.children.length; idx++) {\n                this.bboxChange(element.children[idx]);\n            }\n        } else {\n            if (element._quadNode) {\n                element._quadNode.remove(element);\n            }\n            this._insertShape(element);\n        }\n    }\n\n    add(elements) {\n        const elementsArray = Array.isArray(elements) ? elements.slice(0) : [ elements ];\n\n        Object(_util__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"])(this.rootElements, elementsArray);\n        this._insert(elementsArray);\n    }\n\n    childrenChange(e) {\n        if (e.action === \"remove\") {\n            for (let idx = 0; idx < e.items.length; idx++) {\n                this.remove(e.items[idx]);\n            }\n        } else {\n            this._insert(Array.prototype.slice.call(e.items, 0));\n        }\n    }\n\n    _insert(elements) {\n        let element;\n\n        while (elements.length > 0) {\n            element = elements.pop();\n            element.addObserver(this);\n            if (element.nodeType === \"Group\") {\n                Object(_util__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"])(elements, element.children);\n            } else {\n                this._insertShape(element);\n            }\n        }\n    }\n\n    _insertShape(shape) {\n        const bbox = shape.bbox();\n        if (bbox) {\n            const sectors = this.getSectors(bbox);\n            const x = sectors[0][0];\n            const y = sectors[1][0];\n\n            if (this.inRoot(sectors)) {\n                this.root.insert(shape, bbox);\n            } else {\n                const rootMap = this.rootMap;\n                if (!rootMap[x]) {\n                    rootMap[x] = {};\n                }\n\n                if (!rootMap[x][y]) {\n                    rootMap[x][y] = new _quad_node__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"](\n                        new _geometry__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"]([ x * ROOT_SIZE, y * ROOT_SIZE ], [ ROOT_SIZE, ROOT_SIZE ])\n                    );\n                }\n\n                rootMap[x][y].insert(shape, bbox);\n            }\n        }\n    }\n\n    remove(element) {\n        element.removeObserver(this);\n\n        if (element.nodeType === \"Group\") {\n            const children = element.children;\n            for (let idx = 0; idx < children.length; idx++) {\n                this.remove(children[idx]);\n            }\n        } else if (element._quadNode) {\n            element._quadNode.remove(element);\n            delete element._quadNode;\n        }\n    }\n\n    inRoot(sectors) {\n        return sectors[0].length > 1 || sectors[1].length > 1;\n    }\n\n    getSectors(rect) {\n        const bottomRight = rect.bottomRight();\n        const bottomX = Math.floor(bottomRight.x / ROOT_SIZE);\n        const bottomY = Math.floor(bottomRight.y / ROOT_SIZE);\n        const sectors = [ [], [] ];\n        for (let x = Math.floor(rect.origin.x / ROOT_SIZE); x <= bottomX; x++) {\n            sectors[0].push(x);\n        }\n        for (let y = Math.floor(rect.origin.y / ROOT_SIZE); y <= bottomY; y++) {\n            sectors[1].push(y);\n        }\n        return sectors;\n    }\n}\n\nfunction zIndexComparer(x1, x2) {\n    if (x1._zIndex < x2._zIndex) {\n        return 1;\n    }\n    if (x1._zIndex > x2._zIndex) {\n        return -1;\n    }\n\n    return 0;\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ShapesQuadTree);\n\n/***/ }),\n\n/***/ \"5HPa\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _path_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"UzJa\");\n/* harmony import */ var _utils_render_path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"hype\");\n\n\n\nclass MultiPathNode extends _path_node__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"] {\n    renderPoints(ctx) {\n        const paths = this.srcElement.paths;\n        for (let i = 0; i < paths.length; i++) {\n            Object(_utils_render_path__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(ctx, paths[i]);\n        }\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (MultiPathNode);\n\n\n/***/ }),\n\n/***/ \"5Jba\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return alignStart; });\n\nfunction alignStart(size, rect, align, axis, sizeField) {\n    let start;\n    if (align === \"start\") {\n        start = rect.origin[axis];\n    } else if (align === \"end\") {\n        start = rect.origin[axis] + rect.size[sizeField] - size;\n    } else {\n        start = rect.origin[axis] + (rect.size[sizeField] - size) / 2;\n    }\n\n    return start;\n}\n\n/***/ }),\n\n/***/ \"63qr\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/core/has-observers.js\nvar has_observers = __webpack_require__(\"7joe\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/rect.js\nvar geometry_rect = __webpack_require__(\"XJRY\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/point.js\nvar geometry_point = __webpack_require__(\"lRJa\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/transform.js\nvar transform = __webpack_require__(\"uBxF\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/deg.js\nvar deg = __webpack_require__(\"9rnm\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/constants.js\nvar constants = __webpack_require__(\"2Ic7\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/math/is-out-of-end-point.js\n\n\n\nfunction isOutOfEndPoint(endPoint, controlPoint, point) {\n    const angle = Object(deg[\"a\" /* default */])(Math.atan2(controlPoint.y - endPoint.y, controlPoint.x - endPoint.x));\n    const rotatedPoint = point.transformCopy(Object(transform[\"a\" /* default */])().rotate(-angle, endPoint));\n\n    return rotatedPoint.x < endPoint.x;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/math/calculate-curve-at.js\nfunction calculateCurveAt(t, field, points) {\n    const t1 = 1 - t;\n    return Math.pow(t1, 3) * points[0][field] +\n        3 * Math.pow(t1, 2) * t * points[1][field] +\n        3 * Math.pow(t, 2) * t1 * points[2][field] +\n        Math.pow(t, 3) * points[3][field];\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/math/to-cubic-polynomial.js\nfunction toCubicPolynomial(points, field) {\n    return [ -points[0][field] + 3 * points[1][field] - 3 * points[2][field] + points[3][field],\n        3 * (points[0][field] - 2 * points[1][field] + points[2][field]),\n        3 * (-points[0][field] + points[1][field]),\n        points[0][field]\n    ];\n}\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/constants.js\nvar geometry_constants = __webpack_require__(\"TD7o\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/common/class.js\nvar common_class = __webpack_require__(\"LHUb\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/round.js\nvar round = __webpack_require__(\"RlWg\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/math/complex-number.js\n\n\n\n\nclass complex_number_ComplexNumber extends common_class[\"a\" /* default */] {\n\n    constructor(real = 0, img = 0) {\n        super();\n\n        this.real = real;\n        this.img = img;\n    }\n\n    add(cNumber) {\n        return new complex_number_ComplexNumber(Object(round[\"a\" /* default */])(this.real + cNumber.real, geometry_constants[\"a\" /* PRECISION */]), Object(round[\"a\" /* default */])(this.img + cNumber.img, geometry_constants[\"a\" /* PRECISION */]));\n    }\n\n    addConstant(value) {\n        return new complex_number_ComplexNumber(this.real + value, this.img);\n    }\n\n    negate() {\n        return new complex_number_ComplexNumber(-this.real, -this.img);\n    }\n\n    multiply(cNumber) {\n        return new complex_number_ComplexNumber(this.real * cNumber.real - this.img * cNumber.img,\n            this.real * cNumber.img + this.img * cNumber.real);\n    }\n\n    multiplyConstant(value) {\n        return new complex_number_ComplexNumber(this.real * value, this.img * value);\n    }\n\n    nthRoot(n) {\n        const rad = Math.atan2(this.img, this.real);\n        const r = Math.sqrt(Math.pow(this.img, 2) + Math.pow(this.real, 2));\n        const nthR = Math.pow(r, 1 / n);\n\n        return new complex_number_ComplexNumber(nthR * Math.cos(rad / n), nthR * Math.sin(rad / n)); //Moivre's formula\n    }\n\n    equals(cNumber) {\n        return this.real === cNumber.real && this.img === cNumber.img;\n    }\n\n    isReal() {\n        return this.img === 0;\n    }\n}\n\n/* harmony default export */ var complex_number = (complex_number_ComplexNumber);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/math/solve-cubic-equation.js\n\n\n\n\nfunction numberSign(x) {\n    return x < 0 ? -1 : 1;\n}\n\nfunction solveQuadraticEquation(a, b, c) {\n    const squareRoot = Math.sqrt(Math.pow(b, 2) - 4 * a * c);\n    return [\n        (-b + squareRoot) / (2 * a),\n        (-b - squareRoot) / (2 * a)\n    ];\n}\n\n//Cardano's formula\nfunction solveCubicEquation(a, b, c, d) {\n    if (a === 0) {\n        return solveQuadraticEquation(b, c, d);\n    }\n\n    const p = (3 * a * c - Math.pow(b, 2)) / (3 * Math.pow(a, 2));\n    const q = (2 * Math.pow(b, 3) - 9 * a * b * c + 27 * Math.pow(a, 2) * d) / (27 * Math.pow(a, 3));\n    const Q = Math.pow(p / 3, 3) + Math.pow(q / 2, 2);\n    const i = new complex_number(0,1);\n    const b3a = -b / (3 * a);\n    let x1, x2, y1, y2, y3, z1, z2;\n\n    if (Q < 0) {\n        x1 = new complex_number(-q / 2, Math.sqrt(-Q)).nthRoot(3);\n        x2 = new complex_number(-q / 2, - Math.sqrt(-Q)).nthRoot(3);\n    } else {\n        x1 = -q / 2 + Math.sqrt(Q);\n        x1 = new complex_number(numberSign(x1) * Math.pow(Math.abs(x1), 1 / 3));\n        x2 = -q / 2 - Math.sqrt(Q);\n        x2 = new complex_number(numberSign(x2) * Math.pow(Math.abs(x2), 1 / 3));\n    }\n\n    y1 = x1.add(x2);\n\n    z1 = x1.add(x2).multiplyConstant(-1 / 2);\n    z2 = x1.add(x2.negate()).multiplyConstant(Math.sqrt(3) / 2);\n\n    y2 = z1.add(i.multiply(z2));\n    y3 = z1.add(i.negate().multiply(z2));\n\n    const result = [];\n\n    if (y1.isReal()) {\n        result.push(Object(round[\"a\" /* default */])(y1.real + b3a, geometry_constants[\"a\" /* PRECISION */]));\n    }\n    if (y2.isReal()) {\n        result.push(Object(round[\"a\" /* default */])(y2.real + b3a, geometry_constants[\"a\" /* PRECISION */]));\n    }\n    if (y3.isReal()) {\n        result.push(Object(round[\"a\" /* default */])(y3.real + b3a, geometry_constants[\"a\" /* PRECISION */]));\n    }\n\n    return result;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/math/has-roots-in-range.js\n\n\n\n\nfunction hasRootsInRange(points, point, field, rootField, range) {\n    const polynomial = toCubicPolynomial(points, rootField);\n    const roots = solveCubicEquation(polynomial[0], polynomial[1], polynomial[2], polynomial[3] - point[rootField]);\n    let intersection;\n\n    for (let idx = 0; idx < roots.length; idx++) {\n        if (0 <= roots[idx] && roots[idx] <= 1) {\n            intersection = calculateCurveAt(roots[idx], field, points);\n            if (Math.abs(intersection - point[field]) <= range) {\n                return true;\n            }\n        }\n    }\n}\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/math/close.js\nvar math_close = __webpack_require__(\"f4aR\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/math/curve-intersections-count.js\n\n\n\n\n\nfunction curveIntersectionsCount(points, point, bbox) {\n    const polynomial = toCubicPolynomial(points, \"x\");\n    const roots = solveCubicEquation(polynomial[0], polynomial[1], polynomial[2], polynomial[3] - point.x);\n    let rayIntersection, intersectsRay;\n    let count = 0;\n    for (let i = 0; i < roots.length; i++) {\n        rayIntersection = calculateCurveAt(roots[i], \"y\", points);\n        intersectsRay = Object(math_close[\"a\" /* default */])(rayIntersection, point.y) || rayIntersection > point.y;\n        if (intersectsRay && (((roots[i] === 0 || roots[i] === 1) && bbox.bottomRight().x > point.x) || (0 < roots[i] && roots[i] < 1))) {\n            count++;\n        }\n    }\n\n    return count;\n}\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/math/line-intersections-count.js\nvar line_intersections_count = __webpack_require__(\"4rzP\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/mixins/with-points.js\nvar with_points = __webpack_require__(\"zZ53\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/segment.js\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst segment_points = [ \"anchor\", \"controlIn\", \"controlOut\" ];\n\nclass segment_Segment extends Object(with_points[\"a\" /* default */])(has_observers[\"a\" /* default */], segment_points) {\n    constructor(anchor, controlIn, controlOut) {\n        super();\n\n        this.anchor(anchor || new geometry_point[\"a\" /* default */]());\n        this.controlIn(controlIn);\n        this.controlOut(controlOut);\n    }\n\n    bboxTo(toSegment, matrix) {\n        const segmentAnchor = this.anchor().transformCopy(matrix);\n        const toSegmentAnchor = toSegment.anchor().transformCopy(matrix);\n        let rect;\n\n        if (this.controlOut() && toSegment.controlIn()) {\n            rect = this._curveBoundingBox(\n                segmentAnchor, this.controlOut().transformCopy(matrix),\n                toSegment.controlIn().transformCopy(matrix), toSegmentAnchor\n            );\n        } else {\n            rect = this._lineBoundingBox(segmentAnchor, toSegmentAnchor);\n        }\n\n        return rect;\n    }\n\n    _lineBoundingBox(p1, p2) {\n        return geometry_rect[\"a\" /* default */].fromPoints(p1, p2);\n    }\n\n    _curveBoundingBox(p1, cp1, cp2, p2) {\n        const points = [ p1, cp1, cp2, p2 ];\n        const extremesX = this._curveExtremesFor(points, \"x\");\n        const extremesY = this._curveExtremesFor(points, \"y\");\n        const xLimits = arrayLimits([ extremesX.min, extremesX.max, p1.x, p2.x ]);\n        const yLimits = arrayLimits([ extremesY.min, extremesY.max, p1.y, p2.y ]);\n\n        return geometry_rect[\"a\" /* default */].fromPoints(new geometry_point[\"a\" /* default */](xLimits.min, yLimits.min), new geometry_point[\"a\" /* default */](xLimits.max, yLimits.max));\n    }\n\n    _curveExtremesFor(points, field) {\n        const extremes = this._curveExtremes(\n            points[0][field], points[1][field],\n            points[2][field], points[3][field]\n        );\n\n        return {\n            min: calculateCurveAt(extremes.min, field, points),\n            max: calculateCurveAt(extremes.max, field, points)\n        };\n    }\n\n    _curveExtremes(x1, x2, x3, x4) {\n        const a = x1 - 3 * x2 + 3 * x3 - x4;\n        const b = - 2 * (x1 - 2 * x2 + x3);\n        const c = x1 - x2;\n        const sqrt = Math.sqrt(b * b - 4 * a * c);\n        let t1 = 0;\n        let t2 = 1;\n\n        if (a === 0) {\n            if (b !== 0) {\n                t1 = t2 = -c / b;\n            }\n        } else if (!isNaN(sqrt)) {\n            t1 = (- b + sqrt) / (2 * a);\n            t2 = (- b - sqrt) / (2 * a);\n        }\n\n        let min = Math.max(Math.min(t1, t2), 0);\n        if (min < 0 || min > 1) {\n            min = 0;\n        }\n\n        let max = Math.min(Math.max(t1, t2), 1);\n        if (max > 1 || max < 0) {\n            max = 1;\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    }\n\n    _intersectionsTo(segment, point) {\n        let intersectionsCount;\n        if (this.controlOut() && segment.controlIn()) {\n            intersectionsCount = curveIntersectionsCount([ this.anchor(), this.controlOut(), segment.controlIn(), segment.anchor() ], point, this.bboxTo(segment));\n        } else {\n            intersectionsCount = Object(line_intersections_count[\"a\" /* default */])(this.anchor(), segment.anchor(), point);\n        }\n        return intersectionsCount;\n    }\n\n    _isOnCurveTo(segment, point, width, endSegment) {\n        const bbox = this.bboxTo(segment).expand(width, width);\n        if (bbox.containsPoint(point)) {\n            const p1 = this.anchor();\n            const p2 = this.controlOut();\n            const p3 = segment.controlIn();\n            const p4 = segment.anchor();\n\n            if (endSegment === \"start\" && p1.distanceTo(point) <= width) {\n                return !isOutOfEndPoint(p1, p2, point);\n            } else if (endSegment === \"end\" && p4.distanceTo(point) <= width) {\n                return !isOutOfEndPoint(p4, p3, point);\n            }\n\n            //the approach is not entirely correct but is close and the alternatives are solving a 6th degree polynomial or testing the segment points\n            const points = [ p1, p2, p3, p4 ];\n            if (hasRootsInRange(points, point, \"x\", \"y\", width) || hasRootsInRange(points, point, \"y\", \"x\", width)) {\n                return true;\n            }\n            const rotation = Object(transform[\"a\" /* default */])().rotate(45, point);\n            const rotatedPoints = [ p1.transformCopy(rotation), p2.transformCopy(rotation), p3.transformCopy(rotation), p4.transformCopy(rotation) ];\n            return hasRootsInRange(rotatedPoints, point, \"x\", \"y\", width) || hasRootsInRange(rotatedPoints, point, \"y\", \"x\", width);\n        }\n    }\n\n    _isOnLineTo(segment, point, width) {\n        const p1 = this.anchor();\n        const p2 = segment.anchor();\n        const angle = Object(deg[\"a\" /* default */])(Math.atan2(p2.y - p1.y, p2.x - p1.x));\n        const rect = new geometry_rect[\"a\" /* default */]([ p1.x, p1.y - width / 2 ], [ p1.distanceTo(p2), width ]);\n        return rect.containsPoint(point.transformCopy(Object(transform[\"a\" /* default */])().rotate(-angle, p1)));\n    }\n\n    _isOnPathTo(segment, point, width, endSegment) {\n        let isOnPath;\n        if (this.controlOut() && segment.controlIn()) {\n            isOnPath = this._isOnCurveTo(segment, point, width / 2, endSegment);\n        } else {\n            isOnPath = this._isOnLineTo(segment, point, width);\n        }\n        return isOnPath;\n    }\n}\n\nfunction arrayLimits(arr) {\n    let length = arr.length;\n    let min = constants[\"b\" /* MAX_NUM */];\n    let max = constants[\"c\" /* MIN_NUM */];\n\n    for (let i = 0; i < length; i ++) {\n        max = Math.max(max, arr[i]);\n        min = Math.min(min, arr[i]);\n    }\n\n    return {\n        min: min,\n        max: max\n    };\n}\n\n/* harmony default export */ var geometry_segment = __webpack_exports__[\"a\"] = (segment_Segment);\n\n\n/***/ }),\n\n/***/ \"6BXq\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return throttle; });\n/* harmony import */ var _util_now__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"hSuW\");\n\n\nfunction throttle(fn, delay) {\n    let lastExecTime = 0;\n    let timeout;\n\n    if (!delay || delay <= 0) {\n        return fn;\n    }\n\n    const throttled = function() {\n        const elapsed = Object(_util_now__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])() - lastExecTime;\n        const args = arguments;\n\n        const exec = function() {\n            fn.apply(null, args);\n            lastExecTime = Object(_util_now__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])();\n        };\n\n        // first execution\n        if (!lastExecTime) {\n            return exec();\n        }\n\n        if (timeout) {\n            clearTimeout(timeout);\n        }\n\n        if (elapsed > delay) {\n            exec();\n        } else {\n            timeout = setTimeout(exec, delay - elapsed);\n        }\n    };\n\n    throttled.cancel = function() {\n        clearTimeout(timeout);\n    };\n\n    return throttled;\n}\n\n\n/***/ }),\n\n/***/ \"6USk\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return rad; });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"2Ic7\");\n\n\nfunction rad(degrees) {\n    return degrees * _constants__WEBPACK_IMPORTED_MODULE_0__[/* DEG_TO_RAD */ \"a\"];\n}\n\n\n/***/ }),\n\n/***/ \"7Jhm\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _mixins_with_points__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"zZ53\");\n/* harmony import */ var _geometry_point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"lRJa\");\n/* harmony import */ var _gradient__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"4DQW\");\n\n\n\n\n\nconst points = [ \"start\", \"end\" ];\n\nclass LinearGradient extends Object(_mixins_with_points__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(_gradient__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"], points) {\n    constructor(options = {}) {\n        super(options);\n\n        this.start(options.start || new _geometry_point__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"]());\n        this.end(options.end || new _geometry_point__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"](1, 0));\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (LinearGradient);\n\n\n/***/ }),\n\n/***/ \"7PhV\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _gradient_stop_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"Fs4b\");\n/* harmony import */ var _core_base_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"ztN+\");\n/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"7Prh\");\n/* harmony import */ var _utils_render_all_attributes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"YDM/\");\n\n\n\n\n\nclass GradientNode extends _node__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"] {\n    constructor(srcElement) {\n        super(srcElement);\n\n        this.id = srcElement.id;\n\n        this.loadStops();\n    }\n\n    loadStops() {\n        const stops = this.srcElement.stops;\n        const element = this.element;\n\n        for (let idx = 0; idx < stops.length; idx++) {\n            let stopNode = new _gradient_stop_node__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"](stops[idx]);\n            this.append(stopNode);\n            if (element) {\n                stopNode.attachTo(element);\n            }\n        }\n    }\n\n    optionsChange(e) {\n        if (e.field === \"gradient.stops\") {\n            _core_base_node__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"].prototype.clear.call(this);\n            this.loadStops();\n        } else if (e.field === \"gradient\") {\n            this.allAttr(this.mapCoordinates());\n        }\n    }\n\n    renderCoordinates() {\n        return Object(_utils_render_all_attributes__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(this.mapCoordinates());\n    }\n\n    mapSpace() {\n        return [ \"gradientUnits\", this.srcElement.userSpace() ? \"userSpaceOnUse\" : \"objectBoundingBox\" ];\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (GradientNode);\n\n/***/ }),\n\n/***/ \"7Prh\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _core_base_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"ztN+\");\n/* harmony import */ var _utils_render_all_attributes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"YDM/\");\n/* harmony import */ var _utils_render_attribute__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"08A6\");\n/* harmony import */ var _utils_render_style__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"8tN3\");\n/* harmony import */ var _node_map__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"uNz1\");\n/* harmony import */ var _utils_render_svg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"tZVE\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(\"V34t\");\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(\"/EQf\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(\"VqL+\");\n\n\n\n\n\n\n\n\n\n\nconst TRANSFORM = \"transform\";\nconst DefinitionMap = {\n    clip: \"clip-path\",\n    fill: \"fill\"\n};\n\nfunction isDefinition(type, value) {\n    return type === \"clip\" || (type === \"fill\" && (!value || value.nodeType === \"Gradient\"));\n}\n\nfunction baseUrl() {\n    const base = document.getElementsByTagName(\"base\")[0];\n    let href = document.location.href;\n    let url = \"\";\n\n    if (base && !(_common__WEBPACK_IMPORTED_MODULE_7__[/* default */ \"a\"].browser || {}).msie) {\n        const hashIndex = href.indexOf(\"#\");\n        if (hashIndex !== -1) {\n            href = href.substring(0, hashIndex);\n        }\n\n        url = href;\n    }\n\n    return url;\n}\n\nclass Node extends _core_base_node__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"] {\n\n    constructor(srcElement, options) {\n        super(srcElement);\n        this.definitions = {};\n\n        this.options = options;\n    }\n\n    destroy() {\n        if (this.element) {\n            this.element._kendoNode = null;\n            this.element = null;\n        }\n\n        this.clearDefinitions();\n        super.destroy();\n    }\n\n    load(elements, pos) {\n        for (let i = 0; i < elements.length; i++) {\n            const srcElement = elements[i];\n            const children = srcElement.children;\n\n            const childNode = new _node_map__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"][srcElement.nodeType](srcElement, this.options);\n\n            if (Object(_util__WEBPACK_IMPORTED_MODULE_8__[/* default */ \"a\"])(pos)) {\n                this.insertAt(childNode, pos);\n            } else {\n                this.append(childNode);\n            }\n\n            childNode.createDefinitions();\n\n            if (children && children.length > 0) {\n                childNode.load(children);\n            }\n\n            const element = this.element;\n            if (element) {\n                childNode.attachTo(element, pos);\n            }\n        }\n    }\n\n    root() {\n        let root = this;\n\n        while (root.parent) {\n            root = root.parent;\n        }\n\n        return root;\n    }\n\n    attachTo(domElement, pos) {\n        const container = document.createElement(\"div\");\n        Object(_utils_render_svg__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"])(container,\n            \"<svg xmlns='\" + _constants__WEBPACK_IMPORTED_MODULE_6__[/* SVG_NS */ \"b\"] + \"' version='1.1'>\" +\n                this.render() +\n            \"</svg>\"\n        );\n\n        const element = container.firstChild.firstChild;\n        if (element) {\n            if (Object(_util__WEBPACK_IMPORTED_MODULE_8__[/* default */ \"a\"])(pos)) {\n                domElement.insertBefore(element, domElement.childNodes[pos] || null);\n            } else {\n                domElement.appendChild(element);\n            }\n            this.setElement(element);\n        }\n    }\n\n    setElement(element) {\n        if (this.element) {\n            this.element._kendoNode = null;\n        }\n\n        this.element = element;\n        this.element._kendoNode = this;\n\n        const nodes = this.childNodes;\n        for (let i = 0; i < nodes.length; i++) {\n            let childElement = element.childNodes[i];\n            nodes[i].setElement(childElement);\n        }\n    }\n\n    clear() {\n        this.clearDefinitions();\n\n        if (this.element) {\n            this.element.innerHTML = \"\";\n        }\n\n        const children = this.childNodes;\n        for (let i = 0; i < children.length; i++) {\n            children[i].destroy();\n        }\n\n        this.childNodes = [];\n    }\n\n    removeSelf() {\n        if (this.element) {\n            const parentNode = this.element.parentNode;\n            if (parentNode) {\n                parentNode.removeChild(this.element);\n            }\n            this.element = null;\n        }\n\n        super.removeSelf();\n    }\n\n    template() {\n        return this.renderChildren();\n    }\n\n    render() {\n        return this.template();\n    }\n\n    renderChildren() {\n        const nodes = this.childNodes;\n        let output = \"\";\n\n        for (let i = 0; i < nodes.length; i++) {\n            output += nodes[i].render();\n        }\n\n        return output;\n    }\n\n    optionsChange(e) {\n        const { field, value } = e;\n\n        if (field === \"visible\") {\n            this.css(\"display\", value ? \"\" : _constants__WEBPACK_IMPORTED_MODULE_6__[/* NONE */ \"a\"]);\n        } else if (DefinitionMap[field] && isDefinition(field, value)) {\n            this.updateDefinition(field, value);\n        } else if (field === \"opacity\") {\n            this.attr(\"opacity\", value);\n        } else if (field === \"cursor\") {\n            this.css(\"cursor\", value);\n        } else if (field === \"id\") {\n            if (value) {\n                this.attr(\"id\", value);\n            } else {\n                this.removeAttr(\"id\");\n            }\n        }\n\n        super.optionsChange(e);\n    }\n\n    attr(name, value) {\n        if (this.element) {\n            this.element.setAttribute(name, value);\n        }\n    }\n\n    allAttr(attrs) {\n        for (let i = 0; i < attrs.length; i++) {\n            this.attr(attrs[i][0], attrs[i][1]);\n        }\n    }\n\n    css(name, value) {\n        if (this.element) {\n            this.element.style[name] = value;\n        }\n    }\n\n    allCss(styles) {\n        for (let i = 0; i < styles.length; i++) {\n            this.css(styles[i][0], styles[i][1]);\n        }\n    }\n\n    removeAttr(name) {\n        if (this.element) {\n            this.element.removeAttribute(name);\n        }\n    }\n\n    mapTransform(transform) {\n        const attrs = [];\n        if (transform) {\n            attrs.push([\n                TRANSFORM,\n                \"matrix(\" + transform.matrix().toString(6) + \")\"\n            ]);\n        }\n\n        return attrs;\n    }\n\n    renderTransform() {\n        return Object(_utils_render_all_attributes__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(\n            this.mapTransform(this.srcElement.transform())\n        );\n    }\n\n    transformChange(value) {\n        if (value) {\n            this.allAttr(this.mapTransform(value));\n        } else {\n            this.removeAttr(TRANSFORM);\n        }\n    }\n\n    mapStyle() {\n        const options = this.srcElement.options;\n        const style = [ [ \"cursor\", options.cursor ] ];\n\n        if (options.visible === false) {\n            style.push([ \"display\", _constants__WEBPACK_IMPORTED_MODULE_6__[/* NONE */ \"a\"] ]);\n        }\n\n        return style;\n    }\n\n    renderStyle() {\n        return Object(_utils_render_attribute__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"])(\"style\", Object(_utils_render_style__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(this.mapStyle(true)));\n    }\n\n    renderOpacity() {\n        return Object(_utils_render_attribute__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"])(\"opacity\", this.srcElement.options.opacity);\n    }\n\n    renderId() {\n        return Object(_utils_render_attribute__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"])(\"id\", this.srcElement.options.id);\n    }\n\n    createDefinitions() {\n        const srcElement = this.srcElement;\n        const definitions = this.definitions;\n        if (srcElement) {\n            const options = srcElement.options;\n            let hasDefinitions;\n\n            for (let field in DefinitionMap) {\n                let definition = options.get(field);\n                if (definition && isDefinition(field, definition)) {\n                    definitions[field] = definition;\n                    hasDefinitions = true;\n                }\n            }\n            if (hasDefinitions) {\n                this.definitionChange({\n                    action: \"add\",\n                    definitions: definitions\n                });\n            }\n        }\n    }\n\n    definitionChange(e) {\n        if (this.parent) {\n            this.parent.definitionChange(e);\n        }\n    }\n\n    updateDefinition(type, value) {\n        const definitions = this.definitions;\n        const current = definitions[type];\n        const attr = DefinitionMap[type];\n        const definition = {};\n        if (current) {\n            definition[type] = current;\n            this.definitionChange({\n                action: \"remove\",\n                definitions: definition\n            });\n            delete definitions[type];\n        }\n\n        if (!value) {\n            if (current) {\n                this.removeAttr(attr);\n            }\n        } else {\n            definition[type] = value;\n            this.definitionChange({\n                action: \"add\",\n                definitions: definition\n            });\n            definitions[type] = value;\n            this.attr(attr, this.refUrl(value.id));\n        }\n    }\n\n    clearDefinitions() {\n        const definitions = this.definitions;\n\n        this.definitionChange({\n            action: \"remove\",\n            definitions: definitions\n        });\n        this.definitions = {};\n    }\n\n    renderDefinitions() {\n        return Object(_utils_render_all_attributes__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(this.mapDefinitions());\n    }\n\n    mapDefinitions() {\n        const definitions = this.definitions;\n        const attrs = [];\n\n        for (let field in definitions) {\n            attrs.push([ DefinitionMap[field], this.refUrl(definitions[field].id) ]);\n        }\n\n        return attrs;\n    }\n\n    refUrl(id) {\n        const skipBaseHref = (this.options || {}).skipBaseHref;\n        const baseHref = this.baseUrl().replace(/'/g, \"\\\\'\");\n        const base = skipBaseHref ? '' : baseHref;\n        return `url(${ base }#${ id })`;\n    }\n\n    baseUrl() {\n        return baseUrl();\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Node);\n\n\n/***/ }),\n\n/***/ \"7WKN\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _gradients_linear_gradient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"7Jhm\");\n/* harmony import */ var _gradients_radial_gradient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"yhXd\");\n/* harmony import */ var _linear_gradient_node__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"4U2A\");\n/* harmony import */ var _radial_gradient_node__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"inPS\");\n/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"7Prh\");\n/* harmony import */ var _clip_node__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"gNPy\");\n\n\n\n\n\n\n\nclass DefinitionNode extends _node__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"] {\n    constructor() {\n        super();\n        this.definitionMap = {};\n    }\n\n    attachTo(domElement) {\n        this.element = domElement;\n    }\n\n    template() {\n        return `<defs>${ this.renderChildren() }</defs>`;\n    }\n\n    definitionChange(e) {\n        const { definitions, action } = e;\n\n        if (action === \"add\") {\n            this.addDefinitions(definitions);\n        } else if (action === \"remove\") {\n            this.removeDefinitions(definitions);\n        }\n    }\n\n    createDefinition(type, item) {\n        let nodeType;\n        if (type === \"clip\") {\n            nodeType = _clip_node__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"];\n        } else if (type === \"fill\") {\n            if (item instanceof _gradients_linear_gradient__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"]) {\n                nodeType = _linear_gradient_node__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"];\n            } else if (item instanceof _gradients_radial_gradient__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"]) {\n                nodeType = _radial_gradient_node__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"];\n            }\n        }\n        return new nodeType(item);\n    }\n\n    addDefinitions(definitions) {\n        for (let field in definitions) {\n            this.addDefinition(field, definitions[field]);\n        }\n    }\n\n    addDefinition(type, srcElement) {\n        const { element, definitionMap } = this;\n        const id = srcElement.id;\n        const mapItem = definitionMap[id];\n        if (!mapItem) {\n            const node = this.createDefinition(type, srcElement);\n            definitionMap[id] = {\n                element: node,\n                count: 1\n            };\n            this.append(node);\n            if (element) {\n                node.attachTo(this.element);\n            }\n        } else {\n            mapItem.count++;\n        }\n    }\n\n    removeDefinitions(definitions) {\n        for (let field in definitions) {\n            this.removeDefinition(definitions[field]);\n        }\n    }\n\n    removeDefinition(srcElement) {\n        const definitionMap = this.definitionMap;\n        const id = srcElement.id;\n        const mapItem = definitionMap[id];\n\n        if (mapItem) {\n            mapItem.count--;\n            if (mapItem.count === 0) {\n                this.remove(this.childNodes.indexOf(mapItem.element), 1);\n                delete definitionMap[id];\n            }\n        }\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (DefinitionNode);\n\n/***/ }),\n\n/***/ \"7joe\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"LHUb\");\n\n\nclass HasObservers extends _common__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"] {\n    observers() {\n        this._observers = this._observers || [];\n        return this._observers;\n    }\n\n    addObserver(element) {\n        if (!this._observers) {\n            this._observers = [ element ];\n        } else {\n            this._observers.push(element);\n        }\n        return this;\n    }\n\n    removeObserver(element) {\n        const observers = this.observers();\n        const index = observers.indexOf(element);\n        if (index !== -1) {\n            observers.splice(index, 1);\n        }\n        return this;\n    }\n\n    trigger(methodName, event) {\n        const observers = this._observers;\n\n        if (observers && !this._suspended) {\n            for (let idx = 0; idx < observers.length; idx++) {\n                let observer = observers[idx];\n                if (observer[methodName]) {\n                    observer[methodName](event);\n                }\n            }\n        }\n        return this;\n    }\n\n    optionsChange(e = {}) {\n        e.element = this;\n        this.trigger(\"optionsChange\", e);\n    }\n\n    geometryChange() {\n        this.trigger(\"geometryChange\", {\n            element: this\n        });\n    }\n\n    suspend() {\n        this._suspended = (this._suspended || 0) + 1;\n        return this;\n    }\n\n    resume() {\n        this._suspended = Math.max((this._suspended || 0) - 1, 0);\n        return this;\n    }\n\n    _observerField(field, value) {\n        if (this[field]) {\n            this[field].removeObserver(this);\n        }\n        this[field] = value;\n        value.addObserver(this);\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (HasObservers);\n\n\n\n/***/ }),\n\n/***/ \"8tN3\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return renderStyle; });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"VqL+\");\n\n\nfunction renderStyle(attrs) {\n    let output = \"\";\n    for (let i = 0; i < attrs.length; i++) {\n        let value = attrs[i][1];\n        if (Object(_util__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(value)) {\n            output += attrs[i][0] + \":\" + value + \";\";\n        }\n    }\n\n    if (output !== \"\") {\n        return output;\n    }\n}\n\n/***/ }),\n\n/***/ \"9rnm\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return deg; });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"2Ic7\");\n\n\nfunction deg(radians) {\n    return radians / _constants__WEBPACK_IMPORTED_MODULE_0__[/* DEG_TO_RAD */ \"a\"];\n}\n\n/***/ }),\n\n/***/ \"9uUv\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return valueOrDefault; });\n/* harmony import */ var _defined__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"VqL+\");\n\n\nfunction valueOrDefault(value, defaultValue) {\n    return Object(_defined__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(value) ? value : defaultValue;\n}\n\n/***/ }),\n\n/***/ \"APnZ\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return bindEvents; });\nfunction bindEvents(element, events) {\n    for (let eventName in events) {\n        const eventNames = eventName.trim().split(\" \");\n        for (let idx = 0; idx < eventNames.length; idx++) {\n            element.addEventListener(eventNames[idx], events[eventName], false);\n        }\n    }\n}\n\n/***/ }),\n\n/***/ \"Ah4p\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"b\", function() { return /* binding */ path_Path; });\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ path_MultiPath; });\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/shapes/elements-array.js\nvar elements_array = __webpack_require__(\"Vvtp\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/shapes/geometry-elements-array.js\n\n\nclass geometry_elements_array_GeometryElementsArray extends elements_array[\"a\" /* default */] {\n    _change() {\n        this.geometryChange();\n    }\n}\n\n/* harmony default export */ var geometry_elements_array = (geometry_elements_array_GeometryElementsArray);\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/shapes/element.js\nvar shapes_element = __webpack_require__(\"XdXH\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/mixins/paintable.js\nvar paintable = __webpack_require__(\"T3aN\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/mixins/measurable.js\nvar measurable = __webpack_require__(\"qNx/\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/arc.js + 2 modules\nvar geometry_arc = __webpack_require__(\"HKF7\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/rect.js\nvar rect = __webpack_require__(\"XJRY\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/segment.js + 7 modules\nvar geometry_segment = __webpack_require__(\"63qr\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/point.js\nvar geometry_point = __webpack_require__(\"lRJa\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/size.js\nvar size = __webpack_require__(\"ZfP6\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/math/line-intersections-count.js\nvar line_intersections_count = __webpack_require__(\"4rzP\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/defined.js\nvar defined = __webpack_require__(\"VqL+\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/last.js\nvar last = __webpack_require__(\"Eu+R\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/rad.js\nvar rad = __webpack_require__(\"6USk\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/parsing/parse-path.js + 1 modules\nvar parse_path = __webpack_require__(\"sK2o\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/shapes/utils/elements-bounding-box.js\nvar elements_bounding_box = __webpack_require__(\"x/aw\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/shapes/utils/elements-clippend-bounding-box.js\nvar elements_clippend_bounding_box = __webpack_require__(\"wbRH\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/shapes/path.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass path_Path extends Object(paintable[\"a\" /* default */])(Object(measurable[\"a\" /* default */])(shapes_element[\"a\" /* default */])) {\n    static parse(str, options) {\n        return path_MultiPath.parse(str, options);\n    }\n\n    get nodeType() {\n        return \"Path\";\n    }\n\n    constructor(options) {\n        super(options);\n        this.segments = new geometry_elements_array();\n        this.segments.addObserver(this);\n\n        if (!Object(defined[\"a\" /* default */])(this.options.stroke)) {\n            this.stroke(\"#000\");\n\n            if (!Object(defined[\"a\" /* default */])(this.options.stroke.lineJoin)) {\n                this.options.set(\"stroke.lineJoin\", \"miter\");\n            }\n        }\n    }\n\n    moveTo(x, y) {\n        this.suspend();\n        this.segments.elements([]);\n        this.resume();\n\n        this.lineTo(x, y);\n\n        return this;\n    }\n\n    lineTo(x, y) {\n        const point = Object(defined[\"a\" /* default */])(y) ? new geometry_point[\"a\" /* default */](x, y) : x;\n        const segment = new geometry_segment[\"a\" /* default */](point);\n\n        this.segments.push(segment);\n\n        return this;\n    }\n\n    curveTo(controlOut, controlIn, point) {\n        if (this.segments.length > 0) {\n            const lastSegment = Object(last[\"a\" /* default */])(this.segments);\n            const segment = new geometry_segment[\"a\" /* default */](point, controlIn);\n            this.suspend();\n            lastSegment.controlOut(controlOut);\n            this.resume();\n\n            this.segments.push(segment);\n        }\n\n        return this;\n    }\n\n    arc(startAngle, endAngle, radiusX, radiusY, anticlockwise) {\n        if (this.segments.length > 0) {\n            const lastSegment = Object(last[\"a\" /* default */])(this.segments);\n            const anchor = lastSegment.anchor();\n            const start = Object(rad[\"a\" /* default */])(startAngle);\n            const center = new geometry_point[\"a\" /* default */](anchor.x - radiusX * Math.cos(start),\n                anchor.y - radiusY * Math.sin(start));\n            const arc = new geometry_arc[\"a\" /* default */](center, {\n                startAngle: startAngle,\n                endAngle: endAngle,\n                radiusX: radiusX,\n                radiusY: radiusY,\n                anticlockwise: anticlockwise\n            });\n\n            this._addArcSegments(arc);\n        }\n\n        return this;\n    }\n\n    arcTo(end, rx, ry, largeArc, swipe, rotation) {\n        if (this.segments.length > 0) {\n            const lastSegment = Object(last[\"a\" /* default */])(this.segments);\n            const anchor = lastSegment.anchor();\n            const arc = geometry_arc[\"a\" /* default */].fromPoints(anchor, end, rx, ry, largeArc, swipe, rotation);\n\n            this._addArcSegments(arc);\n        }\n        return this;\n    }\n\n    _addArcSegments(arc) {\n        this.suspend();\n\n        const curvePoints = arc.curvePoints();\n\n        for (let i = 1; i < curvePoints.length; i += 3) {\n            this.curveTo(curvePoints[i], curvePoints[i + 1], curvePoints[i + 2]);\n        }\n\n        this.resume();\n        this.geometryChange();\n    }\n\n    close() {\n        this.options.closed = true;\n        this.geometryChange();\n\n        return this;\n    }\n\n    rawBBox() {\n        return this._bbox();\n    }\n\n    _containsPoint(point) {\n        const segments = this.segments;\n        const length = segments.length;\n        let intersectionsCount = 0;\n        let previous, current;\n\n        for (let idx = 1; idx < length; idx++) {\n            previous = segments[idx - 1];\n            current = segments[idx];\n            intersectionsCount += previous._intersectionsTo(current, point);\n        }\n\n        if (this.options.closed || !segments[0].anchor().equals(segments[length - 1].anchor())) {\n            intersectionsCount += Object(line_intersections_count[\"a\" /* default */])(segments[0].anchor(), segments[length - 1].anchor(), point);\n        }\n\n        return intersectionsCount % 2 !== 0;\n    }\n\n    _isOnPath(point, width) {\n        const segments = this.segments;\n        const length = segments.length;\n        const pathWidth = width || this.options.stroke.width;\n\n        if (length > 1) {\n            if (segments[0]._isOnPathTo(segments[1], point, pathWidth, \"start\")) {\n                return true;\n            }\n\n            for (let idx = 2; idx <= length - 2; idx++) {\n                if (segments[idx - 1]._isOnPathTo(segments[idx], point, pathWidth)) {\n                    return true;\n                }\n            }\n\n            if (segments[length - 2]._isOnPathTo(segments[length - 1], point, pathWidth, \"end\")) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    _bbox(matrix) {\n        const segments = this.segments;\n        const length = segments.length;\n        let boundingBox;\n\n        if (length === 1) {\n            let anchor = segments[0].anchor().transformCopy(matrix);\n            boundingBox = new rect[\"a\" /* default */](anchor, size[\"a\" /* default */].ZERO);\n        } else if (length > 0) {\n            for (let i = 1; i < length; i++) {\n                let segmentBox = segments[i - 1].bboxTo(segments[i], matrix);\n                if (boundingBox) {\n                    boundingBox = rect[\"a\" /* default */].union(boundingBox, segmentBox);\n                } else {\n                    boundingBox = segmentBox;\n                }\n            }\n        }\n\n        return boundingBox;\n    }\n\n    static fromRect(rect, options) {\n        return new path_Path(options)\n            .moveTo(rect.topLeft())\n            .lineTo(rect.topRight())\n            .lineTo(rect.bottomRight())\n            .lineTo(rect.bottomLeft())\n            .close();\n    }\n\n    static fromPoints(points, options) {\n        if (points) {\n            const path = new path_Path(options);\n\n            for (let i = 0; i < points.length; i++) {\n                let point = geometry_point[\"a\" /* default */].create(points[i]);\n                if (point) {\n                    if (i === 0) {\n                        path.moveTo(point);\n                    } else {\n                        path.lineTo(point);\n                    }\n                }\n            }\n\n            return path;\n        }\n    }\n\n    static fromArc(arc, options) {\n        const path = new path_Path(options);\n        const startAngle = arc.startAngle;\n        const start = arc.pointAt(startAngle);\n        path.moveTo(start.x, start.y);\n        path.arc(startAngle, arc.endAngle, arc.radiusX, arc.radiusY, arc.anticlockwise);\n        return path;\n    }\n}\n\nclass path_MultiPath extends Object(paintable[\"a\" /* default */])(Object(measurable[\"a\" /* default */])(shapes_element[\"a\" /* default */])) {\n    static parse(str, options) {\n        const instance = new path_MultiPath(options);\n        return Object(parse_path[\"a\" /* default */])(instance, str);\n    }\n\n    get nodeType() {\n        return \"MultiPath\";\n    }\n\n    constructor(options) {\n        super(options);\n        this.paths = new geometry_elements_array();\n        this.paths.addObserver(this);\n\n        if (!Object(defined[\"a\" /* default */])(this.options.stroke)) {\n            this.stroke(\"#000\");\n        }\n    }\n\n    moveTo(x, y) {\n        const path = new path_Path();\n        path.moveTo(x, y);\n\n        this.paths.push(path);\n\n        return this;\n    }\n\n    lineTo(x, y) {\n        if (this.paths.length > 0) {\n            Object(last[\"a\" /* default */])(this.paths).lineTo(x, y);\n        }\n\n        return this;\n    }\n\n    curveTo(controlOut, controlIn, point) {\n        if (this.paths.length > 0) {\n            Object(last[\"a\" /* default */])(this.paths).curveTo(controlOut, controlIn, point);\n        }\n\n        return this;\n    }\n\n    arc(startAngle, endAngle, radiusX, radiusY, anticlockwise) {\n        if (this.paths.length > 0) {\n            Object(last[\"a\" /* default */])(this.paths).arc(startAngle, endAngle, radiusX, radiusY, anticlockwise);\n        }\n\n        return this;\n    }\n\n    arcTo(end, rx, ry, largeArc, swipe, rotation) {\n        if (this.paths.length > 0) {\n            Object(last[\"a\" /* default */])(this.paths).arcTo(end, rx, ry, largeArc, swipe, rotation);\n        }\n\n        return this;\n    }\n\n    close() {\n        if (this.paths.length > 0) {\n            Object(last[\"a\" /* default */])(this.paths).close();\n        }\n\n        return this;\n    }\n\n    _bbox(matrix) {\n        return Object(elements_bounding_box[\"a\" /* default */])(this.paths, true, matrix);\n    }\n\n    rawBBox() {\n        return Object(elements_bounding_box[\"a\" /* default */])(this.paths, false);\n    }\n\n    _containsPoint(point) {\n        const paths = this.paths;\n\n        for (let idx = 0; idx < paths.length; idx++) {\n            if (paths[idx]._containsPoint(point)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    _isOnPath(point) {\n        const paths = this.paths;\n        const width = this.options.stroke.width;\n\n        for (let idx = 0; idx < paths.length; idx++) {\n            if (paths[idx]._isOnPath(point, width)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    _clippedBBox(transformation) {\n        return Object(elements_clippend_bounding_box[\"a\" /* default */])(this.paths, this.currentTransform(transformation));\n    }\n}\n\n\n\n/***/ }),\n\n/***/ \"Aie7\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return unbindEvents; });\nfunction unbindEvents(element, events = {}) {\n    for (let name in events) {\n        const eventNames = name.trim().split(\" \");\n        for (let idx = 0; idx < eventNames.length; idx++) {\n            element.removeEventListener(eventNames[idx], events[name], false);\n        }\n    }\n}\n\n/***/ }),\n\n/***/ \"BIVv\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _mixins_with_accessors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"bp4U\");\n/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"lRJa\");\n/* harmony import */ var _rect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"XJRY\");\n/* harmony import */ var _math_ellipse_extreme_angles__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"Ll3z\");\n/* harmony import */ var _core_has_observers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"7joe\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"6USk\");\n\n\n\n\n\n\n\n\nconst PI_DIV_2 = Math.PI / 2;\n\nclass Circle extends Object(_mixins_with_accessors__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(_core_has_observers__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"], [ \"radius\" ]) {\n    constructor(center = new _point__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"](), radius = 0) {\n        super();\n\n        this.setCenter(center);\n        this.setRadius(radius);\n    }\n\n    setCenter(value) {\n        this._observerField(\"center\", _point__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"].create(value));\n        this.geometryChange();\n        return this;\n    }\n\n    getCenter() {\n        return this.center;\n    }\n\n    equals(other) {\n        return other &&\n               other.center.equals(this.center) &&\n               other.radius === this.radius;\n    }\n\n    clone() {\n        return new Circle(this.center.clone(), this.radius);\n    }\n\n    pointAt(angle) {\n        return this._pointAt(Object(_util__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"])(angle));\n    }\n\n    bbox(matrix) {\n        const extremeAngles = Object(_math_ellipse_extreme_angles__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(this.center, this.radius, this.radius, matrix);\n        let minPoint = _point__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"].maxPoint();\n        let maxPoint = _point__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"].minPoint();\n\n        for (let i = 0; i < 4; i++) {\n            let currentPointX = this._pointAt(extremeAngles.x + i * PI_DIV_2).transformCopy(matrix);\n            let currentPointY = this._pointAt(extremeAngles.y + i * PI_DIV_2).transformCopy(matrix);\n            let currentPoint = new _point__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"](currentPointX.x, currentPointY.y);\n\n            minPoint = _point__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"].min(minPoint, currentPoint);\n            maxPoint = _point__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"].max(maxPoint, currentPoint);\n        }\n\n        return _rect__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"].fromPoints(minPoint, maxPoint);\n    }\n\n    _pointAt(angle) {\n        const { center, radius } = this;\n\n        return new _point__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"](\n            center.x + radius * Math.cos(angle),\n            center.y + radius * Math.sin(angle)\n        );\n    }\n\n    containsPoint(point) {\n        const { center, radius } = this;\n        const inCircle = Math.pow(point.x - center.x, 2) +\n            Math.pow(point.y - center.y, 2) <= Math.pow(radius, 2);\n        return inCircle;\n    }\n\n    _isOnPath(point, width) {\n        const { center, radius } = this;\n        const pointDistance = center.distanceTo(point);\n\n        return radius - width <= pointDistance && pointDistance <= radius + width;\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Circle);\n\n\n/***/ }),\n\n/***/ \"BK/f\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _mixins_with_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"O6F+\");\n/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"XdXH\");\n/* harmony import */ var _geometry_rect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"XJRY\");\n/* harmony import */ var _geometry_to_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"x/GK\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"VqL+\");\n\n\n\n\n\n\n\nclass Image extends Object(_mixins_with_geometry__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(_element__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"], [ \"rect\" ]) {\n    get nodeType() {\n        return \"Image\";\n    }\n\n    constructor(src, rect = new _geometry_rect__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"](), options = {}) {\n        super(options);\n\n        this.src(src);\n        this.rect(rect);\n    }\n\n    src(value) {\n        if (Object(_util__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"])(value)) {\n            this.options.set(\"src\", value);\n            return this;\n        }\n\n        return this.options.get(\"src\");\n    }\n\n    bbox(transformation) {\n        const combinedMatrix = Object(_geometry_to_matrix__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(this.currentTransform(transformation));\n        return this._rect.bbox(combinedMatrix);\n    }\n\n    rawBBox() {\n        return this._rect.bbox();\n    }\n\n    _containsPoint(point) {\n        return this._rect.containsPoint(point);\n    }\n\n    _hasFill() {\n        return this.src();\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Image);\n\n/***/ }),\n\n/***/ \"C91f\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return objectKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return hashKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return normalizeText; });\nconst REPLACE_REGEX = /\\r?\\n|\\r|\\t/g;\nconst SPACE = ' ';\n\nfunction normalizeText(text) {\n    return String(text).replace(REPLACE_REGEX, SPACE);\n}\n\nfunction objectKey(object) {\n    const parts = [];\n    for (let key in object) {\n        parts.push(key + object[key]);\n    }\n\n    return parts.sort().join(\"\");\n}\n\n// Computes FNV-1 hash\n// See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function\nfunction hashKey(str) {\n    // 32-bit FNV-1 offset basis\n    // See http://isthe.com/chongo/tech/comp/fnv/#FNV-param\n    let hash = 0x811C9DC5;\n\n    for (let i = 0; i < str.length; ++i) {\n        hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);\n        hash ^= str.charCodeAt(i);\n    }\n\n    return hash >>> 0;\n}\n\n\n\n/***/ }),\n\n/***/ \"DPs4\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return elementPadding; });\n/* harmony import */ var _element_styles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"oY8A\");\n\n\nfunction elementPadding(element) {\n    const { paddingLeft, paddingTop } = Object(_element_styles__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(element, [ \"paddingLeft\", \"paddingTop\" ]);\n    return {\n        top: parseFloat(paddingTop),\n        left: parseFloat(paddingLeft)\n    };\n}\n\n\n/***/ }),\n\n/***/ \"E7ME\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return definitionId; });\nlet defId = 1;\n\nfunction definitionId() {\n    return \"kdef\" + defId++;\n}\n\n/***/ }),\n\n/***/ \"Eu+R\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return last; });\nfunction last(array) {\n    if (array) {\n        return array[array.length - 1];\n    }\n}\n\n/***/ }),\n\n/***/ \"FRnV\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nlet animationFrameProxy = (callback) => {\n    const wnd = typeof window !== \"undefined\" ? window : {};\n    const animationFrame = wnd.requestAnimationFrame ||\n                        wnd.webkitRequestAnimationFrame ||\n                        wnd.mozRequestAnimationFrame ||\n                        wnd.oRequestAnimationFrame ||\n                        wnd.msRequestAnimationFrame ||\n                        function(callback) { setTimeout(callback, 1000 / 60); };\n\n    animationFrameProxy = callback => animationFrame.call(wnd, callback);\n    animationFrameProxy(callback);\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (animationFrameProxy);\n\n\n/***/ }),\n\n/***/ \"FSED\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _path_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"UzJa\");\n\n\nclass CircleNode extends _path_node__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"] {\n    renderPoints(ctx) {\n        const { center, radius } = this.srcElement.geometry();\n\n        ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (CircleNode);\n\n\n/***/ }),\n\n/***/ \"Fs4b\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"7Prh\");\n/* harmony import */ var _utils_render_attribute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"08A6\");\n\n\n\nclass GradientStopNode extends _node__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"] {\n    template() {\n        return `<stop ${this.renderOffset()} ${this.renderStyle()} />`;\n    }\n\n    renderOffset() {\n        return Object(_utils_render_attribute__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(\"offset\", this.srcElement.offset());\n    }\n\n    mapStyle() {\n        const srcElement = this.srcElement;\n        return [\n            [ \"stop-color\", srcElement.color() ],\n            [ \"stop-opacity\", srcElement.opacity() ]\n        ];\n    }\n\n    optionsChange(e) {\n        if (e.field === \"offset\") {\n            this.attr(e.field, e.value);\n        } else if (e.field === \"color\" || e.field === \"opacity\") {\n            this.css(\"stop-\" + e.field, e.value);\n        }\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (GradientStopNode);\n\n/***/ }),\n\n/***/ \"G/KS\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _path_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"UzJa\");\n\n\nclass TextNode extends _path_node__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"] {\n    renderTo(ctx) {\n        const text = this.srcElement;\n        const pos = text.position();\n        const size = text.measure();\n\n        ctx.save();\n\n        this.setTransform(ctx);\n        this.setClip(ctx);\n        this.setOpacity(ctx);\n\n        ctx.beginPath();\n\n        ctx.font = text.options.font;\n        ctx.textAlign = 'left';\n\n        if (this.setFill(ctx)) {\n            ctx.fillText(text.content(), pos.x, pos.y + size.baseline);\n        }\n\n        if (this.setStroke(ctx)) {\n            this.setLineDash(ctx);\n            ctx.strokeText(text.content(), pos.x, pos.y + size.baseline);\n        }\n\n        ctx.restore();\n    }\n}\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (TextNode);\n\n\n/***/ }),\n\n/***/ \"HKF7\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/core/has-observers.js\nvar has_observers = __webpack_require__(\"7joe\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/rad.js\nvar rad = __webpack_require__(\"6USk\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/deg.js\nvar deg = __webpack_require__(\"9rnm\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/round.js\nvar round = __webpack_require__(\"RlWg\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/mixins/with-accessors.js\nvar with_accessors = __webpack_require__(\"bp4U\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/math/close.js\nvar math_close = __webpack_require__(\"f4aR\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/math/close-or-less.js\n\n\nfunction closeOrLess(a, b, tolerance) {\n    return a < b || Object(math_close[\"a\" /* default */])(a, b, tolerance);\n}\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/point.js\nvar geometry_point = __webpack_require__(\"lRJa\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/math/line-intersection.js\n\n\nfunction lineIntersection(p0, p1, p2, p3) {\n    const s1x = p1.x - p0.x;\n    const s2x = p3.x - p2.x;\n    const s1y = p1.y - p0.y;\n    const s2y = p3.y - p2.y;\n    const nx = p0.x - p2.x;\n    const ny = p0.y - p2.y;\n    const d = s1x * s2y - s2x * s1y;\n    const s = (s1x * ny - s1y * nx) / d;\n    const t = (s2x * ny - s2y * nx) / d;\n\n    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {\n        return new geometry_point[\"a\" /* default */](p0.x + t * s1x, p0.y + t * s1y);\n    }\n}\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/math/ellipse-extreme-angles.js\nvar ellipse_extreme_angles = __webpack_require__(\"Ll3z\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/constants.js\nvar constants = __webpack_require__(\"TD7o\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/rect.js\nvar rect = __webpack_require__(\"XJRY\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/transform.js\nvar transform = __webpack_require__(\"uBxF\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/arc.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst MAX_INTERVAL = 45;\nconst pow = Math.pow;\nconst accessors = [ \"radiusX\", \"radiusY\", \"startAngle\", \"endAngle\", \"anticlockwise\" ];\n\nclass arc_Arc extends Object(with_accessors[\"a\" /* default */])(has_observers[\"a\" /* default */], accessors) {\n    constructor(center = new geometry_point[\"a\" /* default */](), options = {}) {\n        super();\n\n        this.setCenter(center);\n\n        this.radiusX = options.radiusX;\n        this.radiusY = options.radiusY || options.radiusX;\n        this.startAngle = options.startAngle;\n        this.endAngle = options.endAngle;\n        this.anticlockwise = options.anticlockwise || false;\n        this.xRotation = options.xRotation;\n    }\n\n    clone() {\n        return new arc_Arc(this.center, {\n            radiusX: this.radiusX,\n            radiusY: this.radiusY,\n            startAngle: this.startAngle,\n            endAngle: this.endAngle,\n            anticlockwise: this.anticlockwise\n        });\n    }\n\n    setCenter(value) {\n        this._observerField(\"center\", geometry_point[\"a\" /* default */].create(value));\n        this.geometryChange();\n        return this;\n    }\n\n    getCenter() {\n        return this.center;\n    }\n\n    pointAt(angle) {\n        const center = this.center;\n        const radian = Object(rad[\"a\" /* default */])(angle);\n\n        return new geometry_point[\"a\" /* default */](\n            center.x + this.radiusX * Math.cos(radian),\n            center.y + this.radiusY * Math.sin(radian)\n        );\n    }\n\n    curvePoints() {\n        const startAngle = this.startAngle;\n        const dir = this.anticlockwise ? -1 : 1;\n        const curvePoints = [ this.pointAt(startAngle) ];\n        const interval = this._arcInterval();\n        const intervalAngle = interval.endAngle - interval.startAngle;\n        const subIntervalsCount = Math.ceil(intervalAngle / MAX_INTERVAL);\n        const subIntervalAngle = intervalAngle / subIntervalsCount;\n        let currentAngle = startAngle;\n        let transformation;\n        if (this.xRotation) {\n            transformation = Object(transform[\"a\" /* default */])().rotate(this.xRotation, this.center);\n        }\n\n        for (let i = 1; i <= subIntervalsCount; i++) {\n            const nextAngle = currentAngle + dir * subIntervalAngle;\n            const points = this._intervalCurvePoints(currentAngle, nextAngle, transformation);\n\n            curvePoints.push(points.cp1, points.cp2, points.p2);\n            currentAngle = nextAngle;\n        }\n\n        return curvePoints;\n    }\n\n    bbox(matrix) {\n        const interval = this._arcInterval();\n        const startAngle = interval.startAngle;\n        const endAngle = interval.endAngle;\n        const extremeAngles = Object(ellipse_extreme_angles[\"a\" /* default */])(this.center, this.radiusX, this.radiusY, matrix);\n        const extremeX = Object(deg[\"a\" /* default */])(extremeAngles.x);\n        const extremeY = Object(deg[\"a\" /* default */])(extremeAngles.y);\n        const endPoint = this.pointAt(endAngle).transformCopy(matrix);\n        let currentAngleX = bboxStartAngle(extremeX, startAngle);\n        let currentAngleY = bboxStartAngle(extremeY, startAngle);\n        let currentPoint = this.pointAt(startAngle).transformCopy(matrix);\n        let minPoint = geometry_point[\"a\" /* default */].min(currentPoint, endPoint);\n        let maxPoint = geometry_point[\"a\" /* default */].max(currentPoint, endPoint);\n\n        while (currentAngleX < endAngle || currentAngleY < endAngle) {\n            let currentPointX;\n            if (currentAngleX < endAngle) {\n                currentPointX = this.pointAt(currentAngleX).transformCopy(matrix);\n                currentAngleX += 90;\n            }\n\n            let currentPointY;\n            if (currentAngleY < endAngle) {\n                currentPointY = this.pointAt(currentAngleY).transformCopy(matrix);\n                currentAngleY += 90;\n            }\n\n            currentPoint = new geometry_point[\"a\" /* default */](currentPointX.x, currentPointY.y);\n            minPoint = geometry_point[\"a\" /* default */].min(minPoint, currentPoint);\n            maxPoint = geometry_point[\"a\" /* default */].max(maxPoint, currentPoint);\n        }\n\n        return rect[\"a\" /* default */].fromPoints(minPoint, maxPoint);\n    }\n\n    _arcInterval() {\n        let { startAngle, endAngle, anticlockwise } = this;\n\n        if (anticlockwise) {\n            let oldStart = startAngle;\n            startAngle = endAngle;\n            endAngle = oldStart;\n        }\n\n        if (startAngle > endAngle || (anticlockwise && startAngle === endAngle)) {\n            endAngle += 360;\n        }\n\n        return {\n            startAngle: startAngle,\n            endAngle: endAngle\n        };\n    }\n\n    _intervalCurvePoints(startAngle, endAngle, transformation) {\n        const p1 = this.pointAt(startAngle);\n        const p2 = this.pointAt(endAngle);\n        const p1Derivative = this._derivativeAt(startAngle);\n        const p2Derivative = this._derivativeAt(endAngle);\n        const t = (Object(rad[\"a\" /* default */])(endAngle) - Object(rad[\"a\" /* default */])(startAngle)) / 3;\n        const cp1 = new geometry_point[\"a\" /* default */](p1.x + t * p1Derivative.x, p1.y + t * p1Derivative.y);\n        const cp2 = new geometry_point[\"a\" /* default */](p2.x - t * p2Derivative.x, p2.y - t * p2Derivative.y);\n        if (transformation) {\n            p1.transform(transformation);\n            p2.transform(transformation);\n            cp1.transform(transformation);\n            cp2.transform(transformation);\n        }\n\n        return {\n            p1: p1,\n            cp1: cp1,\n            cp2: cp2,\n            p2: p2\n        };\n    }\n\n    _derivativeAt(angle) {\n        const radian = Object(rad[\"a\" /* default */])(angle);\n\n        return new geometry_point[\"a\" /* default */](-this.radiusX * Math.sin(radian), this.radiusY * Math.cos(radian));\n    }\n\n    containsPoint(point) {\n        const interval = this._arcInterval();\n        const intervalAngle = interval.endAngle - interval.startAngle;\n        const { center, radiusX, radiusY } = this;\n        const distance = center.distanceTo(point);\n        const angleRad = Math.atan2(point.y - center.y, point.x - center.x);\n        const pointRadius = (radiusX * radiusY) /\n            Math.sqrt(pow(radiusX, 2) * pow(Math.sin(angleRad), 2) + pow(radiusY, 2) * pow(Math.cos(angleRad), 2));\n        const startPoint = this.pointAt(this.startAngle).round(constants[\"a\" /* PRECISION */]);\n        const endPoint = this.pointAt(this.endAngle).round(constants[\"a\" /* PRECISION */]);\n        const intersection = lineIntersection(center, point.round(constants[\"a\" /* PRECISION */]), startPoint, endPoint);\n        let containsPoint;\n\n        if (intervalAngle < 180) {\n            containsPoint = intersection && closeOrLess(center.distanceTo(intersection), distance) && closeOrLess(distance, pointRadius);\n        } else {\n            let angle = calculateAngle(center.x, center.y, radiusX, radiusY, point.x, point.y);\n            if (angle !== 360) {\n                angle = (360 + angle) % 360;\n            }\n\n            let inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;\n            containsPoint = (inAngleRange && closeOrLess(distance, pointRadius)) || (!inAngleRange && (!intersection || intersection.equals(point)));\n        }\n        return containsPoint;\n    }\n\n    _isOnPath(point, width) {\n        const interval = this._arcInterval();\n        const center = this.center;\n        let angle = calculateAngle(center.x, center.y, this.radiusX, this.radiusY, point.x, point.y);\n        if (angle !== 360) {\n            angle = (360 + angle) % 360;\n        }\n\n        const inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;\n\n        return inAngleRange && this.pointAt(angle).distanceTo(point) <= width;\n    }\n\n    static fromPoints(start, end, rx, ry, largeArc, swipe, rotation) {// eslint-disable-line max-params\n        const arcParameters = normalizeArcParameters({\n            x1: start.x,\n            y1: start.y,\n            x2: end.x,\n            y2: end.y,\n            rx: rx,\n            ry: ry,\n            largeArc: largeArc,\n            swipe: swipe,\n            rotation: rotation\n        });\n\n        return new arc_Arc(arcParameters.center, {\n            startAngle: arcParameters.startAngle,\n            endAngle: arcParameters.endAngle,\n            radiusX: arcParameters.radiusX,\n            radiusY: arcParameters.radiusY,\n            xRotation: arcParameters.xRotation,\n            anticlockwise: swipe === 0\n        });\n    }\n}\n\nfunction calculateAngle(cx, cy, rx, ry, x, y) {\n    const cos = Object(round[\"a\" /* default */])((x - cx) / rx, 3);\n    const sin = Object(round[\"a\" /* default */])((y - cy) / ry, 3);\n\n    return Object(round[\"a\" /* default */])(Object(deg[\"a\" /* default */])(Math.atan2(sin, cos)));\n}\n\nfunction normalizeArcParameters(parameters) {\n    let { x1, y1, x2, y2, rx, ry, largeArc, swipe, rotation = 0 } = parameters;\n\n    const radians = Object(rad[\"a\" /* default */])(rotation);\n    const cosine = Math.cos(radians);\n    const sine = Math.sin(radians);\n\n    const xT = cosine * (x1 - x2) / 2 + sine * (y1 - y2) / 2;\n    const yT = -sine * (x1 - x2) / 2 + cosine * (y1 - y2) / 2;\n\n    const sign = largeArc !== swipe ? 1 : -1;\n\n    const xt2 = Math.pow(xT, 2);\n    const yt2 = Math.pow(yT, 2);\n    let rx2 = Math.pow(rx, 2);\n    let ry2 = Math.pow(ry, 2);\n\n    let delta = xt2 / rx2 + yt2 / ry2;\n\n    if (delta > 1) {\n        delta = Math.sqrt(xt2 / rx2 + yt2 / ry2);\n        rx = delta * rx;\n        rx2 = Math.pow(rx, 2);\n\n        ry = delta * ry;\n        ry2 = Math.pow(ry, 2);\n    }\n\n    let constT = sign * Math.sqrt((rx2 * ry2 - rx2 * yt2 - ry2 * xt2) / (rx2 * yt2 + ry2 * xt2));\n    // due to rounding errors the value could become NaN even after radii correction\n    if (isNaN(constT)) {\n        constT = 0;\n    }\n\n    const cxT = constT * (rx * yT) / ry;\n    const cyT = - constT * (ry * xT) / rx;\n\n    const cx = cosine * cxT - sine * cyT + (x1 + x2) / 2;\n    const cy = sine * cxT + cosine * cyT + (y1 + y2) / 2;\n\n\n    const uX = (xT - cxT) / rx;\n    const uY = (yT - cyT) / ry;\n    const vX = -(xT + cxT) / rx;\n    const vY = -(yT + cyT) / ry;\n\n    const startAngle = (uY >= 0 ? 1 : -1) * Object(deg[\"a\" /* default */])(Math.acos(uX / Math.sqrt(uX * uX + uY * uY)));\n\n    const angleCosine = Object(round[\"a\" /* default */])((uX * vX + uY * vY) / (Math.sqrt(uX * uX + uY * uY) * Math.sqrt(vX * vX + vY * vY)), 10);\n    let angle = (uX * vY - uY * vX >= 0 ? 1 : -1) * Object(deg[\"a\" /* default */])(Math.acos(angleCosine));\n\n    if (!swipe && angle > 0) {\n        angle -= 360;\n    }\n\n    if (swipe && angle < 0) {\n        angle += 360;\n    }\n    let endAngle = startAngle + angle;\n    const signEndAngle = endAngle >= 0 ? 1 : -1;\n    endAngle = (Math.abs(endAngle) % 360) * signEndAngle;\n\n    return {\n        center: new geometry_point[\"a\" /* default */](cx, cy),\n        startAngle: startAngle,\n        endAngle: endAngle,\n        radiusX: rx,\n        radiusY: ry,\n        xRotation: rotation\n    };\n}\n\nfunction bboxStartAngle(angle, start) {\n    let startAngle = angle;\n\n    while (startAngle < start) {\n        startAngle += 90;\n    }\n\n    return startAngle;\n}\n\n/* harmony default export */ var arc = __webpack_exports__[\"a\"] = (arc_Arc);\n\n\n/***/ }),\n\n/***/ \"IU+O\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return eventElement; });\nfunction eventElement(e = {}) {\n    return e.touch ? e.touch.initialTouch : e.target;\n}\n\n/***/ }),\n\n/***/ \"IsCa\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return elementOffset; });\nfunction elementOffset(element) {\n    const box = element.getBoundingClientRect();\n\n    const documentElement = document.documentElement;\n\n    return {\n        top: box.top + (window.pageYOffset || documentElement.scrollTop) - (documentElement.clientTop || 0),\n        left: box.left + (window.pageXOffset || documentElement.scrollLeft) - (documentElement.clientLeft || 0)\n    };\n}\n\n/***/ }),\n\n/***/ \"JZGi\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return elementScale; });\n/* harmony import */ var _geometry_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"hL34\");\n\n\nconst matrixRegexp = /matrix\\((.*)\\)/;\n\nfunction parseMatrix(matrixString) {\n    const match = matrixString.match(matrixRegexp);\n    if (match === null || match.length !== 2) {\n        return _geometry_matrix__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].unit();\n    }\n\n    const members = match[1].split(',').map(x => parseFloat(x));\n    return new _geometry_matrix__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"](...members);\n}\n\nfunction transformMatrix(element) {\n    const transform = getComputedStyle(element).transform;\n\n    if (transform === 'none') {\n        return _geometry_matrix__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].unit();\n    }\n\n    return parseMatrix(transform);\n}\n\nfunction elementScale(element) {\n    if (!element) {\n        return _geometry_matrix__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].unit();\n    }\n\n    let matrix = transformMatrix(element);\n    let parent = element.parentElement;\n    while (parent) {\n        const parentMatrix = transformMatrix(parent);\n        matrix = matrix.multiplyCopy(parentMatrix);\n        parent = parent.parentElement;\n    }\n\n    matrix.b = matrix.c = matrix.e = matrix.f = 0;\n    return matrix;\n}\n\n\n/***/ }),\n\n/***/ \"K3Ik\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _mixins_with_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"O6F+\");\n/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"XdXH\");\n/* harmony import */ var _mixins_paintable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"T3aN\");\n/* harmony import */ var _mixins_measurable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"qNx/\");\n/* harmony import */ var _geometry_rect__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"XJRY\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"VqL+\");\n\n\n\n\n\n\n\n\nclass Rect extends Object(_mixins_paintable__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"])(Object(_mixins_measurable__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(Object(_mixins_with_geometry__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(_element__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"]))) {\n    get nodeType() {\n        return \"Rect\";\n    }\n\n    constructor(geometry = new _geometry_rect__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"](), options = {}) {\n        super(options);\n\n        this.geometry(geometry);\n\n        if (!Object(_util__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"])(this.options.stroke)) {\n            this.stroke(\"#000\");\n        }\n    }\n\n    _bbox(matrix) {\n        return this._geometry.bbox(matrix);\n    }\n\n    rawBBox() {\n        return this._geometry.bbox();\n    }\n\n    _containsPoint(point) {\n        return this._geometry.containsPoint(point);\n    }\n\n    _isOnPath(point) {\n        return this.geometry()._isOnPath(point, this.options.stroke.width / 2);\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Rect);\n\n\n/***/ }),\n\n/***/ \"LHUb\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Class; });\nclass Class {\n    // Empty base class needed for compatibility with Kendo UI for jQuery\n}\n\n\n/***/ }),\n\n/***/ \"Ll3z\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return ellipseExtremeAngles; });\nfunction ellipseExtremeAngles(center, rx, ry, matrix) {\n    let extremeX = 0;\n    let extremeY = 0;\n\n    if (matrix) {\n        extremeX = Math.atan2(matrix.c * ry, matrix.a * rx);\n        if (matrix.b !== 0) {\n            extremeY = Math.atan2(matrix.d * ry, matrix.b * rx);\n        }\n    }\n\n    return {\n        x: extremeX,\n        y: extremeY\n    };\n}\n\n/***/ }),\n\n/***/ \"O6F+\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"VqL+\");\n\n\nfunction geometryAccessor(name) {\n    const fieldName = \"_\" + name;\n    return function(value) {\n        if (Object(_util__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(value)) {\n            this._observerField(fieldName, value);\n            this.geometryChange();\n            return this;\n        }\n\n        return this[fieldName];\n    };\n}\n\nfunction defineGeometryAccessors(fn, names) {\n    for (let i = 0; i < names.length; i++) {\n        fn[names[i]] = geometryAccessor(names[i]);\n    }\n}\n\nconst withGeometry = (TBase, names = [ \"geometry\" ]) => {\n    const result = class extends TBase {};\n    defineGeometryAccessors(result.prototype, names);\n\n    return result;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (withGeometry);\n\n\n/***/ }),\n\n/***/ \"OOjv\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return DASH_ARRAYS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return SOLID; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return BUTT; });\nconst DASH_ARRAYS = {\n    dot: [ 1.5, 3.5 ],\n    dash: [ 4, 3.5 ],\n    longdash: [ 8, 3.5 ],\n    dashdot: [ 3.5, 3.5, 1.5, 3.5 ],\n    longdashdot: [ 8, 3.5, 1.5, 3.5 ],\n    longdashdotdot: [ 8, 3.5, 1.5, 3.5, 1.5, 3.5 ]\n};\n\nconst SOLID = \"solid\";\nconst BUTT = \"butt\";\n\n\n\n/***/ }),\n\n/***/ \"Ptn1\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"LHUb\");\n/* harmony import */ var _has_observers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"7joe\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"VqL+\");\n\n\n\n\n\nconst toString = {}.toString;\n\nclass OptionsStore extends _has_observers__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"] {\n    constructor(options, prefix = \"\") {\n        super();\n\n        this.prefix = prefix;\n\n        for (let field in options) {\n            let member = options[field];\n            member = this._wrap(member, field);\n            this[field] = member;\n        }\n    }\n\n    get(field) {\n        const parts = field.split(\".\");\n        let result = this;\n\n        while (parts.length && result) {\n            let part = parts.shift();\n            result = result[part];\n        }\n\n        return result;\n    }\n\n    set(field, value) {\n        const current = this.get(field);\n\n        if (current !== value) {\n            this._set(field, this._wrap(value, field));\n            this.optionsChange({\n                field: this.prefix + field,\n                value: value\n            });\n        }\n    }\n\n    _set(field, value) {\n        const composite = field.indexOf(\".\") >= 0;\n        let parentObj = this;\n        let fieldName = field;\n\n        if (composite) {\n            const parts = fieldName.split(\".\");\n            let prefix = this.prefix;\n\n            while (parts.length > 1) {\n                fieldName = parts.shift();\n                prefix += fieldName + \".\";\n\n                let obj = parentObj[fieldName];\n\n                if (!obj) {\n                    obj = new OptionsStore({}, prefix);\n                    obj.addObserver(this);\n                    parentObj[fieldName] = obj;\n                }\n                parentObj = obj;\n            }\n            fieldName = parts[0];\n        }\n\n        parentObj._clear(fieldName);\n        parentObj[fieldName] = value;\n    }\n\n    _clear(field) {\n        const current = this[field];\n        if (current && current.removeObserver) {\n            current.removeObserver(this);\n        }\n    }\n\n    _wrap(object, field) {\n        const type = toString.call(object);\n        let wrapped = object;\n\n        if (wrapped !== null && Object(_util__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"])(wrapped) && type === \"[object Object]\") {\n            if (!(object instanceof OptionsStore) && !(object instanceof _common__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])) {\n                wrapped = new OptionsStore(wrapped, this.prefix + field + \".\");\n            }\n\n            wrapped.addObserver(this);\n        }\n\n        return wrapped;\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (OptionsStore);\n\n\n/***/ }),\n\n/***/ \"QPDK\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/core/options-store.js\nvar options_store = __webpack_require__(\"Ptn1\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/defined.js\nvar defined = __webpack_require__(\"VqL+\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/mixins/with-options.js\n\n\nfunction optionsAccessor(name) {\n    return function(value) {\n        if (Object(defined[\"a\" /* default */])(value)) {\n            this.options.set(name, value);\n            return this;\n        }\n\n        return this.options.get(name);\n    };\n}\n\nfunction defineOptionsAccessors(fn, names) {\n    for (let i = 0; i < names.length; i++) {\n        fn[names[i]] = optionsAccessor(names[i]);\n    }\n}\n\nconst withOptions = (TBase, names) => {\n    const result = class extends TBase {};\n    defineOptionsAccessors(result.prototype, names);\n\n    return result;\n};\n\n/* harmony default export */ var with_options = (withOptions);\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/core/has-observers.js\nvar has_observers = __webpack_require__(\"7joe\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/gradients/gradient-stop.js\n\n\n\n\n\n\nconst options = [ \"offset\", \"color\", \"opacity\" ];\n\nclass gradient_stop_GradientStop extends with_options(has_observers[\"a\" /* default */], options) {\n    constructor(offset, color, opacity) {\n        super();\n\n        this.options = new options_store[\"a\" /* default */]({\n            offset: offset,\n            color: color,\n            opacity: Object(defined[\"a\" /* default */])(opacity) ? opacity : 1\n        });\n\n        this.options.addObserver(this);\n    }\n\n    static create(arg) {\n        if (Object(defined[\"a\" /* default */])(arg)) {\n            let stop;\n            if (arg instanceof gradient_stop_GradientStop) {\n                stop = arg;\n            } else if (arg.length > 1) {\n                stop = new gradient_stop_GradientStop(arg[0], arg[1], arg[2]);\n            } else {\n                stop = new gradient_stop_GradientStop(arg.offset, arg.color, arg.opacity);\n            }\n\n            return stop;\n        }\n    }\n}\n\n/* harmony default export */ var gradient_stop = __webpack_exports__[\"a\"] = (gradient_stop_GradientStop);\n\n\n/***/ }),\n\n/***/ \"QUbS\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _class__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"LHUb\");\n/* harmony import */ var _named_colors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"T8t9\");\n/* harmony import */ var _parse_color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"om2P\");\n\n\n\nconst DARK_TRESHOLD = 180;\nlet Color = /*@__PURE__*/ (() => {\n    class Color extends _class__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"] {\n        constructor(value) {\n            super();\n            if (arguments.length === 1) {\n                const formats = Color.formats;\n                const resolvedColor = this.resolveColor(value);\n                for (let idx = 0; idx < formats.length; idx++) {\n                    const formatRegex = formats[idx].re;\n                    const processor = formats[idx].process;\n                    const parts = formatRegex.exec(resolvedColor);\n                    if (parts) {\n                        const channels = processor(parts);\n                        this.r = channels[0];\n                        this.g = channels[1];\n                        this.b = channels[2];\n                    }\n                }\n            }\n            else {\n                this.r = arguments[0];\n                this.g = arguments[1];\n                this.b = arguments[2];\n            }\n            this.r = this.normalizeByte(this.r);\n            this.g = this.normalizeByte(this.g);\n            this.b = this.normalizeByte(this.b);\n        }\n        toHex() {\n            const pad = this.padDigit;\n            const r = this.r.toString(16);\n            const g = this.g.toString(16);\n            const b = this.b.toString(16);\n            return \"#\" + pad(r) + pad(g) + pad(b);\n        }\n        resolveColor(value) {\n            let color = value || \"black\";\n            if (color.charAt(0) === \"#\") {\n                color = color.substr(1, 6);\n            }\n            color = color.replace(/ /g, \"\");\n            color = color.toLowerCase();\n            color = Color.namedColors[color] || color;\n            return color;\n        }\n        normalizeByte(value) {\n            if (value < 0 || isNaN(value)) {\n                return 0;\n            }\n            return value > 255 ? 255 : value;\n        }\n        padDigit(value) {\n            return (value.length === 1) ? \"0\" + value : value;\n        }\n        brightness(value) {\n            const round = Math.round;\n            this.r = round(this.normalizeByte(this.r * value));\n            this.g = round(this.normalizeByte(this.g * value));\n            this.b = round(this.normalizeByte(this.b * value));\n            return this;\n        }\n        percBrightness() {\n            return Math.sqrt(0.241 * this.r * this.r + 0.691 * this.g * this.g + 0.068 * this.b * this.b);\n        }\n        isDark() {\n            return this.percBrightness() < DARK_TRESHOLD;\n        }\n        static fromBytes(r, g, b, a) {\n            return new _parse_color__WEBPACK_IMPORTED_MODULE_2__[/* Bytes */ \"a\"](r, g, b, a != null ? a : 1);\n        }\n        static fromRGB(r, g, b, a) {\n            return new _parse_color__WEBPACK_IMPORTED_MODULE_2__[/* RGB */ \"d\"](r, g, b, a != null ? a : 1);\n        }\n        static fromHSV(h, s, v, a) {\n            return new _parse_color__WEBPACK_IMPORTED_MODULE_2__[/* HSV */ \"c\"](h, s, v, a != null ? a : 1);\n        }\n        static fromHSL(h, s, l, a) {\n            return new _parse_color__WEBPACK_IMPORTED_MODULE_2__[/* HSL */ \"b\"](h, s, l, a != null ? a : 1);\n        }\n    }\n    Color.formats = [{\n            re: /^rgb\\((\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3})\\)$/,\n            process: function (parts) {\n                return [\n                    parseInt(parts[1], 10), parseInt(parts[2], 10), parseInt(parts[3], 10)\n                ];\n            }\n        }, {\n            re: /^(\\w{2})(\\w{2})(\\w{2})$/,\n            process: function (parts) {\n                return [\n                    parseInt(parts[1], 16), parseInt(parts[2], 16), parseInt(parts[3], 16)\n                ];\n            }\n        }, {\n            re: /^(\\w{1})(\\w{1})(\\w{1})$/,\n            process: function (parts) {\n                return [\n                    parseInt(parts[1] + parts[1], 16),\n                    parseInt(parts[2] + parts[2], 16),\n                    parseInt(parts[3] + parts[3], 16)\n                ];\n            }\n        }];\n    Color.namedColors = _named_colors__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"];\n    return Color;\n})();\n/* harmony default export */ __webpack_exports__[\"a\"] = (Color);\n\n\n/***/ }),\n\n/***/ \"R/Fs\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _quad_root__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"2smt\");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"XJRY\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"i9ZU\");\n\n\n\n\nclass QuadNode extends _quad_root__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"] {\n    constructor(rect) {\n        super();\n        this.children = [];\n        this.rect = rect;\n    }\n\n    inBounds(rect) {\n        const nodeRect = this.rect;\n        const nodeBottomRight = nodeRect.bottomRight();\n        const bottomRight = rect.bottomRight();\n        const inBounds = nodeRect.origin.x <= rect.origin.x && nodeRect.origin.y <= rect.origin.y && bottomRight.x <= nodeBottomRight.x &&\n            bottomRight.y <= nodeBottomRight.y;\n        return inBounds;\n    }\n\n    pointShapes(point) {\n        const children = this.children;\n        const length = children.length;\n        const result = super.pointShapes(point);\n        for (let idx = 0; idx < length; idx++) {\n            Object(_util__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"])(result, children[idx].pointShapes(point));\n        }\n        return result;\n    }\n\n    insert(shape, bbox) {\n        const children = this.children;\n        let inserted = false;\n\n        if (this.inBounds(bbox)) {\n            if (this.shapes.length < 4) {\n                this._add(shape, bbox);\n            } else {\n                if (!children.length) {\n                    this._initChildren();\n                }\n\n                for (let idx = 0; idx < children.length; idx++) {\n                    if (children[idx].insert(shape, bbox)) {\n                        inserted = true;\n                        break;\n                    }\n                }\n\n                if (!inserted) {\n                    this._add(shape, bbox);\n                }\n            }\n            inserted = true;\n        }\n\n        return inserted;\n    }\n\n    _initChildren() {\n        const { rect, children } = this;\n        const center = rect.center();\n        const halfWidth = rect.width() / 2;\n        const halfHeight = rect.height() / 2;\n\n        children.push(\n            new QuadNode(new _geometry__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"]([ rect.origin.x, rect.origin.y ], [ halfWidth, halfHeight ])),\n            new QuadNode(new _geometry__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"]([ center.x, rect.origin.y ], [ halfWidth, halfHeight ])),\n            new QuadNode(new _geometry__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"]([ rect.origin.x, center.y ], [ halfWidth, halfHeight ])),\n            new QuadNode(new _geometry__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"]([ center.x, center.y ], [ halfWidth, halfHeight ]))\n        );\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (QuadNode);\n\n/***/ }),\n\n/***/ \"RlWg\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return round; });\nfunction pow(p) {\n    if (p) {\n        return Math.pow(10, p);\n    }\n\n    return 1;\n}\n\nfunction round(value, precision) {\n    const power = pow(precision);\n    return Math.round(value * power) / power;\n}\n\n/***/ }),\n\n/***/ \"SMq3\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _path_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"UzJa\");\n\n\nclass RectNode extends _path_node__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"] {\n    renderPoints(ctx) {\n        const { origin, size } = this.srcElement.geometry();\n\n        ctx.rect(origin.x, origin.y, size.width, size.height);\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (RectNode);\n\n\n/***/ }),\n\n/***/ \"T3aN\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"VqL+\");\n\n\nconst GRADIENT = \"Gradient\";\n\nconst paintable = TBase => (\n    class extends TBase {\n        fill(color, opacity) {\n            const options = this.options;\n\n            if (Object(_util__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(color)) {\n                if (color && color.nodeType !== GRADIENT) {\n                    const newFill = {\n                        color: color\n                    };\n                    if (Object(_util__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(opacity)) {\n                        newFill.opacity = opacity;\n                    }\n                    options.set(\"fill\", newFill);\n                } else {\n                    options.set(\"fill\", color);\n                }\n\n                return this;\n            }\n\n            return options.get(\"fill\");\n        }\n\n        stroke(color, width, opacity) {\n            if (Object(_util__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(color)) {\n                this.options.set(\"stroke.color\", color);\n\n                if (Object(_util__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(width)) {\n                    this.options.set(\"stroke.width\", width);\n                }\n\n                if (Object(_util__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(opacity)) {\n                    this.options.set(\"stroke.opacity\", opacity);\n                }\n\n                return this;\n            }\n\n            return this.options.get(\"stroke\");\n        }\n}\n);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (paintable);\n\n\n/***/ }),\n\n/***/ \"T8t9\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nconst namedColors = {\n    aliceblue: \"f0f8ff\", antiquewhite: \"faebd7\", aqua: \"00ffff\",\n    aquamarine: \"7fffd4\", azure: \"f0ffff\", beige: \"f5f5dc\",\n    bisque: \"ffe4c4\", black: \"000000\", blanchedalmond: \"ffebcd\",\n    blue: \"0000ff\", blueviolet: \"8a2be2\", brown: \"a52a2a\",\n    burlywood: \"deb887\", cadetblue: \"5f9ea0\", chartreuse: \"7fff00\",\n    chocolate: \"d2691e\", coral: \"ff7f50\", cornflowerblue: \"6495ed\",\n    cornsilk: \"fff8dc\", crimson: \"dc143c\", cyan: \"00ffff\",\n    darkblue: \"00008b\", darkcyan: \"008b8b\", darkgoldenrod: \"b8860b\",\n    darkgray: \"a9a9a9\", darkgrey: \"a9a9a9\", darkgreen: \"006400\",\n    darkkhaki: \"bdb76b\", darkmagenta: \"8b008b\", darkolivegreen: \"556b2f\",\n    darkorange: \"ff8c00\", darkorchid: \"9932cc\", darkred: \"8b0000\",\n    darksalmon: \"e9967a\", darkseagreen: \"8fbc8f\", darkslateblue: \"483d8b\",\n    darkslategray: \"2f4f4f\", darkslategrey: \"2f4f4f\", darkturquoise: \"00ced1\",\n    darkviolet: \"9400d3\", deeppink: \"ff1493\", deepskyblue: \"00bfff\",\n    dimgray: \"696969\", dimgrey: \"696969\", dodgerblue: \"1e90ff\",\n    firebrick: \"b22222\", floralwhite: \"fffaf0\", forestgreen: \"228b22\",\n    fuchsia: \"ff00ff\", gainsboro: \"dcdcdc\", ghostwhite: \"f8f8ff\",\n    gold: \"ffd700\", goldenrod: \"daa520\", gray: \"808080\",\n    grey: \"808080\", green: \"008000\", greenyellow: \"adff2f\",\n    honeydew: \"f0fff0\", hotpink: \"ff69b4\", indianred: \"cd5c5c\",\n    indigo: \"4b0082\", ivory: \"fffff0\", khaki: \"f0e68c\",\n    lavender: \"e6e6fa\", lavenderblush: \"fff0f5\", lawngreen: \"7cfc00\",\n    lemonchiffon: \"fffacd\", lightblue: \"add8e6\", lightcoral: \"f08080\",\n    lightcyan: \"e0ffff\", lightgoldenrodyellow: \"fafad2\", lightgray: \"d3d3d3\",\n    lightgrey: \"d3d3d3\", lightgreen: \"90ee90\", lightpink: \"ffb6c1\",\n    lightsalmon: \"ffa07a\", lightseagreen: \"20b2aa\", lightskyblue: \"87cefa\",\n    lightslategray: \"778899\", lightslategrey: \"778899\", lightsteelblue: \"b0c4de\",\n    lightyellow: \"ffffe0\", lime: \"00ff00\", limegreen: \"32cd32\",\n    linen: \"faf0e6\", magenta: \"ff00ff\", maroon: \"800000\",\n    mediumaquamarine: \"66cdaa\", mediumblue: \"0000cd\", mediumorchid: \"ba55d3\",\n    mediumpurple: \"9370d8\", mediumseagreen: \"3cb371\", mediumslateblue: \"7b68ee\",\n    mediumspringgreen: \"00fa9a\", mediumturquoise: \"48d1cc\", mediumvioletred: \"c71585\",\n    midnightblue: \"191970\", mintcream: \"f5fffa\", mistyrose: \"ffe4e1\",\n    moccasin: \"ffe4b5\", navajowhite: \"ffdead\", navy: \"000080\",\n    oldlace: \"fdf5e6\", olive: \"808000\", olivedrab: \"6b8e23\",\n    orange: \"ffa500\", orangered: \"ff4500\", orchid: \"da70d6\",\n    palegoldenrod: \"eee8aa\", palegreen: \"98fb98\", paleturquoise: \"afeeee\",\n    palevioletred: \"d87093\", papayawhip: \"ffefd5\", peachpuff: \"ffdab9\",\n    peru: \"cd853f\", pink: \"ffc0cb\", plum: \"dda0dd\",\n    powderblue: \"b0e0e6\", purple: \"800080\", red: \"ff0000\",\n    rosybrown: \"bc8f8f\", royalblue: \"4169e1\", saddlebrown: \"8b4513\",\n    salmon: \"fa8072\", sandybrown: \"f4a460\", seagreen: \"2e8b57\",\n    seashell: \"fff5ee\", sienna: \"a0522d\", silver: \"c0c0c0\",\n    skyblue: \"87ceeb\", slateblue: \"6a5acd\", slategray: \"708090\",\n    slategrey: \"708090\", snow: \"fffafa\", springgreen: \"00ff7f\",\n    steelblue: \"4682b4\", tan: \"d2b48c\", teal: \"008080\",\n    thistle: \"d8bfd8\", tomato: \"ff6347\", turquoise: \"40e0d0\",\n    violet: \"ee82ee\", wheat: \"f5deb3\", white: \"ffffff\",\n    whitesmoke: \"f5f5f5\", yellow: \"ffff00\", yellowgreen: \"9acd32\"\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (namedColors);\n\n/***/ }),\n\n/***/ \"TD7o\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return PRECISION; });\nconst PRECISION = 10;\n\n\n\n/***/ }),\n\n/***/ \"Ual8\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _geometry_circle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"BIVv\");\n/* harmony import */ var _mixins_paintable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"T3aN\");\n/* harmony import */ var _mixins_measurable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"qNx/\");\n/* harmony import */ var _mixins_with_geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"O6F+\");\n/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"XdXH\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"VqL+\");\n\n\n\n\n\n\n\nconst DEFAULT_STROKE = \"#000\";\n\nclass Circle extends Object(_mixins_paintable__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(Object(_mixins_measurable__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"])(Object(_mixins_with_geometry__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(_element__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"]))) {\n    get nodeType() {\n        return \"Circle\";\n    }\n\n    constructor(geometry = new _geometry_circle__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"](), options = {}) {\n        super(options);\n\n        this.geometry(geometry);\n\n        if (!Object(_util__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"])(this.options.stroke)) {\n            this.stroke(DEFAULT_STROKE);\n        }\n    }\n\n    rawBBox() {\n        return this._geometry.bbox();\n    }\n\n    _bbox(matrix) {\n        return this._geometry.bbox(matrix);\n    }\n\n    _containsPoint(point) {\n        return this.geometry().containsPoint(point);\n    }\n\n    _isOnPath(point) {\n        return this.geometry()._isOnPath(point, this.options.stroke.width / 2);\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Circle);\n\n\n/***/ }),\n\n/***/ \"UzJa\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"o+K8\");\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"om2P\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"3Quq\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"9uUv\");\n/* harmony import */ var _gradients_linear_gradient__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"7Jhm\");\n/* harmony import */ var _gradients_radial_gradient__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"yhXd\");\n/* harmony import */ var _core_constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(\"OOjv\");\n/* harmony import */ var _utils_render_path__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(\"hype\");\n\n\n\n\n\n\n\n\nfunction addGradientStops(gradient, stops) {\n    for (let idx = 0; idx < stops.length; idx++) {\n        let stop = stops[idx];\n        let color = Object(_common__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"e\"])(stop.color());\n\n        color.a *= stop.opacity();\n\n        gradient.addColorStop(stop.offset(), color.toCssRgba());\n    }\n}\n\nclass PathNode extends _node__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"] {\n\n    renderTo(ctx) {\n        ctx.save();\n\n        this.setTransform(ctx);\n        this.setClip(ctx);\n        this.setOpacity(ctx);\n\n        ctx.beginPath();\n\n        this.renderPoints(ctx, this.srcElement);\n\n        this.setLineDash(ctx);\n        this.setLineCap(ctx);\n        this.setLineJoin(ctx);\n\n        this.setFill(ctx);\n        this.setStroke(ctx);\n\n        ctx.restore();\n    }\n\n    setFill(ctx) {\n        const fill = this.srcElement.options.fill;\n        let hasFill = false;\n\n        if (fill) {\n            if (fill.nodeType === \"Gradient\") {\n                this.setGradientFill(ctx, fill);\n                hasFill = true;\n            } else if (!Object(_util__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"])(fill.color)) {\n                ctx.fillStyle = fill.color;\n\n                ctx.save();\n                this.globalAlpha(ctx, fill.opacity);\n                ctx.fill();\n                ctx.restore();\n\n                hasFill = true;\n            }\n        }\n\n        return hasFill;\n    }\n\n    setGradientFill(ctx, fill) {\n        const bbox = this.srcElement.rawBBox();\n        let gradient;\n\n        if (fill instanceof _gradients_linear_gradient__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"]) {\n            let start = fill.start();\n            let end = fill.end();\n            gradient = ctx.createLinearGradient(start.x, start.y, end.x, end.y);\n        } else if (fill instanceof _gradients_radial_gradient__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"]) {\n            let center = fill.center();\n            gradient = ctx.createRadialGradient(center.x, center.y, 0, center.x, center.y, fill.radius());\n        }\n\n        addGradientStops(gradient, fill.stops);\n\n        ctx.save();\n\n        if (!fill.userSpace()) {\n            ctx.transform(bbox.width(), 0, 0, bbox.height(), bbox.origin.x, bbox.origin.y);\n        }\n        ctx.fillStyle = gradient;\n        ctx.fill();\n\n        ctx.restore();\n    }\n\n    setStroke(ctx) {\n        const stroke = this.srcElement.options.stroke;\n        if (stroke && !Object(_util__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"])(stroke.color) && stroke.width > 0) {\n            ctx.strokeStyle = stroke.color;\n            ctx.lineWidth = Object(_util__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(stroke.width, 1);\n\n            ctx.save();\n            this.globalAlpha(ctx, stroke.opacity);\n            ctx.stroke();\n            ctx.restore();\n\n            return true;\n        }\n    }\n\n    dashType() {\n        const stroke = this.srcElement.options.stroke;\n        if (stroke && stroke.dashType) {\n            return stroke.dashType.toLowerCase();\n        }\n    }\n\n    setLineDash(ctx) {\n        const dashType = this.dashType();\n        if (dashType && dashType !== _core_constants__WEBPACK_IMPORTED_MODULE_6__[/* SOLID */ \"c\"]) {\n            const dashArray = _core_constants__WEBPACK_IMPORTED_MODULE_6__[/* DASH_ARRAYS */ \"b\"][dashType];\n            if (ctx.setLineDash) {\n                ctx.setLineDash(dashArray);\n            } else {\n                ctx.mozDash = dashArray;\n                ctx.webkitLineDash = dashArray;\n            }\n        }\n    }\n\n    setLineCap(ctx) {\n        const dashType = this.dashType();\n        const stroke = this.srcElement.options.stroke;\n        if (dashType && dashType !== _core_constants__WEBPACK_IMPORTED_MODULE_6__[/* SOLID */ \"c\"]) {\n            ctx.lineCap = _core_constants__WEBPACK_IMPORTED_MODULE_6__[/* BUTT */ \"a\"];\n        } else if (stroke && stroke.lineCap) {\n            ctx.lineCap = stroke.lineCap;\n        }\n    }\n\n    setLineJoin(ctx) {\n        const stroke = this.srcElement.options.stroke;\n        if (stroke && stroke.lineJoin) {\n            ctx.lineJoin = stroke.lineJoin;\n        }\n    }\n\n    renderPoints(ctx, path) {\n        Object(_utils_render_path__WEBPACK_IMPORTED_MODULE_7__[/* default */ \"a\"])(ctx, path);\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (PathNode);\n\n\n/***/ }),\n\n/***/ \"V34t\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return SVG_NS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return NONE; });\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\nconst NONE = \"none\";\n\n\n\n/***/ }),\n\n/***/ \"VqL+\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return defined; });\nconst UNDEFINED = \"undefined\";\n\nfunction defined(value) {\n    return typeof value !== UNDEFINED;\n}\n\n/***/ }),\n\n/***/ \"Vvtp\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _core_has_observers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"7joe\");\n\n\nconst push = [].push;\nconst pop = [].pop;\nconst splice = [].splice;\nconst shift = [].shift;\nconst slice = [].slice;\nconst unshift = [].unshift;\n\nclass ElementsArray extends _core_has_observers__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"] {\n    constructor(array = []) {\n        super();\n\n        this.length = 0;\n        this._splice(0, array.length, array);\n    }\n\n    elements(value) {\n        if (value) {\n            this._splice(0, this.length, value);\n\n            this._change();\n            return this;\n        }\n\n        return this.slice(0);\n    }\n\n    push() {\n        const elements = arguments;\n        const result = push.apply(this, elements);\n\n        this._add(elements);\n\n        return result;\n    }\n\n    slice() {\n        return slice.call(this);\n    }\n\n    pop() {\n        const length = this.length;\n        const result = pop.apply(this);\n\n        if (length) {\n            this._remove([ result ]);\n        }\n\n        return result;\n    }\n\n    splice(index, howMany) {\n        const elements = slice.call(arguments, 2);\n        const result = this._splice(index, howMany, elements);\n\n        this._change();\n\n        return result;\n    }\n\n    shift() {\n        const length = this.length;\n        const result = shift.apply(this);\n\n        if (length) {\n            this._remove([ result ]);\n        }\n\n        return result;\n    }\n\n    unshift() {\n        const elements = arguments;\n        const result = unshift.apply(this, elements);\n\n        this._add(elements);\n\n        return result;\n    }\n\n    indexOf(element) {\n        const length = this.length;\n\n        for (let idx = 0; idx < length; idx++) {\n            if (this[idx] === element) {\n                return idx;\n            }\n        }\n        return -1;\n    }\n\n    _splice(index, howMany, elements) {\n        const result = splice.apply(this, [ index, howMany ].concat(elements));\n\n        this._clearObserver(result);\n        this._setObserver(elements);\n\n        return result;\n    }\n\n    _add(elements) {\n        this._setObserver(elements);\n        this._change();\n    }\n\n    _remove(elements) {\n        this._clearObserver(elements);\n        this._change();\n    }\n\n    _setObserver(elements) {\n        for (let idx = 0; idx < elements.length; idx++) {\n            elements[idx].addObserver(this);\n        }\n    }\n\n    _clearObserver(elements) {\n        for (let idx = 0; idx < elements.length; idx++) {\n            elements[idx].removeObserver(this);\n        }\n    }\n\n    _change() {}\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ElementsArray);\n\n\n/***/ }),\n\n/***/ \"XJRY\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _core_has_observers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"7joe\");\n/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"lRJa\");\n/* harmony import */ var _size__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"ZfP6\");\n\n\n\n\nclass Rect extends _core_has_observers__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"] {\n    constructor(origin = new _point__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"](), size = new _size__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"]()) {\n        super();\n\n        this.setOrigin(origin);\n        this.setSize(size);\n    }\n\n    clone() {\n        return new Rect(\n            this.origin.clone(),\n            this.size.clone()\n        );\n    }\n\n    equals(other) {\n        return other &&\n               other.origin.equals(this.origin) &&\n               other.size.equals(this.size);\n    }\n\n    setOrigin(value) {\n        this._observerField(\"origin\", _point__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"].create(value));\n        this.geometryChange();\n        return this;\n    }\n\n    getOrigin() {\n        return this.origin;\n    }\n\n    setSize(value) {\n        this._observerField(\"size\", _size__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"].create(value));\n        this.geometryChange();\n        return this;\n    }\n\n    getSize() {\n        return this.size;\n    }\n\n    width() {\n        return this.size.width;\n    }\n\n    height() {\n        return this.size.height;\n    }\n\n    topLeft() {\n        return this.origin.clone();\n    }\n\n    bottomRight() {\n        return this.origin.clone().translate(this.width(), this.height());\n    }\n\n    topRight() {\n        return this.origin.clone().translate(this.width(), 0);\n    }\n\n    bottomLeft() {\n        return this.origin.clone().translate(0, this.height());\n    }\n\n    center() {\n        return this.origin.clone().translate(this.width() / 2, this.height() / 2);\n    }\n\n    bbox(matrix) {\n        const tl = this.topLeft().transformCopy(matrix);\n        const tr = this.topRight().transformCopy(matrix);\n        const br = this.bottomRight().transformCopy(matrix);\n        const bl = this.bottomLeft().transformCopy(matrix);\n\n        return Rect.fromPoints(tl, tr, br, bl);\n    }\n\n    transformCopy(m) {\n        return Rect.fromPoints(\n            this.topLeft().transform(m),\n            this.bottomRight().transform(m)\n        );\n    }\n\n    expand(x, y = x) {\n\n        this.size.width += 2 * x;\n        this.size.height += 2 * y;\n\n        this.origin.translate(-x, -y);\n\n        return this;\n    }\n\n    expandCopy(x, y) {\n        return this.clone().expand(x, y);\n    }\n\n    containsPoint(point) {\n        const origin = this.origin;\n        const bottomRight = this.bottomRight();\n        return !(point.x < origin.x || point.y < origin.y || bottomRight.x < point.x || bottomRight.y < point.y);\n    }\n\n    _isOnPath(point, width) {\n        const rectOuter = this.expandCopy(width, width);\n        const rectInner = this.expandCopy(-width, -width);\n\n        return rectOuter.containsPoint(point) && !rectInner.containsPoint(point);\n    }\n\n    static fromPoints() {\n        const topLeft = _point__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"].min.apply(null, arguments);\n        const bottomRight = _point__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"].max.apply(null, arguments);\n        const size = new _size__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"](\n            bottomRight.x - topLeft.x,\n            bottomRight.y - topLeft.y\n        );\n\n        return new Rect(topLeft, size);\n    }\n\n    static union(a, b) {\n        return Rect.fromPoints(\n            _point__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"].min(a.topLeft(), b.topLeft()),\n            _point__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"].max(a.bottomRight(), b.bottomRight())\n        );\n    }\n\n    static intersect(a, b) {\n        const rect1 = {\n            left: a.topLeft().x,\n            top: a.topLeft().y,\n            right: a.bottomRight().x,\n            bottom: a.bottomRight().y\n        };\n\n        const rect2 = {\n            left: b.topLeft().x,\n            top: b.topLeft().y,\n            right: b.bottomRight().x,\n            bottom: b.bottomRight().y\n        };\n\n        if (rect1.left <= rect2.right &&\n            rect2.left <= rect1.right &&\n            rect1.top <= rect2.bottom &&\n            rect2.top <= rect1.bottom) {\n            return Rect.fromPoints(\n                new _point__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"](Math.max(rect1.left, rect2.left), Math.max(rect1.top, rect2.top)),\n                new _point__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"](Math.min(rect1.right, rect2.right), Math.min(rect1.bottom, rect2.bottom))\n            );\n        }\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Rect);\n\n\n/***/ }),\n\n/***/ \"XdXH\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _core_options_store__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"Ptn1\");\n/* harmony import */ var _geometry_rect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"XJRY\");\n/* harmony import */ var _geometry_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"hL34\");\n/* harmony import */ var _geometry_transform__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"uBxF\");\n/* harmony import */ var _geometry_to_matrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"x/GK\");\n/* harmony import */ var _core_has_observers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"7joe\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(\"E7ME\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(\"VqL+\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(\"9uUv\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(\"3Quq\");\n\n\n\n\n\n\n\n\nclass Element extends _core_has_observers__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"] {\n    get nodeType() {\n        return \"Rect\";\n    }\n\n    constructor(options) {\n        super();\n\n        this._initOptions(options);\n    }\n\n    _initOptions(options = {}) {\n        const { clip, transform } = options;\n\n        if (transform) {\n            options.transform = Object(_geometry_transform__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(transform);\n        }\n\n        if (clip && !clip.id) {\n            clip.id = Object(_util__WEBPACK_IMPORTED_MODULE_6__[/* default */ \"a\"])();\n        }\n\n        this.options = new _core_options_store__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"](options);\n        this.options.addObserver(this);\n    }\n\n    transform(value) {\n        if (Object(_util__WEBPACK_IMPORTED_MODULE_7__[/* default */ \"a\"])(value)) {\n            this.options.set(\"transform\", Object(_geometry_transform__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(value));\n        } else {\n            return this.options.get(\"transform\");\n        }\n    }\n\n    parentTransform() {\n        let element = this;\n        let parentMatrix;\n\n        while (element.parent) {\n            element = element.parent;\n            let transformation = element.transform();\n            if (transformation) {\n                parentMatrix = transformation.matrix().multiplyCopy(parentMatrix || _geometry_matrix__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"].unit());\n            }\n        }\n\n        if (parentMatrix) {\n            return Object(_geometry_transform__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(parentMatrix);\n        }\n    }\n\n    currentTransform(parentTransform = this.parentTransform()) {\n        const elementTransform = this.transform();\n        const elementMatrix = Object(_geometry_to_matrix__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"])(elementTransform);\n\n        let parentMatrix = Object(_geometry_to_matrix__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"])(parentTransform);\n        let combinedMatrix;\n\n        if (elementMatrix && parentMatrix) {\n            combinedMatrix = parentMatrix.multiplyCopy(elementMatrix);\n        } else {\n            combinedMatrix = elementMatrix || parentMatrix;\n        }\n\n        if (combinedMatrix) {\n            return Object(_geometry_transform__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(combinedMatrix);\n        }\n    }\n\n    visible(value) {\n        if (Object(_util__WEBPACK_IMPORTED_MODULE_7__[/* default */ \"a\"])(value)) {\n            this.options.set(\"visible\", value);\n            return this;\n        }\n\n        return this.options.get(\"visible\") !== false;\n    }\n\n    clip(value) {\n        const options = this.options;\n        if (Object(_util__WEBPACK_IMPORTED_MODULE_7__[/* default */ \"a\"])(value)) {\n            if (value && !value.id) {\n                value.id = Object(_util__WEBPACK_IMPORTED_MODULE_6__[/* default */ \"a\"])();\n            }\n            options.set(\"clip\", value);\n            return this;\n        }\n\n        return options.get(\"clip\");\n    }\n\n    opacity(value) {\n        if (Object(_util__WEBPACK_IMPORTED_MODULE_7__[/* default */ \"a\"])(value)) {\n            this.options.set(\"opacity\", value);\n            return this;\n        }\n\n        return Object(_util__WEBPACK_IMPORTED_MODULE_8__[/* default */ \"a\"])(this.options.get(\"opacity\"), 1);\n    }\n\n    clippedBBox(transformation) {\n        const bbox = this._clippedBBox(transformation);\n        if (bbox) {\n            const clip = this.clip();\n            return clip ? _geometry_rect__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"].intersect(bbox, clip.bbox(transformation)) : bbox;\n        }\n    }\n\n    containsPoint(point, parentTransform) {\n        if (this.visible()) {\n            const transform = this.currentTransform(parentTransform);\n            let transformedPoint = point;\n            if (transform) {\n                transformedPoint = point.transformCopy(transform.matrix().invert());\n            }\n            return (this._hasFill() && this._containsPoint(transformedPoint)) || (this._isOnPath && this._hasStroke() && this._isOnPath(transformedPoint));\n        }\n        return false;\n    }\n\n    _hasFill() {\n        const fill = this.options.fill;\n        return fill && !Object(_util__WEBPACK_IMPORTED_MODULE_9__[/* default */ \"a\"])(fill.color);\n    }\n\n    _hasStroke() {\n        const stroke = this.options.stroke;\n        return stroke && stroke.width > 0 && !Object(_util__WEBPACK_IMPORTED_MODULE_9__[/* default */ \"a\"])(stroke.color);\n    }\n\n    _clippedBBox(transformation) {\n        return this.bbox(transformation);\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Element);\n\n\n/***/ }),\n\n/***/ \"YDM/\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return renderAllAttr; });\n/* harmony import */ var _render_attribute__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"08A6\");\n\n\nfunction renderAllAttr(attrs) {\n    let output = \"\";\n    for (let i = 0; i < attrs.length; i++) {\n        output += Object(_render_attribute__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(attrs[i][0], attrs[i][1]);\n    }\n\n    return output;\n}\n\n/***/ }),\n\n/***/ \"Ytya\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _group_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"xYjD\");\n/* harmony import */ var _mixins_traversable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"fdcc\");\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"6BXq\");\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"FRnV\");\n\n\n\n\n\nconst FRAME_DELAY = 1000 / 60;\n\nclass RootNode extends Object(_mixins_traversable__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(_group_node__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"], \"childNodes\") {\n    constructor(canvas, size) {\n        super();\n\n        this.canvas = canvas;\n        this.size = size;\n        this.ctx = canvas.getContext(\"2d\");\n\n        const invalidateHandler = this._invalidate.bind(this);\n        this.invalidate = Object(_common__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"])(() => {\n            Object(_common__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(invalidateHandler);\n        }, FRAME_DELAY);\n    }\n\n    destroy() {\n        super.destroy();\n        this.canvas = null;\n        this.ctx = null;\n    }\n\n    load(elements, pos, cors) {\n        this.loadElements(elements, pos, cors);\n        this._invalidate();\n    }\n\n    _rescale(scale) {\n        const { canvas, size } = this;\n        canvas.width = size.width * scale;\n        canvas.height = size.height * scale;\n        this.ctx.scale(scale, scale);\n    }\n\n    _devicePixelRatio() {\n        if (typeof window.devicePixelRatio === 'number') {\n            return window.devicePixelRatio;\n        }\n\n        return 1;\n    }\n\n    _invalidate(options) {\n        if (!this.ctx) {\n            return;\n        }\n\n        const fixedScale = options && options.fixedScale;\n        const scale = fixedScale ? 1 : this._devicePixelRatio();\n        this._rescale(scale);\n\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        this.renderTo(this.ctx);\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (RootNode);\n\n\n/***/ }),\n\n/***/ \"Z3TV\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return promiseAll; });\nfunction promiseAll(promises) {\n    return Promise.all(promises);\n}\n\n/***/ }),\n\n/***/ \"ZfP6\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _core_has_observers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"7joe\");\n/* harmony import */ var _mixins_with_accessors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"bp4U\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"VqL+\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"RlWg\");\n\n\n\n\n\nclass Size extends Object(_mixins_with_accessors__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(_core_has_observers__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"], [ \"width\", \"height\" ]) {\n    constructor(width, height) {\n        super();\n\n        this.width = width || 0;\n        this.height = height || 0;\n    }\n\n    equals(other) {\n        return other && other.width === this.width && other.height === this.height;\n    }\n\n    clone() {\n        return new Size(this.width, this.height);\n    }\n\n    toArray(digits) {\n        const doRound = Object(_util__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"])(digits);\n        const width = doRound ? Object(_util__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(this.width, digits) : this.width;\n        const height = doRound ? Object(_util__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(this.height, digits) : this.height;\n\n        return [ width, height ];\n    }\n\n    static create(arg0, arg1) {\n        if (Object(_util__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"])(arg0)) {\n            if (arg0 instanceof Size) {\n                return arg0;\n            } else if (arguments.length === 1 && arg0.length === 2) {\n                return new Size(arg0[0], arg0[1]);\n            }\n\n            return new Size(arg0, arg1);\n        }\n    }\n\n    static get ZERO() {\n        return new Size(0, 0);\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Size);\n\n\n/***/ }),\n\n/***/ \"bRfn\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _path_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"UzJa\");\n/* harmony import */ var _utils_render_path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"hype\");\n\n\n\nclass ArcNode extends _path_node__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"] {\n    renderPoints(ctx) {\n        const path = this.srcElement.toPath();\n        Object(_utils_render_path__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(ctx, path);\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ArcNode);\n\n\n/***/ }),\n\n/***/ \"bSS5\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _class__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"LHUb\");\n\n\nclass Observable extends _class__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"] {\n    constructor() {\n        super();\n\n        this._events = {};\n    }\n\n    bind(eventName, handlers, one) {\n        const eventNames = getArray(eventName);\n        const handlersIsFunction = isFunction(handlers);\n        const length = eventNames.length;\n\n        if (handlers === undefined) {\n            for (let field in eventName) {\n                this.bind(field, eventName[field]);\n            }\n            return this;\n        }\n\n        for (let idx = 0; idx < length; idx++) {\n            const eventName = eventNames[idx];\n\n            let handler = handlersIsFunction ? handlers : handlers[eventName];\n\n            if (handler) {\n                if (one) {\n                    const original = handler;\n                    handler = () => { // eslint-disable-line no-loop-func\n                        this.unbind(eventName, handler);\n                        original.apply(this, arguments);\n                    };\n                    handler.original = original;\n                }\n                let events = this._events[eventName] = this._events[eventName] || [];\n                events.push(handler);\n            }\n        }\n\n        return this;\n    }\n\n    one(eventNames, handlers) {\n        return this.bind(eventNames, handlers, true);\n    }\n\n    first(eventName, handlers) {\n        const eventNames = getArray(eventName);\n        const handlersIsFunction = isFunction(handlers);\n\n        for (let idx = 0, length = eventNames.length; idx < length; idx++) {\n            const eventName = eventNames[idx];\n\n            const handler = handlersIsFunction ? handlers : handlers[eventName];\n\n            if (handler) {\n                const events = this._events[eventName] = this._events[eventName] || [];\n                events.unshift(handler);\n            }\n        }\n\n        return this;\n    }\n\n    trigger(eventName, e = {}) {\n        let events = this._events[eventName];\n\n        if (events) {\n            const length = events.length;\n\n            e.sender = this;\n            e._defaultPrevented = false;\n            e.preventDefault = preventDefault;\n            e.isDefaultPrevented = isDefaultPrevented;\n\n            events = events.slice();\n\n            for (let idx = 0; idx < length; idx++) {\n                events[idx].call(this, e);\n            }\n\n            return e._defaultPrevented === true;\n        }\n\n        return false;\n    }\n\n    unbind(eventName, handler) {\n        const events = this._events[eventName];\n\n        if (eventName === undefined) {\n            this._events = {};\n        } else if (events) {\n            if (handler) {\n                for (let idx = events.length - 1; idx >= 0; idx--) {\n                    if (events[idx] === handler || events[idx].original === handler) {\n                        events.splice(idx, 1);\n                    }\n                }\n            } else {\n                this._events[eventName] = [];\n            }\n        }\n\n        return this;\n    }\n}\n\nfunction isFunction(value) {\n    return typeof value === \"function\";\n}\n\nfunction getArray(value) {\n    return typeof value === \"string\" ? [ value ] : value;\n}\n\nfunction preventDefault() {\n    this._defaultPrevented = true;\n}\n\nfunction isDefaultPrevented() {\n    return this._defaultPrevented === true;\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Observable);\n\n/***/ }),\n\n/***/ \"bp4U\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nfunction setAccessor(field) {\n    return function(value) {\n        if (this[field] !== value) {\n            this[field] = value;\n            this.geometryChange();\n        }\n\n        return this;\n    };\n}\n\nfunction getAccessor(field) {\n    return function() {\n        return this[field];\n    };\n}\n\nfunction defineAccessors(fn, fields) {\n    for (let i = 0; i < fields.length; i++) {\n        let name = fields[i];\n        let capitalized = name.charAt(0).toUpperCase() +\n                          name.substring(1, name.length);\n\n        fn[\"set\" + capitalized] = setAccessor(name);\n        fn[\"get\" + capitalized] = getAccessor(name);\n    }\n}\n\nconst withAccessors = (TBase, names) => {\n    const result = class extends TBase {};\n    defineAccessors(result.prototype, names);\n\n    return result;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (withAccessors);\n\n\n/***/ }),\n\n/***/ \"dH2W\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return eventCoordinates; });\n/* harmony import */ var _defined__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"VqL+\");\n\n\nfunction eventCoordinates(e) {\n    if (Object(_defined__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])((e.x || {}).location)) {\n        return {\n            x: e.x.location,\n            y: e.y.location\n        };\n    }\n\n    return {\n        x: e.pageX || e.clientX || 0,\n        y: e.pageY || e.clientY || 0\n    };\n}\n\n/***/ }),\n\n/***/ \"dsTk\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return createPromise; });\nfunction createPromise() {\n    let resolveFn, rejectFn;\n    const promise = new Promise((resolve, reject) => {\n        resolveFn = (data) => {\n            promise._state = \"resolved\";\n            resolve(data);\n            return promise;\n        };\n        rejectFn = (data) => {\n            promise._state = \"rejected\";\n            reject(data);\n\n            return promise;\n        };\n    });\n    promise._state = \"pending\";\n    promise.resolve = resolveFn;\n    promise.reject = rejectFn;\n    promise.state = () => promise._state;\n\n    return promise;\n}\n\n\n/***/ }),\n\n/***/ \"e5dn\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/shapes/group.js\nvar shapes_group = __webpack_require__(\"qUqW\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/size.js\nvar geometry_size = __webpack_require__(\"ZfP6\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/rect.js\nvar geometry_rect = __webpack_require__(\"XJRY\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/point.js\nvar point = __webpack_require__(\"lRJa\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/transform.js\nvar geometry_transform = __webpack_require__(\"uBxF\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/alignment/translate-to-point.js\nvar translate_to_point = __webpack_require__(\"pVqk\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/alignment/align-start.js\nvar align_start = __webpack_require__(\"5Jba\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/alignment/align-start-reverse.js\n\nfunction alignStartReverse(size, rect, align, axis, sizeField) {\n    let start;\n    if (align === \"start\") {\n        start = rect.origin[axis] + rect.size[sizeField] - size;\n    } else if (align === \"end\") {\n        start = rect.origin[axis];\n    } else {\n        start = rect.origin[axis] + (rect.size[sizeField] - size) / 2;\n    }\n\n    return start;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/shapes/layout.js\n\n\n\n\n\n\n\n\n\nconst DEFAULT_OPTIONS = {\n    alignContent: \"start\",\n    justifyContent: \"start\",\n    alignItems: \"start\",\n    spacing: 0,\n    orientation: \"horizontal\",\n    lineSpacing: 0,\n    wrap: true,\n    revers: false\n};\n\nconst forEach = (elements, callback) => {\n    elements.forEach(callback);\n};\n\nconst forEachReverse = (elements, callback) => {\n    const length = elements.length;\n\n    for (let idx = length - 1; idx >= 0; idx--) {\n        callback(elements[idx], idx);\n    }\n};\n\nclass layout_Layout extends shapes_group[\"a\" /* default */] {\n\n    constructor(rect, options) {\n        super(Object.assign({}, DEFAULT_OPTIONS, options));\n        this._rect = rect;\n        this._fieldMap = {};\n    }\n\n    rect(value) {\n        if (value) {\n            this._rect = value;\n            return this;\n        }\n\n        return this._rect;\n    }\n\n    _initMap() {\n        const options = this.options;\n        const fieldMap = this._fieldMap;\n        if (options.orientation === \"horizontal\") {\n            fieldMap.sizeField = \"width\";\n            fieldMap.groupsSizeField = \"height\";\n            fieldMap.groupAxis = \"x\";\n            fieldMap.groupsAxis = \"y\";\n        } else {\n            fieldMap.sizeField = \"height\";\n            fieldMap.groupsSizeField = \"width\";\n            fieldMap.groupAxis = \"y\";\n            fieldMap.groupsAxis = \"x\";\n        }\n\n        if (options.reverse) {\n            this.forEach = forEachReverse;\n            this.justifyAlign = alignStartReverse;\n        } else {\n            this.forEach = forEach;\n            this.justifyAlign = align_start[\"a\" /* default */];\n        }\n    }\n\n    reflow() {\n        if (!this._rect || this.children.length === 0) {\n            return;\n        }\n        this._initMap();\n\n        if (this.options.transform) {\n            this.transform(null);\n        }\n\n        const options = this.options;\n        const rect = this._rect;\n        const { groups, groupsSize } = this._initGroups();\n        const { sizeField, groupsSizeField, groupAxis, groupsAxis } = this._fieldMap;\n        const groupOrigin = new point[\"a\" /* default */]();\n        const elementOrigin = new point[\"a\" /* default */]();\n        const size = new geometry_size[\"a\" /* default */]();\n        let groupStart = Object(align_start[\"a\" /* default */])(groupsSize, rect, options.alignContent, groupsAxis, groupsSizeField);\n        let elementStart, group, groupBox;\n\n        const arrangeElements = (bbox, idx) => {\n            const element = group.elements[idx];\n\n            elementOrigin[groupAxis] = elementStart;\n            elementOrigin[groupsAxis] = Object(align_start[\"a\" /* default */])(bbox.size[groupsSizeField], groupBox, options.alignItems, groupsAxis, groupsSizeField);\n            Object(translate_to_point[\"a\" /* default */])(elementOrigin, bbox, element);\n            elementStart += bbox.size[sizeField] + options.spacing;\n        };\n\n        for (let groupIdx = 0; groupIdx < groups.length; groupIdx++) {\n            group = groups[groupIdx];\n            groupOrigin[groupAxis] = elementStart = this.justifyAlign(group.size, rect, options.justifyContent, groupAxis, sizeField);\n            groupOrigin[groupsAxis] = groupStart;\n            size[sizeField] = group.size;\n            size[groupsSizeField] = group.lineSize;\n            groupBox = new geometry_rect[\"a\" /* default */](groupOrigin, size);\n            this.forEach(group.bboxes, arrangeElements);\n\n            groupStart += group.lineSize + options.lineSpacing;\n        }\n\n        if (!options.wrap && group.size > rect.size[sizeField]) {\n            const scale = rect.size[sizeField] / groupBox.size[sizeField];\n            const scaledStart = groupBox.topLeft().scale(scale, scale);\n            const scaledSize = groupBox.size[groupsSizeField] * scale;\n            const newStart = Object(align_start[\"a\" /* default */])(scaledSize, rect, options.alignContent, groupsAxis, groupsSizeField);\n            const transform = Object(geometry_transform[\"a\" /* default */])();\n            if (groupAxis === \"x\") {\n                transform.translate(rect.origin.x - scaledStart.x, newStart - scaledStart.y);\n            } else {\n                transform.translate(newStart - scaledStart.x, rect.origin.y - scaledStart.y);\n            }\n            transform.scale(scale, scale);\n\n            this.transform(transform);\n        }\n    }\n\n    _initGroups() {\n        const { options, children } = this;\n        const { lineSpacing, wrap, spacing } = options;\n        const sizeField = this._fieldMap.sizeField;\n        let group = this._newGroup();\n        const groups = [];\n        const addGroup = function() {\n            groups.push(group);\n            groupsSize += group.lineSize + lineSpacing;\n        };\n        let groupsSize = -lineSpacing;\n\n        for (let idx = 0; idx < children.length; idx++) {\n            let element = children[idx];\n            let bbox = children[idx].clippedBBox();\n            if (element.visible() && bbox) {\n                if (wrap && group.size + bbox.size[sizeField] + spacing > this._rect.size[sizeField]) {\n                    if (group.bboxes.length === 0) {\n                        this._addToGroup(group, bbox, element);\n                        addGroup();\n                        group = this._newGroup();\n                    } else {\n                        addGroup();\n                        group = this._newGroup();\n                        this._addToGroup(group, bbox, element);\n                    }\n                } else {\n                    this._addToGroup(group, bbox, element);\n                }\n            }\n        }\n\n        if (group.bboxes.length) {\n            addGroup();\n        }\n\n        return {\n            groups: groups,\n            groupsSize: groupsSize\n        };\n    }\n\n    _addToGroup(group, bbox, element) {\n        group.size += bbox.size[this._fieldMap.sizeField] + this.options.spacing;\n        group.lineSize = Math.max(bbox.size[this._fieldMap.groupsSizeField], group.lineSize);\n        group.bboxes.push(bbox);\n        group.elements.push(element);\n    }\n\n    _newGroup() {\n        return {\n            lineSize: 0,\n            size: -this.options.spacing,\n            bboxes: [],\n            elements: []\n        };\n    }\n}\n\n/* harmony default export */ var layout = __webpack_exports__[\"a\"] = (layout_Layout);\n\n/***/ }),\n\n/***/ \"eMc0\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return exportGroup; });\n/* harmony import */ var _root_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"wJcK\");\n/* harmony import */ var _shapes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"qUqW\");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"uBxF\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"V34t\");\n\n\n\n\n\nfunction exportGroup(group) {\n    const root = new _root_node__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"]({\n        skipBaseHref: true\n    });\n    const bbox = group.clippedBBox();\n    let rootGroup = group;\n\n    if (bbox) {\n        const origin = bbox.getOrigin();\n        const exportRoot = new _shapes__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"]();\n        exportRoot.transform(Object(_geometry__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"])().translate(-origin.x, -origin.y));\n        exportRoot.children.push(group);\n        rootGroup = exportRoot;\n    }\n\n    root.load([ rootGroup ]);\n\n    const svg = `<?xml version='1.0' ?><svg xmlns='${ _constants__WEBPACK_IMPORTED_MODULE_3__[/* SVG_NS */ \"b\"] }' xmlns:xlink='http://www.w3.org/1999/xlink' version='1.1'>${ root.render() }</svg>`;\n\n    root.destroy();\n\n    return svg;\n}\n\n/***/ }),\n\n/***/ \"eO0B\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return exportSVG; });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"iYt6\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"dsTk\");\n/* harmony import */ var _export_group__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"eMc0\");\n\n\n\nfunction exportSVG(group, options) {\n    let svg = Object(_export_group__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"])(group);\n\n    if (!options || !options.raw) {\n        svg = \"data:image/svg+xml;base64,\" + Object(_util__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(svg);\n    }\n\n    return Object(_util__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])().resolve(svg);\n}\n\n\n/***/ }),\n\n/***/ \"f4aR\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return close; });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"TD7o\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"RlWg\");\n\n\n\n\nfunction close(a, b, tolerance = _constants__WEBPACK_IMPORTED_MODULE_0__[/* PRECISION */ \"a\"]) {\n    return Object(_util__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(Math.abs(a - b), tolerance) === 0;\n}\n\n/***/ }),\n\n/***/ \"fdcc\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nconst traversable = (TBase, childrenField) => (\n    class extends TBase {\n        traverse(callback) {\n            const children = this[childrenField];\n\n            for (let i = 0; i < children.length; i++) {\n                let child = children[i];\n\n                if (child.traverse) {\n                    child.traverse(callback);\n                } else {\n                    callback(child);\n                }\n            }\n\n            return this;\n        }\n    }\n);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (traversable);\n\n\n/***/ }),\n\n/***/ \"gNPy\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"7Prh\");\n\n\nclass ClipNode extends _node__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"] {\n    constructor(srcElement) {\n        super();\n\n        this.srcElement = srcElement;\n        this.id = srcElement.id;\n\n        this.load([ srcElement ]);\n    }\n\n    template() {\n        return `<clipPath id='${ this.id }'>${ this.renderChildren() }</clipPath>`;\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ClipNode);\n\n/***/ }),\n\n/***/ \"gQeN\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nconst NODE_MAP = {};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (NODE_MAP);\n\n/***/ }),\n\n/***/ \"gofQ\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _core_has_observers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"7joe\");\n/* harmony import */ var _to_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"x/GK\");\n/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"hL34\");\n/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"lRJa\");\n\n\n\n\n\nclass Transformation extends _core_has_observers__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"] {\n    constructor(matrix = _matrix__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"].unit()) {\n        super();\n\n        this._matrix = matrix;\n    }\n\n    clone() {\n        return new Transformation(\n            this._matrix.clone()\n        );\n    }\n\n    equals(other) {\n        return other &&\n               other._matrix.equals(this._matrix);\n    }\n\n    translate(x, y) {\n        this._matrix = this._matrix.multiplyCopy(_matrix__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"].translate(x, y));\n\n        this._optionsChange();\n        return this;\n    }\n\n    scale(scaleX, scaleY = scaleX, origin = null) {\n        let originPoint = origin;\n\n        if (originPoint) {\n            originPoint = _point__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"].create(originPoint);\n            this._matrix = this._matrix.multiplyCopy(_matrix__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"].translate(originPoint.x, originPoint.y));\n        }\n\n        this._matrix = this._matrix.multiplyCopy(_matrix__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"].scale(scaleX, scaleY));\n\n        if (originPoint) {\n            this._matrix = this._matrix.multiplyCopy(_matrix__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"].translate(-originPoint.x, -originPoint.y));\n        }\n\n        this._optionsChange();\n        return this;\n    }\n\n    rotate(angle, origin) {\n        const originPoint = _point__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"].create(origin) || _point__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"].ZERO;\n\n        this._matrix = this._matrix.multiplyCopy(_matrix__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"].rotate(angle, originPoint.x, originPoint.y));\n\n        this._optionsChange();\n        return this;\n    }\n\n    multiply(transformation) {\n        const matrix = Object(_to_matrix__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(transformation);\n\n        this._matrix = this._matrix.multiplyCopy(matrix);\n\n        this._optionsChange();\n        return this;\n    }\n\n    matrix(value) {\n        if (value) {\n            this._matrix = value;\n            this._optionsChange();\n            return this;\n        }\n\n        return this._matrix;\n    }\n\n    _optionsChange() {\n        this.optionsChange({\n            field: \"transform\",\n            value: this\n        });\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Transformation);\n\n\n/***/ }),\n\n/***/ \"hL34\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"LHUb\");\n/* harmony import */ var _util_defined__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"VqL+\");\n/* harmony import */ var _util_rad__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"6USk\");\n/* harmony import */ var _util_round__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"RlWg\");\n\n\n\n\nlet Matrix = /*@__PURE__*/ (() => {\n    class Matrix extends _common__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"] {\n        constructor(a = 0, b = 0, c = 0, d = 0, e = 0, f = 0) {\n            super();\n            this.a = a;\n            this.b = b;\n            this.c = c;\n            this.d = d;\n            this.e = e;\n            this.f = f;\n        }\n        multiplyCopy(matrix) {\n            return new Matrix(this.a * matrix.a + this.c * matrix.b, this.b * matrix.a + this.d * matrix.b, this.a * matrix.c + this.c * matrix.d, this.b * matrix.c + this.d * matrix.d, this.a * matrix.e + this.c * matrix.f + this.e, this.b * matrix.e + this.d * matrix.f + this.f);\n        }\n        invert() {\n            const { a, b, c: d, d: e, e: g, f: h } = this;\n            const det = a * e - b * d;\n            if (det === 0) {\n                return null;\n            }\n            return new Matrix(e / det, -b / det, -d / det, a / det, (d * h - e * g) / det, (b * g - a * h) / det);\n        }\n        clone() {\n            return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);\n        }\n        equals(other) {\n            if (!other) {\n                return false;\n            }\n            return this.a === other.a && this.b === other.b &&\n                this.c === other.c && this.d === other.d &&\n                this.e === other.e && this.f === other.f;\n        }\n        round(precision) {\n            this.a = Object(_util_round__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(this.a, precision);\n            this.b = Object(_util_round__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(this.b, precision);\n            this.c = Object(_util_round__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(this.c, precision);\n            this.d = Object(_util_round__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(this.d, precision);\n            this.e = Object(_util_round__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(this.e, precision);\n            this.f = Object(_util_round__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(this.f, precision);\n            return this;\n        }\n        toArray(precision) {\n            const result = [this.a, this.b, this.c, this.d, this.e, this.f];\n            if (Object(_util_defined__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(precision)) {\n                for (let i = 0; i < result.length; i++) {\n                    result[i] = Object(_util_round__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(result[i], precision);\n                }\n            }\n            return result;\n        }\n        toString(precision, separator = \",\") {\n            return this.toArray(precision).join(separator);\n        }\n        static translate(x, y) {\n            return new Matrix(1, 0, 0, 1, x, y);\n        }\n        static unit() {\n            return new Matrix(1, 0, 0, 1, 0, 0);\n        }\n        static rotate(angle, x, y) {\n            const matrix = new Matrix();\n            matrix.a = Math.cos(Object(_util_rad__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"])(angle));\n            matrix.b = Math.sin(Object(_util_rad__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"])(angle));\n            matrix.c = -matrix.b;\n            matrix.d = matrix.a;\n            matrix.e = (x - x * matrix.a + y * matrix.b) || 0;\n            matrix.f = (y - y * matrix.a - x * matrix.b) || 0;\n            return matrix;\n        }\n        static scale(scaleX, scaleY) {\n            return new Matrix(scaleX, 0, 0, scaleY, 0, 0);\n        }\n    }\n    Matrix.IDENTITY = Matrix.unit();\n    return Matrix;\n})();\n/* harmony default export */ __webpack_exports__[\"a\"] = (Matrix);\n\n\n/***/ }),\n\n/***/ \"hSuW\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nconst now = Date.now || function() {\n    return new Date().getTime();\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (now);\n\n\n/***/ }),\n\n/***/ \"hype\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return renderPath; });\n\nfunction renderPath(ctx, path) {\n    const segments = path.segments;\n\n    if (segments.length === 0) {\n        return;\n    }\n\n    let segment = segments[0];\n    let anchor = segment.anchor();\n    ctx.moveTo(anchor.x, anchor.y);\n\n    for (let i = 1; i < segments.length; i++) {\n        segment = segments[i];\n        anchor = segment.anchor();\n\n        let prevSeg = segments[i - 1];\n        let prevOut = prevSeg.controlOut();\n        let controlIn = segment.controlIn();\n\n        if (prevOut && controlIn) {\n            ctx.bezierCurveTo(prevOut.x, prevOut.y,\n                              controlIn.x, controlIn.y,\n                              anchor.x, anchor.y);\n        } else {\n            ctx.lineTo(anchor.x, anchor.y);\n        }\n    }\n\n    if (path.options.closed) {\n        ctx.closePath();\n    }\n}\n\n/***/ }),\n\n/***/ \"i9ZU\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return append; });\nfunction append(first, second) {\n    first.push.apply(first, second);\n    return first;\n}\n\n/***/ }),\n\n/***/ \"iYt6\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ encodeBase64; });\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/encode-utf.js\nconst fromCharCode = String.fromCharCode;\n\nconst BOM = '\\xfe\\xff';\n\n// Encodes a string as UTF-8\nfunction encodeUTF8(input) {\n    let output = \"\";\n\n    for (let i = 0; i < input.length; i++) {\n        let code = input.charCodeAt(i);\n\n        if (0xD800 <= code && code <= 0xDBFF) {\n            const hi = code;\n            const low = input.charCodeAt(++i);\n\n            if (!isNaN(low)) {\n                // Combine high and low surrogate\n                // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt\n                code = (hi - 0xD800) * 0x400 +\n                       (low - 0xDC00) + 0x10000;\n            }\n        }\n\n        if (code < 0x80) {\n            // One byte\n            output += fromCharCode(code);\n        } else if (code < 0x800) {\n            // Two bytes\n            output += fromCharCode(0xC0 | (code >>> 6));\n            output += fromCharCode(0x80 | (code & 0x3f));\n        } else if (code < 0x10000) {\n            // Three bytes\n            output += fromCharCode(0xE0 | (code >>> 12));\n            output += fromCharCode(0x80 | (code >>> 6 & 0x3f));\n            output += fromCharCode(0x80 | (code & 0x3f));\n        } else if (code < 0x10FFFF) {\n            // Four bytes\n            output += fromCharCode(0xF0 | (code >>> 18));\n            output += fromCharCode(0x80 | (code >>> 12 & 0x3f));\n            output += fromCharCode(0x80 | (code >>> 6 & 0x3f));\n            output += fromCharCode(0x80 | (code & 0x3f));\n        }\n    }\n\n    return output;\n}\n\nfunction encodeUnit(codeUnit) {\n    return fromCharCode(codeUnit >> 8) + fromCharCode(codeUnit & 0x00ff);\n}\n\n// Encodes a string as UTF-16 big-endian\nfunction encodeUTF16BE(input) {\n    let output = '';\n\n    for (let i = 0; i < input.length; i++) {\n        const c = input.charCodeAt(i);\n\n        if (c < 0xFFFF) {\n            output += encodeUnit(c);\n        } else {\n            const lead = ((c - 0x10000) >> 10) + 0xD800;\n            const trail = ((c - 0x10000) & 0x3FF) + 0xDC00;\n            output += encodeUnit(lead);\n            output += encodeUnit(trail);\n        }\n    }\n\n    return output;\n}\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/encode-base64.js\n\n\nconst KEY_STR = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\nfunction encodeBase64(input) {\n    let output = \"\";\n    let i = 0;\n\n    const utfInput = encodeUTF8(input);\n\n    while (i < utfInput.length) {\n        let chr1 = utfInput.charCodeAt(i++);\n        let chr2 = utfInput.charCodeAt(i++);\n        let chr3 = utfInput.charCodeAt(i++);\n\n        let enc1 = chr1 >> 2;\n        let enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n        let enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n        let enc4 = chr3 & 63;\n\n        if (isNaN(chr2)) {\n            enc3 = enc4 = 64;\n        } else if (isNaN(chr3)) {\n            enc4 = 64;\n        }\n\n        output = output +\n            KEY_STR.charAt(enc1) + KEY_STR.charAt(enc2) +\n            KEY_STR.charAt(enc3) + KEY_STR.charAt(enc4);\n    }\n\n    return output;\n}\n\n/***/ }),\n\n/***/ \"ijzS\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _path_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"UzJa\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"dsTk\");\n\n\n\nclass ImageNode extends _path_node__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"] {\n    constructor(srcElement, cors) {\n        super(srcElement);\n\n        this.onLoad = this.onLoad.bind(this);\n        this.onError = this.onError.bind(this);\n\n        this.loading = Object(_util__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])();\n\n        const img = this.img = new Image();\n\n        if (cors && !(/^data:/i.test(srcElement.src()))) {\n            img.crossOrigin = cors;\n        }\n\n        img.src = srcElement.src();\n\n        if (img.complete) {\n            this.onLoad();\n        } else {\n            img.onload = this.onLoad;\n            img.onerror = this.onError;\n        }\n    }\n\n    renderTo(ctx) {\n        if (this.loading.state() === \"resolved\") {\n            ctx.save();\n\n            this.setTransform(ctx);\n            this.setClip(ctx);\n\n            this.drawImage(ctx);\n\n            ctx.restore();\n        }\n    }\n\n    optionsChange(e) {\n        if (e.field === \"src\") {\n            this.loading = Object(_util__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])();\n            this.img.src = this.srcElement.src();\n        } else {\n            super.optionsChange(e);\n        }\n    }\n\n    onLoad() {\n        this.loading.resolve();\n        this.invalidate();\n    }\n\n    onError() {\n        this.loading.reject(new Error(\n            \"Unable to load image '\" + this.img.src +\n            \"'. Check for connectivity and verify CORS headers.\"\n        ));\n    }\n\n    drawImage(ctx) {\n        const rect = this.srcElement.rect();\n        const topLeft = rect.topLeft();\n\n        ctx.drawImage(\n            this.img, topLeft.x, topLeft.y, rect.width(), rect.height()\n        );\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (ImageNode);\n\n\n/***/ }),\n\n/***/ \"inPS\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _gradient_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"7PhV\");\n\n\nclass RadialGradientNode extends _gradient_node__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"] {\n    template() {\n        return `<radialGradient id='${ this.id }' ${ this.renderCoordinates()}>${ this.renderChildren() }</radialGradient>`;\n    }\n\n    mapCoordinates() {\n        const srcElement = this.srcElement;\n        const center = srcElement.center();\n        const radius = srcElement.radius();\n        const attrs = [\n            [ \"cx\", center.x ],\n            [ \"cy\", center.y ],\n            [ \"r\", radius ],\n            this.mapSpace()\n        ];\n        return attrs;\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (RadialGradientNode);\n\n/***/ }),\n\n/***/ \"jQ5i\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _lru_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"kTcp\");\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"LHUb\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"C91f\");\n\n\n\nfunction zeroSize() {\n    return { width: 0, height: 0, baseline: 0 };\n}\nconst DEFAULT_OPTIONS = {\n    baselineMarkerSize: 1\n};\nlet defaultMeasureBox;\nif (typeof document !== \"undefined\") {\n    defaultMeasureBox = document.createElement(\"div\");\n    defaultMeasureBox.style.cssText = \"position: absolute !important; top: -4000px !important; width: auto !important; height: auto !important;\" +\n        \"padding: 0 !important; margin: 0 !important; border: 0 !important;\" +\n        \"line-height: normal !important; visibility: hidden !important; white-space: pre!important;\";\n}\nlet TextMetrics = /*@__PURE__*/ (() => {\n    class TextMetrics extends _common__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"] {\n        constructor(options) {\n            super();\n            this._cache = new _lru_cache__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"](1000);\n            this.options = Object.assign({}, DEFAULT_OPTIONS, options);\n        }\n        measure(text, style, options = {}) {\n            if (typeof text === 'undefined' || text === null) {\n                return zeroSize();\n            }\n            const styleKey = Object(_util__WEBPACK_IMPORTED_MODULE_2__[/* objectKey */ \"c\"])(style);\n            const cacheKey = Object(_util__WEBPACK_IMPORTED_MODULE_2__[/* hashKey */ \"a\"])(text + styleKey);\n            const cachedResult = this._cache.get(cacheKey);\n            if (cachedResult) {\n                return cachedResult;\n            }\n            const size = zeroSize();\n            const measureBox = options.box || defaultMeasureBox;\n            const baselineMarker = this._baselineMarker().cloneNode(false);\n            for (let key in style) {\n                let value = style[key];\n                if (typeof value !== \"undefined\") {\n                    measureBox.style[key] = value;\n                }\n            }\n            const textStr = options.normalizeText !== false ? Object(_util__WEBPACK_IMPORTED_MODULE_2__[/* normalizeText */ \"b\"])(text) : String(text);\n            measureBox.textContent = textStr;\n            measureBox.appendChild(baselineMarker);\n            document.body.appendChild(measureBox);\n            if (textStr.length) {\n                size.width = measureBox.offsetWidth - this.options.baselineMarkerSize;\n                size.height = measureBox.offsetHeight;\n                size.baseline = baselineMarker.offsetTop + this.options.baselineMarkerSize;\n            }\n            if (size.width > 0 && size.height > 0) {\n                this._cache.put(cacheKey, size);\n            }\n            measureBox.parentNode.removeChild(measureBox);\n            return size;\n        }\n        _baselineMarker() {\n            const marker = document.createElement(\"div\");\n            marker.style.cssText = \"display: inline-block; vertical-align: baseline;width: \" +\n                this.options.baselineMarkerSize + \"px; height: \" + this.options.baselineMarkerSize + \"px;overflow: hidden;\";\n            return marker;\n        }\n    }\n    TextMetrics.current = new TextMetrics();\n    return TextMetrics;\n})();\n/* harmony default export */ __webpack_exports__[\"a\"] = (TextMetrics);\n\n\n/***/ }),\n\n/***/ \"kGoT\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/core/surface.js\nvar surface = __webpack_require__(\"mcME\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/element-size.js\nvar element_size = __webpack_require__(\"wd4i\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/bind-events.js\nvar bind_events = __webpack_require__(\"APnZ\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/unbind-events.js\nvar unbind_events = __webpack_require__(\"Aie7\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/create-promise.js\nvar create_promise = __webpack_require__(\"dsTk\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/promise-all.js\nvar promise_all = __webpack_require__(\"Z3TV\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/canvas/root-node.js\nvar root_node = __webpack_require__(\"Ytya\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/search/shapes-quad-tree.js\nvar shapes_quad_tree = __webpack_require__(\"5FN0\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/defined.js\nvar defined = __webpack_require__(\"VqL+\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/canvas/surface-cursor.js\n\n\nclass surface_cursor_SurfaceCursor {\n\n    constructor(surface) {\n        surface.bind(\"mouseenter\", this._mouseenter.bind(this));\n        surface.bind(\"mouseleave\", this._mouseleave.bind(this));\n\n        this.element = surface.element;\n    }\n\n    clear() {\n        this._resetCursor();\n    }\n\n    destroy() {\n        this._resetCursor();\n        delete this.element;\n    }\n\n    _mouseenter(e) {\n        const cursor = this._shapeCursor(e);\n\n        if (!cursor) {\n            this._resetCursor();\n        } else {\n            if (!this._current) {\n                this._defaultCursor = this._getCursor();\n            }\n\n            this._setCursor(cursor);\n        }\n    }\n\n    _mouseleave() {\n        this._resetCursor();\n    }\n\n    _shapeCursor(e) {\n        let shape = e.element;\n\n        while (shape && !Object(defined[\"a\" /* default */])(shape.options.cursor)) {\n            shape = shape.parent;\n        }\n\n        if (shape) {\n            return shape.options.cursor;\n        }\n    }\n\n    _getCursor() {\n        if (this.element) {\n            return this.element.style.cursor;\n        }\n    }\n\n    _setCursor(cursor) {\n        if (this.element) {\n            this.element.style.cursor = cursor;\n            this._current = cursor;\n        }\n    }\n\n    _resetCursor() {\n        if (this._current) {\n            this._setCursor(this._defaultCursor || \"\");\n            delete this._current;\n        }\n    }\n}\n\n/* harmony default export */ var surface_cursor = (surface_cursor_SurfaceCursor);\n\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/canvas/arc-node.js\nvar arc_node = __webpack_require__(\"bRfn\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/canvas/circle-node.js\nvar circle_node = __webpack_require__(\"FSED\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/canvas/group-node.js\nvar group_node = __webpack_require__(\"xYjD\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/canvas/image-node.js\nvar image_node = __webpack_require__(\"ijzS\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/canvas/multi-path-node.js\nvar multi_path_node = __webpack_require__(\"5HPa\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/canvas/path-node.js\nvar path_node = __webpack_require__(\"UzJa\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/canvas/rect-node.js\nvar rect_node = __webpack_require__(\"SMq3\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/canvas/text-node.js\nvar text_node = __webpack_require__(\"G/KS\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/canvas/node-map.js\nvar node_map = __webpack_require__(\"gQeN\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/canvas/surface.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nnode_map[\"a\" /* default */].Arc = arc_node[\"a\" /* default */];\nnode_map[\"a\" /* default */].Circle = circle_node[\"a\" /* default */];\nnode_map[\"a\" /* default */].Group = group_node[\"a\" /* default */];\nnode_map[\"a\" /* default */].Image = image_node[\"a\" /* default */];\nnode_map[\"a\" /* default */].MultiPath = multi_path_node[\"a\" /* default */];\nnode_map[\"a\" /* default */].Path = path_node[\"a\" /* default */];\nnode_map[\"a\" /* default */].Rect = rect_node[\"a\" /* default */];\nnode_map[\"a\" /* default */].Text = text_node[\"a\" /* default */];\n\n\nclass surface_Surface extends surface[\"a\" /* default */] {\n    get type() {\n        return \"canvas\";\n    }\n\n    constructor(element, options) {\n        super(element, options);\n\n        this.element.innerHTML = this._template(this);\n\n        const canvas = this.element.firstElementChild;\n        const size = Object(element_size[\"a\" /* default */])(element);\n\n        canvas.width = size.width;\n        canvas.height = size.height;\n\n        this._rootElement = canvas;\n\n        this._root = new root_node[\"a\" /* default */](canvas, size);\n\n        this._mouseTrackHandler = this._trackMouse.bind(this);\n\n        Object(bind_events[\"a\" /* default */])(this.element, {\n            click: this._mouseTrackHandler,\n            mousemove: this._mouseTrackHandler\n        });\n    }\n\n    destroy() {\n        super.destroy();\n\n        if (this._root) {\n            this._root.destroy();\n            this._root = null;\n        }\n\n        if (this._searchTree) {\n            this._searchTree.clear();\n            delete this._searchTree;\n        }\n\n        if (this._cursor) {\n            this._cursor.destroy();\n            delete this._cursor;\n        }\n\n        Object(unbind_events[\"a\" /* default */])(this.element, {\n            click: this._mouseTrackHandler,\n            mousemove: this._mouseTrackHandler\n        });\n    }\n\n    draw(element) {\n        super.draw(element);\n        this._root.load([ element ], undefined, this.options.cors);\n\n        if (this._searchTree) {\n            this._searchTree.add([ element ]);\n        }\n    }\n\n    clear() {\n        super.clear();\n        this._root.clear();\n\n        if (this._searchTree) {\n            this._searchTree.clear();\n        }\n\n        if (this._cursor) {\n            this._cursor.clear();\n        }\n    }\n\n    eventTarget(e) {\n        if (this._searchTree) {\n            const point = this._surfacePoint(e);\n            const shape = this._searchTree.pointShape(point);\n            return shape;\n        }\n    }\n\n    image() {\n        const { _root: root, _rootElement: rootElement } = this;\n        const loadingStates = [];\n\n        root.traverse((childNode) => {\n            if (childNode.loading) {\n                loadingStates.push(childNode.loading);\n            }\n        });\n\n        const promise = Object(create_promise[\"a\" /* default */])();\n        const resolveDataURL = () => {\n            root._invalidate({ fixedScale: true });\n\n            try {\n                const data = rootElement.toDataURL();\n                promise.resolve(data);\n            } catch (e) {\n                promise.reject(e);\n            }\n        };\n\n        Object(promise_all[\"a\" /* default */])(loadingStates).then(resolveDataURL, resolveDataURL);\n\n        return promise;\n    }\n\n    suspendTracking() {\n        super.suspendTracking();\n        if (this._searchTree) {\n            this._searchTree.clear();\n            delete this._searchTree;\n        }\n    }\n\n    resumeTracking() {\n        super.resumeTracking();\n        if (!this._searchTree) {\n            this._searchTree = new shapes_quad_tree[\"a\" /* default */]();\n\n            const childNodes = this._root.childNodes;\n            const rootElements = [];\n            for (let idx = 0; idx < childNodes.length; idx++) {\n                rootElements.push(childNodes[idx].srcElement);\n            }\n            this._searchTree.add(rootElements);\n        }\n    }\n\n    _resize() {\n        this._rootElement.width = this._size.width;\n        this._rootElement.height = this._size.height;\n\n        this._root.size = this._size;\n        this._root.invalidate();\n    }\n\n    _template() {\n        return \"<canvas style='width: 100%; height: 100%;'></canvas>\";\n    }\n\n    _enableTracking() {\n        this._searchTree = new shapes_quad_tree[\"a\" /* default */]();\n        this._cursor = new surface_cursor(this);\n\n        super._enableTracking();\n    }\n\n    _trackMouse(e) {\n        if (this._suspendedTracking) {\n            return;\n        }\n\n        const shape = this.eventTarget(e);\n\n        if (e.type !== \"click\") {\n            const currentShape = this._currentShape;\n            if (currentShape && currentShape !== shape) {\n                this.trigger(\"mouseleave\", {\n                    element: currentShape,\n                    originalEvent: e,\n                    type: \"mouseleave\"\n                });\n            }\n\n            if (shape && currentShape !== shape) {\n                this.trigger(\"mouseenter\", {\n                    element: shape,\n                    originalEvent: e,\n                    type: \"mouseenter\"\n                });\n            }\n\n            this.trigger(\"mousemove\", {\n                element: shape,\n                originalEvent: e,\n                type: \"mousemove\"\n            });\n\n            this._currentShape = shape;\n        } else if (shape) {\n            this.trigger(\"click\", {\n                element: shape,\n                originalEvent: e,\n                type: \"click\"\n            });\n        }\n    }\n}\n\n/* harmony default export */ var canvas_surface = __webpack_exports__[\"a\"] = (surface_Surface);\n\n\n/***/ }),\n\n/***/ \"kTcp\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"LHUb\");\n\n\nclass LRUCache extends _common__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"] {\n    constructor(size) {\n        super();\n\n        this._size = size;\n        this._length = 0;\n        this._map = {};\n    }\n\n    put(key, value) {\n        const map = this._map;\n        const entry = { key: key, value: value };\n\n        map[key] = entry;\n\n        if (!this._head) {\n            this._head = this._tail = entry;\n        } else {\n            this._tail.newer = entry;\n            entry.older = this._tail;\n            this._tail = entry;\n        }\n\n        if (this._length >= this._size) {\n            map[this._head.key] = null;\n            this._head = this._head.newer;\n            this._head.older = null;\n        } else {\n            this._length++;\n        }\n    }\n\n    get(key) {\n        const entry = this._map[key];\n\n        if (entry) {\n            if (entry === this._head && entry !== this._tail) {\n                this._head = entry.newer;\n                this._head.older = null;\n            }\n\n            if (entry !== this._tail) {\n                if (entry.older) {\n                    entry.older.newer = entry.newer;\n                    entry.newer.older = entry.older;\n                }\n\n                entry.older = this._tail;\n                entry.newer = null;\n\n                this._tail.newer = entry;\n                this._tail = entry;\n            }\n\n            return entry.value;\n        }\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (LRUCache);\n\n/***/ }),\n\n/***/ \"l/PP\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return logToConsole; });\n/* eslint-disable no-console */\n\nfunction logToConsole(message) {\n    const console = window.console;\n\n    if (typeof(console) != \"undefined\" && console.log) {\n        console.log(message);\n    }\n}\n\n/***/ }),\n\n/***/ \"lRJa\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _mixins_with_accessors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"bp4U\");\n/* harmony import */ var _core_has_observers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"7joe\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"RlWg\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"VqL+\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"2Ic7\");\n/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"hL34\");\n/* harmony import */ var _to_matrix__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(\"x/GK\");\n\n\n\n\n\n\n\nclass Point extends Object(_mixins_with_accessors__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(_core_has_observers__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"], [ \"x\", \"y\" ]) {\n    constructor(x, y) {\n        super();\n\n        this.x = x || 0;\n        this.y = y || 0;\n    }\n\n    equals(other) {\n        return other && other.x === this.x && other.y === this.y;\n    }\n\n    clone() {\n        return new Point(this.x, this.y);\n    }\n\n    rotate(angle, origin) {\n        const originPoint = Point.create(origin) || Point.ZERO;\n\n        return this.transform(_matrix__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"].rotate(angle, originPoint.x, originPoint.y));\n    }\n\n    translate(x, y) {\n        this.x += x;\n        this.y += y;\n\n        this.geometryChange();\n\n        return this;\n    }\n\n    translateWith(point) {\n        return this.translate(point.x, point.y);\n    }\n\n    move(x, y) {\n        this.x = this.y = 0;\n        return this.translate(x, y);\n    }\n\n    scale(scaleX, scaleY = scaleX) {\n        this.x *= scaleX;\n        this.y *= scaleY;\n\n        this.geometryChange();\n\n        return this;\n    }\n\n    scaleCopy(scaleX, scaleY) {\n        return this.clone().scale(scaleX, scaleY);\n    }\n\n    transform(transformation) {\n        const matrix = Object(_to_matrix__WEBPACK_IMPORTED_MODULE_6__[/* default */ \"a\"])(transformation);\n        const { x, y } = this;\n\n        this.x = matrix.a * x + matrix.c * y + matrix.e;\n        this.y = matrix.b * x + matrix.d * y + matrix.f;\n\n        this.geometryChange();\n\n        return this;\n    }\n\n    transformCopy(transformation) {\n        const point = this.clone();\n\n        if (transformation) {\n            point.transform(transformation);\n        }\n\n        return point;\n    }\n\n    distanceTo(point) {\n        const dx = this.x - point.x;\n        const dy = this.y - point.y;\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    round(digits) {\n        this.x = Object(_util__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"])(this.x, digits);\n        this.y = Object(_util__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"])(this.y, digits);\n\n        this.geometryChange();\n\n        return this;\n    }\n\n    toArray(digits) {\n        const doRound = Object(_util__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(digits);\n        const x = doRound ? Object(_util__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"])(this.x, digits) : this.x;\n        const y = doRound ? Object(_util__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"])(this.y, digits) : this.y;\n\n        return [ x, y ];\n    }\n\n    toString(digits, separator = \" \") {\n        let { x, y } = this;\n\n        if (Object(_util__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(digits)) {\n            x = Object(_util__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"])(x, digits);\n            y = Object(_util__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"])(y, digits);\n        }\n\n        return x + separator + y;\n    }\n\n    static create(arg0, arg1) {\n        if (Object(_util__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(arg0)) {\n            if (arg0 instanceof Point) {\n                return arg0;\n            } else if (arguments.length === 1 && arg0.length === 2) {\n                return new Point(arg0[0], arg0[1]);\n            }\n\n            return new Point(arg0, arg1);\n        }\n    }\n\n    static min() {\n        let minX = _util__WEBPACK_IMPORTED_MODULE_4__[/* MAX_NUM */ \"b\"];\n        let minY = _util__WEBPACK_IMPORTED_MODULE_4__[/* MAX_NUM */ \"b\"];\n\n        for (let i = 0; i < arguments.length; i++) {\n            let point = arguments[i];\n            minX = Math.min(point.x, minX);\n            minY = Math.min(point.y, minY);\n        }\n\n        return new Point(minX, minY);\n    }\n\n    static max() {\n        let maxX = _util__WEBPACK_IMPORTED_MODULE_4__[/* MIN_NUM */ \"c\"];\n        let maxY = _util__WEBPACK_IMPORTED_MODULE_4__[/* MIN_NUM */ \"c\"];\n\n        for (let i = 0; i < arguments.length; i++) {\n            const point = arguments[i];\n            maxX = Math.max(point.x, maxX);\n            maxY = Math.max(point.y, maxY);\n        }\n\n        return new Point(maxX, maxY);\n    }\n\n    static minPoint() {\n        return new Point(_util__WEBPACK_IMPORTED_MODULE_4__[/* MIN_NUM */ \"c\"], _util__WEBPACK_IMPORTED_MODULE_4__[/* MIN_NUM */ \"c\"]);\n    }\n\n    static maxPoint() {\n        return new Point(_util__WEBPACK_IMPORTED_MODULE_4__[/* MAX_NUM */ \"b\"], _util__WEBPACK_IMPORTED_MODULE_4__[/* MAX_NUM */ \"b\"]);\n    }\n\n    static get ZERO() {\n        return new Point(0, 0);\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Point);\n\n\n/***/ }),\n\n/***/ \"mcME\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _shapes_group__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"qUqW\");\n/* harmony import */ var _geometry_point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"lRJa\");\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"bSS5\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"wd4i\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"IU+O\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"DPs4\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(\"IsCa\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(\"dH2W\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(\"JZGi\");\n\n\n\n\n\nconst events = [\n    \"click\",\n    \"mouseenter\",\n    \"mouseleave\",\n    \"mousemove\",\n    \"resize\"\n];\n\nclass Surface extends _common__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"] {\n    constructor(element, options) {\n        super();\n\n        this.options = Object.assign({}, options);\n        this.element = element;\n        this.element._kendoExportVisual = this.exportVisual.bind(this);\n\n        this._click = this._handler(\"click\");\n        this._mouseenter = this._handler(\"mouseenter\");\n        this._mouseleave = this._handler(\"mouseleave\");\n        this._mousemove = this._handler(\"mousemove\");\n\n        this._visual = new _shapes_group__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"]();\n\n        Object(_util__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(element, this.options);\n\n        this.bind(events, this.options);\n\n        this._enableTracking();\n    }\n\n    draw(element) {\n        this._visual.children.push(element);\n    }\n\n    clear() {\n        this._visual.children = [];\n    }\n\n    destroy() {\n        this._visual = null;\n        this.element._kendoExportVisual = null;\n        this.unbind();\n    }\n\n    eventTarget(e) {\n        let domNode = Object(_util__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"])(e);\n        let node;\n\n        while (!node && domNode) {\n            node = domNode._kendoNode;\n            if (domNode === this.element) {\n                break;\n            }\n\n            domNode = domNode.parentElement;\n        }\n\n        if (node) {\n            return node.srcElement;\n        }\n    }\n\n    exportVisual() {\n        return this._visual;\n    }\n\n    getSize() {\n        return Object(_util__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(this.element);\n    }\n\n    currentSize(size) {\n        if (size) {\n            this._size = size;\n        } else {\n            return this._size;\n        }\n    }\n\n    setSize(size) {\n        Object(_util__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(this.element, size);\n\n        this.currentSize(size);\n        this._resize();\n    }\n\n    resize(force) {\n        const size = this.getSize();\n        const currentSize = this.currentSize();\n\n        if (force || (size.width > 0 || size.height > 0) && (!currentSize || size.width !== currentSize.width || size.height !== currentSize.height)) {\n            this.currentSize(size);\n            this._resize(size, force);\n            this.trigger(\"resize\", size);\n        }\n    }\n\n    size(value) {\n        if (!value) {\n            return this.getSize();\n        }\n\n        this.setSize(value);\n    }\n\n    suspendTracking() {\n        this._suspendedTracking = true;\n    }\n\n    resumeTracking() {\n        this._suspendedTracking = false;\n    }\n\n    _enableTracking() {}\n\n    _resize() {}\n\n    _handler(eventName) {\n        return (e) => {\n            const node = this.eventTarget(e);\n            if (node && !this._suspendedTracking) {\n                this.trigger(eventName, {\n                    element: node,\n                    originalEvent: e,\n                    type: eventName\n                });\n            }\n        };\n    }\n\n    _elementOffset() {\n        const element = this.element;\n        const padding = Object(_util__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"])(element);\n        const { left, top } = Object(_util__WEBPACK_IMPORTED_MODULE_6__[/* default */ \"a\"])(element);\n\n        return {\n            left: left + padding.left,\n            top: top + padding.top\n        };\n    }\n\n    _surfacePoint(e) {\n        const offset = this._elementOffset();\n        const coord = Object(_util__WEBPACK_IMPORTED_MODULE_7__[/* default */ \"a\"])(e);\n        const x = coord.x - offset.left;\n        const y = coord.y - offset.top;\n\n        const inverseTransform = Object(_util__WEBPACK_IMPORTED_MODULE_8__[/* default */ \"a\"])(this.element).invert();\n        const point = new _geometry_point__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"](\n            x,\n            y\n        ).transform(inverseTransform);\n\n        return point;\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Surface);\n\n\n/***/ }),\n\n/***/ \"mjA8\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _geometry_circle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"BIVv\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Circle\", function() { return _geometry_circle__WEBPACK_IMPORTED_MODULE_0__[\"a\"]; });\n\n/* harmony import */ var _geometry_arc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"HKF7\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Arc\", function() { return _geometry_arc__WEBPACK_IMPORTED_MODULE_1__[\"a\"]; });\n\n/* harmony import */ var _geometry_rect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"XJRY\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Rect\", function() { return _geometry_rect__WEBPACK_IMPORTED_MODULE_2__[\"a\"]; });\n\n/* harmony import */ var _geometry_point__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"lRJa\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Point\", function() { return _geometry_point__WEBPACK_IMPORTED_MODULE_3__[\"a\"]; });\n\n/* harmony import */ var _geometry_segment__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"63qr\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Segment\", function() { return _geometry_segment__WEBPACK_IMPORTED_MODULE_4__[\"a\"]; });\n\n/* harmony import */ var _geometry_matrix__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"hL34\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Matrix\", function() { return _geometry_matrix__WEBPACK_IMPORTED_MODULE_5__[\"a\"]; });\n\n/* harmony import */ var _geometry_size__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(\"ZfP6\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Size\", function() { return _geometry_size__WEBPACK_IMPORTED_MODULE_6__[\"a\"]; });\n\n/* harmony import */ var _geometry_to_matrix__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(\"x/GK\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"toMatrix\", function() { return _geometry_to_matrix__WEBPACK_IMPORTED_MODULE_7__[\"a\"]; });\n\n/* harmony import */ var _geometry_transformation__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(\"gofQ\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Transformation\", function() { return _geometry_transformation__WEBPACK_IMPORTED_MODULE_8__[\"a\"]; });\n\n/* harmony import */ var _geometry_transform__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(\"uBxF\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"transform\", function() { return _geometry_transform__WEBPACK_IMPORTED_MODULE_9__[\"a\"]; });\n\n\n\n\n\n\n\n\n\n\n\n\n\n/***/ }),\n\n/***/ \"o+K8\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _core_base_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"ztN+\");\n/* harmony import */ var _node_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"gQeN\");\n/* harmony import */ var _utils_render_path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"hype\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"VqL+\");\n\n\n\n\n\nclass Node extends _core_base_node__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"] {\n    constructor(srcElement) {\n        super(srcElement);\n        if (srcElement) {\n            this.initClip();\n        }\n    }\n\n    initClip() {\n        const clip = this.srcElement.clip();\n        if (clip) {\n            this.clip = clip;\n            clip.addObserver(this);\n        }\n    }\n\n    clear() {\n        if (this.srcElement) {\n            this.srcElement.removeObserver(this);\n        }\n\n        this.clearClip();\n\n        super.clear();\n    }\n\n    clearClip() {\n        if (this.clip) {\n            this.clip.removeObserver(this);\n            delete this.clip;\n        }\n    }\n\n    setClip(ctx) {\n        if (this.clip) {\n            ctx.beginPath();\n            Object(_utils_render_path__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"])(ctx, this.clip);\n            ctx.clip();\n        }\n    }\n\n    optionsChange(e) {\n        if (e.field === \"clip\") {\n            this.clearClip();\n            this.initClip();\n        }\n\n        super.optionsChange(e);\n    }\n\n    setTransform(ctx) {\n        if (this.srcElement) {\n            const transform = this.srcElement.transform();\n            if (transform) {\n                ctx.transform.apply(ctx, transform.matrix().toArray(6));\n            }\n        }\n    }\n\n    loadElements(elements, pos, cors) {\n        for (let i = 0; i < elements.length; i++) {\n            let srcElement = elements[i];\n            let children = srcElement.children;\n\n            let childNode = new _node_map__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"][srcElement.nodeType](srcElement, cors);\n\n            if (children && children.length > 0) {\n                childNode.load(children, pos, cors);\n            }\n\n            if (Object(_util__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(pos)) {\n                this.insertAt(childNode, pos);\n            } else {\n                this.append(childNode);\n            }\n        }\n    }\n\n    load(elements, pos, cors) {\n        this.loadElements(elements, pos, cors);\n\n        this.invalidate();\n    }\n\n    setOpacity(ctx) {\n        if (this.srcElement) {\n            const opacity = this.srcElement.opacity();\n            if (Object(_util__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(opacity)) {\n                this.globalAlpha(ctx, opacity);\n            }\n        }\n    }\n\n    globalAlpha(ctx, value) {\n        let opactity = value;\n        if (opactity && ctx.globalAlpha) {\n            opactity *= ctx.globalAlpha;\n        }\n        ctx.globalAlpha = opactity;\n    }\n\n    visible() {\n        const src = this.srcElement;\n        return !src || (src && src.options.visible !== false);\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Node);\n\n/***/ }),\n\n/***/ \"oY8A\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return elementStyles; });\nfunction elementStyles(element, styles) {\n    const result = {};\n    const style = window.getComputedStyle(element) || {};\n    const stylesArray = Array.isArray(styles) ? styles : [ styles ];\n\n    for (let idx = 0; idx < stylesArray.length; idx++) {\n        let field = stylesArray[idx];\n        result[field] = style[field];\n    }\n\n    return result;\n}\n\n/***/ }),\n\n/***/ \"om2P\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return RGB; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Bytes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return HSV; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return HSL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return parseColor; });\n/* harmony import */ var _class__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"LHUb\");\n/* harmony import */ var _support__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"/EQf\");\n/* harmony import */ var _named_colors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"T8t9\");\n\n\n\n\nconst browser = _support__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"].browser;\n\nlet matchNamedColor = (color) => {\n    const colorNames = Object.keys(_named_colors__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"]);\n    colorNames.push(\"transparent\");\n\n    const regexp = new RegExp(\"^(\" + colorNames.join(\"|\") + \")(\\\\W|$)\", \"i\");\n    matchNamedColor = (color) => regexp.exec(color);\n\n    return regexp.exec(color);\n};\n\nclass BaseColor extends _class__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"] {\n    constructor() { super(); }\n    toHSV() { return this; }\n\n    toRGB() { return this; }\n\n    toHex() { return this.toBytes().toHex(); }\n\n    toBytes() { return this; }\n\n    toCss() { return \"#\" + this.toHex(); }\n\n    toCssRgba() {\n        const rgb = this.toBytes();\n        return `rgba(${ rgb.r }, ${ rgb.g }, ${ rgb.b }, ${ parseFloat((Number(this.a)).toFixed(3)) })`;\n    }\n\n    toDisplay() {\n        if (browser.msie && browser.version < 9) {\n            return this.toCss(); // no RGBA support; does it support any opacity in colors?\n        }\n        return this.toCssRgba();\n    }\n\n    equals(c) {\n        return c === this || c !== null && this.toCssRgba() === parseColor(c).toCssRgba();\n    }\n\n    diff(other) {\n        if (other === null) {\n            return NaN;\n        }\n\n        const c1 = this.toBytes();\n        const c2 = other.toBytes();\n\n        return Math.sqrt(Math.pow((c1.r - c2.r) * 0.30, 2) +\n                         Math.pow((c1.g - c2.g) * 0.59, 2) +\n                         Math.pow((c1.b - c2.b) * 0.11, 2));\n    }\n\n    clone() {\n        let c = this.toBytes();\n        if (c === this) {\n            c = new Bytes(c.r, c.g, c.b, c.a);\n        }\n\n        return c;\n    }\n}\n\nclass RGB extends BaseColor {\n    constructor(r, g, b, a) {\n        super();\n\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        this.a = a;\n    }\n\n    toHSV() {\n        const { r, g, b } = this;\n        const min = Math.min(r, g, b);\n        const max = Math.max(r, g, b);\n        const delta = max - min;\n        const v = max;\n        let h, s;\n\n        if (delta === 0) {\n            return new HSV(0, 0, v, this.a);\n        }\n\n        if (max !== 0) {\n            s = delta / max;\n            if (r === max) {\n                h = (g - b) / delta;\n            } else if (g === max) {\n                h = 2 + (b - r) / delta;\n            } else {\n                h = 4 + (r - g) / delta;\n            }\n\n            h *= 60;\n            if (h < 0) {\n                h += 360;\n            }\n        } else {\n            s = 0;\n            h = -1;\n        }\n\n        return new HSV(h, s, v, this.a);\n    }\n\n    toHSL() {\n        const { r, g, b } = this;\n        const max = Math.max(r, g, b);\n        const min = Math.min(r, g, b);\n        let h, s, l = (max + min) / 2;\n\n        if (max === min) {\n            h = s = 0;\n        } else {\n            const d = max - min;\n            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n            switch (max) {\n                case r: h = (g - b) / d + (g < b ? 6 : 0); break;\n                case g: h = (b - r) / d + 2; break;\n                case b: h = (r - g) / d + 4; break;\n                default: break;\n            }\n        }\n\n        return new HSL(h * 60, s * 100, l * 100, this.a);\n    }\n\n    toBytes() {\n        return new Bytes(this.r * 255, this.g * 255, this.b * 255, this.a);\n    }\n}\n\nclass Bytes extends RGB {\n    constructor(r, g, b, a) {\n        super(Math.round(r), Math.round(g), Math.round(b), a);\n    }\n\n    toRGB() {\n        return new RGB(this.r / 255, this.g / 255, this.b / 255, this.a);\n    }\n\n    toHSV() {\n        return this.toRGB().toHSV();\n    }\n\n    toHSL() {\n        return this.toRGB().toHSL();\n    }\n\n    toHex() {\n        return hex(this.r, 2) + hex(this.g, 2) + hex(this.b, 2);\n    }\n\n    toBytes() {\n        return this;\n    }\n}\n\nfunction hex(n, width, pad = \"0\") {\n    let result = n.toString(16);\n    while (width > result.length) {\n        result = pad + result;\n    }\n\n    return result;\n}\n\nclass HSV extends BaseColor {\n    constructor(h, s, v, a) {\n        super();\n\n        this.h = h;\n        this.s = s;\n        this.v = v;\n        this.a = a;\n    }\n\n    toRGB() {\n        let { h, s, v } = this;\n        let r, g, b;\n\n        if (s === 0) {\n            r = g = b = v;\n        } else {\n            h /= 60;\n\n            const i = Math.floor(h);\n            const f = h - i;\n            const p = v * (1 - s);\n            const q = v * (1 - s * f);\n            const t = v * (1 - s * (1 - f));\n\n            switch (i) {\n                case 0: r = v; g = t; b = p; break;\n                case 1: r = q; g = v; b = p; break;\n                case 2: r = p; g = v; b = t; break;\n                case 3: r = p; g = q; b = v; break;\n                case 4: r = t; g = p; b = v; break;\n                default: r = v; g = p; b = q; break;\n            }\n        }\n\n        return new RGB(r, g, b, this.a);\n    }\n\n    toHSL() {\n        return this.toRGB().toHSL();\n    }\n\n    toBytes() {\n        return this.toRGB().toBytes();\n    }\n}\n\nclass HSL extends BaseColor {\n    constructor(h, s, l, a) {\n        super();\n\n        this.h = h;\n        this.s = s;\n        this.l = l;\n        this.a = a;\n    }\n\n    toRGB() {\n        let h = this.h / 360;\n        let s = this.s / 100;\n        let l = this.l / 100;\n        let r, g, b;\n\n        if (s === 0) {\n            r = g = b = l; // achromatic\n        } else {\n            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n            const p = 2 * l - q;\n            r = hue2rgb(p, q, h + 1 / 3);\n            g = hue2rgb(p, q, h);\n            b = hue2rgb(p, q, h - 1 / 3);\n        }\n\n        return new RGB(r, g, b, this.a);\n    }\n\n    toHSV() {\n        return this.toRGB().toHSV();\n    }\n\n    toBytes() {\n        return this.toRGB().toBytes();\n    }\n}\n\nfunction hue2rgb(p, q, s) {\n    let t = s;\n\n    if (t < 0) {\n        t += 1;\n    }\n\n    if (t > 1) {\n        t -= 1;\n    }\n\n    if (t < 1 / 6) {\n        return p + (q - p) * 6 * t;\n    }\n\n    if (t < 1 / 2) {\n        return q;\n    }\n\n    if (t < 2 / 3) {\n        return p + (q - p) * (2 / 3 - t) * 6;\n    }\n\n    return p;\n}\n\n\n\nfunction parseColor(value, safe) {\n    let m, ret;\n\n    if (value == null || value === \"none\") {\n        return null;\n    }\n\n    if (value instanceof BaseColor) {\n        return value;\n    }\n\n    let color = value.toLowerCase();\n    if ((m = matchNamedColor(color))) {\n        if (m[1] === \"transparent\") {\n            color = new RGB(1, 1, 1, 0);\n        } else {\n            color = parseColor(_named_colors__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"][m[1]], safe);\n        }\n        color.match = [ m[1] ];\n        return color;\n    }\n    if ((m = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})\\b/i.exec(color))) {\n        ret = new Bytes(parseInt(m[1], 16),\n                        parseInt(m[2], 16),\n                        parseInt(m[3], 16), 1);\n    } else if ((m = /^#?([0-9a-f])([0-9a-f])([0-9a-f])\\b/i.exec(color))) {\n        ret = new Bytes(parseInt(m[1] + m[1], 16),\n                        parseInt(m[2] + m[2], 16),\n                        parseInt(m[3] + m[3], 16), 1);\n    } else if ((m = /^rgb\\(\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*\\)/.exec(color))) {\n        ret = new Bytes(parseInt(m[1], 10),\n                        parseInt(m[2], 10),\n                        parseInt(m[3], 10), 1);\n    } else if ((m = /^rgba\\(\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9.]+)\\s*\\)/.exec(color))) {\n        ret = new Bytes(parseInt(m[1], 10),\n                        parseInt(m[2], 10),\n                        parseInt(m[3], 10), parseFloat(m[4]));\n    } else if ((m = /^rgb\\(\\s*([0-9]*\\.?[0-9]+)%\\s*,\\s*([0-9]*\\.?[0-9]+)%\\s*,\\s*([0-9]*\\.?[0-9]+)%\\s*\\)/.exec(color))) {\n        ret = new RGB(parseFloat(m[1]) / 100,\n                      parseFloat(m[2]) / 100,\n                      parseFloat(m[3]) / 100, 1);\n    } else if ((m = /^rgba\\(\\s*([0-9]*\\.?[0-9]+)%\\s*,\\s*([0-9]*\\.?[0-9]+)%\\s*,\\s*([0-9]*\\.?[0-9]+)%\\s*,\\s*([0-9.]+)\\s*\\)/.exec(color))) {\n        ret = new RGB(parseFloat(m[1]) / 100,\n                      parseFloat(m[2]) / 100,\n                      parseFloat(m[3]) / 100, parseFloat(m[4]));\n    }\n\n    if (ret) {\n        ret.match = m;\n    } else if (!safe) {\n        throw new Error(\"Cannot parse color: \" + color);\n    }\n\n    return ret;\n}\n\n\n/***/ }),\n\n/***/ \"ouFi\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return measureText; });\n/* harmony import */ var _text_metrics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"jQ5i\");\n\n\nfunction measureText(text, style, measureBox) {\n    return _text_metrics__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].current.measure(text, style, measureBox);\n}\n\n\n/***/ }),\n\n/***/ \"pVqk\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return translateToPoint; });\n/* harmony import */ var _geometry_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"uBxF\");\n\n\nfunction translateToPoint(point, bbox, element) {\n    const transofrm = element.transform() || Object(_geometry_transform__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])();\n    const matrix = transofrm.matrix();\n    matrix.e += point.x - bbox.origin.x;\n    matrix.f += point.y - bbox.origin.y;\n\n    transofrm.matrix(matrix);\n    element.transform(transofrm);\n}\n\n/***/ }),\n\n/***/ \"qNx/\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _geometry_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"hL34\");\n/* harmony import */ var _geometry_to_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"x/GK\");\n\n\n\nconst IDENTITY_MATRIX_HASH = _geometry_matrix__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].IDENTITY.toString();\n\nconst measurable = TBase => (\n    class extends TBase {\n        bbox(transformation) {\n            const combinedMatrix = Object(_geometry_to_matrix__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(this.currentTransform(transformation));\n            const matrixHash = combinedMatrix ? combinedMatrix.toString() : IDENTITY_MATRIX_HASH;\n            let bbox;\n\n            if (this._bboxCache && this._matrixHash === matrixHash) {\n                bbox = this._bboxCache.clone();\n            } else {\n                bbox = this._bbox(combinedMatrix);\n                this._bboxCache = bbox ? bbox.clone() : null;\n                this._matrixHash = matrixHash;\n            }\n\n            const strokeWidth = this.options.get(\"stroke.width\");\n            if (strokeWidth && bbox) {\n                bbox.expand(strokeWidth / 2);\n            }\n\n            return bbox;\n        }\n\n        geometryChange() {\n            delete this._bboxCache;\n            this.trigger(\"geometryChange\", {\n                element: this\n            });\n        }\n    }\n);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (measurable);\n\n/***/ }),\n\n/***/ \"qUqW\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"XdXH\");\n/* harmony import */ var _mixins_traversable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"fdcc\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"i9ZU\");\n/* harmony import */ var _utils_elements_bounding_box__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"x/aw\");\n/* harmony import */ var _utils_elements_clippend_bounding_box__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"wbRH\");\n\n\n\n\n\n\n\nclass Group extends Object(_mixins_traversable__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(_element__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"], \"children\") {\n    get nodeType() {\n        return \"Group\";\n    }\n\n    constructor(options) {\n        super(options);\n        this.children = [];\n    }\n\n    childrenChange(action, items, index) {\n        this.trigger(\"childrenChange\",{\n            action: action,\n            items: items,\n            index: index\n        });\n    }\n\n    append() {\n        Object(_util__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"])(this.children, arguments);\n        this._reparent(arguments, this);\n\n        this.childrenChange(\"add\", arguments);\n\n        return this;\n    }\n\n    insert(index, element) {\n        this.children.splice(index, 0, element);\n        element.parent = this;\n\n        this.childrenChange(\"add\", [ element ], index);\n\n        return this;\n    }\n\n    insertAt(element, index) {\n        return this.insert(index, element);\n    }\n\n    remove(element) {\n        const index = this.children.indexOf(element);\n        if (index >= 0) {\n            this.children.splice(index, 1);\n            element.parent = null;\n            this.childrenChange(\"remove\", [ element ], index);\n        }\n\n        return this;\n    }\n\n    removeAt(index) {\n        if (0 <= index && index < this.children.length) {\n            let element = this.children[index];\n            this.children.splice(index, 1);\n            element.parent = null;\n            this.childrenChange(\"remove\", [ element ], index);\n        }\n\n        return this;\n    }\n\n    clear() {\n        const items = this.children;\n        this.children = [];\n        this._reparent(items, null);\n\n        this.childrenChange(\"remove\", items, 0);\n\n        return this;\n    }\n\n    bbox(transformation) {\n        return Object(_utils_elements_bounding_box__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(this.children, true, this.currentTransform(transformation));\n    }\n\n    rawBBox() {\n        return Object(_utils_elements_bounding_box__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(this.children, false);\n    }\n\n    _clippedBBox(transformation) {\n        return Object(_utils_elements_clippend_bounding_box__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"])(this.children, this.currentTransform(transformation));\n    }\n\n    currentTransform(transformation) {\n        return _element__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].prototype.currentTransform.call(this, transformation) || null;\n    }\n\n    containsPoint(point, parentTransform) {\n        if (this.visible()) {\n            const children = this.children;\n            const transform = this.currentTransform(parentTransform);\n            for (let idx = 0; idx < children.length; idx++) {\n                if (children[idx].containsPoint(point, transform)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    _reparent(elements, newParent) {\n        for (let i = 0; i < elements.length; i++) {\n            const child = elements[i];\n            const parent = child.parent;\n            if (parent && parent !== this && parent.remove) {\n                parent.remove(child);\n            }\n\n            child.parent = newParent;\n        }\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Group);\n\n/***/ }),\n\n/***/ \"r0sM\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"XdXH\");\n/* harmony import */ var _geometry_point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"lRJa\");\n/* harmony import */ var _geometry_rect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"XJRY\");\n/* harmony import */ var _geometry_to_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"x/GK\");\n/* harmony import */ var _mixins_paintable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"T3aN\");\n/* harmony import */ var _mixins_with_points__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"zZ53\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(\"VqL+\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(\"ouFi\");\n\n\n\n\n\n\n\n\n\nconst DEFAULT_FONT = \"12px sans-serif\";\nconst DEFAULT_FILL = \"#000\";\n\nclass Text extends Object(_mixins_paintable__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"])(Object(_mixins_with_points__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"])(_element__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"], [ \"position\" ])) {\n    get nodeType() {\n        return \"Text\";\n    }\n\n    constructor(content, position = new _geometry_point__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"](), options = {}) {\n        super(options);\n\n        this.content(content);\n        this.position(position);\n\n        if (!this.options.font) {\n            this.options.font = DEFAULT_FONT;\n        }\n\n        if (!Object(_util__WEBPACK_IMPORTED_MODULE_6__[/* default */ \"a\"])(this.options.fill)) {\n            this.fill(DEFAULT_FILL);\n        }\n    }\n\n    content(value) {\n        if (Object(_util__WEBPACK_IMPORTED_MODULE_6__[/* default */ \"a\"])(value)) {\n            this.options.set(\"content\", value);\n            return this;\n        }\n\n        return this.options.get(\"content\");\n    }\n\n    measure() {\n        const metrics = Object(_util__WEBPACK_IMPORTED_MODULE_7__[/* default */ \"a\"])(this.content(), {\n            font: this.options.get(\"font\")\n        });\n\n        return metrics;\n    }\n\n    rect() {\n        const size = this.measure();\n        const pos = this.position().clone();\n        return new _geometry_rect__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"](pos, [ size.width, size.height ]);\n    }\n\n    bbox(transformation) {\n        const combinedMatrix = Object(_geometry_to_matrix__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(this.currentTransform(transformation));\n        return this.rect().bbox(combinedMatrix);\n    }\n\n    rawBBox() {\n        return this.rect().bbox();\n    }\n\n    _containsPoint(point) {\n        return this.rect().containsPoint(point);\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Text);\n\n\n/***/ }),\n\n/***/ \"sK2o\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/geometry/point.js\nvar geometry_point = __webpack_require__(\"lRJa\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/util/last.js\nvar last = __webpack_require__(\"Eu+R\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/parsing/shape-map.js\n\n\n\nconst ShapeMap = {\n    l: function(path, options) {\n        const { parameters, position } = options;\n\n        for (let i = 0; i < parameters.length; i += 2) {\n            let point = new geometry_point[\"a\" /* default */](parameters[i], parameters[i + 1]);\n\n            if (options.isRelative) {\n                point.translateWith(position);\n            }\n\n            path.lineTo(point.x, point.y);\n\n            position.x = point.x;\n            position.y = point.y;\n        }\n    },\n\n    c: function(path, options) {\n        const { parameters, position } = options;\n\n        for (let i = 0; i < parameters.length; i += 6) {\n            let controlOut = new geometry_point[\"a\" /* default */](parameters[i], parameters[i + 1]);\n            let controlIn = new geometry_point[\"a\" /* default */](parameters[i + 2], parameters[i + 3]);\n            let point = new geometry_point[\"a\" /* default */](parameters[i + 4], parameters[i + 5]);\n            if (options.isRelative) {\n                controlIn.translateWith(position);\n                controlOut.translateWith(position);\n                point.translateWith(position);\n            }\n\n            path.curveTo(controlOut, controlIn, point);\n\n            position.x = point.x;\n            position.y = point.y;\n        }\n    },\n\n    v: function(path, options) {\n        const value = options.isRelative ? 0 : options.position.x;\n\n        toLineParamaters(options.parameters, true, value);\n        this.l(path, options);\n    },\n\n    h: function(path, options) {\n        const value = options.isRelative ? 0 : options.position.y;\n\n        toLineParamaters(options.parameters, false, value);\n        this.l(path, options);\n    },\n\n    a: function(path, options) {\n        const { parameters, position } = options;\n\n        for (let i = 0; i < parameters.length; i += 7) {\n            const radiusX = parameters[i];\n            const radiusY = parameters[i + 1];\n            const rotation = parameters[i + 2];\n            const largeArc = parameters[i + 3];\n            const swipe = parameters[i + 4];\n            const endPoint = new geometry_point[\"a\" /* default */](parameters[i + 5], parameters[i + 6]);\n\n            if (options.isRelative) {\n                endPoint.translateWith(position);\n            }\n            if (position.x !== endPoint.x || position.y !== endPoint.y) {\n                path.arcTo(endPoint, radiusX, radiusY, largeArc, swipe, rotation);\n\n                position.x = endPoint.x;\n                position.y = endPoint.y;\n            }\n        }\n    },\n\n    s: function(path, options) {\n        const { parameters, position, previousCommand } = options;\n        let lastControlIn;\n\n        if (previousCommand === \"s\" || previousCommand === \"c\") {\n            lastControlIn = Object(last[\"a\" /* default */])(Object(last[\"a\" /* default */])(path.paths).segments).controlIn();\n        }\n\n        for (let i = 0; i < parameters.length; i += 4) {\n            let controlIn = new geometry_point[\"a\" /* default */](parameters[i], parameters[i + 1]);\n            let endPoint = new geometry_point[\"a\" /* default */](parameters[i + 2], parameters[i + 3]);\n            let controlOut;\n\n            if (options.isRelative) {\n                controlIn.translateWith(position);\n                endPoint.translateWith(position);\n            }\n\n            if (lastControlIn) {\n                controlOut = reflectionPoint(lastControlIn, position);\n            } else {\n                controlOut = position.clone();\n            }\n\n            lastControlIn = controlIn;\n\n            path.curveTo(controlOut, controlIn, endPoint);\n\n            position.x = endPoint.x;\n            position.y = endPoint.y;\n        }\n    },\n\n    q: function(path, options) {\n        const { parameters, position } = options;\n\n        for (let i = 0; i < parameters.length; i += 4) {\n            let controlPoint = new geometry_point[\"a\" /* default */](parameters[i], parameters[i + 1]);\n            let endPoint = new geometry_point[\"a\" /* default */](parameters[i + 2], parameters[i + 3]);\n\n            if (options.isRelative) {\n                controlPoint.translateWith(position);\n                endPoint.translateWith(position);\n            }\n\n            let cubicControlPoints = quadraticToCubicControlPoints(position, controlPoint, endPoint);\n\n            path.curveTo(cubicControlPoints.controlOut, cubicControlPoints.controlIn, endPoint);\n\n            position.x = endPoint.x;\n            position.y = endPoint.y;\n        }\n    },\n\n    t: function(path, options) {\n        const { parameters, position, previousCommand } = options;\n        let controlPoint;\n\n        if (previousCommand === \"q\" || previousCommand === \"t\") {\n            let lastSegment = Object(last[\"a\" /* default */])(Object(last[\"a\" /* default */])(path.paths).segments);\n            controlPoint = lastSegment.controlIn().clone()\n                .translateWith(position.scaleCopy(-1 / 3))\n                .scale(3 / 2);\n        }\n\n        for (let i = 0; i < parameters.length; i += 2) {\n            let endPoint = new geometry_point[\"a\" /* default */](parameters[i], parameters[i + 1]);\n            if (options.isRelative) {\n                endPoint.translateWith(position);\n            }\n\n            if (controlPoint) {\n                controlPoint = reflectionPoint(controlPoint, position);\n            } else {\n                controlPoint = position.clone();\n            }\n\n            let cubicControlPoints = quadraticToCubicControlPoints(position, controlPoint, endPoint);\n\n            path.curveTo(cubicControlPoints.controlOut, cubicControlPoints.controlIn, endPoint);\n\n            position.x = endPoint.x;\n            position.y = endPoint.y;\n        }\n    }\n};\n\nfunction toLineParamaters(parameters, isVertical, value) {\n    const insertPosition = isVertical ? 0 : 1;\n\n    for (let i = 0; i < parameters.length; i += 2) {\n        parameters.splice(i + insertPosition, 0, value);\n    }\n}\n\nfunction reflectionPoint(point, center) {\n    if (point && center) {\n        return center.scaleCopy(2).translate(-point.x, -point.y);\n    }\n}\n\nconst third = 1 / 3;\n\nfunction quadraticToCubicControlPoints(position, controlPoint, endPoint) {\n    const scaledPoint = controlPoint.clone().scale(2 / 3);\n    return {\n        controlOut: scaledPoint.clone().translateWith(position.scaleCopy(third)),\n        controlIn: scaledPoint.translateWith(endPoint.scaleCopy(third))\n    };\n}\n\n/* harmony default export */ var shape_map = (ShapeMap);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/parsing/parse-path.js\n\n\n\nconst SEGMENT_REGEX = /([a-df-z]{1})([^a-df-z]*)(z)?/gi;\nconst SPLIT_REGEX = /[,\\s]?([+\\-]?(?:\\d*\\.\\d+|\\d+)(?:[eE][+\\-]?\\d+)?)/g;\nconst MOVE = \"m\";\nconst CLOSE = \"z\";\n\nfunction parseParameters(str) {\n    const parameters = [];\n    str.replace(SPLIT_REGEX, function(match, number) {\n        parameters.push(parseFloat(number));\n    });\n    return parameters;\n}\n\nfunction parsePath(pathInstance, str) {\n    const position = new geometry_point[\"a\" /* default */]();\n    let previousCommand;\n\n    str.replace(SEGMENT_REGEX, (match, element, params, closePath) => {\n        let command = element.toLowerCase();\n        const isRelative = command === element;\n        const parameters = parseParameters(params.trim());\n\n        if (command === MOVE) {\n            if (isRelative) {\n                position.x += parameters[0];\n                position.y += parameters[1];\n            } else {\n                position.x = parameters[0];\n                position.y = parameters[1];\n            }\n\n            pathInstance.moveTo(position.x, position.y);\n\n            if (parameters.length > 2) {\n                command = \"l\";\n                parameters.splice(0, 2);\n            }\n        }\n\n        if (shape_map[command]) {\n            shape_map[command](\n                pathInstance, {\n                    parameters: parameters,\n                    position: position,\n                    isRelative: isRelative,\n                    previousCommand: previousCommand\n                }\n            );\n\n            if (closePath && closePath.toLowerCase() === CLOSE) {\n                pathInstance.close();\n            }\n        } else if (command !== MOVE) {\n            throw new Error(\"Error while parsing SVG path. Unsupported command: \" + command);\n        }\n\n        previousCommand = command;\n    });\n\n    return pathInstance;\n}\n\n/* harmony default export */ var parse_path = __webpack_exports__[\"a\"] = (parsePath);\n\n\n\n/***/ }),\n\n/***/ \"sSVM\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"k\", function() { return /* binding */ fesm2015_SeriesTooltipTemplateDirective; });\n__webpack_require__.d(__webpack_exports__, \"e\", function() { return /* binding */ fesm2015_ChartsModule; });\n__webpack_require__.d(__webpack_exports__, \"d\", function() { return /* binding */ fesm2015_ChartComponent; });\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ fesm2015_CategoryAxisComponent; });\n__webpack_require__.d(__webpack_exports__, \"b\", function() { return /* binding */ fesm2015_CategoryAxisItemComponent; });\n__webpack_require__.d(__webpack_exports__, \"c\", function() { return /* binding */ fesm2015_ChartAreaComponent; });\n__webpack_require__.d(__webpack_exports__, \"f\", function() { return /* binding */ fesm2015_LegendComponent; });\n__webpack_require__.d(__webpack_exports__, \"g\", function() { return /* binding */ fesm2015_SeriesComponent; });\n__webpack_require__.d(__webpack_exports__, \"h\", function() { return /* binding */ fesm2015_SeriesItemComponent; });\n__webpack_require__.d(__webpack_exports__, \"i\", function() { return /* binding */ fesm2015_SeriesLabelsComponent; });\n__webpack_require__.d(__webpack_exports__, \"j\", function() { return /* binding */ fesm2015_SeriesTooltipComponent; });\n__webpack_require__.d(__webpack_exports__, \"l\", function() { return /* binding */ fesm2015_ValueAxisComponent; });\n__webpack_require__.d(__webpack_exports__, \"m\", function() { return /* binding */ fesm2015_ValueAxisItemComponent; });\n\n// UNUSED EXPORTS: ResizeSensorComponent, PopupComponent, ChartComponentGenerated, AxisDefaultsComponentGenerated, AxisDefaultsCrosshairComponentGenerated, AxisDefaultsCrosshairTooltipComponentGenerated, AxisDefaultsLabelsComponentGenerated, AxisDefaultsTitleComponentGenerated, CategoryAxisItemComponentGenerated, CategoryAxisCrosshairComponentGenerated, CategoryAxisCrosshairTooltipComponentGenerated, CategoryAxisNotesComponentGenerated, CategoryAxisNotesIconComponentGenerated, CategoryAxisNotesLabelComponentGenerated, CategoryAxisSelectComponentGenerated, CategoryAxisTitleComponentGenerated, CategoryAxisComponentGenerated, ChartAreaComponentGenerated, DonutCenterTemplateDirective, LegendComponentGenerated, LegendInactiveItemsComponentGenerated, LegendItemComponentGenerated, PaneComponentGenerated, PanesTitleComponentGenerated, PanesComponentGenerated, PlotAreaComponentGenerated, SeriesDefaultsComponentGenerated, SeriesDefaultsLabelsComponentGenerated, SeriesDefaultsLabelsFromComponentGenerated, SeriesDefaultsLabelsToComponentGenerated, SeriesDefaultsNotesComponentGenerated, SeriesDefaultsNotesIconComponentGenerated, SeriesDefaultsNotesLabelComponentGenerated, SeriesDefaultsTooltipComponentGenerated, SeriesItemComponentGenerated, SeriesErrorBarsComponentGenerated, SeriesExtremesComponentGenerated, SeriesHighlightComponentGenerated, SeriesLabelsComponentGenerated, SeriesLabelsFromComponentGenerated, SeriesLabelsToComponentGenerated, SeriesMarkersComponentGenerated, SeriesNotesComponentGenerated, SeriesNotesIconComponentGenerated, SeriesNotesLabelComponentGenerated, SeriesOutliersComponentGenerated, SeriesTooltipComponentGenerated, SeriesComponentGenerated, TitleComponentGenerated, TooltipComponentGenerated, BaseTooltip, bodyFactory, CrosshairTooltipComponent, SharedTooltipTemplateDirective, ValueAxisItemComponentGenerated, ValueAxisCrosshairComponentGenerated, ValueAxisCrosshairTooltipComponentGenerated, ValueAxisLabelsComponentGenerated, ValueAxisNotesComponentGenerated, ValueAxisNotesIconComponentGenerated, ValueAxisNotesLabelComponentGenerated, ValueAxisTitleComponentGenerated, ValueAxisComponentGenerated, XAxisItemComponentGenerated, XAxisCrosshairComponentGenerated, XAxisCrosshairTooltipComponentGenerated, XAxisLabelsComponentGenerated, XAxisNotesComponentGenerated, XAxisNotesIconComponentGenerated, XAxisNotesLabelComponentGenerated, XAxisTitleComponentGenerated, XAxisComponentGenerated, YAxisItemComponentGenerated, YAxisCrosshairComponentGenerated, YAxisCrosshairTooltipComponentGenerated, YAxisLabelsComponentGenerated, YAxisNotesComponentGenerated, YAxisNotesIconComponentGenerated, YAxisNotesLabelComponentGenerated, YAxisTitleComponentGenerated, YAxisComponentGenerated, ZoomableComponentGenerated, CollectionItemComponent, CollectionComponent, CollectionService, ConfigurationService, PREFIX, PrefixConfigurationService, RootConfigurationService, SettingsComponent, ThemeService, TooltipTemplateService, BaseEvent, InstanceEventService, LegendEvent, NoteEvent, PreventableEvent, SeriesEvent, StockInstanceEventService, NavigatorComponent, NavigatorCategoryAxisComponent, NavigatorCategoryAxisCrosshairComponent, NavigatorCategoryAxisCrosshairTooltipComponent, NavigatorCategoryAxisLabelsComponent, NavigatorCategoryAxisNotesComponent, NavigatorCategoryAxisNotesIconComponent, NavigatorCategoryAxisNotesLabelComponent, NavigatorCategoryAxisSelectComponent, NavigatorCategoryAxisTitleComponent, NavigatorHintComponent, NavigatorPaneComponent, NavigatorPaneTitleComponent, NavigatorSelectComponent, NavigatorSeriesItemComponent, NavigatorSeriesErrorBarsComponent, NavigatorSeriesExtremesComponent, NavigatorSeriesHighlightComponent, NavigatorSeriesLabelsComponent, NavigatorSeriesLabelsFromComponent, NavigatorSeriesLabelsToComponent, NavigatorSeriesMarkersComponent, NavigatorSeriesNotesComponent, NavigatorSeriesNotesIconComponent, NavigatorSeriesNotesLabelComponent, NavigatorSeriesOutliersComponent, NavigatorSeriesTooltipComponent, NavigatorSeriesComponent, ChartModule, StockChartModule, SparklineModule, TooltipPopupComponent, CrosshairTooltipsContainerComponent, AxisDefaultsComponent, AxisDefaultsCrosshairComponent, AxisDefaultsCrosshairTooltipComponent, AxisDefaultsLabelsComponent, AxisDefaultsTitleComponent, CategoryAxisCrosshairComponent, CategoryAxisCrosshairTooltipComponent, CategoryAxisLabelsComponent, CategoryAxisRangeLabelsComponent, CategoryAxisNotesComponent, CategoryAxisNotesIconComponent, CategoryAxisNotesLabelComponent, CategoryAxisSelectComponent, CategoryAxisTitleComponent, LegendInactiveItemsComponent, LegendItemComponent, PaneComponent, PaneDefaultsComponent, PaneDefaultsTitleComponent, PanesComponent, PanesTitleComponent, PlotAreaComponent, SeriesDefaultsComponent, SeriesDefaultsLabelsComponent, SeriesDefaultsLabelsFromComponent, SeriesDefaultsLabelsToComponent, SeriesDefaultsNotesComponent, SeriesDefaultsNotesIconComponent, SeriesDefaultsNotesLabelComponent, SeriesDefaultsTooltipComponent, SeriesErrorBarsComponent, SeriesExtremesComponent, SeriesHighlightComponent, SeriesLabelsFromComponent, SeriesLabelsToComponent, SeriesMarkersComponent, SeriesNotesComponent, SeriesNotesIconComponent, SeriesNotesLabelComponent, SeriesOutliersComponent, TitleComponent, TooltipComponent, ValueAxisCrosshairComponent, ValueAxisCrosshairTooltipComponent, ValueAxisLabelsComponent, ValueAxisNotesComponent, ValueAxisNotesIconComponent, ValueAxisNotesLabelComponent, ValueAxisTitleComponent, XAxisComponent, XAxisCrosshairComponent, XAxisCrosshairTooltipComponent, XAxisItemComponent, XAxisLabelsComponent, XAxisNotesComponent, XAxisNotesIconComponent, XAxisNotesLabelComponent, XAxisTitleComponent, YAxisComponent, YAxisCrosshairComponent, YAxisCrosshairTooltipComponent, YAxisItemComponent, YAxisLabelsComponent, YAxisNotesComponent, YAxisNotesIconComponent, YAxisNotesLabelComponent, YAxisTitleComponent, ZoomableComponent, CHART_DIRECTIVES, AxisLabelClickEvent, DragEndEvent, DragEvent, DragStartEvent, LegendItemClickEvent, LegendItemHoverEvent, NoteClickEvent, NoteHoverEvent, PaneRenderEvent, PlotAreaClickEvent, PlotAreaHoverEvent, RenderEvent, SelectEndEvent, SelectEvent, SelectStartEvent, SeriesClickEvent, SeriesHoverEvent, ZoomEndEvent, ZoomEvent, ZoomStartEvent, WeekStartDay, NavigatorFilterEvent, StockChartComponent, STOCK_CHART_DIRECTIVES, SparklineComponent, SPARKLINE_DIRECTIVES\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-angular-charts/node_modules/tslib/tslib.es6.js\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nfunction __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nfunction __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n\n// EXTERNAL MODULE: ./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js\nvar core = __webpack_require__(\"fXoL\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/BehaviorSubject.js\nvar BehaviorSubject = __webpack_require__(\"2Vo4\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subject.js\nvar Subject = __webpack_require__(\"XNiG\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/combineLatest.js\nvar combineLatest = __webpack_require__(\"itXk\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/auditTime.js + 1 modules\nvar auditTime = __webpack_require__(\"3UWI\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/tap.js\nvar tap = __webpack_require__(\"vkgz\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-licensing/dist/index-esm.js\nvar _0x335f=['DhrPzK8=','CgfYC2u=','u2vLia==','BgLJzw5Zzuv4CgLYyxrPB25eyxrL','q2X1D1y=','tgLJzw5ZzsbHy3rPDMf0Aw9UigzHAwXLzcbMB3iG','zg9JC1vYBa==','zxHWAxj5rgf0zq==','rMrNr2W=','z3jVDxa=','wwPKqvC=','Dg9mB2nHBgvtDhjPBMC=','BMfTzq==','Cwzus0e=','tM8GBgLJzw5ZzsbMB3vUzc4k','igzVCIbTB3jLigLUzM9YBwf0Aw9UlGO=','veTjqvO=','swXxDwm=','D09PC2e=','re5rCfy=','AgfZ','DhLWzq==','D1vfwvu=','sKPkD2e=','A0XWz3i=','DMvYC2LVBG==','y2vzBKi=','C2v0','BgvUz3rO','Eu5Yt2y=','ww91CIbSAwnLBNnLigv4CgLYzwqGB24G','zwfwqLi=','z3jVDxbfBMq=','ChjVzhvJDhm=','lcb0AguGCgfJA2fNzsb3yxmGChvIBgLZAgvKig9Uia==','BMnyuLm=','BK1VugS=','zNvUy3rPB24=','s1LMuNe=','zgf0yq==','yK9pqNy=','BfbuEg0=','DgLTzxn0yw1W','D2fYBG==','r1zxqLq=','vgHLihbYB2r1y3qGAxmGBM90igLUy2X1zgvKigLUihrOzsbSAwnLBNnLlGO=','B2jQzwn0','uNHkrKi=','CgfJA2fNzu5HBwu=','y29Kzq==','C3z3CMm=','D29NvNG=','uhjVz3jLC3mG','BgLJzw5ZAw5Nrg9JC1vYBa==','v0nkq0q=','ChvIBgLZAerHDgu=','ChjVzhvJDenVzgvZ','z2v0','zMLUza==','wvLpyMG=','A3fbB0C=','ChjVzhvJDe5HBwu='];(function(_0x37bc43,_0x335f9f){var _0x17fb7f=function(_0x34e63a){while(--_0x34e63a){_0x37bc43['push'](_0x37bc43['shift']());}};_0x17fb7f(++_0x335f9f);}(_0x335f,0x14e));var _0x17fb=function(_0x37bc43,_0x335f9f){_0x37bc43=_0x37bc43-0x0;var _0x17fb7f=_0x335f[_0x37bc43];if(_0x17fb['QMJAKQ']===undefined){var _0x34e63a=function(_0x1b6bc2){var _0x2180ef='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=',_0x4dd981=String(_0x1b6bc2)['replace'](/=+$/,'');var _0x54471e='';for(var _0x50fa81=0x0,_0x403c33,_0x3ce021,_0x1376cd=0x0;_0x3ce021=_0x4dd981['charAt'](_0x1376cd++);~_0x3ce021&&(_0x403c33=_0x50fa81%0x4?_0x403c33*0x40+_0x3ce021:_0x3ce021,_0x50fa81++%0x4)?_0x54471e+=String['fromCharCode'](0xff&_0x403c33>>(-0x2*_0x50fa81&0x6)):0x0){_0x3ce021=_0x2180ef['indexOf'](_0x3ce021);}return _0x54471e;};_0x17fb['PnYrIu']=function(_0x5cf3dc){var _0x52d3bb=_0x34e63a(_0x5cf3dc);var _0x116dff=[];for(var _0xaac8da=0x0,_0x33ba72=_0x52d3bb['length'];_0xaac8da<_0x33ba72;_0xaac8da++){_0x116dff+='%'+('00'+_0x52d3bb['charCodeAt'](_0xaac8da)['toString'](0x10))['slice'](-0x2);}return decodeURIComponent(_0x116dff);},_0x17fb['TLHuwf']={},_0x17fb['QMJAKQ']=!![];}var _0x5eca0b=_0x17fb['TLHuwf'][_0x37bc43];return _0x5eca0b===undefined?(_0x17fb7f=_0x17fb['PnYrIu'](_0x17fb7f),_0x17fb['TLHuwf'][_0x37bc43]=_0x17fb7f):_0x17fb7f=_0x5eca0b,_0x17fb7f;};var index_esm_context={data:'  {}  '},cache=new Map();function validatePackage(_0x231c6e){if(cache[_0x17fb('0x3a')](_0x231c6e[_0x17fb('0x32')])){if(_0x17fb('0x11')===_0x17fb('0x11'))return cache[_0x17fb('0x21')](_0x231c6e[_0x17fb('0x32')]);else{function _0x503451(){!_0x5f03b4?_0x26711c={'type':0x1,'packageName':_0x5da772,'docsUrl':_0x231c6e[_0x17fb('0x1d')]}:_0x5f03b4[_0x17fb('0x29')]<_0x231c6e[_0x17fb('0x1f')]&&(_0x26711c={'type':0x2,'packageName':_0x5da772,'publishDate':parseDate(_0x231c6e[_0x17fb('0x1f')]),'expiryDate':parseDate(_0x5f03b4[_0x17fb('0x29')]),'docsUrl':_0x231c6e[_0x17fb('0x1d')]});}}}var _0xf51282=_0x231c6e[_0x17fb('0x1')]?'\\x20v'+_0x231c6e[_0x17fb('0x1')]:'',_0x5da772=_0x231c6e[_0x17fb('0x32')]+_0xf51282,_0x4905fd=JSON[_0x17fb('0x27')](index_esm_context[_0x17fb('0xf')]),_0x5b03bd=!_0x4905fd[_0x17fb('0x12')],_0x5f03b4=matchProduct(_0x4905fd,_0x231c6e[_0x17fb('0x20')]),_0x26711c;if(_0x5b03bd){if(_0x17fb('0x2')!==_0x17fb('0xe'))_0x26711c={'type':0x0,'packageName':_0x5da772,'docsUrl':_0x231c6e[_0x17fb('0x1d')]};else{function _0x4c0ffc(){var _0x36b895=_0x4905fd[_0x17fb('0x9')];if(!_0x36b895||!_0x36b895[_0x17fb('0x4')])return null;var _0x3bf4ee=new Set(productCodes);return _0x36b895[_0x17fb('0x22')](function(_0x2e49f8){return _0x3bf4ee[_0x17fb('0x3a')](_0x2e49f8[_0x17fb('0x19')]);});}}}else{if(_0x17fb('0x10')===_0x17fb('0x23')){function _0x36fd18(){var _0x5ad726=_0x17fb('0x2b')+_0x26711c[_0x17fb('0x18')]+'\\x0a';if(_0x26711c[_0x17fb('0x3b')]===0x2)_0x5ad726+=_0x17fb('0x6')+_0x26711c[_0x17fb('0x2d')][_0x17fb('0x31')]()+_0x17fb('0xa')+_0x26711c[_0x17fb('0x1f')][_0x17fb('0x31')]()+'.\\x0a';else{if(_0x26711c[_0x17fb('0x3b')]===0x0)_0x5ad726+=_0x17fb('0x34');else _0x26711c[_0x17fb('0x3b')]===0x1&&(_0x5ad726+=_0x17fb('0x15'));}return _0x5ad726+=_0x17fb('0x28')+_0x26711c[_0x17fb('0x2c')]+_0x17fb('0x35'),_0x5ad726;}}else{if(!_0x5f03b4){if(_0x17fb('0x39')===_0x17fb('0x5')){function _0x12b830(){console[_0x17fb('0x2f')](_0x1ad8fc);}}else _0x26711c={'type':0x1,'packageName':_0x5da772,'docsUrl':_0x231c6e[_0x17fb('0x1d')]};}else{if(_0x17fb('0x2e')===_0x17fb('0xb')){function _0x116f54(){_0x26711c={'type':0x0,'packageName':_0x5da772,'docsUrl':_0x231c6e[_0x17fb('0x1d')]};}}else{if(_0x5f03b4[_0x17fb('0x29')]<_0x231c6e[_0x17fb('0x1f')]){if(_0x17fb('0x24')!==_0x17fb('0x24')){function _0x9a7c90(){var _0x5a2005=_0x17fb('0x1c')+_0x231c6e[_0x17fb('0x25')],_0x49e359=typeof console[_0x17fb('0x2f')]===_0x17fb('0xd');_0x49e359?console[_0x17fb('0x2f')](_0x5a2005):console[_0x17fb('0x13')](_0x5a2005),console[_0x17fb('0x13')](formatError(_0x26711c)),_0x49e359&&console[_0x17fb('0x8')]();}}else _0x26711c={'type':0x2,'packageName':_0x5da772,'publishDate':parseDate(_0x231c6e[_0x17fb('0x1f')]),'expiryDate':parseDate(_0x5f03b4[_0x17fb('0x29')]),'docsUrl':_0x231c6e[_0x17fb('0x1d')]};}}}}}if(_0x26711c&&typeof console===_0x17fb('0x16')){if(_0x17fb('0x7')===_0x17fb('0x3d')){function _0x51d874(){console[_0x17fb('0x8')]();}}else{var _0x1ad8fc=_0x17fb('0x1c')+_0x231c6e[_0x17fb('0x25')],_0x167679=typeof console[_0x17fb('0x2f')]===_0x17fb('0xd');if(_0x167679){if(_0x17fb('0x3c')!==_0x17fb('0x37'))console[_0x17fb('0x2f')](_0x1ad8fc);else{function _0x441019(){return null;}}}else{if(_0x17fb('0x33')===_0x17fb('0x26')){function _0x10cb0d(){message+=_0x17fb('0x34');}}else console[_0x17fb('0x13')](_0x1ad8fc);}console[_0x17fb('0x13')](formatError(_0x26711c));if(_0x167679){if(_0x17fb('0x30')!==_0x17fb('0x1e'))console[_0x17fb('0x8')]();else{function _0x4eb84b(){_0x26711c={'type':0x1,'packageName':_0x5da772,'docsUrl':_0x231c6e[_0x17fb('0x1d')]};}}}}}var _0x489e60=!_0x26711c;return cache[_0x17fb('0x3')](_0x231c6e[_0x17fb('0x32')],_0x489e60),_0x489e60;}function formatError(_0x1a8fe1){var _0x1028b1=_0x17fb('0x2b')+_0x1a8fe1[_0x17fb('0x18')]+'\\x0a';if(_0x1a8fe1[_0x17fb('0x3b')]===0x2){if(_0x17fb('0x0')===_0x17fb('0x36')){function _0xde44b9(){return new Date(timestamp*0x3e8);}}else _0x1028b1+=_0x17fb('0x6')+_0x1a8fe1[_0x17fb('0x2d')][_0x17fb('0x31')]()+_0x17fb('0xa')+_0x1a8fe1[_0x17fb('0x1f')][_0x17fb('0x31')]()+'.\\x0a';}else{if(_0x1a8fe1[_0x17fb('0x3b')]===0x0){if(_0x17fb('0x14')!==_0x17fb('0x38'))_0x1028b1+=_0x17fb('0x34');else{function _0x192cf5(){return packageProducts[_0x17fb('0x3a')](product[_0x17fb('0x19')]);}}}else{if(_0x1a8fe1[_0x17fb('0x3b')]===0x1){if(_0x17fb('0x17')===_0x17fb('0xc')){function _0x1a4d83(){console[_0x17fb('0x13')](header);}}else _0x1028b1+=_0x17fb('0x15');}}}return _0x1028b1+=_0x17fb('0x28')+_0x1a8fe1[_0x17fb('0x2c')]+_0x17fb('0x35'),_0x1028b1;}function matchProduct(_0x5a5e37,_0x26c644){var _0x1b0686=_0x5a5e37[_0x17fb('0x9')];if(!_0x1b0686||!_0x1b0686[_0x17fb('0x4')]){if(_0x17fb('0x1b')===_0x17fb('0x1b'))return null;else{function _0x2706c6(){message+=_0x17fb('0x15');}}}var _0x1e133e=new Set(_0x26c644);return _0x1b0686[_0x17fb('0x22')](function(_0x1ee491){if(_0x17fb('0x2a')===_0x17fb('0x1a')){function _0x222f5c(){licenseProduct[_0x17fb('0x29')]<meta[_0x17fb('0x1f')]&&(error={'type':0x2,'packageName':packageName,'publishDate':parseDate(meta[_0x17fb('0x1f')]),'expiryDate':parseDate(licenseProduct[_0x17fb('0x29')]),'docsUrl':meta[_0x17fb('0x1d')]});}}else return _0x1e133e[_0x17fb('0x3a')](_0x1ee491[_0x17fb('0x19')]);});}function parseDate(_0x282e4b){return new Date(_0x282e4b*0x3e8);}\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/common/constants.js\nconst ARC = \"arc\";\nconst AXIS_LABEL_CLICK = \"axisLabelClick\";\nconst BLACK = \"#000\";\nconst BOTTOM = \"bottom\";\nconst CENTER = \"center\";\nconst CIRCLE = \"circle\";\nconst COORD_PRECISION = 3;\nconst CROSS = \"cross\";\nconst DATE = \"date\";\nconst DEFAULT_FONT = \"12px sans-serif\";\nconst DEFAULT_HEIGHT = 400;\nconst DEFAULT_PRECISION = 10;\nconst DEFAULT_WIDTH = 600;\nconst END = \"end\";\nconst FORMAT_REGEX = /\\{\\d+:?/;\nconst HEIGHT = \"height\";\nconst HIGHLIGHT_ZINDEX = 100;\nconst INSIDE = \"inside\";\nconst LEFT = \"left\";\nconst MAX_VALUE = Number.MAX_VALUE;\nconst MIN_VALUE = -Number.MAX_VALUE;\nconst NONE = \"none\";\nconst NOTE_CLICK = \"noteClick\";\nconst NOTE_HOVER = \"noteHover\";\nconst NOTE_LEAVE = \"noteLeave\";\nconst OBJECT = \"object\";\nconst OUTSIDE = \"outside\";\nconst RIGHT = \"right\";\nconst START = \"start\";\nconst STRING = \"string\";\nconst TOP = \"top\";\nconst TRIANGLE = \"triangle\";\nconst VALUE = \"value\";\nconst WHITE = \"#fff\";\nconst WIDTH = \"width\";\nconst X = \"x\";\nconst Y = \"y\";\nconst DEFAULT_SERIES_OPACITY = 1;\n\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/common/is-array.js\nfunction isArray(value) {\n    return Array.isArray(value);\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/common/add-class.js\n\n\nfunction addClass(element, classes) {\n    const classArray = isArray(classes) ? classes : [ classes ];\n\n    for (let idx = 0; idx < classArray.length; idx++) {\n        const className = classArray[idx];\n        if (element.className.indexOf(className) === -1) {\n            element.className += \" \" + className;\n        }\n    }\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/common/remove-class.js\nconst SPACE_REGEX = /\\s+/g;\n\nfunction removeClass(element, className) {\n    if (element && element.className) {\n        element.className = element.className.replace(className, \"\").replace(SPACE_REGEX, \" \");\n    }\n}\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/main.js + 33 modules\nvar main = __webpack_require__(\"16KE\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/common/align-path-to-pixel.js\n\n\nfunction alignPathToPixel(path) {\n    let offset = 0.5;\n    if (path.options.stroke && main[\"a\" /* drawing */].util.defined(path.options.stroke.width)) {\n        if (path.options.stroke.width % 2 === 0) {\n            offset = 0;\n        }\n    }\n\n    for (let i = 0; i < path.segments.length; i++) {\n        path.segments[i].anchor().round(0).translate(offset, offset);\n    }\n\n    return path;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/common/clockwise.js\nfunction clockwise(angle1, angle2) {\n    // True if angle2 is clockwise of angle1\n    // assuming angles grow in clock-wise direction\n    // (as in the pie and radar charts)\n    return -angle1.x * angle2.y + angle1.y * angle2.x < 0;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/common/is-number.js\nfunction isNumber(value) {\n    return typeof value === \"number\" && !isNaN(value);\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/common/is-string.js\n\n\nfunction isString(value) {\n    return typeof value === STRING;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/common/convertable-to-number.js\n\n\n\nfunction convertableToNumber(value) {\n    return isNumber(value) || (isString(value) && isFinite(value));\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/common/is-function.js\nfunction isFunction(fn) {\n    return typeof fn === \"function\";\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/common/deep-extend.js\n\n\nconst deep_extend_OBJECT = \"object\";\nconst UNDEFINED = \"undefined\";\n\nfunction deepExtendOne(destination, source) {\n\n    for (let property in source) {\n        let propValue = source[property];\n        let propType = typeof propValue;\n\n        let propInit;\n        if (propType === deep_extend_OBJECT && propValue !== null) {\n            propInit = propValue.constructor;\n        } else {\n            propInit = null;\n        }\n\n        if (propInit && propInit !== Array) {\n\n            if (propValue instanceof Date) {\n                destination[property] = new Date(propValue.getTime());\n            } else if (isFunction(propValue.clone)) {\n                destination[property] = propValue.clone();\n            } else {\n                let destProp = destination[property];\n                if (typeof (destProp) === deep_extend_OBJECT) {\n                    destination[property] = destProp || {};\n                } else {\n                    destination[property] = {};\n                }\n                deepExtendOne(destination[property], propValue);\n            }\n        } else if (propType !== UNDEFINED) {\n            destination[property] = propValue;\n        }\n    }\n\n    return destination;\n}\n\nfunction deepExtend(destination) {\n    const length = arguments.length;\n\n    for (let i = 1; i < length; i++) {\n        deepExtendOne(destination, arguments[i]);\n    }\n\n    return destination;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/common/is-object.js\nfunction isObject(value) {\n    return typeof value === \"object\";\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/common/style-value.js\n\n\nfunction styleValue(value) {\n    if (isNumber(value)) {\n        return value + \"px\";\n    }\n    return value;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/common/element-styles.js\n\n\n\n\n\nconst SIZE_STYLES_REGEX = /width|height|top|left|bottom|right/i;\n\nfunction isSizeField(field) {\n    return SIZE_STYLES_REGEX.test(field);\n}\n\nfunction element_styles_elementStyles(element, styles) {\n    const stylesArray = isString(styles) ? [ styles ] : styles;\n\n    if (isArray(stylesArray)) {\n        const result = {};\n        const style = window.getComputedStyle(element);\n\n        for (let idx = 0; idx < stylesArray.length; idx++) {\n            let field = stylesArray[idx];\n            result[field] = isSizeField(field) ? parseFloat(style[field]) : style[field];\n        }\n\n        return result;\n    } else if (isObject(styles)) {\n        for (let field in styles) {\n            element.style[field] = styleValue(styles[field]);\n        }\n    }\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/common/get-spacing.js\n\n\nfunction getSpacing(value, defaultSpacing = 0) {\n    const spacing = { top: 0, right: 0, bottom: 0, left: 0 };\n\n    if (typeof(value) === \"number\") {\n        spacing[TOP] = spacing[RIGHT] = spacing[BOTTOM] = spacing[LEFT] = value;\n    } else {\n        spacing[TOP] = value[TOP] || defaultSpacing;\n        spacing[RIGHT] = value[RIGHT] || defaultSpacing;\n        spacing[BOTTOM] = value[BOTTOM] || defaultSpacing;\n        spacing[LEFT] = value[LEFT] || defaultSpacing;\n    }\n\n    return spacing;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/services/intl-service.js\nconst defaultImplementation = {\n    format: (format, value) => value,\n\n    toString: (value) => value,\n\n    parseDate: (value) => new Date(value),\n\n    firstDay: () => 0\n};\n\nlet intl_service_current = defaultImplementation;\n\nclass intl_service_IntlService {\n    static register(userImplementation) {\n        intl_service_current = userImplementation;\n    }\n\n    static get implementation() {\n        return intl_service_current;\n    }\n}\n\n/* harmony default export */ var intl_service = (intl_service_IntlService);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/services/format-service.js\n\n\n\n\nconst FORMAT_REPLACE_REGEX = /\\{(\\d+)(:[^\\}]+)?\\}/g;\n\nclass format_service_FormatService {\n    constructor(intlService) {\n        this._intlService = intlService;\n    }\n\n    get intl() {\n        return this._intlService || intl_service.implementation;\n    }\n\n    set intl(value) {\n        this._intlService = value;\n    }\n\n    auto(formatString, ...values) {\n        const intl = this.intl;\n\n        if (isString(formatString) && formatString.match(FORMAT_REGEX)) {\n            return intl.format(formatString, ...values);\n        }\n\n        return intl.toString(values[0], formatString);\n    }\n\n    localeAuto(formatString, values, locale) {\n        const intl = this.intl;\n        let result;\n\n        if (isString(formatString) && formatString.match(FORMAT_REGEX)) {\n            result = formatString.replace(FORMAT_REPLACE_REGEX, function(match, index, placeholderFormat) {\n                let value = values[parseInt(index, 10)];\n\n                return intl.toString(value, placeholderFormat ? placeholderFormat.substring(1) : \"\", locale);\n            });\n        } else {\n            result = intl.toString(values[0], formatString, locale);\n        }\n\n        return result;\n    }\n}\n\n/* harmony default export */ var format_service = (format_service_FormatService);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/services/chart-service.js\n\n\n\nclass chart_service_ChartService {\n    constructor(chart, context = {}) {\n        this._intlService = context.intlService;\n        this.sender = context.sender || chart;\n        this.format = new format_service(context.intlService);\n        this.chart = chart;\n        this.rtl = Boolean(context.rtl);\n    }\n\n    get intl() {\n        return this._intlService || intl_service.implementation;\n    }\n\n    set intl(value) {\n        this._intlService = value;\n        this.format.intl = value;\n    }\n\n    notify(name, args) {\n        if (this.chart) {\n            this.chart.trigger(name, args);\n        }\n    }\n\n    isPannable(axis) {\n        const pannable = ((this.chart || {}).options || {}).pannable;\n        return pannable && pannable.lock !== axis;\n    }\n}\n\n/* harmony default export */ var chart_service = (chart_service_ChartService);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/services/dom-events-builder.js\nlet dom_events_builder_current;\n\nclass DomEventsBuilder {\n    static register(userImplementation) {\n        dom_events_builder_current = userImplementation;\n    }\n\n    static create(element, events) {\n        if (dom_events_builder_current) {\n            return dom_events_builder_current.create(element, events);\n        }\n    }\n}\n\n/* harmony default export */ var dom_events_builder = (DomEventsBuilder);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/services/template-service.js\nlet template_service_current = {\n    compile: function(template) {\n        return template;\n    }\n};\n\nclass TemplateService {\n    static register(userImplementation) {\n        template_service_current = userImplementation;\n    }\n\n    static compile(template) {\n        return template_service_current.compile(template);\n    }\n}\n\n/* harmony default export */ var template_service = (TemplateService);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/services.js\n\n\n\n\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/common/get-template.js\n\n\n\nfunction getTemplate(options = {}) {\n    let template;\n    if (options.template) {\n        options.template = template = template_service.compile(options.template);\n    } else if (isFunction(options.content)) {\n        template = options.content;\n    }\n\n    return template;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/common/getter.js\n\n\nconst FIELD_REGEX = /\\[(?:(\\d+)|['\"](.*?)['\"])\\]|((?:(?!\\[.*?\\]|\\.).)+)/g;\nconst getterCache = {};\n\ngetterCache['undefined'] = function(obj) {\n    return obj;\n};\n\nfunction getter_getter(field) {\n    if (getterCache[field]) {\n        return getterCache[field];\n    }\n\n    const fields = [];\n    field.replace(FIELD_REGEX, function(match, index, indexAccessor, field) {\n        fields.push(main[\"a\" /* drawing */].util.defined(index) ? index : (indexAccessor || field));\n    });\n\n    getterCache[field] = function(obj) {\n        let result = obj;\n        for (let idx = 0; idx < fields.length && result; idx++) {\n            result = result[fields[idx]];\n        }\n\n        return result;\n    };\n\n    return getterCache[field];\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/common/grep.js\nfunction grep(array, callback) {\n    const length = array.length;\n    const result = [];\n    for (let idx = 0; idx < length; idx++) {\n        if (callback(array[idx])) {\n            result .push(array[idx]);\n        }\n    }\n\n    return result;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/common/has-classes.js\nfunction hasClasses(element, classNames) {\n    if (element.className) {\n        const names = classNames.split(\" \");\n        for (let idx = 0; idx < names.length; idx++) {\n            if (element.className.indexOf(names[idx]) !== -1) {\n                return true;\n            }\n        }\n    }\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/common/hash-map.js\n\nclass HashMap {\n    constructor() {\n        this._map = {};\n    }\n\n    get(name) {\n        return this._map[this._key(name)];\n    }\n\n    set(name, value) {\n        this._map[this._key(name)] = value;\n    }\n\n    _key(name) {\n        return name instanceof Date ? name.getTime() : name;\n    }\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/common/in-array.js\nfunction inArray(value, array) {\n    if (array) {\n        return array.indexOf(value) !== -1;\n    }\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/common/interpolate-value.js\n\n\n\nfunction interpolateValue(start, end, progress) {\n    return main[\"a\" /* drawing */].util.round(start + (end - start) * progress, COORD_PRECISION);\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/common/instance-observer.js\n\n\nconst TRIGGER = 'trigger';\n\nclass instance_observer_InstanceObserver {\n    constructor(observer, handlers) {\n        this.observer = observer;\n        this.handlerMap = deepExtend({}, this.handlerMap, handlers);\n    }\n\n    trigger(name, args) {\n        const { observer, handlerMap } = this;\n        let isDefaultPrevented;\n        if (handlerMap[name]) {\n            isDefaultPrevented = this.callObserver(handlerMap[name], args);\n        } else if (observer[TRIGGER]) {\n            isDefaultPrevented = this.callObserver(TRIGGER, name, args);\n        }\n\n        return isDefaultPrevented;\n    }\n\n    callObserver(fnName, ...args) {\n        return this.observer[fnName].apply(this.observer, args);\n    }\n\n    requiresHandlers(names) {\n        if (this.observer.requiresHandlers) {\n            return this.observer.requiresHandlers(names);\n        }\n\n        for (let idx = 0; idx < names.length; idx++) {\n            if (this.handlerMap[names[idx]]) {\n                return true;\n            }\n        }\n    }\n}\n\n/* harmony default export */ var instance_observer = (instance_observer_InstanceObserver);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/common/map.js\n\n\nfunction map_map(array, callback) {\n    const length = array.length;\n    const result = [];\n    for (let idx = 0; idx < length; idx++) {\n        let value = callback(array[idx]);\n        if (main[\"a\" /* drawing */].util.defined(value)) {\n            result.push(value);\n        }\n    }\n    return result;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/common/mousewheel-delta.js\n\n\nfunction mousewheelDelta(e) {\n    let delta = 0;\n\n    if (e.wheelDelta) {\n        delta = -e.wheelDelta / 120;\n        delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);\n    }\n\n    if (e.detail) {\n        delta = main[\"a\" /* drawing */].util.round(e.detail / 3);\n    }\n\n    return delta;\n}\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/common/class.js\nvar common_class = __webpack_require__(\"LHUb\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/common/log-to-console.js\nvar log_to_console = __webpack_require__(\"l/PP\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/drawing-utils.js\n\n\nconst { append, bindEvents, defined, deg, elementOffset: drawing_utils_elementOffset, elementSize: drawing_utils_elementSize, eventElement, eventCoordinates, last, limitValue, objectKey, rad, round, unbindEvents, valueOrDefault } = main[\"a\" /* drawing */].util;\n\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/common/font-loader.js\n\n\nclass font_loader_FontLoader {\n    static fetchFonts(options, fonts, state = { depth: 0 }) {\n        const MAX_DEPTH = 5;\n\n        if (!options || state.depth > MAX_DEPTH || !document.fonts) {\n            return;\n        }\n\n        Object.keys(options).forEach(function(key) {\n            const value = options[key];\n            if (key === \"dataSource\" || key[0] === \"$\" || !value) {\n                return;\n            }\n\n            if (key === \"font\") {\n                fonts.push(value);\n            } else if (typeof value === \"object\") {\n                state.depth++;\n                font_loader_FontLoader.fetchFonts(value, fonts, state);\n                state.depth--;\n            }\n        });\n    }\n\n    static loadFonts(fonts, callback) {\n        let promises = [];\n\n        if (fonts.length > 0 && document.fonts) {\n            try {\n                promises = fonts.map(function(font) {\n                    return document.fonts.load(font);\n                });\n            } catch (e) {\n                // Silence font-loading errors\n                Object(log_to_console[\"a\" /* default */])(e);\n            }\n\n            Promise.all(promises).then(callback, callback);\n        } else {\n            callback();\n        }\n    }\n\n    static preloadFonts(options, callback) {\n        const fonts = [];\n        font_loader_FontLoader.fetchFonts(options, fonts);\n\n        font_loader_FontLoader.loadFonts(fonts, callback);\n    }\n}\n\n/* harmony default export */ var font_loader = (font_loader_FontLoader);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/common/set-default-options.js\n\n\nfunction setDefaultOptions(type, options) {\n    const proto = type.prototype;\n    if (proto.options) {\n        proto.options = deepExtend({}, proto.options, options);\n    } else {\n        proto.options = options;\n    }\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/common/sparse-array-limits.js\n\n\nfunction sparseArrayLimits(arr) {\n    let min = MAX_VALUE;\n    let max = MIN_VALUE;\n\n    for (let idx = 0, length = arr.length; idx < length; idx++) {\n        const value = arr[idx];\n        if (value !== null && isFinite(value)) {\n            min = Math.min(min, value);\n            max = Math.max(max, value);\n        }\n    }\n\n    return {\n        min: min === MAX_VALUE ? undefined : min,\n        max: max === MIN_VALUE ? undefined : max\n    };\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/common/find.js\nfunction find(array, predicate) {\n    for (let i = 0; i < array.length; i++) {\n        const item = array[i];\n        if (predicate(item, i, array)) {\n            return item;\n        }\n    }\n}\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/common/element-scale.js\n\n\nconst Matrix = main[\"b\" /* geometry */].Matrix;\nconst matrixRegexp = /matrix\\((.*)\\)/;\n\nfunction parseMatrix(matrixString) {\n    const match = matrixString.match(matrixRegexp);\n    if (match === null || match.length !== 2) {\n        return Matrix.unit();\n    }\n\n    const members = match[1].split(',').map(x => parseFloat(x));\n    return new Matrix(...members);\n}\n\nfunction transformMatrix(element) {\n    const transform = getComputedStyle(element).transform;\n\n    if (transform === 'none') {\n        return Matrix.unit();\n    }\n\n    return parseMatrix(transform);\n}\n\nfunction elementScale(element) {\n    if (!element) {\n        return Matrix.unit();\n    }\n\n    let matrix = transformMatrix(element);\n    let parent = element.parentElement;\n    while (parent) {\n        const parentMatrix = transformMatrix(parent);\n        matrix = matrix.multiplyCopy(parentMatrix);\n        parent = parent.parentElement;\n    }\n\n    matrix.b = matrix.c = matrix.e = matrix.f = 0;\n    return matrix;\n}\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/common.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/utils/auto-major-unit.js\n\n\n\nfunction autoMajorUnit(min, max) {\n    let diff = round(max - min, DEFAULT_PRECISION - 1);\n\n    if (diff === 0) {\n        if (max === 0) {\n            return 0.1;\n        }\n\n        diff = Math.abs(max);\n    }\n\n    const scale = Math.pow(10, Math.floor(Math.log(diff) / Math.log(10)));\n    const relativeValue = round((diff / scale), DEFAULT_PRECISION);\n    let scaleMultiplier = 1;\n\n    if (relativeValue < 1.904762) {\n        scaleMultiplier = 0.2;\n    } else if (relativeValue < 4.761904) {\n        scaleMultiplier = 0.5;\n    } else if (relativeValue < 9.523809) {\n        scaleMultiplier = 1;\n    } else {\n        scaleMultiplier = 2;\n    }\n\n    return round(scale * scaleMultiplier, DEFAULT_PRECISION);\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/point.js\n\n\n\nclass point_Point extends common_class[\"a\" /* default */] {\n    constructor(x, y) {\n        super();\n\n        this.x = x || 0;\n        this.y = y || 0;\n    }\n\n    clone() {\n        return new point_Point(this.x, this.y);\n    }\n\n    equals(point) {\n        return point && this.x === point.x && this.y === point.y;\n    }\n\n    rotate(center, degrees) {\n        const theta = rad(degrees);\n        const cosT = Math.cos(theta);\n        const sinT = Math.sin(theta);\n        const { x: cx, y: cy } = center;\n        const { x, y } = this;\n\n        this.x = round(\n            cx + (x - cx) * cosT + (y - cy) * sinT,\n            COORD_PRECISION\n        );\n\n        this.y = round(\n            cy + (y - cy) * cosT - (x - cx) * sinT,\n            COORD_PRECISION\n        );\n\n        return this;\n    }\n\n    multiply(a) {\n\n        this.x *= a;\n        this.y *= a;\n\n        return this;\n    }\n\n    distanceTo(point) {\n        const dx = this.x - point.x;\n        const dy = this.y - point.y;\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    static onCircle(center, angle, radius) {\n        const radians = rad(angle);\n\n        return new point_Point(\n            center.x - radius * Math.cos(radians),\n            center.y - radius * Math.sin(radians)\n        );\n    }\n}\n\n\n/* harmony default export */ var core_point = (point_Point);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/box.js\n\n\n\n\n\n\n\nclass box_Box extends common_class[\"a\" /* default */] {\n    constructor(x1, y1, x2, y2) {\n        super();\n\n        this.x1 = x1 || 0;\n        this.y1 = y1 || 0;\n        this.x2 = x2 || 0;\n        this.y2 = y2 || 0;\n    }\n\n    equals(box) {\n        return this.x1 === box.x1 && this.x2 === box.x2 &&\n            this.y1 === box.y1 && this.y2 === box.y2;\n    }\n\n    width() {\n        return this.x2 - this.x1;\n    }\n\n    height() {\n        return this.y2 - this.y1;\n    }\n\n    translate(dx, dy) {\n        this.x1 += dx;\n        this.x2 += dx;\n        this.y1 += dy;\n        this.y2 += dy;\n\n        return this;\n    }\n\n    move(x, y) {\n        const height = this.height();\n        const width = this.width();\n\n        if (defined(x)) {\n            this.x1 = x;\n            this.x2 = this.x1 + width;\n        }\n\n        if (defined(y)) {\n            this.y1 = y;\n            this.y2 = this.y1 + height;\n        }\n\n        return this;\n    }\n\n    wrap(targetBox) {\n        this.x1 = Math.min(this.x1, targetBox.x1);\n        this.y1 = Math.min(this.y1, targetBox.y1);\n        this.x2 = Math.max(this.x2, targetBox.x2);\n        this.y2 = Math.max(this.y2, targetBox.y2);\n\n        return this;\n    }\n\n    wrapPoint(point) {\n        const arrayPoint = isArray(point);\n        const x = arrayPoint ? point[0] : point.x;\n        const y = arrayPoint ? point[1] : point.y;\n        this.wrap(new box_Box(x, y, x, y));\n\n        return this;\n    }\n\n    snapTo(targetBox, axis) {\n\n        if (axis === X || !axis) {\n            this.x1 = targetBox.x1;\n            this.x2 = targetBox.x2;\n        }\n\n        if (axis === Y || !axis) {\n            this.y1 = targetBox.y1;\n            this.y2 = targetBox.y2;\n        }\n\n        return this;\n    }\n\n    alignTo(targetBox, anchor) {\n        const height = this.height();\n        const width = this.width();\n        const axis = anchor === TOP || anchor === BOTTOM ? Y : X;\n        const offset = axis === Y ? height : width;\n\n        if (anchor === CENTER) {\n            const targetCenter = targetBox.center();\n            const center = this.center();\n\n            this.x1 += targetCenter.x - center.x;\n            this.y1 += targetCenter.y - center.y;\n        } else if (anchor === TOP || anchor === LEFT) {\n            this[axis + 1] = targetBox[axis + 1] - offset;\n        } else {\n            this[axis + 1] = targetBox[axis + 2];\n        }\n\n        this.x2 = this.x1 + width;\n        this.y2 = this.y1 + height;\n\n        return this;\n    }\n\n    shrink(dw, dh) {\n\n        this.x2 -= dw;\n        this.y2 -= dh;\n\n        return this;\n    }\n\n    expand(dw, dh) {\n        this.shrink(-dw, -dh);\n        return this;\n    }\n\n    pad(padding) {\n        const spacing = getSpacing(padding);\n\n        this.x1 -= spacing.left;\n        this.x2 += spacing.right;\n        this.y1 -= spacing.top;\n        this.y2 += spacing.bottom;\n\n        return this;\n    }\n\n    unpad(padding) {\n        const spacing = getSpacing(padding);\n\n        spacing.left = -spacing.left;\n        spacing.top = -spacing.top;\n        spacing.right = -spacing.right;\n        spacing.bottom = -spacing.bottom;\n\n        return this.pad(spacing);\n    }\n\n    clone() {\n        return new box_Box(this.x1, this.y1, this.x2, this.y2);\n    }\n\n    center() {\n        return new core_point(\n            this.x1 + this.width() / 2,\n            this.y1 + this.height() / 2\n        );\n    }\n\n    containsPoint(point) {\n\n        return point.x >= this.x1 && point.x <= this.x2 &&\n               point.y >= this.y1 && point.y <= this.y2;\n    }\n\n    points() {\n        return [\n            new core_point(this.x1, this.y1),\n            new core_point(this.x2, this.y1),\n            new core_point(this.x2, this.y2),\n            new core_point(this.x1, this.y2)\n        ];\n    }\n\n    getHash() {\n        return [ this.x1, this.y1, this.x2, this.y2 ].join(\",\");\n    }\n\n    overlaps(box) {\n        return !(box.y2 < this.y1 || this.y2 < box.y1 || box.x2 < this.x1 || this.x2 < box.x1);\n    }\n\n    rotate(rotation) {\n        let width = this.width();\n        let height = this.height();\n        const { x: cx, y: cy } = this.center();\n\n        const r1 = rotatePoint(0, 0, cx, cy, rotation);\n        const r2 = rotatePoint(width, 0, cx, cy, rotation);\n        const r3 = rotatePoint(width, height, cx, cy, rotation);\n        const r4 = rotatePoint(0, height, cx, cy, rotation);\n\n        width = Math.max(r1.x, r2.x, r3.x, r4.x) - Math.min(r1.x, r2.x, r3.x, r4.x);\n        height = Math.max(r1.y, r2.y, r3.y, r4.y) - Math.min(r1.y, r2.y, r3.y, r4.y);\n\n        this.x2 = this.x1 + width;\n        this.y2 = this.y1 + height;\n\n        return this;\n    }\n\n    toRect() {\n        return new main[\"b\" /* geometry */].Rect([ this.x1, this.y1 ], [ this.width(), this.height() ]);\n    }\n\n    hasSize() {\n        return this.width() !== 0 && this.height() !== 0;\n    }\n\n    align(targetBox, axis, alignment) {\n        const c1 = axis + 1;\n        const c2 = axis + 2;\n        const sizeFunc = axis === X ? WIDTH : HEIGHT;\n        const size = this[sizeFunc]();\n\n        if (inArray(alignment, [ LEFT, TOP ])) {\n            this[c1] = targetBox[c1];\n            this[c2] = this[c1] + size;\n        } else if (inArray(alignment, [ RIGHT, BOTTOM ])) {\n            this[c2] = targetBox[c2];\n            this[c1] = this[c2] - size;\n        } else if (alignment === CENTER) {\n            this[c1] = targetBox[c1] + (targetBox[sizeFunc]() - size) / 2;\n            this[c2] = this[c1] + size;\n        }\n    }\n}\n\nfunction rotatePoint(x, y, cx, cy, angle) {\n    const theta = rad(angle);\n\n    return new core_point(\n        cx + (x - cx) * Math.cos(theta) + (y - cy) * Math.sin(theta),\n        cy - (x - cx) * Math.sin(theta) + (y - cy) * Math.cos(theta)\n    );\n}\n\n/* harmony default export */ var core_box = (box_Box);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/ring.js\n\n\n\n\n\nclass ring_Ring extends common_class[\"a\" /* default */] {\n\n    constructor(center, innerRadius, radius, startAngle, angle) {\n        super();\n\n        this.center = center;\n        this.innerRadius = innerRadius;\n        this.radius = radius;\n        this.startAngle = startAngle;\n        this.angle = angle;\n    }\n\n    clone() {\n        return new ring_Ring(this.center, this.innerRadius, this.radius, this.startAngle, this.angle);\n    }\n\n    middle() {\n        return this.startAngle + this.angle / 2;\n    }\n\n    setRadius(newRadius, innerRadius) {\n        if (innerRadius) {\n            this.innerRadius = newRadius;\n        } else {\n            this.radius = newRadius;\n        }\n\n        return this;\n    }\n\n    // TODO: Remove and replace with Point.onCircle\n    point(angle, innerRadius) {\n        const radianAngle = rad(angle);\n        const ax = Math.cos(radianAngle);\n        const ay = Math.sin(radianAngle);\n        const radius = innerRadius ? this.innerRadius : this.radius;\n        const x = round(this.center.x - (ax * radius), COORD_PRECISION);\n        const y = round(this.center.y - (ay * radius), COORD_PRECISION);\n\n        return new core_point(x, y);\n    }\n\n    adjacentBox(distance, width, height) {\n        const sector = this.clone().expand(distance);\n        const midAndle = sector.middle();\n        const midPoint = sector.point(midAndle);\n        const hw = width / 2;\n        const hh = height / 2;\n        const sa = Math.sin(rad(midAndle));\n        const ca = Math.cos(rad(midAndle));\n        let x = midPoint.x - hw;\n        let y = midPoint.y - hh;\n\n        if (Math.abs(sa) < 0.9) {\n            x += hw * -ca / Math.abs(ca);\n        }\n\n        if (Math.abs(ca) < 0.9) {\n            y += hh * -sa / Math.abs(sa);\n        }\n\n        return new core_box(x, y, x + width, y + height);\n    }\n\n    containsPoint(p) {\n        const center = this.center;\n        const innerRadius = this.innerRadius;\n        const radius = this.radius;\n        const startAngle = this.startAngle;\n        const endAngle = this.startAngle + this.angle;\n        const dx = p.x - center.x;\n        const dy = p.y - center.y;\n        const vector = new core_point(dx, dy);\n        const startPoint = this.point(startAngle);\n        const startVector = new core_point(startPoint.x - center.x, startPoint.y - center.y);\n        const endPoint = this.point(endAngle);\n        const endVector = new core_point(endPoint.x - center.x, endPoint.y - center.y);\n        const dist = round(dx * dx + dy * dy, COORD_PRECISION);\n\n        return (startVector.equals(vector) || clockwise(startVector, vector)) &&\n               !clockwise(endVector, vector) &&\n               dist >= innerRadius * innerRadius && dist <= radius * radius;\n    }\n\n    getBBox() {\n        const box = new core_box(MAX_VALUE, MAX_VALUE, MIN_VALUE, MIN_VALUE);\n        const startAngle = round(this.startAngle % 360);\n        const endAngle = round((startAngle + this.angle) % 360);\n        const innerRadius = this.innerRadius;\n        const allAngles = [ 0, 90, 180, 270, startAngle, endAngle ].sort(numericComparer);\n        const startAngleIndex = allAngles.indexOf(startAngle);\n        const endAngleIndex = allAngles.indexOf(endAngle);\n        let angles;\n\n        if (startAngle === endAngle) {\n            angles = allAngles;\n        } else {\n            if (startAngleIndex < endAngleIndex) {\n                angles = allAngles.slice(startAngleIndex, endAngleIndex + 1);\n            } else {\n                angles = [].concat(\n                    allAngles.slice(0, endAngleIndex + 1),\n                    allAngles.slice(startAngleIndex, allAngles.length)\n                );\n            }\n        }\n\n        for (let i = 0; i < angles.length; i++) {\n            let point = this.point(angles[i]);\n            box.wrapPoint(point);\n            box.wrapPoint(point, innerRadius);\n        }\n\n        if (!innerRadius) {\n            box.wrapPoint(this.center);\n        }\n\n        return box;\n    }\n\n    expand(value) {\n        this.radius += value;\n        return this;\n    }\n}\n\nfunction numericComparer(a, b) {\n    return a - b;\n}\n\n/* harmony default export */ var core_ring = (ring_Ring);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/sector.js\n\n\nclass sector_Sector extends core_ring {\n    constructor(center, radius, startAngle, angle) {\n        super(center, 0, radius, startAngle, angle);\n    }\n\n    expand(value) {\n        return super.expand(value);\n    }\n\n    clone() {\n        return new sector_Sector(this.center, this.radius, this.startAngle, this.angle);\n    }\n\n    setRadius(newRadius) {\n        this.radius = newRadius;\n\n        return this;\n    }\n}\n\n/* harmony default export */ var core_sector = (sector_Sector);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/shape-builder.js\n\n\nconst DIRECTION_ANGLE = 0.001; //any value that will make the endAngle bigger than the start angle will work here.\nlet shape_builder_ShapeBuilder = /*@__PURE__*/ (() => {\n    class ShapeBuilder extends common_class[\"a\" /* default */] {\n        createRing(sector, options) {\n            const startAngle = sector.startAngle + 180;\n            let endAngle = sector.angle + startAngle;\n            //required in order to avoid reversing the arc direction in cases like 0.000000000000001 + 100 === 100\n            if (sector.angle > 0 && startAngle === endAngle) {\n                endAngle += DIRECTION_ANGLE;\n            }\n            const center = new main[\"b\" /* geometry */].Point(sector.center.x, sector.center.y);\n            const radius = Math.max(sector.radius, 0);\n            const innerRadius = Math.max(sector.innerRadius, 0);\n            const arc = new main[\"b\" /* geometry */].Arc(center, {\n                startAngle: startAngle,\n                endAngle: endAngle,\n                radiusX: radius,\n                radiusY: radius\n            });\n            const path = main[\"a\" /* drawing */].Path.fromArc(arc, options).close();\n            if (innerRadius) {\n                arc.radiusX = arc.radiusY = innerRadius;\n                const innerEnd = arc.pointAt(endAngle);\n                path.lineTo(innerEnd.x, innerEnd.y);\n                path.arc(endAngle, startAngle, innerRadius, innerRadius, true);\n            }\n            else {\n                path.lineTo(center.x, center.y);\n            }\n            return path;\n        }\n    }\n    ShapeBuilder.current = new ShapeBuilder();\n    return ShapeBuilder;\n})();\n/* harmony default export */ var shape_builder = (shape_builder_ShapeBuilder);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/chart-element.js\n\n\n\n\n\nclass chart_element_ChartElement extends common_class[\"a\" /* default */] {\n    constructor(options) {\n        super();\n\n        this.children = [];\n\n        this.options = deepExtend({}, this.options, this.initUserOptions(options));\n    }\n\n    initUserOptions(options) {\n        return options;\n    }\n\n    reflow(targetBox) {\n        const children = this.children;\n        let box;\n\n        for (let i = 0; i < children.length; i++) {\n            let currentChild = children[i];\n            currentChild.reflow(targetBox);\n\n            box = box ? box.wrap(currentChild.box) : currentChild.box.clone();\n        }\n\n        this.box = box || targetBox;\n    }\n\n    destroy() {\n        const children = this.children;\n\n        if (this.animation) {\n            this.animation.destroy();\n        }\n\n        for (let i = 0; i < children.length; i++) {\n            children[i].destroy();\n        }\n    }\n\n    getRoot() {\n        const parent = this.parent;\n\n        return parent ? parent.getRoot() : null;\n    }\n\n    getSender() {\n        const service = this.getService();\n        if (service) {\n            return service.sender;\n        }\n    }\n\n    getService() {\n        let element = this;\n        while (element) {\n            if (element.chartService) {\n                return element.chartService;\n            }\n            element = element.parent;\n        }\n    }\n\n    translateChildren(dx, dy) {\n        const children = this.children;\n        const childrenCount = children.length;\n\n        for (let i = 0; i < childrenCount; i++) {\n            children[i].box.translate(dx, dy);\n        }\n    }\n\n    append() {\n        for (let i = 0; i < arguments.length; i++) {\n            let item = arguments[i];\n            this.children.push(item);\n            item.parent = this;\n        }\n    }\n\n    renderVisual() {\n        if (this.options.visible === false) {\n            return;\n        }\n\n        this.createVisual();\n\n        this.addVisual();\n\n        this.renderChildren();\n\n        this.createAnimation();\n        this.renderComplete();\n    }\n\n    addVisual() {\n        if (this.visual) {\n            this.visual.chartElement = this;\n\n            if (this.parent) {\n                this.parent.appendVisual(this.visual);\n            }\n        }\n    }\n\n    renderChildren() {\n        const children = this.children;\n        const length = children.length;\n        for (let i = 0; i < length; i++) {\n            children[i].renderVisual();\n        }\n    }\n\n    createVisual() {\n        this.visual = new main[\"a\" /* drawing */].Group({\n            zIndex: this.options.zIndex,\n            visible: valueOrDefault(this.options.visible, true)\n        });\n    }\n\n    createAnimation() {\n        if (this.visual && this.options.animation) {\n            this.animation = main[\"a\" /* drawing */].Animation.create(\n                this.visual, this.options.animation\n            );\n        }\n    }\n\n    appendVisual(childVisual) {\n        if (!childVisual.chartElement) {\n            childVisual.chartElement = this;\n        }\n\n        if (childVisual.options.noclip) {\n            this.clipRoot().visual.append(childVisual);\n        } else if (defined(childVisual.options.zIndex)) {\n            this.stackRoot().stackVisual(childVisual);\n        } else if (this.isStackRoot) {\n            this.stackVisual(childVisual);\n        } else if (this.visual) {\n            this.visual.append(childVisual);\n        } else {\n            // Allow chart elements without visuals to\n            // pass through child visuals\n            this.parent.appendVisual(childVisual);\n        }\n    }\n\n    clipRoot() {\n        if (this.parent) {\n            return this.parent.clipRoot();\n        }\n\n        return this;\n    }\n\n    stackRoot() {\n        if (this.parent) {\n            return this.parent.stackRoot();\n        }\n\n        return this;\n    }\n\n    stackVisual(childVisual) {\n        const zIndex = childVisual.options.zIndex || 0;\n        const visuals = this.visual.children;\n        const length = visuals.length;\n        let pos;\n\n        for (pos = 0; pos < length; pos++) {\n            let sibling = visuals[pos];\n            let here = valueOrDefault(sibling.options.zIndex, 0);\n            if (here > zIndex) {\n                break;\n            }\n        }\n\n        this.visual.insert(pos, childVisual);\n    }\n\n    traverse(callback) {\n        const children = this.children;\n        const length = children.length;\n\n        for (let i = 0; i < length; i++) {\n            let child = children[i];\n\n            callback(child);\n            if (child.traverse) {\n                child.traverse(callback);\n            }\n        }\n    }\n\n    closest(match) {\n        let element = this;\n        let matched = false;\n\n        while (element && !matched) {\n            matched = match(element);\n\n            if (!matched) {\n                element = element.parent;\n            }\n        }\n\n        if (matched) {\n            return element;\n        }\n    }\n\n    renderComplete() {}\n\n    hasHighlight() {\n        const options = (this.options || {}).highlight;\n        return !(!this.createHighlight || (options && options.visible === false));\n    }\n\n    toggleHighlight(show, opacity) {\n        const options = (this.options || {}).highlight || {};\n        const customVisual = options.visual;\n        let highlight = this._highlight;\n\n        if (!highlight) {\n            const highlightOptions = {\n                fill: {\n                    color: WHITE,\n                    opacity: opacity || 0.2\n                },\n                stroke: {\n                    color: WHITE,\n                    width: 1,\n                    opacity: opacity || 0.2\n                }\n            };\n\n            if (customVisual) {\n                highlight = this._highlight = customVisual(\n                    Object.assign(this.highlightVisualArgs(), {\n                        createVisual: () => this.createHighlight(highlightOptions),\n                        sender: this.getSender(),\n                        series: this.series,\n                        dataItem: this.dataItem,\n                        category: this.category,\n                        value: this.value,\n                        percentage: this.percentage,\n                        runningTotal: this.runningTotal,\n                        total: this.total\n                    }\n                ));\n\n                if (!highlight) {\n                    return;\n                }\n            } else {\n                highlight = this._highlight = this.createHighlight(highlightOptions);\n            }\n\n            if (!defined(highlight.options.zIndex)) {\n                highlight.options.zIndex = valueOrDefault(options.zIndex, this.options.zIndex);\n            }\n\n            this.appendVisual(highlight);\n        }\n\n        highlight.visible(show);\n    }\n\n    createGradientOverlay(element, options, gradientOptions) {\n        const overlay = new main[\"a\" /* drawing */].Path(Object.assign({\n            stroke: {\n                color: \"none\"\n            },\n            fill: this.createGradient(gradientOptions),\n            closed: element.options.closed\n        }, options));\n\n        overlay.segments.elements(element.segments.elements());\n\n        return overlay;\n    }\n\n    createGradient(options) {\n        if (this.parent) {\n            return this.parent.createGradient(options);\n        }\n    }\n\n    supportsPointInactiveOpacity() {\n        return true;\n    }\n}\n\nchart_element_ChartElement.prototype.options = { };\n\n/* harmony default export */ var chart_element = (chart_element_ChartElement);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/box-element.js\n\n\n\n\n\n\n\n\nclass box_element_BoxElement extends chart_element {\n    constructor(options) {\n        super(options);\n\n        this.options.margin = getSpacing(this.options.margin);\n        this.options.padding = getSpacing(this.options.padding);\n    }\n\n    reflow(targetBox) {\n        const options = this.options;\n        const { width, height, shrinkToFit } = options;\n        const hasSetSize = width && height;\n        const margin = options.margin;\n        const padding = options.padding;\n        const borderWidth = options.border.width;\n        let box;\n\n        const reflowPaddingBox = () => {\n            this.align(targetBox, X, options.align);\n            this.align(targetBox, Y, options.vAlign);\n            this.paddingBox = box.clone().unpad(margin).unpad(borderWidth);\n        };\n\n        let contentBox = targetBox.clone();\n        if (hasSetSize) {\n            contentBox.x2 = contentBox.x1 + width;\n            contentBox.y2 = contentBox.y1 + height;\n        }\n\n        if (shrinkToFit) {\n            contentBox.unpad(margin).unpad(borderWidth).unpad(padding);\n        }\n\n        super.reflow(contentBox);\n\n        if (hasSetSize) {\n            box = this.box = new core_box(0, 0, width, height);\n        } else {\n            box = this.box;\n        }\n\n        if (shrinkToFit && hasSetSize) {\n            reflowPaddingBox();\n            contentBox = this.contentBox = this.paddingBox.clone().unpad(padding);\n        } else {\n            contentBox = this.contentBox = box.clone();\n            box.pad(padding).pad(borderWidth).pad(margin);\n            reflowPaddingBox();\n        }\n\n        this.translateChildren(\n            box.x1 - contentBox.x1 + margin.left + borderWidth + padding.left,\n            box.y1 - contentBox.y1 + margin.top + borderWidth + padding.top\n        );\n\n        const children = this.children;\n        for (let i = 0; i < children.length; i++) {\n            let item = children[i];\n            item.reflow(item.box);\n        }\n    }\n\n    align(targetBox, axis, alignment) {\n        this.box.align(targetBox, axis, alignment);\n    }\n\n    hasBox() {\n        const options = this.options;\n        return options.border.width || options.background;\n    }\n\n    createVisual() {\n        super.createVisual();\n\n        const options = this.options;\n        if (options.visible && this.hasBox()) {\n            this.visual.append(main[\"a\" /* drawing */].Path.fromRect(\n                this.paddingBox.toRect(),\n                this.visualStyle()\n            ));\n        }\n    }\n\n    visualStyle() {\n        const options = this.options;\n        const border = options.border || {};\n\n        return {\n            stroke: {\n                width: border.width,\n                color: border.color,\n                opacity: valueOrDefault(border.opacity, options.opacity),\n                dashType: border.dashType\n            },\n            fill: {\n                color: options.background,\n                opacity: options.opacity\n            },\n            cursor: options.cursor\n        };\n    }\n}\n\nsetDefaultOptions(box_element_BoxElement, {\n    align: LEFT,\n    vAlign: TOP,\n    margin: {},\n    padding: {},\n    border: {\n        color: BLACK,\n        width: 0\n    },\n    background: \"\",\n    shrinkToFit: false,\n    width: 0,\n    height: 0,\n    visible: true\n});\n\n/* harmony default export */ var box_element = (box_element_BoxElement);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/shape-element.js\n\n\n\n\n\n\n\nclass shape_element_ShapeElement extends box_element {\n\n    constructor(options, pointData) {\n        super(options);\n\n        this.pointData = pointData;\n    }\n\n    getElement() {\n        const { options, paddingBox: box } = this;\n        const { type, rotation } = options;\n        const center = box.center();\n        const halfWidth = box.width() / 2;\n\n        if (!options.visible || !this.hasBox()) {\n            return null;\n        }\n\n        const style = this.visualStyle();\n        let element;\n\n        if (type === CIRCLE) {\n            element = new main[\"a\" /* drawing */].Circle(\n                new main[\"b\" /* geometry */].Circle([\n                    round(box.x1 + halfWidth, COORD_PRECISION),\n                    round(box.y1 + box.height() / 2, COORD_PRECISION)\n                ], halfWidth),\n                style\n            );\n        } else if (type === TRIANGLE) {\n            element = main[\"a\" /* drawing */].Path.fromPoints([\n                [ box.x1 + halfWidth, box.y1 ],\n                [ box.x1, box.y2 ],\n                [ box.x2, box.y2 ]\n            ], style).close();\n        } else if (type === CROSS) {\n            element = new main[\"a\" /* drawing */].MultiPath(style);\n\n            element.moveTo(box.x1, box.y1).lineTo(box.x2, box.y2);\n            element.moveTo(box.x1, box.y2).lineTo(box.x2, box.y1);\n        } else {\n            element = main[\"a\" /* drawing */].Path.fromRect(box.toRect(), style);\n        }\n\n        if (rotation) {\n            element.transform(main[\"b\" /* geometry */].transform()\n                .rotate(-rotation, [ center.x, center.y ])\n            );\n        }\n\n        element.options.zIndex = options.zIndex;\n        return element;\n    }\n\n    createElement() {\n        const customVisual = this.options.visual;\n        const pointData = this.pointData || {};\n        let visual;\n\n        if (customVisual) {\n            visual = customVisual({\n                value: pointData.value,\n                dataItem: pointData.dataItem,\n                sender: this.getSender(),\n                series: pointData.series,\n                category: pointData.category,\n                rect: this.paddingBox.toRect(),\n                options: this.visualOptions(),\n                createVisual: () => this.getElement()\n            });\n        } else {\n            visual = this.getElement();\n        }\n\n        return visual;\n    }\n\n    visualOptions() {\n        const options = this.options;\n        return {\n            background: options.background,\n            border: options.border,\n            margin: options.margin,\n            padding: options.padding,\n            type: options.type,\n            size: options.width,\n            visible: options.visible\n        };\n    }\n\n    createVisual() {\n        this.visual = this.createElement();\n    }\n}\n\nsetDefaultOptions(shape_element_ShapeElement, {\n    type: CIRCLE,\n    align: CENTER,\n    vAlign: CENTER\n});\n\n/* harmony default export */ var shape_element = (shape_element_ShapeElement);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/gradients.js\n\n\nconst LINEAR = \"linear\";\nconst RADIAL = \"radial\";\n\nconst GRADIENTS = {\n    glass: {\n        type: LINEAR,\n        rotation: 0,\n        stops: [ {\n            offset: 0,\n            color: WHITE,\n            opacity: 0\n        }, {\n            offset: 0.25,\n            color: WHITE,\n            opacity: 0.3\n        }, {\n            offset: 1,\n            color: WHITE,\n            opacity: 0\n        } ]\n    },\n    sharpBevel: {\n        type: RADIAL,\n        stops: [ {\n            offset: 0,\n            color: WHITE,\n            opacity: 0.55\n        }, {\n            offset: 0.65,\n            color: WHITE,\n            opacity: 0\n        }, {\n            offset: 0.95,\n            color: WHITE,\n            opacity: 0.25\n        } ]\n    },\n    roundedBevel: {\n        type: RADIAL,\n        stops: [ {\n            offset: 0.33,\n            color: WHITE,\n            opacity: 0.06\n        }, {\n            offset: 0.83,\n            color: WHITE,\n            opacity: 0.2\n        }, {\n            offset: 0.95,\n            color: WHITE,\n            opacity: 0\n        } ]\n    },\n    roundedGlass: {\n        type: RADIAL,\n        supportVML: false,\n        stops: [ {\n            offset: 0,\n            color: WHITE,\n            opacity: 0\n        }, {\n            offset: 0.5,\n            color: WHITE,\n            opacity: 0.3\n        }, {\n            offset: 0.99,\n            color: WHITE,\n            opacity: 0\n        } ]\n    },\n    sharpGlass: {\n        type: RADIAL,\n        supportVML: false,\n        stops: [ {\n            offset: 0,\n            color: WHITE,\n            opacity: 0.2\n        }, {\n            offset: 0.15,\n            color: WHITE,\n            opacity: 0.15\n        }, {\n            offset: 0.17,\n            color: WHITE,\n            opacity: 0.35\n        }, {\n            offset: 0.85,\n            color: WHITE,\n            opacity: 0.05\n        }, {\n            offset: 0.87,\n            color: WHITE,\n            opacity: 0.15\n        }, {\n            offset: 0.99,\n            color: WHITE,\n            opacity: 0\n        } ]\n    },\n    bubbleShadow: {\n        type: RADIAL,\n        center: [ 0.5, 0.5 ],\n        radius: 0.5\n    }\n};\n\n/* harmony default export */ var core_gradients = (GRADIENTS);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/utils/box-diff.js\n\n\n\nfunction boxDiff(r, s) {\n    if (r.x1 === s.x1 && r.y1 === s.y1 && r.x2 === s.x2 && r.y2 === s.y2) {\n        return s;\n    }\n\n    const a = Math.min(r.x1, s.x1);\n    const b = Math.max(r.x1, s.x1);\n    const c = Math.min(r.x2, s.x2);\n    const d = Math.max(r.x2, s.x2);\n    const e = Math.min(r.y1, s.y1);\n    const f = Math.max(r.y1, s.y1);\n    const g = Math.min(r.y2, s.y2);\n    const h = Math.max(r.y2, s.y2);\n    const boxes = [];\n\n    // X = intersection, 0-7 = possible difference areas\n    // h +-+-+-+\n    // . |5|6|7|\n    // g +-+-+-+\n    // . |3|X|4|\n    // f +-+-+-+\n    // . |0|1|2|\n    // e +-+-+-+\n    // . a b c d\n\n    // we'll always have rectangles 1, 3, 4 and 6\n    boxes[0] = new core_box(b, e, c, f);\n    boxes[1] = new core_box(a, f, b, g);\n    boxes[2] = new core_box(c, f, d, g);\n    boxes[3] = new core_box(b, g, c, h);\n\n    // decide which corners\n    if (r.x1 === a && r.y1 === e || s.x1 === a && s.y1 === e) { // corners 0 and 7\n        boxes[4] = new core_box(a, e, b, f);\n        boxes[5] = new core_box(c, g, d, h);\n    } else { // corners 2 and 5\n        boxes[4] = new core_box(c, e, d, f);\n        boxes[5] = new core_box(a, g, b, h);\n    }\n\n    return grep(boxes, function(box) {\n        return box.height() > 0 && box.width() > 0;\n    })[0];\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/root-element.js\n\n\n\n\n\n\n\n\n\n\n\nclass root_element_RootElement extends chart_element {\n    constructor(options) {\n        super(options);\n\n        const rootOptions = this.options;\n        rootOptions.width = parseInt(rootOptions.width, 10);\n        rootOptions.height = parseInt(rootOptions.height, 10);\n\n        this.gradients = {};\n    }\n\n    reflow() {\n        const { options, children } = this;\n        let currentBox = new core_box(0, 0, options.width, options.height);\n\n        this.box = currentBox.unpad(options.margin);\n\n        for (let i = 0; i < children.length; i++) {\n            children[i].reflow(currentBox);\n            currentBox = boxDiff(currentBox, children[i].box) || new core_box();\n        }\n    }\n\n    createVisual() {\n        this.visual = new main[\"a\" /* drawing */].Group();\n        this.createBackground();\n    }\n\n    createBackground() {\n        const options = this.options;\n        const border = options.border || {};\n        const box = this.box.clone().pad(options.margin).unpad(border.width);\n\n        const background = main[\"a\" /* drawing */].Path.fromRect(box.toRect(), {\n            stroke: {\n                color: border.width ? border.color : \"\",\n                width: border.width,\n                dashType: border.dashType\n            },\n            fill: {\n                color: options.background,\n                opacity: options.opacity\n            },\n            zIndex: -10\n        });\n\n        this.visual.append(background);\n    }\n\n    getRoot() {\n        return this;\n    }\n\n    createGradient(options) {\n        const gradients = this.gradients;\n        const hashCode = objectKey(options);\n        const gradient = core_gradients[options.gradient];\n        let drawingGradient;\n\n        if (gradients[hashCode]) {\n            drawingGradient = gradients[hashCode];\n        } else {\n            const gradientOptions = Object.assign({}, gradient, options);\n            if (gradient.type === \"linear\") {\n                drawingGradient = new main[\"a\" /* drawing */].LinearGradient(gradientOptions);\n            } else {\n                if (options.innerRadius) {\n                    gradientOptions.stops = innerRadialStops(gradientOptions);\n                }\n                drawingGradient = new main[\"a\" /* drawing */].RadialGradient(gradientOptions);\n                drawingGradient.supportVML = gradient.supportVML !== false;\n            }\n            gradients[hashCode] = drawingGradient;\n        }\n\n        return drawingGradient;\n    }\n\n    cleanGradients() {\n        const gradients = this.gradients;\n        for (let hashCode in gradients) {\n            gradients[hashCode]._observers = [];//add clear observers method in drawing ObserversMixin\n        }\n    }\n\n    size() {\n        const options = this.options;\n        return new core_box(0, 0, options.width, options.height);\n    }\n}\n\nsetDefaultOptions(root_element_RootElement, {\n    width: DEFAULT_WIDTH,\n    height: DEFAULT_HEIGHT,\n    background: WHITE,\n    border: {\n        color: BLACK,\n        width: 0\n    },\n    margin: getSpacing(5),\n    zIndex: -2\n});\n\nfunction innerRadialStops(options) {\n    const stops = options.stops;\n    const usedSpace = ((options.innerRadius / options.radius) * 100);\n    const length = stops.length;\n    const currentStops = [];\n\n    for (let i = 0; i < length; i++) {\n        let currentStop = Object.assign({}, stops[i]);\n        currentStop.offset = (currentStop.offset * (100 - usedSpace) + usedSpace) / 100;\n        currentStops.push(currentStop);\n    }\n\n    return currentStops;\n}\n\n/* harmony default export */ var root_element = (root_element_RootElement);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/float-element.js\n\n\n\n\n\n\nclass float_element_FloatElement extends chart_element {\n    constructor(options) {\n        super(options);\n        this._initDirection();\n    }\n\n    _initDirection() {\n        const options = this.options;\n        if (options.vertical) {\n            this.groupAxis = X;\n            this.elementAxis = Y;\n            this.groupSizeField = WIDTH;\n            this.elementSizeField = HEIGHT;\n            this.groupSpacing = options.spacing;\n            this.elementSpacing = options.vSpacing;\n        } else {\n            this.groupAxis = Y;\n            this.elementAxis = X;\n            this.groupSizeField = HEIGHT;\n            this.elementSizeField = WIDTH;\n            this.groupSpacing = options.vSpacing;\n            this.elementSpacing = options.spacing;\n        }\n    }\n\n    reflow(targetBox) {\n        this.box = targetBox.clone();\n        this.reflowChildren();\n    }\n\n    reflowChildren() {\n        const { box, elementAxis, groupAxis, elementSizeField, groupSizeField } = this;\n        const { groups, groupsSize, maxGroupElementsSize } = this.groupOptions();\n        const groupsCount = groups.length;\n        const groupsStart = box[groupAxis + 1] + this.alignStart(groupsSize, box[groupSizeField]());\n\n        if (groupsCount) {\n            let groupStart = groupsStart;\n\n            for (let groupIdx = 0; groupIdx < groupsCount; groupIdx++) {\n                let group = groups[groupIdx];\n                let groupElements = group.groupElements;\n                let elementStart = box[elementAxis + 1];\n                let groupElementsCount = groupElements.length;\n\n                for (let idx = 0; idx < groupElementsCount; idx++) {\n                    let element = groupElements[idx];\n                    let elementSize = this.elementSize(element);\n                    let groupElementStart = groupStart + this.alignStart(elementSize[groupSizeField], group.groupSize);\n\n                    let elementBox = new core_box();\n                    elementBox[groupAxis + 1] = groupElementStart;\n                    elementBox[groupAxis + 2] = groupElementStart + elementSize[groupSizeField];\n                    elementBox[elementAxis + 1] = elementStart;\n                    elementBox[elementAxis + 2] = elementStart + elementSize[elementSizeField];\n\n                    element.reflow(elementBox);\n\n                    elementStart += elementSize[elementSizeField] + this.elementSpacing;\n                }\n                groupStart += group.groupSize + this.groupSpacing;\n            }\n            box[groupAxis + 1] = groupsStart;\n            box[groupAxis + 2] = groupsStart + groupsSize;\n            box[elementAxis + 2] = box[elementAxis + 1] + maxGroupElementsSize;\n        }\n    }\n\n    alignStart(size, maxSize) {\n        let start = 0;\n        const align = this.options.align;\n        if (align === RIGHT || align === BOTTOM) {\n            start = maxSize - size;\n        } else if (align === CENTER) {\n            start = (maxSize - size) / 2;\n        }\n        return start;\n    }\n\n    groupOptions() {\n        const { box, children, elementSizeField, groupSizeField, elementSpacing, groupSpacing } = this;\n        const maxSize = round(box[elementSizeField]());\n        const childrenCount = children.length;\n        const groups = [];\n\n        let groupSize = 0;\n        let groupElementsSize = 0;\n        let groupsSize = 0;\n        let maxGroupElementsSize = 0;\n        let groupElements = [];\n\n        for (let idx = 0; idx < childrenCount; idx++) {\n            let element = children[idx];\n            if (!element.box) {\n                element.reflow(box);\n            }\n\n            let elementSize = this.elementSize(element);\n            if (this.options.wrap && round(groupElementsSize + elementSpacing + elementSize[elementSizeField]) > maxSize) {\n                groups.push({\n                    groupElements: groupElements,\n                    groupSize: groupSize,\n                    groupElementsSize: groupElementsSize\n                });\n                maxGroupElementsSize = Math.max(maxGroupElementsSize, groupElementsSize);\n                groupsSize += groupSpacing + groupSize;\n                groupSize = 0;\n                groupElementsSize = 0;\n                groupElements = [];\n            }\n            groupSize = Math.max(groupSize, elementSize[groupSizeField]);\n            if (groupElementsSize > 0) {\n                groupElementsSize += elementSpacing;\n            }\n            groupElementsSize += elementSize[elementSizeField];\n            groupElements.push(element);\n        }\n\n        groups.push({\n            groupElements: groupElements,\n            groupSize: groupSize,\n            groupElementsSize: groupElementsSize\n        });\n        maxGroupElementsSize = Math.max(maxGroupElementsSize, groupElementsSize);\n        groupsSize += groupSize;\n\n        return {\n            groups: groups,\n            groupsSize: groupsSize,\n            maxGroupElementsSize: maxGroupElementsSize\n        };\n    }\n\n    elementSize(element) {\n        return {\n            width: element.box.width(),\n            height: element.box.height()\n        };\n    }\n\n    createVisual() {}\n}\n\nsetDefaultOptions(float_element_FloatElement, {\n    vertical: true,\n    wrap: true,\n    vSpacing: 0,\n    spacing: 0\n});\n\n/* harmony default export */ var float_element = (float_element_FloatElement);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/text.js\n\n\n\n\n\n\n\n\nconst DrawingText = main[\"a\" /* drawing */].Text;\n\nclass text_Text extends chart_element {\n\n    constructor(content, options) {\n        super(options);\n\n        this.content = content;\n\n        // Calculate size\n        this.reflow(new core_box());\n    }\n\n    reflow(targetBox) {\n        const options = this.options;\n        const size = options.size = main[\"a\" /* drawing */].util.measureText(this.content, { font: options.font });\n\n        this.baseline = size.baseline;\n\n        this.box = new core_box(targetBox.x1, targetBox.y1,\n                targetBox.x1 + size.width, targetBox.y1 + size.height);\n    }\n\n    createVisual() {\n        const { font, color, opacity, cursor } = this.options;\n\n        this.visual = new DrawingText(this.content, this.box.toRect().topLeft(), {\n            font: font,\n            fill: { color: color, opacity: opacity },\n            cursor: cursor\n        });\n    }\n}\n\nsetDefaultOptions(text_Text, {\n    font: DEFAULT_FONT,\n    color: BLACK\n});\n\n/* harmony default export */ var core_text = (text_Text);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/utils/rect-to-box.js\n\n\nfunction rectToBox(rect) {\n    const origin = rect.origin;\n    const bottomRight = rect.bottomRight();\n\n    return new core_box(origin.x, origin.y, bottomRight.x, bottomRight.y);\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/text-box.js\n\n\n\n\n\n\n\n\n\n\n\n\nconst ROWS_SPLIT_REGEX = /\\n/m;\n\nclass text_box_TextBox extends box_element {\n\n    constructor(content, options, data) {\n        super(options);\n        this.content = content;\n        this.data = data;\n\n        this._initContainer();\n        if (this.options._autoReflow !== false) {\n            this.reflow(new core_box());\n        }\n    }\n\n    _initContainer() {\n        const options = this.options;\n        const rows = String(this.content).split(ROWS_SPLIT_REGEX);\n        const floatElement = new float_element({ vertical: true, align: options.align, wrap: false });\n        const textOptions = deepExtend({ }, options, { opacity: 1, animation: null });\n\n        this.container = floatElement;\n        this.append(floatElement);\n\n        for (let rowIdx = 0; rowIdx < rows.length; rowIdx++) {\n            let text = new core_text(rows[rowIdx].trim(), textOptions);\n            floatElement.append(text);\n        }\n    }\n\n    reflow(targetBox) {\n        const options = this.options;\n        const visualFn = options.visual;\n        this.container.options.align = options.align;\n\n        if (visualFn && !this._boxReflow) {\n            let visualBox = targetBox;\n            if (!visualBox.hasSize()) {\n                this._boxReflow = true;\n                this.reflow(visualBox);\n                this._boxReflow = false;\n                visualBox = this.box;\n            }\n            const visual = this.visual = visualFn(this.visualContext(visualBox));\n\n            if (visual) {\n                visualBox = rectToBox(visual.clippedBBox() || new main[\"b\" /* geometry */].Rect());\n\n                visual.options.zIndex = options.zIndex;\n            }\n\n            this.box = this.contentBox = this.paddingBox = visualBox;\n        } else {\n            super.reflow(targetBox);\n\n            if (options.rotation) {\n                const margin = getSpacing(options.margin);\n                let box = this.box.unpad(margin);\n\n                this.targetBox = targetBox;\n                this.normalBox = box.clone();\n\n                box = this.rotate();\n                box.translate(margin.left - margin.right, margin.top - margin.bottom);\n\n                this.rotatedBox = box.clone();\n\n                box.pad(margin);\n            }\n        }\n    }\n\n    createVisual() {\n        const options = this.options;\n\n        this.visual = new main[\"a\" /* drawing */].Group({\n            transform: this.rotationTransform(),\n            zIndex: options.zIndex,\n            noclip: options.noclip\n        });\n\n        if (this.hasBox()) {\n            const box = main[\"a\" /* drawing */].Path.fromRect(this.paddingBox.toRect(), this.visualStyle());\n            this.visual.append(box);\n        }\n    }\n\n    renderVisual() {\n        if (!this.options.visible) {\n            return;\n        }\n\n        if (this.options.visual) {\n            const visual = this.visual;\n            if (visual && !defined(visual.options.noclip)) {\n                visual.options.noclip = this.options.noclip;\n            }\n            this.addVisual();\n            this.createAnimation();\n        } else {\n            super.renderVisual();\n        }\n    }\n\n    visualContext(targetBox) {\n        const context = {\n            text: this.content,\n            rect: targetBox.toRect(),\n            sender: this.getSender(),\n            options: this.options,\n            createVisual: () => {\n                this._boxReflow = true;\n                this.reflow(targetBox);\n                this._boxReflow = false;\n                return this.getDefaultVisual();\n            }\n        };\n        if (this.data) {\n            Object.assign(context, this.data);\n        }\n\n        return context;\n    }\n\n    getDefaultVisual() {\n        this.createVisual();\n        this.renderChildren();\n        const visual = this.visual;\n        delete this.visual;\n        return visual;\n    }\n\n    rotate() {\n        const options = this.options;\n        this.box.rotate(options.rotation);\n        this.align(this.targetBox, X, options.align);\n        this.align(this.targetBox, Y, options.vAlign);\n        return this.box;\n    }\n\n    rotationTransform() {\n        const rotation = this.options.rotation;\n        if (!rotation) {\n            return null;\n        }\n\n        const { x: cx, y: cy } = this.normalBox.center();\n        const boxCenter = this.rotatedBox.center();\n\n        return main[\"b\" /* geometry */].transform()\n                   .translate(boxCenter.x - cx, boxCenter.y - cy)\n                   .rotate(rotation, [ cx, cy ]);\n    }\n}\n\n/* harmony default export */ var text_box = (text_box_TextBox);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/title.js\n\n\n\n\n\n\nclass title_Title extends chart_element {\n    constructor(options) {\n        super(options);\n\n        this.append(\n            new text_box(this.options.text, Object.assign({}, this.options, {\n                vAlign: this.options.position\n            }))\n        );\n    }\n\n    reflow(targetBox) {\n        super.reflow(targetBox);\n        this.box.snapTo(targetBox, X);\n    }\n\n    static buildTitle(options, parent, defaultOptions) {\n        let titleOptions = options;\n\n        if (typeof options === \"string\") {\n            titleOptions = { text: options };\n        }\n\n        titleOptions = Object.assign({ visible: true }, defaultOptions, titleOptions);\n\n        let title;\n        if (titleOptions && titleOptions.visible && titleOptions.text) {\n            title = new title_Title(titleOptions);\n            parent.append(title);\n        }\n\n        return title;\n    }\n}\n\nsetDefaultOptions(title_Title, {\n    color: BLACK,\n    position: TOP,\n    align: CENTER,\n    margin: getSpacing(5),\n    padding: getSpacing(5)\n});\n\n/* harmony default export */ var core_title = (title_Title);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/axis-label.js\n\n\n\n\n\n\n\n\n\n\n\nclass axis_label_AxisLabel extends text_box {\n    constructor(value, text, index, dataItem, options) {\n        super(text, options);\n\n        this.text = text;\n        this.value = value;\n        this.index = index;\n        this.dataItem = dataItem;\n        this.reflow(new core_box());\n    }\n\n    visualContext(targetBox) {\n        const context = super.visualContext(targetBox);\n\n        context.value = this.value;\n        context.dataItem = this.dataItem;\n        context.format = this.options.format;\n        context.culture = this.options.culture;\n\n        return context;\n    }\n\n    click(widget, e) {\n\n        widget.trigger(AXIS_LABEL_CLICK, {\n            element: eventElement(e),\n            value: this.value,\n            text: this.text,\n            index: this.index,\n            dataItem: this.dataItem,\n            axis: this.parent.options\n        });\n    }\n\n    rotate() {\n        if (this.options.alignRotation !== CENTER) {\n            const box = this.normalBox.toRect();\n            const transform = this.rotationTransform();\n\n            this.box = rectToBox(box.bbox(transform.matrix()));\n        } else {\n            super.rotate();\n        }\n\n        return this.box;\n    }\n\n    rotationTransform() {\n        const options = this.options;\n        const rotation = options.rotation;\n        if (!rotation) {\n            return null;\n        }\n\n        if (options.alignRotation === CENTER) {\n            return super.rotationTransform();\n        }\n\n        const rotationMatrix = main[\"b\" /* geometry */].transform().rotate(rotation).matrix();\n        const box = this.normalBox.toRect();\n        const rect = this.targetBox.toRect();\n\n        const rotationOrigin = options.rotationOrigin || TOP;\n        const alignAxis = rotationOrigin === TOP || rotationOrigin === BOTTOM ? X : Y;\n        const distanceAxis = rotationOrigin === TOP || rotationOrigin === BOTTOM ? Y : X;\n        const axisAnchor = rotationOrigin === TOP || rotationOrigin === LEFT ? rect.origin : rect.bottomRight();\n\n        const topLeft = box.topLeft().transformCopy(rotationMatrix);\n        const topRight = box.topRight().transformCopy(rotationMatrix);\n        const bottomRight = box.bottomRight().transformCopy(rotationMatrix);\n        const bottomLeft = box.bottomLeft().transformCopy(rotationMatrix);\n        const rotatedBox = main[\"b\" /* geometry */].Rect.fromPoints(topLeft, topRight, bottomRight, bottomLeft);\n\n        const translate = {\n            [distanceAxis]: rect.origin[distanceAxis] - rotatedBox.origin[distanceAxis]\n        };\n\n        const distanceLeft = Math.abs(topLeft[distanceAxis] + translate[distanceAxis] - axisAnchor[distanceAxis]);\n        const distanceRight = Math.abs(topRight[distanceAxis] + translate[distanceAxis] - axisAnchor[distanceAxis]);\n\n        let alignStart, alignEnd;\n\n        if (round(distanceLeft, DEFAULT_PRECISION) === round(distanceRight, DEFAULT_PRECISION)) {\n            alignStart = topLeft;\n            alignEnd = topRight;\n        } else if (distanceRight < distanceLeft) {\n            alignStart = topRight;\n            alignEnd = bottomRight;\n        } else {\n            alignStart = topLeft;\n            alignEnd = bottomLeft;\n        }\n\n        const alignCenter = alignStart[alignAxis] + (alignEnd[alignAxis] - alignStart[alignAxis]) / 2;\n        translate[alignAxis] = rect.center()[alignAxis] - alignCenter;\n\n        return main[\"b\" /* geometry */].transform()\n            .translate(translate.x, translate.y)\n            .rotate(rotation);\n    }\n}\n\nsetDefaultOptions(axis_label_AxisLabel, {\n    _autoReflow: false\n});\n\n/* harmony default export */ var axis_label = (axis_label_AxisLabel);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/note.js\n\n\n\n\n\n\n\n\n\n\nconst DEFAULT_ICON_SIZE = 7;\nconst DEFAULT_LABEL_COLOR = \"#fff\";\n\nclass note_Note extends box_element {\n    constructor(fields, options, chartService) {\n        super(options);\n\n        this.fields = fields;\n        this.chartService = chartService;\n\n        this.render();\n    }\n\n    hide() {\n        this.options.visible = false;\n    }\n\n    show() {\n        this.options.visible = true;\n    }\n\n    render() {\n        const options = this.options;\n\n        if (options.visible) {\n            const { label, icon } = options;\n            const box = new core_box();\n            const childAlias = () => this;\n            let size = icon.size;\n            let text = this.fields.text;\n            let width, height;\n\n            if (defined(label) && label.visible) {\n                const noteTemplate = getTemplate(label);\n                if (noteTemplate) {\n                    text = noteTemplate(this.fields);\n                } else if (label.format) {\n                    text = this.chartService.format.auto(label.format, text);\n                }\n\n                if (!label.color) {\n                    label.color = label.position === INSIDE ? DEFAULT_LABEL_COLOR : icon.background;\n                }\n\n                this.label = new text_box(text, deepExtend({}, label));\n                this.label.aliasFor = childAlias;\n\n                if (label.position === INSIDE && !defined(size)) {\n                    if (icon.type === CIRCLE) {\n                        size = Math.max(this.label.box.width(), this.label.box.height());\n                    } else {\n                        width = this.label.box.width();\n                        height = this.label.box.height();\n                    }\n                    box.wrap(this.label.box);\n                }\n            }\n\n            icon.width = width || size || DEFAULT_ICON_SIZE;\n            icon.height = height || size || DEFAULT_ICON_SIZE;\n\n            const marker = new shape_element(deepExtend({}, icon));\n            marker.aliasFor = childAlias;\n\n            this.marker = marker;\n            this.append(marker);\n\n            if (this.label) {\n                this.append(this.label);\n            }\n\n            marker.reflow(new core_box());\n            this.wrapperBox = box.wrap(marker.box);\n        }\n    }\n\n    reflow(targetBox) {\n        const { options, label, marker, wrapperBox } = this;\n        const center = targetBox.center();\n        const length = options.line.length;\n        const position = options.position;\n\n        // TODO: Review\n        if (options.visible) {\n            let lineStart, box, contentBox;\n\n            if (inArray(position, [ LEFT, RIGHT ])) {\n                if (position === LEFT) {\n                    contentBox = wrapperBox.alignTo(targetBox, position).translate(-length, targetBox.center().y - wrapperBox.center().y);\n\n                    if (options.line.visible) {\n                        lineStart = [ targetBox.x1, center.y ];\n                        this.linePoints = [\n                            lineStart,\n                            [ contentBox.x2, center.y ]\n                        ];\n                        box = contentBox.clone().wrapPoint(lineStart);\n                    }\n                } else {\n                    contentBox = wrapperBox.alignTo(targetBox, position).translate(length, targetBox.center().y - wrapperBox.center().y);\n\n                    if (options.line.visible) {\n                        lineStart = [ targetBox.x2, center.y ];\n                        this.linePoints = [\n                            lineStart,\n                            [ contentBox.x1, center.y ]\n                        ];\n                        box = contentBox.clone().wrapPoint(lineStart);\n                    }\n                }\n            } else {\n                if (position === BOTTOM) {\n                    contentBox = wrapperBox.alignTo(targetBox, position).translate(targetBox.center().x - wrapperBox.center().x, length);\n\n                    if (options.line.visible) {\n                        lineStart = [ center.x, targetBox.y2 ];\n                        this.linePoints = [\n                            lineStart,\n                            [ center.x, contentBox.y1 ]\n                        ];\n                        box = contentBox.clone().wrapPoint(lineStart);\n                    }\n                } else {\n                    contentBox = wrapperBox.alignTo(targetBox, position).translate(targetBox.center().x - wrapperBox.center().x, -length);\n\n                    if (options.line.visible) {\n                        lineStart = [ center.x, targetBox.y1 ];\n                        this.linePoints = [\n                            lineStart,\n                            [ center.x, contentBox.y2 ]\n                        ];\n                        box = contentBox.clone().wrapPoint(lineStart);\n                    }\n                }\n            }\n\n            if (marker) {\n                marker.reflow(contentBox);\n            }\n\n            if (label) {\n                label.reflow(contentBox);\n                if (marker) {\n                    if (options.label.position === OUTSIDE) {\n                        label.box.alignTo(marker.box, position);\n                    }\n                    label.reflow(label.box);\n                }\n            }\n\n            this.contentBox = contentBox;\n            this.targetBox = targetBox;\n            this.box = box || contentBox;\n        }\n    }\n\n    createVisual() {\n        super.createVisual();\n        this.visual.options.noclip = this.options.noclip;\n\n        if (this.options.visible) {\n            this.createLine();\n        }\n    }\n\n    renderVisual() {\n        const options = this.options;\n        const customVisual = options.visual;\n        if (options.visible && customVisual) {\n            this.visual = customVisual(Object.assign(this.fields, {\n                sender: this.getSender(),\n                rect: this.targetBox.toRect(),\n                options: {\n                    background: options.background,\n                    border: options.background,\n                    icon: options.icon,\n                    label: options.label,\n                    line: options.line,\n                    position: options.position,\n                    visible: options.visible\n                },\n                createVisual: () => {\n                    this.createVisual();\n                    this.renderChildren();\n                    const defaultVisual = this.visual;\n                    delete this.visual;\n                    return defaultVisual;\n                }\n            }));\n            this.addVisual();\n        } else {\n            super.renderVisual();\n        }\n    }\n\n    createLine() {\n        const options = this.options.line;\n\n        if (this.linePoints) {\n            const path = main[\"a\" /* drawing */].Path.fromPoints(this.linePoints, {\n                stroke: {\n                    color: options.color,\n                    width: options.width,\n                    dashType: options.dashType\n                }\n            });\n\n            alignPathToPixel(path);\n            this.visual.append(path);\n        }\n    }\n\n    click(widget, e) {\n        const args = this.eventArgs(e);\n\n        if (!widget.trigger(NOTE_CLICK, args)) {\n            e.preventDefault();\n        }\n    }\n\n    over(widget, e) {\n        const args = this.eventArgs(e);\n\n        if (!widget.trigger(NOTE_HOVER, args)) {\n            e.preventDefault();\n        }\n    }\n\n    out(widget, e) {\n        const args = this.eventArgs(e);\n\n        widget.trigger(NOTE_LEAVE, args);\n    }\n\n    eventArgs(e) {\n        const options = this.options;\n\n        return Object.assign(this.fields, {\n            element: eventElement(e),\n            text: defined(options.label) ? options.label.text : \"\",\n            visual: this.visual\n        });\n    }\n}\n\nsetDefaultOptions(note_Note, {\n    icon: {\n        visible: true,\n        type: CIRCLE\n    },\n    label: {\n        position: INSIDE,\n        visible: true,\n        align: CENTER,\n        vAlign: CENTER\n    },\n    line: {\n        visible: true\n    },\n    visible: true,\n    position: TOP,\n    zIndex: 2\n});\n\n/* harmony default export */ var core_note = (note_Note);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/utils/create-axis-tick.js\n\n\n\n\nfunction createAxisTick(options, tickOptions) {\n    const { tickX, tickY, position } = options;\n\n    const tick = new main[\"a\" /* drawing */].Path({\n        stroke: {\n            width: tickOptions.width,\n            color: tickOptions.color\n        }\n    });\n\n    if (options.vertical) {\n        tick.moveTo(tickX, position)\n            .lineTo(tickX + tickOptions.size, position);\n    } else {\n        tick.moveTo(position, tickY)\n            .lineTo(position, tickY + tickOptions.size);\n    }\n\n    alignPathToPixel(tick);\n\n    return tick;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/utils/create-axis-grid-line.js\n\n\n\n\nfunction createAxisGridLine(options, gridLine) {\n    const { lineStart, lineEnd, position } = options;\n\n    const line = new main[\"a\" /* drawing */].Path({\n        stroke: {\n            width: gridLine.width,\n            color: gridLine.color,\n            dashType: gridLine.dashType\n        }\n    });\n\n    if (options.vertical) {\n        line.moveTo(lineStart, position)\n            .lineTo(lineEnd, position);\n    } else {\n        line.moveTo(position, lineStart)\n            .lineTo(position, lineEnd);\n    }\n\n    alignPathToPixel(line);\n\n    return line;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/axis.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass axis_Axis extends chart_element {\n    constructor(options, chartService = new chart_service()) {\n        super(options);\n\n        this.chartService = chartService;\n\n        if (!this.options.visible) {\n            this.options = deepExtend({}, this.options, {\n                labels: {\n                    visible: false\n                },\n                line: {\n                    visible: false\n                },\n                margin: 0,\n                majorTickSize: 0,\n                minorTickSize: 0\n            });\n        }\n\n        this.options.minorTicks = deepExtend({}, {\n            color: this.options.line.color,\n            width: this.options.line.width,\n            visible: this.options.minorTickType !== NONE\n        }, this.options.minorTicks, {\n            size: this.options.minorTickSize,\n            align: this.options.minorTickType\n        });\n\n        this.options.majorTicks = deepExtend({}, {\n            color: this.options.line.color,\n            width: this.options.line.width,\n            visible: this.options.majorTickType !== NONE\n        }, this.options.majorTicks, {\n            size: this.options.majorTickSize,\n            align: this.options.majorTickType\n        });\n\n        this.initFields();\n\n        if (!this.options._deferLabels) {\n            this.createLabels();\n        }\n\n        this.createTitle();\n        this.createNotes();\n    }\n\n    initFields() {\n    }\n\n    // abstract labelsCount(): Number\n    // abstract createAxisLabel(index, options): AxisLabel\n\n    labelsRange() {\n        return {\n            min: this.options.labels.skip,\n            max: this.labelsCount()\n        };\n    }\n\n    normalizeLabelRotation(labelOptions) {\n        const rotation = labelOptions.rotation;\n\n        if (isObject(rotation)) {\n            labelOptions.alignRotation = rotation.align;\n            labelOptions.rotation = rotation.angle;\n        }\n    }\n\n    createLabels() {\n        const options = this.options;\n        const align = options.vertical ? RIGHT : CENTER;\n        const labelOptions = deepExtend({ }, options.labels, {\n            align: align,\n            zIndex: options.zIndex\n        });\n        const step = Math.max(1, labelOptions.step);\n\n        this.clearLabels();\n\n        if (labelOptions.visible) {\n            this.normalizeLabelRotation(labelOptions);\n            if (labelOptions.rotation === \"auto\") {\n                labelOptions.rotation = 0;\n                options.autoRotateLabels = true;\n            }\n\n            const range = this.labelsRange();\n            for (let idx = range.min; idx < range.max; idx += step) {\n                const labelContext = { index: idx, count: range.max };\n                let label = this.createAxisLabel(idx, labelOptions, labelContext);\n                if (label) {\n                    this.append(label);\n                    this.labels.push(label);\n                }\n            }\n        }\n    }\n\n    clearLabels() {\n        this.children = grep(this.children, child => !(child instanceof axis_label));\n        this.labels = [];\n    }\n\n    clearTitle() {\n        if (this.title) {\n            this.children = grep(this.children, child => child !== this.title);\n            this.title = undefined;\n        }\n    }\n\n    clear() {\n        this.clearLabels();\n        this.clearTitle();\n    }\n\n    lineBox() {\n        const { options, box } = this;\n        const vertical = options.vertical;\n        const mirror = options.labels.mirror;\n        const axisX = mirror ? box.x1 : box.x2;\n        const axisY = mirror ? box.y2 : box.y1;\n        const lineWidth = options.line.width || 0;\n\n        return vertical ?\n            new core_box(axisX, box.y1, axisX, box.y2 - lineWidth) :\n            new core_box(box.x1, axisY, box.x2 - lineWidth, axisY);\n    }\n\n    createTitle() {\n        const options = this.options;\n        const titleOptions = deepExtend({\n            rotation: options.vertical ? -90 : 0,\n            text: \"\",\n            zIndex: 1,\n            visualSize: true\n        }, options.title);\n\n        if (titleOptions.visible && titleOptions.text) {\n            const title = new text_box(titleOptions.text, titleOptions);\n            this.append(title);\n            this.title = title;\n        }\n    }\n\n    createNotes() {\n        const options = this.options;\n        const notes = options.notes;\n        const items = notes.data || [];\n\n        this.notes = [];\n\n        for (let i = 0; i < items.length; i++) {\n            const item = deepExtend({}, notes, items[i]);\n            item.value = this.parseNoteValue(item.value);\n\n            const note = new core_note({\n                value: item.value,\n                text: item.label.text,\n                dataItem: item\n            }, item, this.chartService);\n\n            if (note.options.visible) {\n                if (defined(note.options.position)) {\n                    if (options.vertical && !inArray(note.options.position, [ LEFT, RIGHT ])) {\n                        note.options.position = options.reverse ? LEFT : RIGHT;\n                    } else if (!options.vertical && !inArray(note.options.position, [ TOP, BOTTOM ])) {\n                        note.options.position = options.reverse ? BOTTOM : TOP;\n                    }\n                } else {\n                    if (options.vertical) {\n                        note.options.position = options.reverse ? LEFT : RIGHT;\n                    } else {\n                        note.options.position = options.reverse ? BOTTOM : TOP;\n                    }\n                }\n                this.append(note);\n                this.notes.push(note);\n            }\n        }\n    }\n\n    parseNoteValue(value) {\n        return value;\n    }\n\n    renderVisual() {\n        super.renderVisual();\n\n        this.createPlotBands();\n    }\n\n    createVisual() {\n        super.createVisual();\n\n        this.createBackground();\n        this.createLine();\n    }\n\n    gridLinesVisual() {\n        let gridLines = this._gridLines;\n        if (!gridLines) {\n            gridLines = this._gridLines = new main[\"a\" /* drawing */].Group({\n                zIndex: -2\n            });\n            this.appendVisual(this._gridLines);\n        }\n\n        return gridLines;\n    }\n\n    createTicks(lineGroup) {\n        const options = this.options;\n        const lineBox = this.lineBox();\n        const mirror = options.labels.mirror;\n        const majorUnit = options.majorTicks.visible ? options.majorUnit : 0;\n        const tickLineOptions = {\n            // TODO\n            // _alignLines: options._alignLines,\n            vertical: options.vertical\n        };\n\n        function render(tickPositions, tickOptions, skipUnit) {\n            const count = tickPositions.length;\n            const step = Math.max(1, tickOptions.step);\n\n            if (tickOptions.visible) {\n                for (let i = tickOptions.skip; i < count; i += step) {\n                    if (defined(skipUnit) && (i % skipUnit === 0)) {\n                        continue;\n                    }\n\n                    tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n                    tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n                    tickLineOptions.position = tickPositions[i];\n\n                    lineGroup.append(createAxisTick(tickLineOptions, tickOptions));\n                }\n            }\n        }\n\n        render(this.getMajorTickPositions(), options.majorTicks);\n        render(this.getMinorTickPositions(), options.minorTicks, majorUnit / options.minorUnit);\n    }\n\n    createLine() {\n        const options = this.options;\n        const line = options.line;\n        const lineBox = this.lineBox();\n\n        if (line.width > 0 && line.visible) {\n            const path = new main[\"a\" /* drawing */].Path({\n                stroke: {\n                    width: line.width,\n                    color: line.color,\n                    dashType: line.dashType\n                }\n\n                /* TODO\n                zIndex: line.zIndex,\n                */\n            });\n\n            path.moveTo(lineBox.x1, lineBox.y1)\n                .lineTo(lineBox.x2, lineBox.y2);\n\n            if (options._alignLines) {\n                alignPathToPixel(path);\n            }\n\n            const group = this._lineGroup = new main[\"a\" /* drawing */].Group();\n            group.append(path);\n\n            this.visual.append(group);\n            this.createTicks(group);\n        }\n    }\n\n    getActualTickSize() {\n        const options = this.options;\n        let tickSize = 0;\n\n        if (options.majorTicks.visible && options.minorTicks.visible) {\n            tickSize = Math.max(options.majorTicks.size, options.minorTicks.size);\n        } else if (options.majorTicks.visible) {\n            tickSize = options.majorTicks.size;\n        } else if (options.minorTicks.visible) {\n            tickSize = options.minorTicks.size;\n        }\n\n        return tickSize;\n    }\n\n    createBackground() {\n        const { options, box } = this;\n        const background = options.background;\n\n        if (background) {\n            this._backgroundPath = main[\"a\" /* drawing */].Path.fromRect(box.toRect(), {\n                fill: {\n                    color: background\n                },\n                stroke: null\n            });\n\n            this.visual.append(this._backgroundPath);\n        }\n    }\n\n    createPlotBands() {\n        const options = this.options;\n        const plotBands = options.plotBands || [];\n        const vertical = options.vertical;\n        const plotArea = this.plotArea;\n\n        if (plotBands.length === 0) {\n            return;\n        }\n\n        const group = this._plotbandGroup = new main[\"a\" /* drawing */].Group({\n            zIndex: -1\n        });\n\n        const altAxis = grep(this.pane.axes, axis => axis.options.vertical !== this.options.vertical)[0];\n\n        for (let idx = 0; idx < plotBands.length; idx++) {\n            let item = plotBands[idx];\n            let slotX, slotY;\n            let labelOptions = item.label;\n            let label;\n\n            if (vertical) {\n                slotX = (altAxis || plotArea.axisX).lineBox();\n                slotY = this.getSlot(item.from, item.to, true);\n            } else {\n                slotX = this.getSlot(item.from, item.to, true);\n                slotY = (altAxis || plotArea.axisY).lineBox();\n            }\n\n            if (labelOptions) {\n                labelOptions.vAlign = labelOptions.position || LEFT;\n                label = this.createPlotBandLabel(\n                    labelOptions,\n                    item,\n                    new core_box(\n                        slotX.x1,\n                        slotY.y1,\n                        slotX.x2,\n                        slotY.y2\n                    )\n\n                );\n            }\n\n            if (slotX.width() !== 0 && slotY.height() !== 0) {\n                const bandRect = new main[\"b\" /* geometry */].Rect(\n                    [ slotX.x1, slotY.y1 ],\n                    [ slotX.width(), slotY.height() ]\n                );\n\n                const path = main[\"a\" /* drawing */].Path.fromRect(bandRect, {\n                    fill: {\n                        color: item.color,\n                        opacity: item.opacity\n                    },\n                    stroke: null\n                });\n\n                group.append(path);\n                if (label) {\n                    group.append(label);\n                }\n            }\n        }\n\n        this.appendVisual(group);\n    }\n\n    createPlotBandLabel(label, item, box) {\n\n        if (label.visible === false) {\n            return null;\n        }\n\n        let text = label.text;\n        let textbox;\n\n        if (defined(label) && label.visible) {\n            const labelTemplate = getTemplate(label);\n            if (labelTemplate) {\n                text = labelTemplate({ text: text, item: item });\n            } else if (label.format) {\n                text = this.chartService.format.auto(label.format, text);\n            }\n\n            if (!label.color) {\n                label.color = this.options.labels.color;\n            }\n        }\n\n        textbox = new text_box(text, label);\n        textbox.reflow(box);\n        textbox.renderVisual();\n\n        return textbox.visual;\n    }\n\n    createGridLines(altAxis) {\n        const options = this.options;\n        const { minorGridLines, majorGridLines, minorUnit, vertical } = options;\n        const axisLineVisible = altAxis.options.line.visible;\n        const majorUnit = majorGridLines.visible ? options.majorUnit : 0;\n        const lineBox = altAxis.lineBox();\n        const linePos = lineBox[vertical ? \"y1\" : \"x1\"];\n        const lineOptions = {\n            lineStart: lineBox[vertical ? \"x1\" : \"y1\"],\n            lineEnd: lineBox[vertical ? \"x2\" : \"y2\"],\n            vertical: vertical\n        };\n        const majorTicks = [];\n\n        const container = this.gridLinesVisual();\n\n        function render(tickPositions, gridLine, skipUnit) {\n            const count = tickPositions.length;\n            const step = Math.max(1, gridLine.step);\n\n            if (gridLine.visible) {\n                for (let i = gridLine.skip; i < count; i += step) {\n                    let pos = round(tickPositions[i]);\n                    if (!inArray(pos, majorTicks)) {\n                        if (i % skipUnit !== 0 && (!axisLineVisible || linePos !== pos)) {\n                            lineOptions.position = pos;\n                            container.append(createAxisGridLine(lineOptions, gridLine));\n\n                            majorTicks.push(pos);\n                        }\n                    }\n                }\n            }\n        }\n\n        render(this.getMajorTickPositions(), majorGridLines);\n        render(this.getMinorTickPositions(), minorGridLines, majorUnit / minorUnit);\n\n        return container.children;\n    }\n\n    reflow(box) {\n        const { options, labels, title } = this;\n        const vertical = options.vertical;\n        const count = labels.length;\n        const sizeFn = vertical ? WIDTH : HEIGHT;\n        const titleSize = title ? title.box[sizeFn]() : 0;\n        const space = this.getActualTickSize() + options.margin + titleSize;\n        const rootBox = (this.getRoot() || {}).box || box;\n        const boxSize = rootBox[sizeFn]();\n        let maxLabelSize = 0;\n\n        for (let i = 0; i < count; i++) {\n            let labelSize = labels[i].box[sizeFn]();\n            if (labelSize + space <= boxSize) {\n                maxLabelSize = Math.max(maxLabelSize, labelSize);\n            }\n        }\n\n        if (vertical) {\n            this.box = new core_box(\n                box.x1, box.y1,\n                box.x1 + maxLabelSize + space, box.y2\n            );\n        } else {\n            this.box = new core_box(\n                box.x1, box.y1,\n                box.x2, box.y1 + maxLabelSize + space\n            );\n        }\n\n        this.arrangeTitle();\n        this.arrangeLabels();\n        this.arrangeNotes();\n    }\n\n    getLabelsTickPositions() {\n        return this.getMajorTickPositions();\n    }\n\n    labelTickIndex(label) {\n        return label.index;\n    }\n\n    arrangeLabels() {\n        const { options, labels } = this;\n        const labelsBetweenTicks = this.labelsBetweenTicks();\n        const vertical = options.vertical;\n        const mirror = options.labels.mirror;\n        const tickPositions = this.getLabelsTickPositions();\n\n        for (let idx = 0; idx < labels.length; idx++) {\n            const label = labels[idx];\n            const tickIx = this.labelTickIndex(label);\n            const labelSize = vertical ? label.box.height() : label.box.width();\n            const firstTickPosition = tickPositions[tickIx];\n            const nextTickPosition = tickPositions[tickIx + 1];\n            let positionStart, positionEnd;\n\n            if (vertical) {\n                if (labelsBetweenTicks) {\n                    const middle = firstTickPosition + (nextTickPosition - firstTickPosition) / 2;\n                    positionStart = middle - (labelSize / 2);\n                } else {\n                    positionStart = firstTickPosition - (labelSize / 2);\n                }\n\n                positionEnd = positionStart;\n            } else {\n                if (labelsBetweenTicks) {\n                    positionStart = firstTickPosition;\n                    positionEnd = nextTickPosition;\n                } else {\n                    positionStart = firstTickPosition - (labelSize / 2);\n                    positionEnd = positionStart + labelSize;\n                }\n            }\n\n            this.positionLabel(label, mirror, positionStart, positionEnd);\n        }\n    }\n\n    positionLabel(label, mirror, positionStart, positionEnd = positionStart) {\n        const options = this.options;\n        const vertical = options.vertical;\n        const lineBox = this.lineBox();\n        const labelOffset = this.getActualTickSize() + options.margin;\n        let labelBox;\n\n        if (vertical) {\n            let labelX = lineBox.x2;\n\n            if (mirror) {\n                labelX += labelOffset;\n                label.options.rotationOrigin = LEFT;\n            } else {\n                labelX -= labelOffset + label.box.width();\n                label.options.rotationOrigin = RIGHT;\n            }\n\n            labelBox = label.box.move(labelX, positionStart);\n        } else {\n            let labelY = lineBox.y1;\n\n            if (mirror) {\n                labelY -= labelOffset + label.box.height();\n                label.options.rotationOrigin = BOTTOM;\n            } else {\n                labelY += labelOffset;\n                label.options.rotationOrigin = TOP;\n            }\n\n            labelBox = new core_box(\n                positionStart, labelY,\n                positionEnd, labelY + label.box.height()\n            );\n        }\n\n        label.reflow(labelBox);\n    }\n\n    autoRotateLabelAngle(labelBox, slotWidth) {\n        if (labelBox.width() < slotWidth) {\n            return 0;\n        }\n\n        if (labelBox.height() > slotWidth) {\n            return -90;\n        }\n\n        return -45;\n    }\n\n    autoRotateLabels() {\n        if (!this.options.autoRotateLabels || this.options.vertical) {\n            return false;\n        }\n\n        const tickPositions = this.getMajorTickPositions();\n        const labels = this.labels;\n        const limit = Math.min(labels.length, tickPositions.length - 1);\n        let angle = 0;\n\n        for (let idx = 0; idx < limit; idx++) {\n            const width = Math.abs(tickPositions[idx + 1] - tickPositions[idx]);\n            const labelBox = labels[idx].box;\n            angle = this.autoRotateLabelAngle(labelBox, width);\n\n            if (angle === -90) {\n                break;\n            }\n        }\n\n        if (angle !== 0) {\n            for (let idx = 0; idx < labels.length; idx++) {\n                labels[idx].options.rotation = angle;\n                labels[idx].reflow(new core_box());\n            }\n\n            return true;\n        }\n    }\n\n    arrangeTitle() {\n        const { options, title } = this;\n        const mirror = options.labels.mirror;\n        const vertical = options.vertical;\n\n        if (title) {\n            if (vertical) {\n                title.options.align = mirror ? RIGHT : LEFT;\n                title.options.vAlign = title.options.position;\n            } else {\n                title.options.align = title.options.position;\n                title.options.vAlign = mirror ? TOP : BOTTOM;\n            }\n\n            title.reflow(this.box);\n        }\n    }\n\n    arrangeNotes() {\n        for (let idx = 0; idx < this.notes.length; idx++) {\n            const item = this.notes[idx];\n            const value = item.options.value;\n            let slot;\n\n            if (defined(value)) {\n                if (this.shouldRenderNote(value)) {\n                    item.show();\n                } else {\n                    item.hide();\n                }\n\n                slot = this.noteSlot(value);\n            } else {\n                item.hide();\n            }\n\n            item.reflow(slot || this.lineBox());\n        }\n    }\n\n    noteSlot(value) {\n        return this.getSlot(value);\n    }\n\n    alignTo(secondAxis) {\n        const lineBox = secondAxis.lineBox();\n        const vertical = this.options.vertical;\n        const pos = vertical ? Y : X;\n\n        this.box.snapTo(lineBox, pos);\n        if (vertical) {\n            this.box.shrink(0, this.lineBox().height() - lineBox.height());\n        } else {\n            this.box.shrink(this.lineBox().width() - lineBox.width(), 0);\n        }\n        this.box[pos + 1] -= this.lineBox()[pos + 1] - lineBox[pos + 1];\n        this.box[pos + 2] -= this.lineBox()[pos + 2] - lineBox[pos + 2];\n    }\n\n    axisLabelText(value, options, context) {\n        let text;\n        const tmpl = getTemplate(options);\n        const defaultText = () => {\n            if (!options.format) {\n                return value;\n            }\n\n            return this.chartService.format.localeAuto(\n                options.format, [ value ], options.culture\n            );\n        };\n\n        if (tmpl) {\n            const templateContext = Object.assign({}, context, {\n                get text() { return defaultText(); },\n                value,\n                format: options.format,\n                culture: options.culture\n            });\n\n            text = tmpl(templateContext);\n        } else {\n            text = defaultText();\n        }\n\n        return text;\n    }\n\n    slot(from , to, limit) {\n        const slot = this.getSlot(from, to, limit);\n        if (slot) {\n            return slot.toRect();\n        }\n    }\n\n    contentBox() {\n        const box = this.box.clone();\n        const labels = this.labels;\n        if (labels.length) {\n            const axis = this.options.vertical ? Y : X;\n            if (this.chartService.isPannable(axis)) {\n                const offset = this.maxLabelOffset();\n                box[axis + 1] -= offset.start;\n                box[axis + 2] += offset.end;\n            } else {\n                if (labels[0].options.visible) {\n                    box.wrap(labels[0].box);\n                }\n                const lastLabel = labels[labels.length - 1];\n                if (lastLabel.options.visible) {\n                    box.wrap(lastLabel.box);\n                }\n            }\n        }\n\n        return box;\n    }\n\n    maxLabelOffset() {\n        const { vertical, reverse } = this.options;\n        const labelsBetweenTicks = this.labelsBetweenTicks();\n        const tickPositions = this.getLabelsTickPositions();\n        const offsetField = vertical ? Y : X;\n        const labels = this.labels;\n        const startPosition = reverse ? 1 : 0;\n        const endPosition = reverse ? 0 : 1;\n        let maxStartOffset = 0;\n        let maxEndOffset = 0;\n\n        for (let idx = 0; idx < labels.length; idx++) {\n            const label = labels[idx];\n            const tickIx = this.labelTickIndex(label);\n            let startTick, endTick;\n\n            if (labelsBetweenTicks) {\n                startTick = tickPositions[tickIx + startPosition];\n                endTick = tickPositions[tickIx + endPosition];\n            } else {\n                startTick = endTick = tickPositions[tickIx];\n            }\n\n            maxStartOffset = Math.max(maxStartOffset, startTick - label.box[offsetField + 1]);\n            maxEndOffset = Math.max(maxEndOffset, label.box[offsetField + 2] - endTick);\n        }\n\n        return {\n            start: maxStartOffset,\n            end: maxEndOffset\n        };\n    }\n\n    limitRange(from, to, min, max, offset) {\n        const options = this.options;\n\n        if ((from < min && offset < 0 && (!defined(options.min) || options.min <= min)) || (max < to && offset > 0 && (!defined(options.max) || max <= options.max))) {\n            return null;\n        }\n\n        if ((to < min && offset > 0) || (max < from && offset < 0)) {\n            return {\n                min: from,\n                max: to\n            };\n        }\n\n        const rangeSize = to - from;\n        let minValue = from;\n        let maxValue = to;\n\n        if (from < min && offset < 0) {\n            minValue = limitValue(from, min, max);\n            maxValue = limitValue(from + rangeSize, min + rangeSize, max);\n        } else if (to > max && offset > 0) {\n            maxValue = limitValue(to, min, max);\n            minValue = limitValue(to - rangeSize, min, max - rangeSize);\n        }\n\n        return {\n            min: minValue,\n            max: maxValue\n        };\n    }\n\n    valueRange() {\n        return {\n            min: this.seriesMin,\n            max: this.seriesMax\n        };\n    }\n\n    labelsBetweenTicks() {\n        return !this.options.justified;\n    }\n\n    //add legacy fields to the options that are no longer generated by default\n    prepareUserOptions() {\n    }\n}\n\nsetDefaultOptions(axis_Axis, {\n    labels: {\n        visible: true,\n        rotation: 0,\n        mirror: false,\n        step: 1,\n        skip: 0\n    },\n    line: {\n        width: 1,\n        color: BLACK,\n        visible: true\n    },\n    title: {\n        visible: true,\n        position: CENTER\n    },\n    majorTicks: {\n        align: OUTSIDE,\n        size: 4,\n        skip: 0,\n        step: 1\n    },\n    minorTicks: {\n        align: OUTSIDE,\n        size: 3,\n        skip: 0,\n        step: 1\n    },\n    axisCrossingValue: 0,\n    majorTickType: OUTSIDE,\n    minorTickType: NONE,\n    majorGridLines: {\n        skip: 0,\n        step: 1\n    },\n    minorGridLines: {\n        visible: false,\n        width: 1,\n        color: BLACK,\n        skip: 0,\n        step: 1\n    },\n    // TODO: Move to line or labels options\n    margin: 5,\n    visible: true,\n    reverse: false,\n    justified: true,\n    notes: {\n        label: {\n            text: \"\"\n        }\n    },\n\n    _alignLines: true,\n    _deferLabels: false\n});\n\n/* harmony default export */ var core_axis = (axis_Axis);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/date-utils/constants.js\nconst MILLISECONDS = \"milliseconds\";\nconst SECONDS = \"seconds\";\nconst MINUTES = \"minutes\";\nconst HOURS = \"hours\";\nconst DAYS = \"days\";\nconst WEEKS = \"weeks\";\nconst MONTHS = \"months\";\nconst YEARS = \"years\";\n\nconst TIME_PER_MILLISECOND = 1;\nconst TIME_PER_SECOND = 1000;\nconst TIME_PER_MINUTE = 60 * TIME_PER_SECOND;\nconst TIME_PER_HOUR = 60 * TIME_PER_MINUTE;\nconst TIME_PER_DAY = 24 * TIME_PER_HOUR;\nconst TIME_PER_WEEK = 7 * TIME_PER_DAY;\nconst TIME_PER_MONTH = 31 * TIME_PER_DAY;\nconst TIME_PER_YEAR = 365 * TIME_PER_DAY;\nconst TIME_PER_UNIT = {\n    \"years\": TIME_PER_YEAR,\n    \"months\": TIME_PER_MONTH,\n    \"weeks\": TIME_PER_WEEK,\n    \"days\": TIME_PER_DAY,\n    \"hours\": TIME_PER_HOUR,\n    \"minutes\": TIME_PER_MINUTE,\n    \"seconds\": TIME_PER_SECOND,\n    \"milliseconds\": TIME_PER_MILLISECOND\n};\n\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/date-utils/absolute-date-diff.js\n\n\nfunction absoluteDateDiff(a, b) {\n    const diff = a.getTime() - b;\n    const offsetDiff = a.getTimezoneOffset() - b.getTimezoneOffset();\n\n    return diff - (offsetDiff * TIME_PER_MINUTE);\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/date-utils/add-ticks.js\nfunction addTicks(date, ticks) {\n    return new Date(date.getTime() + ticks);\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/date-utils/to-date.js\nfunction toDate(value) {\n    let result;\n\n    if (value instanceof Date) {\n        result = value;\n    } else if (value) {\n        result = new Date(value);\n    }\n\n    return result;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/date-utils/start-of-week.js\n\n\n\nfunction startOfWeek(date, weekStartDay = 0) {\n    let daysToSubtract = 0;\n    let day = date.getDay();\n\n    if (!isNaN(day)) {\n        while (day !== weekStartDay) {\n            if (day === 0) {\n                day = 6;\n            } else {\n                day--;\n            }\n\n            daysToSubtract++;\n        }\n    }\n\n    return addTicks(date, -daysToSubtract * TIME_PER_DAY);\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/date-utils/add-duration.js\n\n\n\n\n\nfunction adjustDST(date, hours) {\n    if (hours === 0 && date.getHours() === 23) {\n        date.setHours(date.getHours() + 2);\n        return true;\n    }\n\n    return false;\n}\n\nfunction addHours(date, hours) {\n    const roundedDate = new Date(date);\n\n    roundedDate.setMinutes(0, 0, 0);\n\n    const tzDiff = (date.getTimezoneOffset() - roundedDate.getTimezoneOffset()) * TIME_PER_MINUTE;\n\n    return addTicks(roundedDate, tzDiff + hours * TIME_PER_HOUR);\n}\n\nfunction addDuration(dateValue, value, unit, weekStartDay) {\n    let result = dateValue;\n\n    if (dateValue) {\n        let date = toDate(dateValue);\n        const hours = date.getHours();\n\n        if (unit === YEARS) {\n            result = new Date(date.getFullYear() + value, 0, 1);\n            adjustDST(result, 0);\n        } else if (unit === MONTHS) {\n            result = new Date(date.getFullYear(), date.getMonth() + value, 1);\n            adjustDST(result, hours);\n        } else if (unit === WEEKS) {\n            result = addDuration(startOfWeek(date, weekStartDay), value * 7, DAYS);\n            adjustDST(result, hours);\n        } else if (unit === DAYS) {\n            result = new Date(date.getFullYear(), date.getMonth(), date.getDate() + value);\n            adjustDST(result, hours);\n        } else if (unit === HOURS) {\n            result = addHours(date, value);\n        } else if (unit === MINUTES) {\n            result = addTicks(date, value * TIME_PER_MINUTE);\n\n            if (result.getSeconds() > 0) {\n                result.setSeconds(0);\n            }\n        } else if (unit === SECONDS) {\n            result = addTicks(date, value * TIME_PER_SECOND);\n        } else if (unit === MILLISECONDS) {\n            result = addTicks(date, value);\n        }\n\n        if (unit !== MILLISECONDS && result.getMilliseconds() > 0) {\n            result.setMilliseconds(0);\n        }\n    }\n\n    return result;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/date-utils/floor-date.js\n\n\n\nfunction floorDate(date, unit, weekStartDay) {\n    return addDuration(toDate(date), 0, unit, weekStartDay);\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/date-utils/ceil-date.js\n\n\n\n\nfunction ceilDate(dateValue, unit, weekStartDay) {\n    const date = toDate(dateValue);\n\n    if (date && floorDate(date, unit, weekStartDay).getTime() === date.getTime()) {\n        return date;\n    }\n\n    return addDuration(date, 1, unit, weekStartDay);\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/date-utils/date-comparer.js\nfunction dateComparer(a, b) {\n    if (a && b) {\n        return a.getTime() - b.getTime();\n    }\n\n    return -1;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/date-utils/date-diff.js\nfunction dateDiff(a, b) {\n    return a.getTime() - b;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/date-utils/to-time.js\n\n\n\nfunction toTime(value) {\n    if (isArray(value)) {\n        let result = [];\n        for (let idx = 0; idx < value.length; idx++) {\n            result.push(toTime(value[idx]));\n        }\n\n        return result;\n    } else if (value) {\n        return toDate(value).getTime();\n    }\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/date-utils/date-equals.js\n\n\nfunction dateEquals(a, b) {\n    if (a && b) {\n        return toTime(a) === toTime(b);\n    }\n\n    return a === b;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/date-utils/date-index.js\n\n\n\n\n\nfunction timeIndex(date, start, baseUnit) {\n    return absoluteDateDiff(date, start) / TIME_PER_UNIT[baseUnit];\n}\n\nfunction dateIndex(value, start, baseUnit, baseUnitStep) {\n    const date = toDate(value);\n    const startDate = toDate(start);\n    let index;\n\n    if (baseUnit === MONTHS) {\n        index = (date.getMonth() - startDate.getMonth() + (date.getFullYear() - startDate.getFullYear()) * 12) +\n            timeIndex(date, new Date(date.getFullYear(), date.getMonth()), DAYS) / new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();\n    } else if (baseUnit === YEARS) {\n        index = date.getFullYear() - startDate.getFullYear() + dateIndex(date, new Date(date.getFullYear(), 0), MONTHS, 1) / 12;\n    } else if (baseUnit === DAYS || baseUnit === WEEKS) {\n        index = timeIndex(date, startDate, baseUnit);\n    } else {\n        index = dateDiff(date, start) / TIME_PER_UNIT[baseUnit];\n    }\n\n    return index / baseUnitStep;\n}\n\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/date-utils/duration.js\n\n\n\nfunction duration_duration(a, b, unit) {\n    let diff;\n\n    if (unit === YEARS) {\n        diff = b.getFullYear() - a.getFullYear();\n    } else if (unit === MONTHS) {\n        diff = duration_duration(a, b, YEARS) * 12 + b.getMonth() - a.getMonth();\n    } else if (unit === DAYS) {\n        diff = Math.floor(dateDiff(b, a) / TIME_PER_DAY);\n    } else {\n        diff = Math.floor(dateDiff(b, a) / TIME_PER_UNIT[unit]);\n    }\n\n    return diff;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/date-utils/lte-date-index.js\n\n\nfunction lteDateIndex(date, sortedDates) {\n    let low = 0;\n    let high = sortedDates.length - 1;\n    let index;\n\n    while (low <= high) {\n        index = Math.floor((low + high) / 2);\n        const currentDate = sortedDates[index];\n\n        if (currentDate < date) {\n            low = index + 1;\n            continue;\n        }\n\n        if (currentDate > date) {\n            high = index - 1;\n            continue;\n        }\n\n        while (dateEquals(sortedDates[index - 1], date)) {\n            index--;\n        }\n\n        return index;\n    }\n\n    if (sortedDates[index] <= date) {\n        return index;\n    }\n\n    return index - 1;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/date-utils/parse-date.js\n\n\n\nfunction parse_date_parseDate(intlService, date) {\n    let result;\n    if (isString(date)) {\n        result = intlService.parseDate(date) || toDate(date);\n    } else {\n        result = toDate(date);\n    }\n    return result;\n}\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/date-utils/parse-dates.js\n\n\n\n\nfunction parseDates(intlService, dates) {\n    if (isArray(dates)) {\n        const result = [];\n        for (let idx = 0; idx < dates.length; idx++) {\n            result.push(parse_date_parseDate(intlService, dates[idx]));\n        }\n\n        return result;\n    }\n\n    return parse_date_parseDate(intlService, dates);\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/date-utils/first-day.js\n\n\nfunction first_day_firstDay(options, intlService) {\n    if (isNumber(options.weekStartDay)) {\n        return options.weekStartDay;\n    }\n\n    if (intlService && intlService.firstDay) {\n        return intlService.firstDay();\n    }\n\n    return 0;\n}\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/date-utils.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/category-axis.js\n\n\n\n\n\n\n\nconst MIN_CATEGORY_POINTS_RANGE = 0.01;\n\nfunction indexOf(value, arr) {\n    if (value instanceof Date) {\n        const length = arr.length;\n        for (let idx = 0; idx < length; idx++) {\n            if (dateEquals(arr[idx], value)) {\n                return idx;\n            }\n        }\n\n        return -1;\n    }\n\n    return arr.indexOf(value);\n}\n\nclass category_axis_CategoryAxis extends core_axis {\n    initFields() {\n        this._ticks = {};\n    }\n\n    categoriesHash() {\n        return \"\";\n    }\n\n    clone() {\n        const copy = new category_axis_CategoryAxis(Object.assign({}, this.options, {\n            categories: this.options.srcCategories\n        }), this.chartService);\n        copy.createLabels();\n\n        return copy;\n    }\n\n    initUserOptions(options) {\n        const categories = options.categories || [];\n        const definedMin = defined(options.min);\n        const definedMax = defined(options.max);\n        options.srcCategories = options.categories = categories;\n\n        if ((definedMin || definedMax) && categories.length) {\n            const min = definedMin ? Math.floor(options.min) : 0;\n            let max;\n\n            if (definedMax) {\n                max = options.justified ? Math.floor(options.max) + 1 : Math.ceil(options.max);\n            } else {\n                max = categories.length;\n            }\n\n            options.categories = options.categories.slice(min, max);\n        }\n\n        return options;\n    }\n\n    rangeIndices() {\n        const options = this.options;\n        const length = options.categories.length || 1;\n        const min = isNumber(options.min) ? options.min % 1 : 0;\n        let max;\n\n        if (isNumber(options.max) && options.max % 1 !== 0 && options.max < this.totalRange().max) {\n            max = length - (1 - options.max % 1);\n        } else {\n            max = length - (options.justified ? 1 : 0);\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    }\n\n    totalRangeIndices(limit) {\n        const options = this.options;\n        let min = isNumber(options.min) ? options.min : 0;\n        let max;\n\n        if (isNumber(options.max)) {\n            max = options.max;\n        } else if (isNumber(options.min)) {\n            max = min + options.categories.length;\n        } else {\n            max = this.totalRange().max || 1;\n        }\n\n        if (limit) {\n            const totalRange = this.totalRange();\n            min = limitValue(min, 0, totalRange.max);\n            max = limitValue(max, 0, totalRange.max);\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    }\n\n    range() {\n        const options = this.options;\n        const min = isNumber(options.min) ? options.min : 0;\n        const max = isNumber(options.max) ? options.max : this.totalRange().max;\n\n        return {\n            min: min,\n            max: max\n        };\n    }\n\n    roundedRange() {\n        return this.range();\n    }\n\n    totalRange() {\n        const options = this.options;\n        return { min: 0, max: Math.max(this._seriesMax || 0, options.srcCategories.length) - (options.justified ? 1 : 0) };\n    }\n\n    scaleOptions() {\n        const { min, max } = this.rangeIndices();\n        const lineBox = this.lineBox();\n        const size = this.options.vertical ? lineBox.height() : lineBox.width();\n        const scale = size / ((max - min) || 1);\n\n        return {\n            scale: scale * (this.options.reverse ? -1 : 1),\n            box: lineBox,\n            min: min,\n            max: max\n        };\n    }\n\n    arrangeLabels() {\n        super.arrangeLabels();\n        this.hideOutOfRangeLabels();\n    }\n\n    hideOutOfRangeLabels() {\n        const { box, labels } = this;\n\n        if (labels.length > 0) {\n            const valueAxis = this.options.vertical ? Y : X;\n            const start = box[valueAxis + 1];\n            const end = box[valueAxis + 2];\n            const firstLabel = labels[0];\n            const lastLabel = last(labels);\n\n            if (firstLabel.box[valueAxis + 1] > end || firstLabel.box[valueAxis + 2] < start) {\n                firstLabel.options.visible = false;\n            }\n            if (lastLabel.box[valueAxis + 1] > end || lastLabel.box[valueAxis + 2] < start) {\n                lastLabel.options.visible = false;\n            }\n        }\n    }\n\n    getMajorTickPositions() {\n        return this.getTicks().majorTicks;\n    }\n\n    getMinorTickPositions() {\n        return this.getTicks().minorTicks;\n    }\n\n    getLabelsTickPositions() {\n        return this.getTicks().labelTicks;\n    }\n\n    tickIndices(stepSize) {\n        const { min, max } = this.rangeIndices();\n        const limit = Math.ceil(max);\n        let current = Math.floor(min);\n        const indices = [];\n\n        while (current <= limit) {\n            indices.push(current);\n            current += stepSize;\n        }\n\n        return indices;\n    }\n\n    getTickPositions(stepSize) {\n        const { vertical, reverse } = this.options;\n        const { scale, box, min } = this.scaleOptions();\n        const pos = box[(vertical ? Y : X) + (reverse ? 2 : 1)];\n        const indices = this.tickIndices(stepSize);\n        const positions = [];\n\n        for (let idx = 0; idx < indices.length; idx++) {\n            positions.push(pos + round(scale * (indices[idx] - min), COORD_PRECISION));\n        }\n\n        return positions;\n    }\n\n    getTicks() {\n        const options = this.options;\n        const cache = this._ticks;\n        const range = this.rangeIndices();\n        const lineBox = this.lineBox();\n        const hash = lineBox.getHash() + range.min + \",\" + range.max + options.reverse + options.justified;\n\n        if (cache._hash !== hash) {\n            const hasMinor = options.minorTicks.visible || options.minorGridLines.visible;\n            cache._hash = hash;\n            cache.labelTicks = this.getTickPositions(1);\n            cache.majorTicks = this.filterOutOfRangePositions(cache.labelTicks, lineBox);\n            cache.minorTicks = hasMinor ? this.filterOutOfRangePositions(this.getTickPositions(0.5), lineBox) : [];\n        }\n\n        return cache;\n    }\n\n    filterOutOfRangePositions(positions, lineBox) {\n        if (!positions.length) {\n            return positions;\n        }\n\n        const axis = this.options.vertical ? Y : X;\n        const inRange = (position) => lineBox[axis + 1] <= position && position <= lineBox[axis + 2];\n\n        const end = positions.length - 1;\n        let startIndex = 0;\n        while (!inRange(positions[startIndex]) && startIndex <= end) {\n            startIndex++;\n        }\n\n        let endIndex = end;\n\n        while (!inRange(positions[endIndex]) && endIndex >= 0) {\n            endIndex--;\n        }\n\n        return positions.slice(startIndex, endIndex + 1);\n    }\n\n    getSlot(from, to, limit) {\n        const options = this.options;\n        const { reverse, justified, vertical } = options;\n        const { scale, box, min } = this.scaleOptions();\n        const valueAxis = vertical ? Y : X;\n        const lineStart = box[valueAxis + (reverse ? 2 : 1)];\n        const slotBox = box.clone();\n        const singleSlot = !defined(to);\n\n        const start = valueOrDefault(from, 0);\n        let end = valueOrDefault(to, start);\n        end = Math.max(end - 1, start);\n\n        // Fixes transient bug caused by iOS 6.0 JIT\n        // (one can never be too sure)\n        end = Math.max(start, end);\n\n        let p1 = lineStart + (start - min) * scale;\n        let p2 = lineStart + (end + 1 - min) * scale;\n\n        if (singleSlot && justified) {\n            p2 = p1;\n        }\n\n        if (limit) {\n            p1 = limitValue(p1, box[valueAxis + 1], box[valueAxis + 2]);\n            p2 = limitValue(p2, box[valueAxis + 1], box[valueAxis + 2]);\n        }\n\n        slotBox[valueAxis + 1] = reverse ? p2 : p1;\n        slotBox[valueAxis + 2] = reverse ? p1 : p2;\n\n        return slotBox;\n    }\n\n    limitSlot(slot) {\n        const vertical = this.options.vertical;\n        const valueAxis = vertical ? Y : X;\n        const lineBox = this.lineBox();\n        const limittedSlot = slot.clone();\n\n        limittedSlot[valueAxis + 1] = limitValue(slot[valueAxis + 1], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);\n        limittedSlot[valueAxis + 2] = limitValue(slot[valueAxis + 2], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);\n\n        return limittedSlot;\n    }\n\n    slot(from, to, limit) {\n        const min = Math.floor(this.options.min || 0);\n        let start = from;\n        let end = to;\n\n        if (typeof start === \"string\") {\n            start = this.categoryIndex(start);\n        } else if (isNumber(start)) {\n            start -= min;\n        }\n\n        if (typeof end === \"string\") {\n            end = this.categoryIndex(end);\n        } else if (isNumber(end)) {\n            end -= min;\n        }\n\n        return super.slot(start, end, limit);\n    }\n\n    pointCategoryIndex(point) {\n        const { reverse, justified, vertical } = this.options;\n        const valueAxis = vertical ? Y : X;\n        const { scale, box, min, max } = this.scaleOptions();\n        const startValue = reverse ? max : min;\n        const lineStart = box[valueAxis + 1];\n        const lineEnd = box[valueAxis + 2];\n        const pos = point[valueAxis];\n\n        if (pos < lineStart || pos > lineEnd) {\n            return null;\n        }\n\n        let value = startValue + (pos - lineStart) / scale;\n        const diff = value % 1;\n\n        if (justified) {\n            value = Math.round(value);\n        } else if (diff === 0 && value > 0) {\n            value--;\n        }\n\n        return Math.floor(value);\n    }\n\n    getCategory(point) {\n        const index = this.pointCategoryIndex(point);\n\n        if (index === null) {\n            return null;\n        }\n\n        return this.options.categories[index];\n    }\n\n    categoryIndex(value) {\n        return this.totalIndex(value) - Math.floor(this.options.min || 0);\n    }\n\n    categoryAt(index, total) {\n        const options = this.options;\n\n        return (total ? options.srcCategories : options.categories)[index];\n    }\n\n    categoriesCount() {\n        return (this.options.categories || []).length;\n    }\n\n    translateRange(delta) {\n        const options = this.options;\n        const lineBox = this.lineBox();\n        const size = options.vertical ? lineBox.height() : lineBox.width();\n        const range = options.categories.length;\n        const scale = size / range;\n        const offset = round(delta / scale, DEFAULT_PRECISION);\n\n        return {\n            min: offset,\n            max: range + offset\n        };\n    }\n\n    zoomRange(rate) {\n        const rangeIndices = this.totalRangeIndices();\n        const { min: totalMin, max: totalMax } = this.totalRange();\n        const min = limitValue(rangeIndices.min + rate, totalMin, totalMax);\n        const max = limitValue(rangeIndices.max - rate, totalMin, totalMax);\n\n        if (max - min > 0) {\n            return {\n                min: min,\n                max: max\n            };\n        }\n    }\n\n    scaleRange(scale) {\n        const range = this.options.categories.length;\n        const delta = scale * range;\n\n        return {\n            min: -delta,\n            max: range + delta\n        };\n    }\n\n    labelsCount() {\n        const labelsRange = this.labelsRange();\n\n        return labelsRange.max - labelsRange.min;\n    }\n\n    labelsRange() {\n        const options = this.options;\n        const { justified, labels: labelOptions } = options;\n        let { min, max } = this.totalRangeIndices(true);\n        const start = Math.floor(min);\n\n        if (!justified) {\n            min = Math.floor(min);\n            max = Math.ceil(max);\n        } else {\n            min = Math.ceil(min);\n            max = Math.floor(max);\n        }\n\n        let skip;\n\n        if (min > labelOptions.skip) {\n            skip = labelOptions.skip + labelOptions.step * Math.ceil((min - labelOptions.skip) / labelOptions.step);\n        } else {\n            skip = labelOptions.skip;\n        }\n\n        return {\n            min: skip - start,\n            max: (options.categories.length ? max + (justified ? 1 : 0) : 0) - start\n        };\n    }\n\n    createAxisLabel(index, labelOptions, labelContext) {\n        const options = this.options;\n        const dataItem = options.dataItems ? options.dataItems[index] : null;\n        const category = valueOrDefault(options.categories[index], \"\");\n\n        labelContext.dataItem = dataItem;\n        const text = this.axisLabelText(category, labelOptions, labelContext);\n\n        return new axis_label(category, text, index, dataItem, labelOptions);\n    }\n\n    shouldRenderNote(value) {\n        const range = this.totalRangeIndices();\n\n        return Math.floor(range.min) <= value && value <= Math.ceil(range.max);\n    }\n\n    noteSlot(value) {\n        const options = this.options;\n        const index = value - Math.floor(options.min || 0);\n        return this.getSlot(index);\n    }\n\n    arrangeNotes() {\n        super.arrangeNotes();\n        this.hideOutOfRangeNotes();\n    }\n\n    hideOutOfRangeNotes() {\n        const { notes, box } = this;\n        if (notes && notes.length) {\n            const valueAxis = this.options.vertical ? Y : X;\n            const start = box[valueAxis + 1];\n            const end = box[valueAxis + 2];\n\n            for (let idx = 0; idx < notes.length; idx++) {\n                const note = notes[idx];\n                if (note.box && (end < note.box[valueAxis + 1] || note.box[valueAxis + 2] < start)) {\n                    note.hide();\n                }\n            }\n        }\n    }\n\n    pan(delta) {\n        const range = this.totalRangeIndices(true);\n        const { scale } = this.scaleOptions();\n        const offset = round(delta / scale, DEFAULT_PRECISION);\n        const totalRange = this.totalRange();\n        const min = range.min + offset;\n        const max = range.max + offset;\n\n        return this.limitRange(min, max, 0, totalRange.max, offset);\n    }\n\n    pointsRange(start, end) {\n        const { reverse, vertical } = this.options;\n        const valueAxis = vertical ? Y : X;\n        const range = this.totalRangeIndices(true);\n        const { scale, box } = this.scaleOptions();\n        const lineStart = box[valueAxis + (reverse ? 2 : 1)];\n\n        const diffStart = start[valueAxis] - lineStart;\n        const diffEnd = end[valueAxis] - lineStart;\n\n        const min = range.min + diffStart / scale;\n        const max = range.min + diffEnd / scale;\n        const rangeMin = Math.min(min, max);\n        const rangeMax = Math.max(min, max);\n\n        if (rangeMax - rangeMin >= MIN_CATEGORY_POINTS_RANGE) {\n            return {\n                min: rangeMin,\n                max: rangeMax\n            };\n        }\n    }\n\n    valueRange() {\n        return this.range();\n    }\n\n    totalIndex(value) {\n        const options = this.options;\n        const index = this._categoriesMap ?\n            this._categoriesMap.get(value) : indexOf(value, options.srcCategories);\n\n        return index;\n    }\n\n    currentRangeIndices() {\n        const options = this.options;\n        let min = 0;\n\n        if (isNumber(options.min)) {\n            min = Math.floor(options.min);\n        }\n\n        let max;\n        if (isNumber(options.max)) {\n            max = options.justified ? Math.floor(options.max) : Math.ceil(options.max) - 1;\n        } else {\n            max = this.totalCount() - 1;\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    }\n\n    mapCategories() {\n        if (!this._categoriesMap) {\n            const map = this._categoriesMap = new HashMap();\n            const srcCategories = this.options.srcCategories;\n            for (let idx = 0; idx < srcCategories.length; idx++) {\n                map.set(srcCategories[idx], idx);\n            }\n        }\n    }\n\n    totalCount() {\n        return Math.max(this.options.srcCategories.length, this._seriesMax || 0);\n    }\n}\n\nsetDefaultOptions(category_axis_CategoryAxis, {\n    type: \"category\",\n    vertical: false,\n    majorGridLines: {\n        visible: false,\n        width: 1,\n        color: BLACK\n    },\n    labels: {\n        zIndex: 1\n    },\n    justified: false,\n    _deferLabels: true\n});\n\n/* harmony default export */ var category_axis = (category_axis_CategoryAxis);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/constants.js\nconst COORDINATE_LIMIT = 300000;\n\nconst DateLabelFormats = {\n    milliseconds: \"HH:mm:ss.fff\",\n    seconds: \"HH:mm:ss\",\n    minutes: \"HH:mm\",\n    hours: \"HH:mm\",\n    days: \"M/d\",\n    weeks: \"M/d\",\n    months: \"MMM 'yy\",\n    years: \"yyyy\"\n};\n\nconst ZERO_THRESHOLD = 0.2;\n\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/date-category-axis.js\n\n\n\n\n\n\n\n\n\n\n\n\nconst AUTO = \"auto\";\nconst BASE_UNITS = [\n    MILLISECONDS, SECONDS, MINUTES, HOURS, DAYS, WEEKS, MONTHS, YEARS\n];\nconst FIT = \"fit\";\n\n\nfunction categoryRange(categories) {\n    let range = categories._range;\n    if (!range) {\n        range = categories._range = sparseArrayLimits(categories);\n        range.min = toDate(range.min);\n        range.max = toDate(range.max);\n    }\n\n    return range;\n}\n\nclass EmptyDateRange {\n    constructor(options) {\n        this.options = options;\n    }\n\n    displayIndices() {\n        return {\n            min: 0,\n            max: 1\n        };\n    }\n\n    displayRange() {\n        return {};\n    }\n\n    total() {\n        return {};\n    }\n\n    valueRange() {\n        return {};\n    }\n\n    valueIndex() {\n        return -1;\n    }\n\n    values() {\n        return [];\n    }\n\n    totalIndex() {\n        return -1;\n    }\n\n    valuesCount() {\n        return 0;\n    }\n\n    totalCount() {\n        return 0;\n    }\n\n    dateAt() {\n        return null;\n    }\n}\n\nclass date_category_axis_DateRange {\n    constructor(start, end, options) {\n        this.options = options;\n        options.baseUnitStep = options.baseUnitStep || 1;\n\n        const { roundToBaseUnit, justified } = options;\n\n        this.start = addDuration(start, 0, options.baseUnit, options.weekStartDay);\n        const lowerEnd = this.roundToTotalStep(end);\n        const expandEnd = !justified && dateEquals(end, lowerEnd) && !options.justifyEnd;\n\n        this.end = this.roundToTotalStep(end, !justified, expandEnd ? 1 : 0);\n\n        const min = options.min || start;\n        this.valueStart = this.roundToTotalStep(min);\n        this.displayStart = roundToBaseUnit ? this.valueStart : min;\n\n        const max = options.max;\n        if (!max) {\n            this.valueEnd = lowerEnd;\n            this.displayEnd = roundToBaseUnit || expandEnd ? this.end : end;\n        } else {\n            const next = !justified && dateEquals(max, this.roundToTotalStep(max)) ? -1 : 0;\n            this.valueEnd = this.roundToTotalStep(max, false, next);\n            this.displayEnd = roundToBaseUnit ? this.roundToTotalStep(max, !justified) : options.max;\n        }\n\n        if (this.valueEnd < this.valueStart) {\n            this.valueEnd = this.valueStart;\n        }\n        if (this.displayEnd <= this.displayStart) {\n            this.displayEnd = this.roundToTotalStep(this.displayStart, false, 1);\n        }\n    }\n\n    displayRange() {\n        return {\n            min: this.displayStart,\n            max: this.displayEnd\n        };\n    }\n\n    displayIndices() {\n        if (!this._indices) {\n            const options = this.options;\n\n            const { baseUnit, baseUnitStep } = options;\n\n            const minIdx = dateIndex(this.displayStart, this.valueStart, baseUnit, baseUnitStep);\n            const maxIdx = dateIndex(this.displayEnd, this.valueStart, baseUnit, baseUnitStep);\n\n            this._indices = { min: minIdx, max: maxIdx };\n        }\n\n        return this._indices;\n    }\n\n    total() {\n        return {\n            min: this.start,\n            max: this.end\n        };\n    }\n\n    totalCount() {\n        const last = this.totalIndex(this.end);\n\n        return last + (this.options.justified ? 1 : 0);\n    }\n\n    valueRange() {\n        return {\n            min: this.valueStart,\n            max: this.valueEnd\n        };\n    }\n\n    valueIndex(value) {\n        const options = this.options;\n        return Math.floor(dateIndex(value, this.valueStart, options.baseUnit, options.baseUnitStep));\n    }\n\n    totalIndex(value) {\n        const options = this.options;\n        return Math.floor(dateIndex(value, this.start, options.baseUnit, options.baseUnitStep));\n    }\n\n    dateIndex(value) {\n        const options = this.options;\n        return dateIndex(value, this.valueStart, options.baseUnit, options.baseUnitStep);\n    }\n\n    valuesCount() {\n        const maxIdx = this.valueIndex(this.valueEnd);\n\n        return maxIdx + 1;\n    }\n\n    values() {\n        let values = this._values;\n        if (!values) {\n            const options = this.options;\n            const range = this.valueRange();\n            this._values = values = [];\n\n            for (let date = range.min; date <= range.max;) {\n                values.push(date);\n                date = addDuration(date, options.baseUnitStep, options.baseUnit, options.weekStartDay);\n            }\n        }\n\n        return values;\n    }\n\n    dateAt(index, total) {\n        const options = this.options;\n\n        return addDuration(total ? this.start : this.valueStart, options.baseUnitStep * index, options.baseUnit, options.weekStartDay);\n    }\n\n    roundToTotalStep(value, upper, next) {\n        const { baseUnit, baseUnitStep, weekStartDay } = this.options;\n        const start = this.start;\n\n        const step = dateIndex(value, start, baseUnit, baseUnitStep);\n        let roundedStep = upper ? Math.ceil(step) : Math.floor(step);\n\n        if (next) {\n            roundedStep += next;\n        }\n\n        return addDuration(start, roundedStep * baseUnitStep, baseUnit, weekStartDay);\n    }\n\n}\n\nfunction autoBaseUnit(options, startUnit, startStep) {\n    const categoryLimits = categoryRange(options.categories);\n    const span = (options.max || categoryLimits.max) - (options.min || categoryLimits.min);\n    const { autoBaseUnitSteps, maxDateGroups } = options;\n    const autoUnit = options.baseUnit === FIT;\n    let autoUnitIx = startUnit ? BASE_UNITS.indexOf(startUnit) : 0;\n    let baseUnit = autoUnit ? BASE_UNITS[autoUnitIx++] : options.baseUnit;\n    let units = span / TIME_PER_UNIT[baseUnit];\n    let totalUnits = units;\n    let unitSteps, step, nextStep;\n\n    while (!step || units >= maxDateGroups) {\n        unitSteps = unitSteps || autoBaseUnitSteps[baseUnit].slice(0);\n\n        do {\n            nextStep = unitSteps.shift();\n        } while (nextStep && startUnit === baseUnit && nextStep < startStep);\n\n        if (nextStep) {\n            step = nextStep;\n            units = totalUnits / step;\n        } else if (baseUnit === last(BASE_UNITS)) {\n            step = Math.ceil(totalUnits / maxDateGroups);\n            break;\n        } else if (autoUnit) {\n            baseUnit = BASE_UNITS[autoUnitIx++] || last(BASE_UNITS);\n            totalUnits = span / TIME_PER_UNIT[baseUnit];\n            unitSteps = null;\n        } else {\n            if (units > maxDateGroups) {\n                step = Math.ceil(totalUnits / maxDateGroups);\n            }\n            break;\n        }\n    }\n\n    options.baseUnitStep = step;\n    options.baseUnit = baseUnit;\n}\n\nfunction defaultBaseUnit(options) {\n    const categories = options.categories;\n    const count = defined(categories) ? categories.length : 0;\n    let minDiff = MAX_VALUE;\n    let lastCategory, unit;\n\n    for (let categoryIx = 0; categoryIx < count; categoryIx++) {\n        const category = categories[categoryIx];\n\n        if (category && lastCategory) {\n            const diff = absoluteDateDiff(category, lastCategory);\n            if (diff > 0) {\n                minDiff = Math.min(minDiff, diff);\n\n                if (minDiff >= TIME_PER_YEAR) {\n                    unit = YEARS;\n                } else if (minDiff >= TIME_PER_MONTH - TIME_PER_DAY * 3) {\n                    unit = MONTHS;\n                } else if (minDiff >= TIME_PER_WEEK) {\n                    unit = WEEKS;\n                } else if (minDiff >= TIME_PER_DAY) {\n                    unit = DAYS;\n                } else if (minDiff >= TIME_PER_HOUR) {\n                    unit = HOURS;\n                } else if (minDiff >= TIME_PER_MINUTE) {\n                    unit = MINUTES;\n                } else {\n                    unit = SECONDS;\n                }\n            }\n        }\n\n        lastCategory = category;\n    }\n\n    options.baseUnit = unit || DAYS;\n}\n\nfunction initUnit(options) {\n    const baseUnit = (options.baseUnit || \"\").toLowerCase();\n    const useDefault = baseUnit !== FIT && !inArray(baseUnit, BASE_UNITS);\n\n    if (useDefault) {\n        defaultBaseUnit(options);\n    }\n\n    if (baseUnit === FIT || options.baseUnitStep === AUTO) {\n        autoBaseUnit(options);\n    }\n\n    return options;\n}\n\nclass date_category_axis_DateCategoryAxis extends category_axis {\n\n    clone() {\n        const copy = new date_category_axis_DateCategoryAxis(Object.assign({}, this.options), this.chartService);\n        copy.createLabels();\n\n        return copy;\n    }\n\n    categoriesHash() {\n        const start = this.dataRange.total().min;\n        return this.options.baseUnit + this.options.baseUnitStep + start;\n    }\n\n    initUserOptions(options) {\n        return options;\n    }\n\n    initFields() {\n        super.initFields();\n\n        const chartService = this.chartService;\n        const intlService = chartService.intl;\n        let options = this.options;\n\n        let categories = options.categories || [];\n        if (!categories._parsed) {\n            categories = parseDates(intlService, categories);\n            categories._parsed = true;\n        }\n\n        options = deepExtend({\n            roundToBaseUnit: true\n        }, options, {\n            categories: categories,\n            min: parse_date_parseDate(intlService, options.min),\n            max: parse_date_parseDate(intlService, options.max),\n            weekStartDay: first_day_firstDay(options, intlService)\n        });\n\n        if (chartService.panning && chartService.isPannable(options.vertical ? Y : X)) {\n            options.roundToBaseUnit = false;\n        }\n\n        options.userSetBaseUnit = options.userSetBaseUnit || options.baseUnit;\n        options.userSetBaseUnitStep = options.userSetBaseUnitStep || options.baseUnitStep;\n\n        this.options = options;\n        options.srcCategories = categories;\n\n        if (categories.length > 0) {\n            const range = categoryRange(categories);\n            const maxDivisions = options.maxDivisions;\n\n            this.dataRange = new date_category_axis_DateRange(range.min, range.max, initUnit(options));\n\n            if (maxDivisions) {\n                const dataRange = this.dataRange.displayRange();\n\n                const divisionOptions = Object.assign({}, options, {\n                    justified: true,\n                    roundToBaseUnit: false,\n                    baseUnit: 'fit',\n                    min: dataRange.min,\n                    max: dataRange.max,\n                    maxDateGroups: maxDivisions\n                });\n\n                const dataRangeOptions = this.dataRange.options;\n\n                autoBaseUnit(divisionOptions, dataRangeOptions.baseUnit, dataRangeOptions.baseUnitStep);\n\n                this.divisionRange = new date_category_axis_DateRange(range.min, range.max, divisionOptions);\n            } else {\n                this.divisionRange = this.dataRange;\n            }\n\n        } else {\n            options.baseUnit = options.baseUnit || DAYS;\n            this.dataRange = this.divisionRange = new EmptyDateRange(options);\n        }\n\n        this.rangeLabels = [];\n    }\n\n    tickIndices(stepSize) {\n        const { dataRange, divisionRange } = this;\n        const valuesCount = divisionRange.valuesCount();\n\n        if (!this.options.maxDivisions || !valuesCount) {\n            return super.tickIndices(stepSize);\n        }\n\n        const indices = [];\n        let values = divisionRange.values();\n        let offset = 0;\n\n        if (!this.options.justified) {\n            values = values.concat(divisionRange.dateAt(valuesCount));\n            offset = 0.5;//align ticks to the center of not justified categories\n        }\n\n        for (let idx = 0; idx < values.length; idx++) {\n            indices.push(dataRange.dateIndex(values[idx]) + offset);\n            if (stepSize !== 1 && idx >= 1) {\n                const last = indices.length - 1;\n                indices.splice(idx, 0, indices[last - 1] + (indices[last] - indices[last - 1]) * stepSize);\n            }\n        }\n\n        return indices;\n    }\n\n    shouldRenderNote(value) {\n        const range = this.range();\n        const categories = this.options.categories || [];\n\n        return dateComparer(value, range.min) >= 0 && dateComparer(value, range.max) <= 0 && categories.length;\n    }\n\n    parseNoteValue(value) {\n        return parse_date_parseDate(this.chartService.intl, value);\n    }\n\n    noteSlot(value) {\n        return this.getSlot(value);\n    }\n\n    translateRange(delta) {\n        const options = this.options;\n        const { baseUnit, weekStartDay, vertical } = options;\n        const lineBox = this.lineBox();\n        const size = vertical ? lineBox.height() : lineBox.width();\n        let range = this.range();\n        const scale = size / (range.max - range.min);\n        const offset = round(delta / scale, DEFAULT_PRECISION);\n\n        if (range.min && range.max) {\n            const from = addTicks(options.min || range.min, offset);\n            const to = addTicks(options.max || range.max, offset);\n\n            range = {\n                min: addDuration(from, 0, baseUnit, weekStartDay),\n                max: addDuration(to, 0, baseUnit, weekStartDay)\n            };\n        }\n\n        return range;\n    }\n\n    scaleRange(delta) {\n        let rounds = Math.abs(delta);\n        let result = this.range();\n        let { min: from, max: to } = result;\n\n        if (from && to) {\n            while (rounds--) {\n                const range = dateDiff(from, to);\n                const step = Math.round(range * 0.1);\n                if (delta < 0) {\n                    from = addTicks(from, step);\n                    to = addTicks(to, -step);\n                } else {\n                    from = addTicks(from, -step);\n                    to = addTicks(to, step);\n                }\n            }\n\n            result = { min: from, max: to };\n        }\n\n        return result;\n    }\n\n    labelsRange() {\n        return {\n            min: this.options.labels.skip,\n            max: this.divisionRange.valuesCount()\n        };\n    }\n\n    pan(delta) {\n        if (this.isEmpty()) {\n            return null;\n        }\n\n        const options = this.options;\n        const lineBox = this.lineBox();\n        const size = options.vertical ? lineBox.height() : lineBox.width();\n        const { min, max } = this.dataRange.displayRange();\n        const totalLimits = this.dataRange.total();\n        const scale = size / (max - min);\n        const offset = round(delta / scale, DEFAULT_PRECISION) * (options.reverse ? -1 : 1);\n        const from = addTicks(min, offset);\n        const to = addTicks(max, offset);\n\n        const panRange = this.limitRange(toTime(from), toTime(to), toTime(totalLimits.min), toTime(totalLimits.max), offset);\n\n        if (panRange) {\n            panRange.min = toDate(panRange.min);\n            panRange.max = toDate(panRange.max);\n            panRange.baseUnit = options.baseUnit;\n            panRange.baseUnitStep = options.baseUnitStep || 1;\n            panRange.userSetBaseUnit = options.userSetBaseUnit;\n            panRange.userSetBaseUnitStep = options.userSetBaseUnitStep;\n\n            return panRange;\n        }\n    }\n\n    pointsRange(start, end) {\n        if (this.isEmpty()) {\n            return null;\n        }\n\n        const pointsRange = super.pointsRange(start, end);\n        const datesRange = this.dataRange.displayRange();\n        const indicesRange = this.dataRange.displayIndices();\n        const scale = dateDiff(datesRange.max, datesRange.min) / (indicesRange.max - indicesRange.min);\n        const options = this.options;\n\n        const min = addTicks(datesRange.min, pointsRange.min * scale);\n        const max = addTicks(datesRange.min, pointsRange.max * scale);\n\n        return {\n            min: min,\n            max: max,\n            baseUnit: options.userSetBaseUnit || options.baseUnit,\n            baseUnitStep: options.userSetBaseUnitStep || options.baseUnitStep\n        };\n    }\n\n    zoomRange(delta) {\n        if (this.isEmpty()) {\n            return null;\n        }\n\n        const options = this.options;\n        const fit = options.userSetBaseUnit === FIT;\n        const totalLimits = this.dataRange.total();\n        const { min: rangeMin, max: rangeMax } = this.dataRange.displayRange();\n        let { weekStartDay, baseUnit, baseUnitStep } = this.dataRange.options;\n        let min = addDuration(rangeMin, delta * baseUnitStep, baseUnit, weekStartDay);\n        let max = addDuration(rangeMax, -delta * baseUnitStep, baseUnit, weekStartDay);\n\n        if (fit) {\n            const { autoBaseUnitSteps, maxDateGroups } = options;\n\n            const maxDiff = last(autoBaseUnitSteps[baseUnit]) * maxDateGroups * TIME_PER_UNIT[baseUnit];\n            const rangeDiff = dateDiff(rangeMax, rangeMin);\n            const diff = dateDiff(max, min);\n            let baseUnitIndex = BASE_UNITS.indexOf(baseUnit);\n            let autoBaseUnitStep, ticks;\n\n            if (diff < TIME_PER_UNIT[baseUnit] && baseUnit !== MILLISECONDS) {\n                baseUnit = BASE_UNITS[baseUnitIndex - 1];\n                autoBaseUnitStep = last(autoBaseUnitSteps[baseUnit]);\n                ticks = (rangeDiff - (maxDateGroups - 1) * autoBaseUnitStep * TIME_PER_UNIT[baseUnit]) / 2;\n                min = addTicks(rangeMin, ticks);\n                max = addTicks(rangeMax, -ticks);\n\n            } else if (diff > maxDiff && baseUnit !== YEARS) {\n                let stepIndex = 0;\n\n                do {\n                    baseUnitIndex++;\n                    baseUnit = BASE_UNITS[baseUnitIndex];\n                    stepIndex = 0;\n                    ticks = 2 * TIME_PER_UNIT[baseUnit];\n                    do {\n                        autoBaseUnitStep = autoBaseUnitSteps[baseUnit][stepIndex];\n                        stepIndex++;\n                    } while (stepIndex < autoBaseUnitSteps[baseUnit].length && ticks * autoBaseUnitStep < rangeDiff);\n                } while (baseUnit !== YEARS && ticks * autoBaseUnitStep < rangeDiff);\n\n                ticks = (ticks * autoBaseUnitStep - rangeDiff) / 2;\n                if (ticks > 0) {\n                    min = addTicks(rangeMin, -ticks);\n                    max = addTicks(rangeMax, ticks);\n                    min = addTicks(min, limitValue(max, totalLimits.min, totalLimits.max) - max);\n                    max = addTicks(max, limitValue(min, totalLimits.min, totalLimits.max) - min);\n                }\n            }\n        }\n\n        if (min < totalLimits.min) {\n            min = totalLimits.min;\n        }\n        if (max > totalLimits.max) {\n            max = totalLimits.max;\n        }\n\n        if (min && max && dateDiff(max, min) > 0) {\n            return {\n                min: min,\n                max: max,\n                baseUnit: options.userSetBaseUnit || options.baseUnit,\n                baseUnitStep: options.userSetBaseUnitStep || options.baseUnitStep\n            };\n        }\n    }\n\n    range() {\n        return this.dataRange.displayRange();\n    }\n\n    createLabels() {\n        super.createLabels();\n        this.createRangeLabels();\n    }\n\n    clearLabels() {\n        super.clearLabels();\n        this.rangeLabels = [];\n    }\n\n    arrangeLabels() {\n        this.arrangeRangeLabels();\n        super.arrangeLabels();\n    }\n\n    arrangeRangeLabels() {\n        const { options, rangeLabels } = this;\n        if (rangeLabels.length === 0) {\n            return;\n        }\n\n        const lineBox = this.lineBox();\n        const vertical = options.vertical;\n        const mirror = options.rangeLabels.mirror || options.labels.mirror;\n\n        const firstLabel = rangeLabels[0];\n        if (firstLabel) {\n            const position = vertical ? lineBox.y1 - (firstLabel.box.height() / 2) : lineBox.x1;\n            this.positionLabel(firstLabel, mirror, position);\n        }\n\n        const lastLabel = rangeLabels[1];\n        if (lastLabel) {\n            const position = vertical ? lineBox.y2 - (lastLabel.box.height() / 2) : lineBox.x2;\n            this.positionLabel(lastLabel, mirror, position);\n        }\n    }\n\n    autoRotateLabels() {\n        super.autoRotateLabels();\n        this.autoRotateRangeLabels();\n    }\n\n    hideOutOfRangeLabels() {\n        super.hideOutOfRangeLabels();\n        this.hideOverlappingLabels();\n    }\n\n    hideOverlappingLabels() {\n        const { rangeLabels, labels } = this;\n        if (rangeLabels.length === 0) {\n            return;\n        }\n\n        function clip(rangeLabel, label) {\n            if (!label.options.visible || label.box.overlaps(rangeLabel.box)) {\n                label.options.visible = false;\n                return true;\n            }\n\n            return false;\n        }\n\n        const firstRangeLabel = rangeLabels[0];\n        if (firstRangeLabel && firstRangeLabel.options.visible) {\n            for (let i = 0; i < labels.length; i++) {\n                const overlaps = clip(firstRangeLabel, labels[i]);\n                if (!overlaps) {\n                    break;\n                }\n            }\n        }\n\n        const lastRangeLabel = rangeLabels[1];\n        if (lastRangeLabel && lastRangeLabel.options.visible) {\n            for (let i = labels.length - 1; i > 0; --i) {\n                const overlaps = clip(lastRangeLabel, labels[i]);\n                if (!overlaps) {\n                    break;\n                }\n            }\n        }\n    }\n\n    contentBox() {\n        const box = super.contentBox();\n        const rangeLabels = this.rangeLabels;\n\n        for (let i = 0; i < rangeLabels.length; i++) {\n            const label = rangeLabels[i];\n            if (label.options.visible) {\n                box.wrap(label.box);\n            }\n        }\n\n        return box;\n    }\n\n    createAxisLabel(index, labelOptions, labelContext = {}) {\n        const options = this.options;\n        const dataItem = options.dataItems && !options.maxDivisions ? options.dataItems[index] : null;\n        const date = this.divisionRange.dateAt(index);\n        const unitFormat = labelOptions.dateFormats[this.divisionRange.options.baseUnit];\n\n        labelOptions.format = labelOptions.format || unitFormat;\n        labelContext.dataItem = dataItem;\n\n        const text = this.axisLabelText(date, labelOptions, labelContext);\n        if (text) {\n            return new axis_label(date, text, index, dataItem, labelOptions);\n        }\n    }\n\n    createRangeLabels() {\n        const { displayStart, displayEnd } = this.divisionRange;\n        const options = this.options;\n        const labelOptions = Object.assign({}, options.labels, options.rangeLabels, {\n            align: CENTER,\n            zIndex: options.zIndex\n        });\n\n        if (labelOptions.visible !== true) {\n            return;\n        }\n\n        this.normalizeLabelRotation(labelOptions);\n        labelOptions.alignRotation = CENTER;\n\n        if (labelOptions.rotation === \"auto\") {\n            labelOptions.rotation = 0;\n            options.autoRotateRangeLabels = true;\n        }\n\n        const unitFormat = labelOptions.dateFormats[this.divisionRange.options.baseUnit];\n        labelOptions.format = labelOptions.format || unitFormat;\n\n        const createLabel = (index, date, text) => {\n            if (text) {\n                const label = new axis_label(date, text, index, null, labelOptions);\n                this.append(label);\n                this.rangeLabels.push(label);\n            }\n        };\n\n        const startText = this.axisLabelText(displayStart, labelOptions, { index: 0, count: 2 });\n        createLabel(0, displayStart, startText);\n\n        const endText = this.axisLabelText(displayEnd, labelOptions, { index: 1, count: 2 });\n        createLabel(1, displayEnd, endText);\n    }\n\n    autoRotateRangeLabels() {\n        const labels = this.rangeLabels;\n        if (!this.options.autoRotateRangeLabels || this.options.vertical || labels.length !== 2) {\n            return;\n        }\n\n        const rotateLabel = (label, tickPositions, index) => {\n            const width = Math.abs(tickPositions[index + 1] - tickPositions[index]) * 2;\n            const angle = this.autoRotateLabelAngle(label.box, width);\n            if (angle !== 0) {\n                label.options.rotation = angle;\n                label.reflow(new core_box());\n            }\n        };\n\n        const tickPositions = this.getMajorTickPositions();\n        rotateLabel(labels[0], tickPositions, 0);\n        rotateLabel(labels[1], tickPositions, tickPositions.length - 2);\n    }\n\n    categoryIndex(value) {\n        return this.dataRange.valueIndex(value);\n    }\n\n    slot(from, to, limit) {\n        const dateRange = this.dataRange;\n        let start = from;\n        let end = to;\n\n        if (start instanceof Date) {\n            start = dateRange.dateIndex(start);\n        }\n\n        if (end instanceof Date) {\n            end = dateRange.dateIndex(end);\n        }\n\n        const slot = this.getSlot(start, end, limit);\n        if (slot) {\n            return slot.toRect();\n        }\n    }\n\n    getSlot(a, b, limit) {\n        let start = a;\n        let end = b;\n\n        if (typeof start === OBJECT) {\n            start = this.categoryIndex(start);\n        }\n\n        if (typeof end === OBJECT) {\n            end = this.categoryIndex(end);\n        }\n\n        return super.getSlot(start, end, limit);\n    }\n\n    valueRange() {\n        const options = this.options;\n        const range = categoryRange(options.srcCategories);\n\n        return {\n            min: toDate(range.min),\n            max: toDate(range.max)\n        };\n    }\n\n    categoryAt(index, total) {\n        return this.dataRange.dateAt(index, total);\n    }\n\n    categoriesCount() {\n        return this.dataRange.valuesCount();\n    }\n\n    rangeIndices() {\n        return this.dataRange.displayIndices();\n    }\n\n    labelsBetweenTicks() {\n        return !this.divisionRange.options.justified;\n    }\n\n    prepareUserOptions() {\n        if (this.isEmpty()) {\n            return;\n        }\n\n        this.options.categories = this.dataRange.values();\n    }\n\n    getCategory(point) {\n        const index = this.pointCategoryIndex(point);\n\n        if (index === null) {\n            return null;\n        }\n\n        return this.dataRange.dateAt(index);\n    }\n\n    totalIndex(value) {\n        return this.dataRange.totalIndex(value);\n    }\n\n    currentRangeIndices() {\n        const range = this.dataRange.valueRange();\n        return {\n            min: this.dataRange.totalIndex(range.min),\n            max: this.dataRange.totalIndex(range.max)\n        };\n    }\n\n    totalRange() {\n        return this.dataRange.total();\n    }\n\n    totalCount() {\n        return this.dataRange.totalCount();\n    }\n\n    isEmpty() {\n        return !this.options.srcCategories.length;\n    }\n\n    roundedRange() {\n        if (this.options.roundToBaseUnit !== false || this.isEmpty()) {\n            return this.range();\n        }\n\n        const options = this.options;\n        const datesRange = categoryRange(options.srcCategories);\n\n        const dateRange = new date_category_axis_DateRange(datesRange.min, datesRange.max, Object.assign({}, options, {\n            justified: false,\n            roundToBaseUnit: true,\n            justifyEnd: options.justified\n        }));\n\n        return dateRange.displayRange();\n    }\n}\n\nsetDefaultOptions(date_category_axis_DateCategoryAxis, {\n    type: DATE,\n    labels: {\n        dateFormats: DateLabelFormats\n    },\n    rangeLabels: {\n        visible: false\n    },\n    autoBaseUnitSteps: {\n        milliseconds: [ 1, 10, 100 ],\n        seconds: [ 1, 2, 5, 15, 30 ],\n        minutes: [ 1, 2, 5, 15, 30 ],\n        hours: [ 1, 2, 3 ],\n        days: [ 1, 2, 3 ],\n        weeks: [ 1, 2 ],\n        months: [ 1, 2, 3, 6 ],\n        years: [ 1, 2, 3, 5, 10, 25, 50 ]\n    },\n    maxDateGroups: 10\n});\n\n/* harmony default export */ var date_category_axis = (date_category_axis_DateCategoryAxis);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/utils/auto-axis-min.js\n\n\nfunction autoAxisMin(min, max, narrow) {\n    if (!min && !max) {\n        return 0;\n    }\n\n    let axisMin;\n\n    if (min >= 0 && max >= 0) {\n        const minValue = min === max ? 0 : min;\n\n        let diff = (max - minValue) / max;\n        if (narrow === false || (!narrow && diff > ZERO_THRESHOLD)) {\n            return 0;\n        }\n\n        axisMin = Math.max(0, minValue - ((max - minValue) / 2));\n    } else {\n        axisMin = min;\n    }\n\n    return axisMin;\n}\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/utils/auto-axis-max.js\n\n\nfunction autoAxisMax(min, max, narrow) {\n    if (!min && !max) {\n        return 1;\n    }\n\n    let axisMax;\n\n    if (min <= 0 && max <= 0) {\n        const maxValue = min === max ? 0 : max;\n\n        let diff = Math.abs((maxValue - min) / maxValue);\n        if (narrow === false || (!narrow && diff > ZERO_THRESHOLD)) {\n            return 0;\n        }\n\n        axisMax = Math.min(0, maxValue - ((min - maxValue) / 2));\n    } else {\n        axisMax = max;\n    }\n\n    return axisMax;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/utils/floor.js\n\n\n\nfunction floor(value, step) {\n    return round(Math.floor(value / step) * step, DEFAULT_PRECISION);\n}\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/utils/ceil.js\n\n\n\nfunction ceil(value, step) {\n    return round(Math.ceil(value / step) * step, DEFAULT_PRECISION);\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/utils/limit-coordinate.js\n\n\nfunction limitCoordinate(value) {\n    return Math.max(Math.min(value, COORDINATE_LIMIT), -COORDINATE_LIMIT);\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/numeric-axis.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst MIN_VALUE_RANGE = Math.pow(10, -DEFAULT_PRECISION + 1);\n\nclass numeric_axis_NumericAxis extends core_axis {\n\n    constructor(seriesMin, seriesMax, options, chartService) {\n        super(Object.assign({}, options, {\n            seriesMin: seriesMin,\n            seriesMax: seriesMax\n        }), chartService);\n    }\n\n    initUserOptions(options) {\n        const autoOptions = autoAxisOptions(options.seriesMin, options.seriesMax, options);\n        this.totalOptions = totalAxisOptions(autoOptions, options);\n\n        return numeric_axis_axisOptions(autoOptions, options);\n    }\n\n    initFields() {\n        this.totalMin = this.totalOptions.min;\n        this.totalMax = this.totalOptions.max;\n        this.totalMajorUnit = this.totalOptions.majorUnit;\n        this.seriesMin = this.options.seriesMin;\n        this.seriesMax = this.options.seriesMax;\n    }\n\n    clone() {\n        return new numeric_axis_NumericAxis(\n            this.seriesMin,\n            this.seriesMax,\n            Object.assign({}, this.options),\n            this.chartService\n        );\n    }\n\n    startValue() {\n        return 0;\n    }\n\n    range() {\n        const options = this.options;\n        return { min: options.min, max: options.max };\n    }\n\n    getDivisions(stepValue) {\n        if (stepValue === 0) {\n            return 1;\n        }\n\n        const options = this.options;\n        const range = options.max - options.min;\n\n        return Math.floor(round(range / stepValue, COORD_PRECISION)) + 1;\n    }\n\n    getTickPositions(unit, skipUnit) {\n        const options = this.options;\n        const { vertical, reverse } = options;\n        const lineBox = this.lineBox();\n        const lineSize = vertical ? lineBox.height() : lineBox.width();\n        const range = options.max - options.min;\n        const scale = lineSize / range;\n        const step = unit * scale;\n        const divisions = this.getDivisions(unit);\n        const dir = (vertical ? -1 : 1) * (reverse ? -1 : 1);\n        const startEdge = dir === 1 ? 1 : 2;\n        const positions = [];\n        let pos = lineBox[(vertical ? Y : X) + startEdge];\n        let skipStep = 0;\n\n        if (skipUnit) {\n            skipStep = skipUnit / unit;\n        }\n\n        for (let idx = 0; idx < divisions; idx++) {\n            if (idx % skipStep !== 0) {\n                positions.push(round(pos, COORD_PRECISION));\n            }\n\n            pos = pos + step * dir;\n        }\n\n        return positions;\n    }\n\n    getMajorTickPositions() {\n        return this.getTickPositions(this.options.majorUnit);\n    }\n\n    getMinorTickPositions() {\n        return this.getTickPositions(this.options.minorUnit);\n    }\n\n    getSlot(a, b, limit = false) {\n        const options = this.options;\n        const { vertical, reverse } = options;\n        const valueAxis = vertical ? Y : X;\n        const lineBox = this.lineBox();\n        const lineStart = lineBox[valueAxis + (reverse ? 2 : 1)];\n        const lineSize = vertical ? lineBox.height() : lineBox.width();\n        const dir = reverse ? -1 : 1;\n        const step = dir * (lineSize / (options.max - options.min));\n        const slotBox = new core_box(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);\n\n        let start = a;\n        let end = b;\n\n        if (!defined(start)) {\n            start = end || 0;\n        }\n\n        if (!defined(end)) {\n            end = start || 0;\n        }\n\n        if (limit) {\n            start = Math.max(Math.min(start, options.max), options.min);\n            end = Math.max(Math.min(end, options.max), options.min);\n        }\n\n        let p1, p2;\n\n        if (vertical) {\n            p1 = options.max - Math.max(start, end);\n            p2 = options.max - Math.min(start, end);\n        } else {\n            p1 = Math.min(start, end) - options.min;\n            p2 = Math.max(start, end) - options.min;\n        }\n\n        slotBox[valueAxis + 1] = limitCoordinate(lineStart + step * (reverse ? p2 : p1));\n        slotBox[valueAxis + 2] = limitCoordinate(lineStart + step * (reverse ? p1 : p2));\n\n        return slotBox;\n    }\n\n    getValue(point) {\n        const options = this.options;\n        const { vertical, reverse } = options;\n        const max = Number(options.max);\n        const min = Number(options.min);\n        const valueAxis = vertical ? Y : X;\n        const lineBox = this.lineBox();\n        const lineStart = lineBox[valueAxis + (reverse ? 2 : 1)];\n        const lineSize = vertical ? lineBox.height() : lineBox.width();\n        const dir = reverse ? -1 : 1;\n        const offset = dir * (point[valueAxis] - lineStart);\n        const step = (max - min) / lineSize;\n        const valueOffset = offset * step;\n\n        if (offset < 0 || offset > lineSize) {\n            return null;\n        }\n\n        const value = vertical ?\n                max - valueOffset :\n                min + valueOffset;\n\n        return round(value, DEFAULT_PRECISION);\n    }\n\n    translateRange(delta) {\n        const options = this.options;\n        const { vertical, reverse, max, min } = options;\n        const lineBox = this.lineBox();\n        const size = vertical ? lineBox.height() : lineBox.width();\n        const range = max - min;\n        const scale = size / range;\n        let offset = round(delta / scale, DEFAULT_PRECISION);\n\n        if ((vertical || reverse) && !(vertical && reverse )) {\n            offset = -offset;\n        }\n\n        return {\n            min: min + offset,\n            max: max + offset,\n            offset: offset\n        };\n    }\n\n    scaleRange(delta) {\n        const options = this.options;\n        const offset = -delta * options.majorUnit;\n\n        return {\n            min: options.min - offset,\n            max: options.max + offset\n        };\n    }\n\n    labelsCount() {\n        return this.getDivisions(this.options.majorUnit);\n    }\n\n    createAxisLabel(index, labelOptions, labelContext) {\n        const options = this.options;\n        const value = round(options.min + (index * options.majorUnit), DEFAULT_PRECISION);\n        const text = this.axisLabelText(value, labelOptions, labelContext);\n\n        return new axis_label(value, text, index, null, labelOptions);\n    }\n\n    shouldRenderNote(value) {\n        const range = this.range();\n        return range.min <= value && value <= range.max;\n    }\n\n    pan(delta) {\n        const range = this.translateRange(delta);\n        return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);\n    }\n\n    pointsRange(start, end) {\n        const startValue = this.getValue(start);\n        const endValue = this.getValue(end);\n        const min = Math.min(startValue, endValue);\n        const max = Math.max(startValue, endValue);\n\n        if (this.isValidRange(min, max)) {\n            return {\n                min: min,\n                max: max\n            };\n        }\n    }\n\n    zoomRange(delta) {\n        const { totalMin, totalMax } = this;\n        const newRange = this.scaleRange(delta);\n        const min = limitValue(newRange.min, totalMin, totalMax);\n        const max = limitValue(newRange.max, totalMin, totalMax);\n\n        if (this.isValidRange(min, max)) {\n            return {\n                min: min,\n                max: max\n            };\n        }\n    }\n\n    isValidRange(min, max) {\n        return max - min > MIN_VALUE_RANGE;\n    }\n}\n\nfunction autoAxisOptions(seriesMin, seriesMax, options) {\n    const narrowRange = options.narrowRange;\n\n    let autoMin = autoAxisMin(seriesMin, seriesMax, narrowRange);\n    let autoMax = autoAxisMax(seriesMin, seriesMax, narrowRange);\n\n    const majorUnit = autoMajorUnit(autoMin, autoMax);\n    const autoOptions = {\n        majorUnit: majorUnit\n    };\n\n    if (options.roundToMajorUnit !== false) {\n        if (autoMin < 0 && remainderClose(autoMin, majorUnit, 1 / 3)) {\n            autoMin -= majorUnit;\n        }\n\n        if (autoMax > 0 && remainderClose(autoMax, majorUnit, 1 / 3)) {\n            autoMax += majorUnit;\n        }\n    }\n\n    autoOptions.min = floor(autoMin, majorUnit);\n    autoOptions.max = ceil(autoMax, majorUnit);\n\n    return autoOptions;\n}\n\nfunction totalAxisOptions(autoOptions, options) {\n    return {\n        min: defined(options.min) ? Math.min(autoOptions.min, options.min) : autoOptions.min,\n        max: defined(options.max) ? Math.max(autoOptions.max, options.max) : autoOptions.max,\n        majorUnit: autoOptions.majorUnit\n    };\n}\n\nfunction clearNullValues(options, fields) {\n    for (let idx = 0; idx < fields.length; idx++) {\n        const field = fields[idx];\n        if (options[field] === null) {\n            options[field] = undefined;\n        }\n    }\n}\n\nfunction numeric_axis_axisOptions(autoOptions, userOptions) {\n    let options = userOptions;\n    let userSetMin, userSetMax;\n\n    if (userOptions) {\n        clearNullValues(userOptions, [ 'min', 'max' ]);\n\n        userSetMin = defined(userOptions.min);\n        userSetMax = defined(userOptions.max);\n\n        const userSetLimits = userSetMin || userSetMax;\n\n        if (userSetLimits) {\n            if (userOptions.min === userOptions.max) {\n                if (userOptions.min > 0) {\n                    userOptions.min = 0;\n                } else {\n                    userOptions.max = 1;\n                }\n            }\n        }\n\n        if (userOptions.majorUnit) {\n            autoOptions.min = floor(autoOptions.min, userOptions.majorUnit);\n            autoOptions.max = ceil(autoOptions.max, userOptions.majorUnit);\n        } else if (userSetLimits) {\n            options = deepExtend(autoOptions, userOptions);\n\n            // Determine an auto major unit after min/max have been set\n            autoOptions.majorUnit = autoMajorUnit(options.min, options.max);\n        }\n    }\n\n    autoOptions.minorUnit = (options.majorUnit || autoOptions.majorUnit) / 5;\n\n    const result = deepExtend(autoOptions, options);\n    if (result.min >= result.max) {\n        if (userSetMin && !userSetMax) {\n            result.max = result.min + result.majorUnit;\n        } else if (!userSetMin && userSetMax) {\n            result.min = result.max - result.majorUnit;\n        }\n    }\n\n    return result;\n}\n\nfunction remainderClose(value, divisor, ratio) {\n    const remainder = round(Math.abs(value % divisor), DEFAULT_PRECISION);\n    const threshold = divisor * (1 - ratio);\n\n    return remainder === 0 || remainder > threshold;\n}\n\nsetDefaultOptions(numeric_axis_NumericAxis, {\n    type: \"numeric\",\n    min: 0,\n    max: 1,\n    vertical: true,\n    majorGridLines: {\n        visible: true,\n        width: 1,\n        color: BLACK\n    },\n    labels: {\n        format: \"#.####################\"\n    },\n    zIndex: 1\n});\n\n/* harmony default export */ var numeric_axis = (numeric_axis_NumericAxis);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/date-value-axis.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass date_value_axis_DateValueAxis extends core_axis {\n    constructor(seriesMin, seriesMax, axisOptions, chartService) {\n        const min = toDate(seriesMin);\n        const max = toDate(seriesMax);\n\n        const intlService = chartService.intl;\n        let options = axisOptions || {};\n        options = deepExtend(options || {}, {\n            min: parse_date_parseDate(intlService, options.min),\n            max: parse_date_parseDate(intlService, options.max),\n            axisCrossingValue: parseDates(intlService, options.axisCrossingValues || options.axisCrossingValue),\n            weekStartDay: first_day_firstDay(options, intlService)\n        });\n        options = applyDefaults(min, max, options);\n\n        super(options, chartService);\n\n        this.intlService = intlService;\n        this.seriesMin = min;\n        this.seriesMax = max;\n\n        const weekStartDay = options.weekStartDay || 0;\n        this.totalMin = toTime(floorDate(toTime(min) - 1, options.baseUnit, weekStartDay));\n        this.totalMax = toTime(ceilDate(toTime(max) + 1, options.baseUnit, weekStartDay));\n    }\n\n    clone() {\n        return new date_value_axis_DateValueAxis(this.seriesMin, this.seriesMax, Object.assign({}, this.options), this.chartService);\n    }\n\n    range() {\n        const options = this.options;\n        return { min: options.min, max: options.max };\n    }\n\n    getDivisions(stepValue) {\n        const options = this.options;\n\n        return Math.floor(\n            duration_duration(options.min, options.max, options.baseUnit) / stepValue + 1\n        );\n    }\n\n    getTickPositions(step) {\n        const options = this.options;\n        const vertical = options.vertical;\n        const lineBox = this.lineBox();\n        const dir = (vertical ? -1 : 1) * (options.reverse ? -1 : 1);\n        const startEdge = dir === 1 ? 1 : 2;\n        const start = lineBox[(vertical ? Y : X) + startEdge];\n        const divisions = this.getDivisions(step);\n        const timeRange = dateDiff(options.max, options.min);\n        const lineSize = vertical ? lineBox.height() : lineBox.width();\n        const scale = lineSize / timeRange;\n        const weekStartDay = options.weekStartDay || 0;\n\n        const positions = [ start ];\n        for (let i = 1; i < divisions; i++) {\n            const date = addDuration(options.min, i * step, options.baseUnit, weekStartDay);\n            const pos = start + dateDiff(date, options.min) * scale * dir;\n\n            positions.push(round(pos, COORD_PRECISION));\n        }\n\n        return positions;\n    }\n\n    getMajorTickPositions() {\n        return this.getTickPositions(this.options.majorUnit);\n    }\n\n    getMinorTickPositions() {\n        return this.getTickPositions(this.options.minorUnit);\n    }\n\n    getSlot(a, b, limit) {\n        return numeric_axis.prototype.getSlot.call(\n            this, parse_date_parseDate(this.intlService, a), parse_date_parseDate(this.intlService, b), limit\n        );\n    }\n\n    getValue(point) {\n        const value = numeric_axis.prototype.getValue.call(this, point);\n\n        return value !== null ? toDate(value) : null;\n    }\n\n    labelsCount() {\n        return this.getDivisions(this.options.majorUnit);\n    }\n\n    createAxisLabel(index, labelOptions, labelContext) {\n        const options = this.options;\n        const offset = index * options.majorUnit;\n        const weekStartDay = options.weekStartDay || 0;\n        let date = options.min;\n\n        if (offset > 0) {\n            date = addDuration(date, offset, options.baseUnit, weekStartDay);\n        }\n\n        const unitFormat = labelOptions.dateFormats[options.baseUnit];\n        labelOptions.format = labelOptions.format || unitFormat;\n\n        const text = this.axisLabelText(date, labelOptions, labelContext);\n        return new axis_label(date, text, index, null, labelOptions);\n    }\n\n    translateRange(delta, exact) {\n        const options = this.options;\n        const baseUnit = options.baseUnit;\n        const weekStartDay = options.weekStartDay || 0;\n        const lineBox = this.lineBox();\n        const size = options.vertical ? lineBox.height() : lineBox.width();\n        const range = this.range();\n        const scale = size / dateDiff(range.max, range.min);\n        const offset = round(delta / scale, DEFAULT_PRECISION) * (options.reverse ? -1 : 1);\n        let from = addTicks(options.min, offset);\n        let to = addTicks(options.max, offset);\n\n        if (!exact) {\n            from = addDuration(from, 0, baseUnit, weekStartDay);\n            to = addDuration(to, 0, baseUnit, weekStartDay);\n        }\n\n        return {\n            min: from,\n            max: to,\n            offset: offset\n        };\n    }\n\n    scaleRange(delta) {\n        let { min: from, max: to } = this.options;\n        let rounds = Math.abs(delta);\n\n        while (rounds--) {\n            const range = dateDiff(from, to);\n            const step = Math.round(range * 0.1);\n            if (delta < 0) {\n                from = addTicks(from, step);\n                to = addTicks(to, -step);\n            } else {\n                from = addTicks(from, -step);\n                to = addTicks(to, step);\n            }\n        }\n\n        return { min: from, max: to };\n    }\n\n    shouldRenderNote(value) {\n        const range = this.range();\n\n        return dateComparer(value, range.min) >= 0 && dateComparer(value, range.max) <= 0;\n    }\n\n    pan(delta) {\n        const range = this.translateRange(delta, true);\n        const limittedRange = this.limitRange(toTime(range.min), toTime(range.max), this.totalMin, this.totalMax, range.offset);\n\n        if (limittedRange) {\n            return {\n                min: toDate(limittedRange.min),\n                max: toDate(limittedRange.max)\n            };\n        }\n    }\n\n    pointsRange(start, end) {\n        const startValue = this.getValue(start);\n        const endValue = this.getValue(end);\n        const min = Math.min(startValue, endValue);\n        const max = Math.max(startValue, endValue);\n\n        return {\n            min: toDate(min),\n            max: toDate(max)\n        };\n    }\n\n    zoomRange(delta) {\n        const range = this.scaleRange(delta);\n        const min = toDate(limitValue(toTime(range.min), this.totalMin, this.totalMax));\n        const max = toDate(limitValue(toTime(range.max), this.totalMin, this.totalMax));\n\n        return {\n            min: min,\n            max: max\n        };\n    }\n}\n\nfunction timeUnits(delta) {\n    let unit = HOURS;\n\n    if (delta >= TIME_PER_YEAR) {\n        unit = YEARS;\n    } else if (delta >= TIME_PER_MONTH) {\n        unit = MONTHS;\n    } else if (delta >= TIME_PER_WEEK) {\n        unit = WEEKS;\n    } else if (delta >= TIME_PER_DAY) {\n        unit = DAYS;\n    }\n\n    return unit;\n}\n\nfunction applyDefaults(seriesMin, seriesMax, options) {\n    const min = options.min || seriesMin;\n    const max = options.max || seriesMax;\n    const baseUnit = options.baseUnit || (max && min ? timeUnits(absoluteDateDiff(max, min)) : HOURS);\n    const baseUnitTime = TIME_PER_UNIT[baseUnit];\n    const weekStartDay = options.weekStartDay || 0;\n    const autoMin = floorDate(toTime(min) - 1, baseUnit, weekStartDay) || toDate(max);\n    const autoMax = ceilDate(toTime(max) + 1, baseUnit, weekStartDay);\n    const userMajorUnit = options.majorUnit ? options.majorUnit : undefined;\n    const majorUnit = userMajorUnit || ceil(\n                        autoMajorUnit(autoMin.getTime(), autoMax.getTime()),\n                        baseUnitTime\n                    ) / baseUnitTime;\n    const actualUnits = duration_duration(autoMin, autoMax, baseUnit);\n    const totalUnits = ceil(actualUnits, majorUnit);\n    const unitsToAdd = totalUnits - actualUnits;\n    const head = Math.floor(unitsToAdd / 2);\n    const tail = unitsToAdd - head;\n\n    if (!options.baseUnit) {\n        delete options.baseUnit;\n    }\n\n    options.baseUnit = options.baseUnit || baseUnit;\n    options.min = options.min || addDuration(autoMin, -head, baseUnit, weekStartDay);\n    options.max = options.max || addDuration(autoMax, tail, baseUnit, weekStartDay);\n    options.minorUnit = options.minorUnit || majorUnit / 5;\n    options.majorUnit = majorUnit;\n\n    return options;\n}\n\nsetDefaultOptions(date_value_axis_DateValueAxis, {\n    type: DATE,\n    majorGridLines: {\n        visible: true,\n        width: 1,\n        color: BLACK\n    },\n    labels: {\n        dateFormats: DateLabelFormats\n    }\n});\n\n/* harmony default export */ var date_value_axis = (date_value_axis_DateValueAxis);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/logarithmic-axis.js\n\n\n\n\n\n\n\n\n\n\n\n\nconst DEFAULT_MAJOR_UNIT = 10;\n\nclass logarithmic_axis_LogarithmicAxis extends core_axis {\n    constructor(seriesMin, seriesMax, options, chartService) {\n\n        const axisOptions = deepExtend({ majorUnit: DEFAULT_MAJOR_UNIT, min: seriesMin, max: seriesMax }, options);\n        const base = axisOptions.majorUnit;\n        const autoMax = logarithmic_axis_autoAxisMax(seriesMax, base);\n        const autoMin = logarithmic_axis_autoAxisMin(seriesMin, seriesMax, axisOptions);\n        const range = initRange(autoMin, autoMax, axisOptions, options);\n\n        axisOptions.max = range.max;\n        axisOptions.min = range.min;\n        axisOptions.minorUnit = options.minorUnit || round(base - 1, DEFAULT_PRECISION);\n\n        super(axisOptions, chartService);\n\n        this.totalMin = defined(options.min) ? Math.min(autoMin, options.min) : autoMin;\n        this.totalMax = defined(options.max) ? Math.max(autoMax, options.max) : autoMax;\n        this.logMin = round(log(range.min, base), DEFAULT_PRECISION);\n        this.logMax = round(log(range.max, base), DEFAULT_PRECISION);\n        this.seriesMin = seriesMin;\n        this.seriesMax = seriesMax;\n\n        this.createLabels();\n    }\n\n    clone() {\n        return new logarithmic_axis_LogarithmicAxis(\n            this.seriesMin,\n            this.seriesMax,\n            Object.assign({}, this.options),\n            this.chartService\n        );\n    }\n\n    startValue() {\n        return this.options.min;\n    }\n\n    getSlot(a, b, limit) {\n        const { options, logMin, logMax } = this;\n        const { reverse, vertical, majorUnit: base } = options;\n        const valueAxis = vertical ? Y : X;\n        const lineBox = this.lineBox();\n        const lineStart = lineBox[valueAxis + (reverse ? 2 : 1)];\n        const lineSize = vertical ? lineBox.height() : lineBox.width();\n        const dir = reverse ? -1 : 1;\n        const step = dir * (lineSize / (logMax - logMin));\n        const slotBox = new core_box(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);\n        let start = a;\n        let end = b;\n\n        if (!defined(start)) {\n            start = end || 1;\n        }\n\n        if (!defined(end)) {\n            end = start || 1;\n        }\n\n        if (start <= 0 || end <= 0) {\n            return null;\n        }\n\n        if (limit) {\n            start = Math.max(Math.min(start, options.max), options.min);\n            end = Math.max(Math.min(end, options.max), options.min);\n        }\n\n        start = log(start, base);\n        end = log(end, base);\n\n        let p1, p2;\n\n        if (vertical) {\n            p1 = logMax - Math.max(start, end);\n            p2 = logMax - Math.min(start, end);\n        } else {\n            p1 = Math.min(start, end) - logMin;\n            p2 = Math.max(start, end) - logMin;\n        }\n\n        slotBox[valueAxis + 1] = limitCoordinate(lineStart + step * (reverse ? p2 : p1));\n        slotBox[valueAxis + 2] = limitCoordinate(lineStart + step * (reverse ? p1 : p2));\n\n        return slotBox;\n    }\n\n    getValue(point) {\n        const { options, logMin, logMax } = this;\n        const { reverse, vertical, majorUnit: base } = options;\n        const lineBox = this.lineBox();\n        const dir = vertical === reverse ? 1 : -1;\n        const startEdge = dir === 1 ? 1 : 2;\n        const lineSize = vertical ? lineBox.height() : lineBox.width();\n        const step = ((logMax - logMin) / lineSize);\n        const valueAxis = vertical ? Y : X;\n        const lineStart = lineBox[valueAxis + startEdge];\n        const offset = dir * (point[valueAxis] - lineStart);\n        const valueOffset = offset * step;\n\n        if (offset < 0 || offset > lineSize) {\n            return null;\n        }\n\n        const value = logMin + valueOffset;\n\n        return round(Math.pow(base, value), DEFAULT_PRECISION);\n    }\n\n    range() {\n        const options = this.options;\n        return { min: options.min, max: options.max };\n    }\n\n    scaleRange(delta) {\n        const base = this.options.majorUnit;\n        const offset = -delta;\n\n        return {\n            min: Math.pow(base, this.logMin - offset),\n            max: Math.pow(base, this.logMax + offset)\n        };\n    }\n\n    translateRange(delta) {\n        const { options, logMin, logMax } = this;\n        const { reverse, vertical, majorUnit: base } = options;\n        const lineBox = this.lineBox();\n        const size = vertical ? lineBox.height() : lineBox.width();\n        const scale = size / (logMax - logMin);\n        let offset = round(delta / scale, DEFAULT_PRECISION);\n\n        if ((vertical || reverse) && !(vertical && reverse )) {\n            offset = -offset;\n        }\n\n        return {\n            min: Math.pow(base, logMin + offset),\n            max: Math.pow(base, logMax + offset),\n            offset: offset\n        };\n    }\n\n    labelsCount() {\n        const floorMax = Math.floor(this.logMax);\n        const count = Math.floor(floorMax - this.logMin) + 1;\n\n        return count;\n    }\n\n    getMajorTickPositions() {\n        const ticks = [];\n\n        this.traverseMajorTicksPositions((position) => {\n            ticks.push(position);\n        }, { step: 1, skip: 0 });\n\n        return ticks;\n    }\n\n    createTicks(lineGroup) {\n        const options = this.options;\n        const { majorTicks, minorTicks, vertical } = options;\n        const mirror = options.labels.mirror;\n        const lineBox = this.lineBox();\n        const ticks = [];\n        const tickLineOptions = {\n            // TODO\n            // _alignLines: options._alignLines,\n            vertical: vertical\n        };\n\n        function render(tickPosition, tickOptions) {\n            tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n            tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n            tickLineOptions.position = tickPosition;\n\n            lineGroup.append(createAxisTick(tickLineOptions, tickOptions));\n        }\n\n        if (majorTicks.visible) {\n            this.traverseMajorTicksPositions(render, majorTicks);\n        }\n\n        if (minorTicks.visible) {\n            this.traverseMinorTicksPositions(render, minorTicks);\n        }\n\n        return ticks;\n    }\n\n    createGridLines(altAxis) {\n        const options = this.options;\n        const { minorGridLines, majorGridLines, vertical } = options;\n        const lineBox = altAxis.lineBox();\n        const lineOptions = {\n            lineStart: lineBox[vertical ? \"x1\" : \"y1\"],\n            lineEnd: lineBox[vertical ? \"x2\" : \"y2\"],\n            vertical: vertical\n        };\n        const majorTicks = [];\n\n        const container = this.gridLinesVisual();\n        function render(tickPosition, gridLine) {\n            if (!inArray(tickPosition, majorTicks)) {\n                lineOptions.position = tickPosition;\n                container.append(createAxisGridLine(lineOptions, gridLine));\n\n                majorTicks.push(tickPosition);\n            }\n        }\n\n        if (majorGridLines.visible) {\n            this.traverseMajorTicksPositions(render, majorGridLines);\n        }\n\n        if (minorGridLines.visible) {\n            this.traverseMinorTicksPositions(render, minorGridLines);\n        }\n\n        return container.children;\n    }\n\n    traverseMajorTicksPositions(callback, tickOptions) {\n        const { lineStart, step } = this._lineOptions();\n        const { logMin, logMax } = this;\n\n        for (let power = Math.ceil(logMin) + tickOptions.skip; power <= logMax; power += tickOptions.step) {\n            let position = round(lineStart + step * (power - logMin), DEFAULT_PRECISION);\n            callback(position, tickOptions);\n        }\n    }\n\n    traverseMinorTicksPositions(callback, tickOptions) {\n        const { min, max, minorUnit, majorUnit: base } = this.options;\n        const { lineStart, step } = this._lineOptions();\n        const { logMin, logMax } = this;\n        const start = Math.floor(logMin);\n\n        for (let power = start; power < logMax; power++) {\n            const minorOptions = this._minorIntervalOptions(power);\n            for (let idx = tickOptions.skip; idx < minorUnit; idx += tickOptions.step) {\n                const value = minorOptions.value + idx * minorOptions.minorStep;\n                if (value > max) {\n                    break;\n                }\n                if (value >= min) {\n                    const position = round(lineStart + step * (log(value, base) - logMin), DEFAULT_PRECISION);\n                    callback(position, tickOptions);\n                }\n            }\n        }\n    }\n\n    createAxisLabel(index, labelOptions, labelContext) {\n        const power = Math.ceil(this.logMin + index);\n        const value = Math.pow(this.options.majorUnit, power);\n        const text = this.axisLabelText(value, labelOptions, labelContext);\n\n        return new axis_label(value, text, index, null, labelOptions);\n    }\n\n    shouldRenderNote(value) {\n        const range = this.range();\n        return range.min <= value && value <= range.max;\n    }\n\n    pan(delta) {\n        const range = this.translateRange(delta);\n        return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);\n    }\n\n    pointsRange(start, end) {\n        const startValue = this.getValue(start);\n        const endValue = this.getValue(end);\n        const min = Math.min(startValue, endValue);\n        const max = Math.max(startValue, endValue);\n\n        return {\n            min: min,\n            max: max\n        };\n    }\n\n    zoomRange(delta) {\n        const { options, totalMin, totalMax } = this;\n        const newRange = this.scaleRange(delta);\n        const min = limitValue(newRange.min, totalMin, totalMax);\n        const max = limitValue(newRange.max, totalMin, totalMax);\n        const base = options.majorUnit;\n        const acceptOptionsRange = max > min && options.min && options.max && (round(log(options.max, base) - log(options.min, base), DEFAULT_PRECISION) < 1);\n        const acceptNewRange = !(options.min === totalMin && options.max === totalMax) && round(log(max, base) - log(min, base), DEFAULT_PRECISION) >= 1;\n\n        if (acceptOptionsRange || acceptNewRange) {\n            return {\n                min: min,\n                max: max\n            };\n        }\n    }\n\n    _minorIntervalOptions(power) {\n        const { minorUnit, majorUnit: base } = this.options;\n        const value = Math.pow(base, power);\n        const nextValue = Math.pow(base, power + 1);\n        const difference = nextValue - value;\n        const minorStep = difference / minorUnit;\n\n        return {\n            value: value,\n            minorStep: minorStep\n        };\n    }\n\n    _lineOptions() {\n        const { reverse, vertical } = this.options;\n        const valueAxis = vertical ? Y : X;\n        const lineBox = this.lineBox();\n        const dir = vertical === reverse ? 1 : -1;\n        const startEdge = dir === 1 ? 1 : 2;\n        const lineSize = vertical ? lineBox.height() : lineBox.width();\n        const step = dir * (lineSize / (this.logMax - this.logMin));\n        const lineStart = lineBox[valueAxis + startEdge];\n\n        return {\n            step: step,\n            lineStart: lineStart,\n            lineBox: lineBox\n        };\n    }\n}\n\nfunction initRange(autoMin, autoMax, axisOptions, options) {\n    let { min, max } = axisOptions;\n\n    if (defined(axisOptions.axisCrossingValue) && axisOptions.axisCrossingValue <= 0) {\n        throwNegativeValuesError();\n    }\n\n    if (!defined(options.max)) {\n        max = autoMax;\n    } else if (options.max <= 0) {\n        throwNegativeValuesError();\n    }\n\n    if (!defined(options.min)) {\n        min = autoMin;\n    } else if (options.min <= 0) {\n        throwNegativeValuesError();\n    }\n\n    return {\n        min: min,\n        max: max\n    };\n}\n\nfunction logarithmic_axis_autoAxisMin(min, max, options) {\n    const base = options.majorUnit;\n    let autoMin = min;\n    if (min <= 0) {\n        autoMin = max <= 1 ? Math.pow(base, -2) : 1;\n    } else if (!options.narrowRange) {\n        autoMin = Math.pow(base, Math.floor(log(min, base)));\n    }\n    return autoMin;\n}\n\nfunction logarithmic_axis_autoAxisMax(max, base) {\n    const logMaxRemainder = round(log(max, base), DEFAULT_PRECISION) % 1;\n    let autoMax;\n    if (max <= 0) {\n        autoMax = base;\n    } else if (logMaxRemainder !== 0 && (logMaxRemainder < 0.3 || logMaxRemainder > 0.9)) {\n        autoMax = Math.pow(base, log(max, base) + 0.2);\n    } else {\n        autoMax = Math.pow(base, Math.ceil(log(max, base)));\n    }\n\n    return autoMax;\n}\n\nfunction throwNegativeValuesError() {\n    throw new Error(\"Non positive values cannot be used for a logarithmic axis\");\n}\n\nfunction log(y, x) {\n    return Math.log(y) / Math.log(x);\n}\n\nsetDefaultOptions(logarithmic_axis_LogarithmicAxis, {\n    type: \"log\",\n    majorUnit: DEFAULT_MAJOR_UNIT,\n    minorUnit: 1,\n    axisCrossingValue: 1,\n    vertical: true,\n    majorGridLines: {\n        visible: true,\n        width: 1,\n        color: BLACK\n    },\n    zIndex: 1,\n    _deferLabels: true\n});\n\n/* harmony default export */ var logarithmic_axis = (logarithmic_axis_LogarithmicAxis);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/mixins/grid-lines-mixin.js\n\n\n\n\nconst GridLinesMixin = {\n    createGridLines: function(altAxis) {\n        const options = this.options;\n        const radius = Math.abs(this.box.center().y - altAxis.lineBox().y1);\n        let gridLines = [];\n        let skipMajor = false;\n        let majorAngles, minorAngles;\n\n        if (options.majorGridLines.visible) {\n            majorAngles = this.majorGridLineAngles(altAxis);\n            skipMajor = true;\n\n            gridLines = this.renderMajorGridLines(\n                majorAngles, radius, options.majorGridLines\n            );\n        }\n\n        if (options.minorGridLines.visible) {\n            minorAngles = this.minorGridLineAngles(altAxis, skipMajor);\n\n            append(gridLines, this.renderMinorGridLines(\n                minorAngles, radius, options.minorGridLines, altAxis, skipMajor\n            ));\n        }\n\n        return gridLines;\n    },\n\n    renderMajorGridLines: function(angles, radius, options) {\n        return this.renderGridLines(angles, radius, options);\n    },\n\n    renderMinorGridLines: function(angles, radius, options, altAxis, skipMajor) {\n        const radiusCallback = this.radiusCallback && this.radiusCallback(radius, altAxis, skipMajor);\n        return this.renderGridLines(angles, radius, options, radiusCallback);\n    },\n\n    renderGridLines: function(angles, radius, options, radiusCallback) {\n        const style = {\n            stroke: {\n                width: options.width,\n                color: options.color,\n                dashType: options.dashType\n            }\n        };\n\n        const center = this.box.center();\n        const circle = new main[\"b\" /* geometry */].Circle([ center.x, center.y ], radius);\n        const container = this.gridLinesVisual();\n\n        for (let i = 0; i < angles.length; i++) {\n            const line = new main[\"a\" /* drawing */].Path(style);\n            if (radiusCallback) {\n                circle.radius = radiusCallback(angles[i]);\n            }\n\n            line.moveTo(circle.center)\n                .lineTo(circle.pointAt(angles[i] + 180));\n\n            container.append(line);\n        }\n\n        return container.children;\n    },\n\n    gridLineAngles: function(altAxis, size, skip, step, skipAngles) {\n        const divs = this.intervals(size, skip, step, skipAngles);\n        const options = altAxis.options;\n        const altAxisVisible = options.visible && (options.line || {}).visible !== false;\n\n        return map_map(divs, (d) => {\n            const alpha = this.intervalAngle(d);\n\n            if (!altAxisVisible || alpha !== 90) {\n                return alpha;\n            }\n        });\n    }\n};\n\n/* harmony default export */ var grid_lines_mixin = (GridLinesMixin);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/radar-category-axis.js\n\n\n\n\n\n\n\n\n\n\n\nclass radar_category_axis_RadarCategoryAxis extends category_axis {\n    range() {\n        return { min: 0, max: this.options.categories.length };\n    }\n\n    reflow(box) {\n        this.box = box;\n        this.reflowLabels();\n    }\n\n    lineBox() {\n        return this.box;\n    }\n\n    reflowLabels() {\n        const { labels, options: { labels: labelOptions } } = this;\n        const skip = labelOptions.skip || 0;\n        const step = labelOptions.step || 1;\n        const measureBox = new core_box();\n\n        for (let i = 0; i < labels.length; i++) {\n            labels[i].reflow(measureBox);\n            const labelBox = labels[i].box;\n\n            labels[i].reflow(this.getSlot(skip + i * step).adjacentBox(\n                0, labelBox.width(), labelBox.height()\n            ));\n        }\n    }\n\n    intervals(size, skipOption, stepOption, skipAngles = false) {\n        const options = this.options;\n        const categories = options.categories.length;\n        const divCount = categories / size || 1;\n        const divAngle = 360 / divCount;\n        const skip = skipOption || 0;\n        const step = stepOption || 1;\n        const divs = [];\n        let angle = 0;\n\n        for (let i = skip; i < divCount; i += step) {\n            if (options.reverse) {\n                angle = 360 - i * divAngle;\n            } else {\n                angle = i * divAngle;\n            }\n\n            angle = round(angle, COORD_PRECISION) % 360;\n\n            if (!(skipAngles && inArray(angle, skipAngles))) {\n                divs.push(angle);\n            }\n        }\n\n        return divs;\n    }\n\n    majorIntervals() {\n        return this.intervals(1);\n    }\n\n    minorIntervals() {\n        return this.intervals(0.5);\n    }\n\n    intervalAngle(interval) {\n        return (360 + interval + this.options.startAngle) % 360;\n    }\n\n    majorAngles() {\n        return map_map(this.majorIntervals(), (interval) => this.intervalAngle(interval));\n    }\n\n    createLine() {\n        return [];\n    }\n\n    majorGridLineAngles(altAxis) {\n        const majorGridLines = this.options.majorGridLines;\n        return this.gridLineAngles(altAxis, 1, majorGridLines.skip, majorGridLines.step);\n    }\n\n    minorGridLineAngles(altAxis, skipMajor) {\n        const { minorGridLines, majorGridLines } = this.options;\n        const majorGridLineAngles = skipMajor ? this.intervals(1, majorGridLines.skip, majorGridLines.step) : null;\n\n        return this.gridLineAngles(altAxis, 0.5, minorGridLines.skip, minorGridLines.step, majorGridLineAngles);\n    }\n\n    radiusCallback(radius, altAxis, skipMajor) {\n        if (altAxis.options.type !== ARC) {\n            const minorAngle = rad(360 / (this.options.categories.length * 2));\n            const minorRadius = Math.cos(minorAngle) * radius;\n            const majorAngles = this.majorAngles();\n\n            const radiusCallback = function(angle) {\n                if (!skipMajor && inArray(angle, majorAngles)) {\n                    return radius;\n                }\n\n                return minorRadius;\n            };\n            return radiusCallback;\n        }\n    }\n\n    createPlotBands() {\n        const plotBands = this.options.plotBands || [];\n\n        const group = this._plotbandGroup = new main[\"a\" /* drawing */].Group({\n            zIndex: -1\n        });\n\n        for (let i = 0; i < plotBands.length; i++) {\n            const band = plotBands[i];\n            const slot = this.plotBandSlot(band);\n            const singleSlot = this.getSlot(band.from);\n\n            const head = band.from - Math.floor(band.from);\n            slot.startAngle += head * singleSlot.angle;\n\n            const tail = Math.ceil(band.to) - band.to;\n            slot.angle -= (tail + head) * singleSlot.angle;\n\n            const ring = shape_builder.current.createRing(slot, {\n                fill: {\n                    color: band.color,\n                    opacity: band.opacity\n                },\n                stroke: {\n                    opacity: band.opacity\n                }\n            });\n            group.append(ring);\n        }\n\n        this.appendVisual(group);\n    }\n\n    plotBandSlot(band) {\n        return this.getSlot(band.from, band.to - 1);\n    }\n\n    getSlot(from, to) {\n        const options = this.options;\n        const justified = options.justified;\n        const box = this.box;\n        const divs = this.majorAngles();\n        const totalDivs = divs.length;\n        const slotAngle = 360 / totalDivs;\n        let fromValue = from;\n\n        if (options.reverse && !justified) {\n            fromValue = (fromValue + 1) % totalDivs;\n        }\n\n        fromValue = limitValue(Math.floor(fromValue), 0, totalDivs - 1);\n        let slotStart = divs[fromValue];\n\n        if (justified) {\n            slotStart = slotStart - slotAngle / 2;\n\n            if (slotStart < 0) {\n                slotStart += 360;\n            }\n        }\n\n        const toValue = limitValue(Math.ceil(to || fromValue), fromValue, totalDivs - 1);\n        const slots = toValue - fromValue + 1;\n        const angle = slotAngle * slots;\n\n        return new core_ring(box.center(), 0, box.height() / 2, slotStart, angle);\n    }\n\n    slot(from, to) {\n        const slot = this.getSlot(from, to);\n        const startAngle = slot.startAngle + 180;\n        const endAngle = startAngle + slot.angle;\n\n        return new main[\"b\" /* geometry */].Arc([ slot.center.x, slot.center.y ], {\n            startAngle: startAngle,\n            endAngle: endAngle,\n            radiusX: slot.radius,\n            radiusY: slot.radius\n        });\n    }\n\n    pointCategoryIndex(point) {\n        const length = this.options.categories.length;\n        let index = null;\n\n        for (let i = 0; i < length; i++) {\n            const slot = this.getSlot(i);\n            if (slot.containsPoint(point)) {\n                index = i;\n                break;\n            }\n        }\n\n        return index;\n    }\n}\n\nsetDefaultOptions(radar_category_axis_RadarCategoryAxis, {\n    startAngle: 90,\n    labels: {\n        margin: getSpacing(10)\n    },\n    majorGridLines: {\n        visible: true\n    },\n    justified: true\n});\ndeepExtend(radar_category_axis_RadarCategoryAxis.prototype, grid_lines_mixin);\n\n/* harmony default export */ var radar_category_axis = (radar_category_axis_RadarCategoryAxis);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/polar-axis.js\n\n\n\n\n\n\n\n\n\n\n\n\nclass polar_axis_PolarAxis extends core_axis {\n    constructor(options, chartService) {\n        super(options, chartService);\n\n        const instanceOptions = this.options;\n\n        instanceOptions.minorUnit = instanceOptions.minorUnit || instanceOptions.majorUnit / 2;\n    }\n\n    getDivisions(stepValue) {\n        return numeric_axis.prototype.getDivisions.call(this, stepValue) - 1;\n    }\n\n    reflow(box) {\n        this.box = box;\n        this.reflowLabels();\n    }\n\n    reflowLabels() {\n        const { options, labels, options: { labels: labelOptions } } = this;\n        const skip = labelOptions.skip || 0;\n        const step = labelOptions.step || 1;\n\n        const measureBox = new core_box();\n        const divs = this.intervals(options.majorUnit, skip, step);\n\n        for (let i = 0; i < labels.length; i++) {\n            labels[i].reflow(measureBox);\n            const labelBox = labels[i].box;\n\n            labels[i].reflow(this.getSlot(divs[i]).adjacentBox(0, labelBox.width(), labelBox.height()));\n        }\n    }\n\n    lineBox() {\n        return this.box;\n    }\n\n    intervals(size, skipOption, stepOption, skipAngles = false) {\n        const min = this.options.min;\n        const divisions = this.getDivisions(size);\n        const divs = [];\n        const skip = skipOption || 0;\n        const step = stepOption || 1;\n\n        for (let i = skip; i < divisions; i += step) {\n            const current = (360 + min + i * size) % 360;\n            if (!(skipAngles && inArray(current, skipAngles))) {\n                divs.push(current);\n            }\n        }\n\n        return divs;\n    }\n\n    majorIntervals() {\n        return this.intervals(this.options.majorUnit);\n    }\n\n    minorIntervals() {\n        return this.intervals(this.options.minorUnit);\n    }\n\n    intervalAngle(i) {\n        return (540 - i - this.options.startAngle) % 360;\n    }\n\n    createLine() {\n        return [];\n    }\n\n    majorGridLineAngles(altAxis) {\n        const majorGridLines = this.options.majorGridLines;\n        return this.gridLineAngles(altAxis, this.options.majorUnit, majorGridLines.skip, majorGridLines.step);\n    }\n\n    minorGridLineAngles(altAxis, skipMajor) {\n        const options = this.options;\n        const { minorGridLines, majorGridLines } = options;\n        const majorGridLineAngles = skipMajor ? this.intervals(options.majorUnit, majorGridLines.skip, majorGridLines.step) : null;\n\n        return this.gridLineAngles(altAxis, options.minorUnit, minorGridLines.skip, minorGridLines.step, majorGridLineAngles);\n    }\n\n    plotBandSlot(band) {\n        return this.getSlot(band.from, band.to);\n    }\n\n    getSlot(a, b) {\n        const { options, box } = this;\n        const startAngle = options.startAngle;\n        let start = limitValue(a, options.min, options.max);\n        let end = limitValue(b || start, start, options.max);\n\n        if (options.reverse) {\n            start *= -1;\n            end *= -1;\n        }\n\n        start = (540 - start - startAngle) % 360;\n        end = (540 - end - startAngle) % 360;\n\n        if (end < start) {\n            const tmp = start;\n            start = end;\n            end = tmp;\n        }\n\n        return new core_ring(box.center(), 0, box.height() / 2, start, end - start);\n    }\n\n    slot(from, to = from) {\n        const options = this.options;\n        const start = 360 - options.startAngle;\n        const slot = this.getSlot(from, to);\n        const min = Math.min(from, to);\n        const max = Math.max(from, to);\n        let startAngle, endAngle;\n\n        if (options.reverse) {\n            startAngle = min;\n            endAngle = max;\n        } else {\n            startAngle = 360 - max;\n            endAngle = 360 - min;\n        }\n\n        startAngle = (startAngle + start) % 360;\n        endAngle = (endAngle + start) % 360;\n\n        return new main[\"b\" /* geometry */].Arc([ slot.center.x, slot.center.y ], {\n            startAngle: startAngle,\n            endAngle: endAngle,\n            radiusX: slot.radius,\n            radiusY: slot.radius\n        });\n    }\n\n    getValue(point) {\n        const options = this.options;\n        const center = this.box.center();\n        const dx = point.x - center.x;\n        const dy = point.y - center.y;\n        let theta = Math.round(deg(Math.atan2(dy, dx)));\n        let start = options.startAngle;\n\n        if (!options.reverse) {\n            theta *= -1;\n            start *= -1;\n        }\n\n        return (theta + start + 360) % 360;\n    }\n\n    valueRange() {\n        return {\n            min: 0,\n            max: Math.PI * 2\n        };\n    }\n}\n\nsetDefaultOptions(polar_axis_PolarAxis, {\n    type: \"polar\",\n    startAngle: 0,\n    reverse: false,\n    majorUnit: 60,\n    min: 0,\n    max: 360,\n    labels: {\n        margin: getSpacing(10)\n    },\n    majorGridLines: {\n        color: BLACK,\n        visible: true,\n        width: 1\n    },\n    minorGridLines: {\n        color: \"#aaa\"\n    }\n});\n\ndeepExtend(polar_axis_PolarAxis.prototype, grid_lines_mixin, {\n    createPlotBands: radar_category_axis.prototype.createPlotBands,\n    majorAngles: radar_category_axis.prototype.majorAngles,\n    range: numeric_axis.prototype.range,\n    labelsCount: numeric_axis.prototype.labelsCount,\n    createAxisLabel: numeric_axis.prototype.createAxisLabel\n});\n\n/* harmony default export */ var polar_axis = (polar_axis_PolarAxis);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/mixins/radar-numeric-axis-mixin.js\n\n\n\n\n\n\n\n\n\nconst RadarNumericAxisMixin = {\n    options: {\n        majorGridLines: {\n            visible: true\n        }\n    },\n\n    createPlotBands: function() {\n        const { majorGridLines: { type }, plotBands = [] } = this.options;\n        const altAxis = this.plotArea.polarAxis;\n        const majorAngles = altAxis.majorAngles();\n        const center = altAxis.box.center();\n        const group = this._plotbandGroup = new main[\"a\" /* drawing */].Group({\n            zIndex: -1\n        });\n\n        for (let i = 0; i < plotBands.length; i++) {\n            const band = plotBands[i];\n            const bandStyle = {\n                fill: {\n                    color: band.color,\n                    opacity: band.opacity\n                },\n                stroke: {\n                    opacity: band.opacity\n                }\n            };\n\n            const slot = this.getSlot(band.from, band.to, true);\n            const ring = new core_ring(center, center.y - slot.y2, center.y - slot.y1, 0, 360);\n\n            let shape;\n            if (type === ARC) {\n                shape = shape_builder.current.createRing(ring, bandStyle);\n            } else {\n                shape = main[\"a\" /* drawing */].Path.fromPoints(this.plotBandPoints(ring, majorAngles), bandStyle).close();\n            }\n\n            group.append(shape);\n        }\n\n        this.appendVisual(group);\n    },\n\n    plotBandPoints: function(ring, angles) {\n        const innerPoints = [];\n        const outerPoints = [];\n        const center = [ ring.center.x, ring.center.y ];\n        const innerCircle = new main[\"b\" /* geometry */].Circle(center, ring.innerRadius);\n        const outerCircle = new main[\"b\" /* geometry */].Circle(center, ring.radius);\n\n        for (let i = 0; i < angles.length; i++) {\n            innerPoints.push(innerCircle.pointAt(angles[i] + 180));\n            outerPoints.push(outerCircle.pointAt(angles[i] + 180));\n        }\n\n        innerPoints.reverse();\n        innerPoints.push(innerPoints[0]);\n        outerPoints.push(outerPoints[0]);\n\n        return outerPoints.concat(innerPoints);\n    },\n\n    createGridLines: function(altAxis) {\n        const options = this.options;\n        const majorTicks = this.radarMajorGridLinePositions();\n        const majorAngles = altAxis.majorAngles();\n        const center = altAxis.box.center();\n        let gridLines = [];\n\n        if (options.majorGridLines.visible) {\n            gridLines = this.renderGridLines(\n                center, majorTicks, majorAngles, options.majorGridLines\n            );\n        }\n\n        if (options.minorGridLines.visible) {\n            const minorTicks = this.radarMinorGridLinePositions();\n            append(gridLines, this.renderGridLines(\n                center, minorTicks, majorAngles, options.minorGridLines\n            ));\n        }\n\n        return gridLines;\n    },\n\n    renderGridLines: function(center, ticks, angles, options) {\n        const style = {\n            stroke: {\n                width: options.width,\n                color: options.color,\n                dashType: options.dashType\n            }\n        };\n        const { skip = 0, step = 0 } = options;\n        const container = this.gridLinesVisual();\n\n        for (let tickIx = skip; tickIx < ticks.length; tickIx += step) {\n            const tickRadius = center.y - ticks[tickIx];\n            if (tickRadius > 0) {\n                const circle = new main[\"b\" /* geometry */].Circle([ center.x, center.y ], tickRadius);\n                if (options.type === ARC) {\n                    container.append(new main[\"a\" /* drawing */].Circle(circle, style));\n                } else {\n                    const line = new main[\"a\" /* drawing */].Path(style);\n                    for (let angleIx = 0; angleIx < angles.length; angleIx++) {\n                        line.lineTo(circle.pointAt(angles[angleIx] + 180));\n                    }\n\n                    line.close();\n                    container.append(line);\n                }\n            }\n        }\n\n        return container.children;\n    },\n\n    getValue: function(point) {\n        const lineBox = this.lineBox();\n        const altAxis = this.plotArea.polarAxis;\n        const majorAngles = altAxis.majorAngles();\n        const center = altAxis.box.center();\n        const radius = point.distanceTo(center);\n        let distance = radius;\n\n        if (this.options.majorGridLines.type !== ARC && majorAngles.length > 1) {\n            const dx = point.x - center.x;\n            const dy = point.y - center.y;\n            const theta = (deg(Math.atan2(dy, dx)) + 540) % 360;\n\n            majorAngles.sort(function(a, b) {\n                return angularDistance(a, theta) - angularDistance(b, theta);\n            });\n\n            // Solve triangle (center, point, axis X) using one side (radius) and two angles.\n            // Angles are derived from triangle (center, point, gridline X)\n            const midAngle = angularDistance(majorAngles[0], majorAngles[1]) / 2;\n            const alpha = angularDistance(theta, majorAngles[0]);\n            const gamma = 90 - midAngle;\n            const beta = 180 - alpha - gamma;\n\n            distance = radius * (Math.sin(rad(beta)) / Math.sin(rad(gamma)));\n        }\n\n        return this.axisType().prototype.getValue.call(\n            this, new core_point(lineBox.x1, lineBox.y2 - distance)\n        );\n    }\n};\n\nfunction angularDistance(a, b) {\n    return 180 - Math.abs(Math.abs(a - b) - 180);\n}\n\n/* harmony default export */ var radar_numeric_axis_mixin = (RadarNumericAxisMixin);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/radar-numeric-axis.js\n\n\n\n\n\nclass radar_numeric_axis_RadarNumericAxis extends numeric_axis {\n    radarMajorGridLinePositions() {\n        return this.getTickPositions(this.options.majorUnit);\n    }\n\n    radarMinorGridLinePositions() {\n        const options = this.options;\n        let minorSkipStep = 0;\n\n        if (options.majorGridLines.visible) {\n            minorSkipStep = options.majorUnit;\n        }\n        return this.getTickPositions(options.minorUnit, minorSkipStep);\n    }\n\n    axisType() {\n        return numeric_axis;\n    }\n}\n\ndeepExtend(radar_numeric_axis_RadarNumericAxis.prototype, radar_numeric_axis_mixin);\n\n/* harmony default export */ var radar_numeric_axis = (radar_numeric_axis_RadarNumericAxis);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/radar-logarithmic-axis.js\n\n\n\n\n\nclass radar_logarithmic_axis_RadarLogarithmicAxis extends logarithmic_axis {\n    radarMajorGridLinePositions() {\n        const positions = [];\n\n        this.traverseMajorTicksPositions(function(position) {\n            positions.push(position);\n        }, this.options.majorGridLines);\n\n        return positions;\n    }\n\n    radarMinorGridLinePositions() {\n        const positions = [];\n\n        this.traverseMinorTicksPositions(function(position) {\n            positions.push(position);\n        }, this.options.minorGridLines);\n\n        return positions;\n    }\n\n    axisType() {\n        return logarithmic_axis;\n    }\n}\n\ndeepExtend(radar_logarithmic_axis_RadarLogarithmicAxis.prototype, radar_numeric_axis_mixin);\n\n/* harmony default export */ var radar_logarithmic_axis = (radar_logarithmic_axis_RadarLogarithmicAxis);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core/curve-processor.js\n\n\n\n\n\nconst WEIGHT = 0.333;\nconst EXTREMUM_ALLOWED_DEVIATION = 0.01;\n\nclass curve_processor_CurveProcessor extends common_class[\"a\" /* default */] {\n\n    constructor(closed) {\n        super();\n\n        this.closed = closed;\n    }\n\n    process(dataPoints) {\n        const points = dataPoints.slice(0);\n        const segments = [];\n        let closed = this.closed;\n        let length = points.length;\n\n        if (length > 2) {\n            this.removeDuplicates(0, points);\n            length = points.length;\n        }\n\n        if (length < 2 || (length === 2 && points[0].equals(points[1]))) {\n            return segments;\n        }\n\n        let p0 = points[0];\n        let p1 = points[1];\n        let p2 = points[2];\n\n        segments.push(new main[\"b\" /* geometry */].Segment(p0));\n\n        while (p0.equals(points[length - 1])) {\n            closed = true;\n            points.pop();\n            length--;\n        }\n\n        if (length === 2) {\n            const tangent = this.tangent(p0,p1, X, Y);\n\n            last(segments).controlOut(\n                this.firstControlPoint(tangent, p0, p1, X, Y)\n            );\n\n            segments.push(new main[\"b\" /* geometry */].Segment(\n                p1,\n                this.secondControlPoint(tangent, p0, p1, X, Y)\n            ));\n\n            return segments;\n        }\n\n        let initialControlPoint, lastControlPoint;\n\n        if (closed) {\n            p0 = points[length - 1]; p1 = points[0]; p2 = points[1];\n            const controlPoints = this.controlPoints(p0, p1, p2);\n            initialControlPoint = controlPoints[1];\n            lastControlPoint = controlPoints[0];\n        } else {\n            const tangent = this.tangent(p0, p1, X,Y);\n            initialControlPoint = this.firstControlPoint(tangent, p0, p1, X, Y);\n        }\n\n        let cp0 = initialControlPoint;\n        for (let idx = 0; idx <= length - 3; idx++) {\n            this.removeDuplicates(idx, points);\n            length = points.length;\n            if (idx + 3 <= length) {\n                p0 = points[idx]; p1 = points[idx + 1]; p2 = points[idx + 2];\n                const controlPoints = this.controlPoints(p0,p1,p2);\n\n                last(segments).controlOut(cp0);\n                cp0 = controlPoints[1];\n\n                const cp1 = controlPoints[0];\n                segments.push(new main[\"b\" /* geometry */].Segment(p1, cp1));\n            }\n        }\n\n        if (closed) {\n            p0 = points[length - 2]; p1 = points[length - 1]; p2 = points[0];\n            const controlPoints = this.controlPoints(p0, p1, p2);\n\n            last(segments).controlOut(cp0);\n            segments.push(new main[\"b\" /* geometry */].Segment(\n                p1,\n                controlPoints[0]\n            ));\n\n            last(segments).controlOut(controlPoints[1]);\n            segments.push(new main[\"b\" /* geometry */].Segment(\n                p2,\n                lastControlPoint\n            ));\n        } else {\n            const tangent = this.tangent(p1, p2, X, Y);\n\n            last(segments).controlOut(cp0);\n            segments.push(new main[\"b\" /* geometry */].Segment(\n                p2,\n                this.secondControlPoint(tangent, p1, p2, X, Y)\n            ));\n        }\n\n        return segments;\n    }\n\n    removeDuplicates(idx, points) {\n        while (points[idx + 1] && (points[idx].equals(points[idx + 1]) || points[idx + 1].equals(points[idx + 2]))) {\n            points.splice(idx + 1, 1);\n        }\n    }\n\n    invertAxis(p0, p1, p2) {\n        let invertAxis = false;\n\n        if (p0.x === p1.x) {\n            invertAxis = true;\n        } else if (p1.x === p2.x) {\n            if ((p1.y < p2.y && p0.y <= p1.y) || (p2.y < p1.y && p1.y <= p0.y)) {\n                invertAxis = true;\n            }\n        } else {\n            const fn = this.lineFunction(p0,p1);\n            const y2 = this.calculateFunction(fn, p2.x);\n            if (!(p0.y <= p1.y && p2.y <= y2) &&\n                !(p1.y <= p0.y && p2.y >= y2)) {\n                invertAxis = true;\n            }\n        }\n\n        return invertAxis;\n    }\n\n    isLine(p0, p1, p2) {\n        const fn = this.lineFunction(p0, p1);\n        const y2 = this.calculateFunction(fn, p2.x);\n\n        return (p0.x === p1.x && p1.x === p2.x) || round(y2, 1) === round(p2.y, 1);\n    }\n\n    lineFunction(p1, p2) {\n        const a = (p2.y - p1.y) / (p2.x - p1.x);\n        const b = p1.y - a * p1.x;\n\n        return [ b, a ];\n    }\n\n    controlPoints(p0, p1, p2) {\n        let xField = X;\n        let yField = Y;\n        let restrict = false;\n        let switchOrientation = false;\n        let tangent;\n\n        if (this.isLine(p0, p1, p2)) {\n            tangent = this.tangent(p0, p1, X, Y);\n        } else {\n            const monotonic = {\n                x: this.isMonotonicByField(p0, p1, p2, X),\n                y: this.isMonotonicByField(p0, p1, p2, Y)\n            };\n\n            if (monotonic.x && monotonic.y) {\n                tangent = this.tangent(p0, p2, X, Y);\n                restrict = true;\n            } else {\n                if (this.invertAxis(p0, p1, p2)) {\n                    xField = Y;\n                    yField = X;\n                }\n\n                if (monotonic[xField]) {\n                    tangent = 0;\n                } else {\n                    let sign;\n                    if ((p2[yField] < p0[yField] && p0[yField] <= p1[yField]) ||\n                        (p0[yField] < p2[yField] && p1[yField] <= p0[yField])) {\n                        sign = numberSign((p2[yField] - p0[yField]) * (p1[xField] - p0[xField]));\n                    } else {\n                        sign = -numberSign((p2[xField] - p0[xField]) * (p1[yField] - p0[yField]));\n                    }\n\n                    tangent = EXTREMUM_ALLOWED_DEVIATION * sign;\n                    switchOrientation = true;\n                }\n            }\n        }\n\n        const secondControlPoint = this.secondControlPoint(tangent, p0, p1, xField, yField);\n\n        if (switchOrientation) {\n            const oldXField = xField;\n            xField = yField;\n            yField = oldXField;\n        }\n\n        const firstControlPoint = this.firstControlPoint(tangent, p1, p2, xField, yField);\n\n        if (restrict) {\n            this.restrictControlPoint(p0, p1, secondControlPoint, tangent);\n            this.restrictControlPoint(p1, p2, firstControlPoint, tangent);\n        }\n\n        return [ secondControlPoint, firstControlPoint ];\n    }\n\n    restrictControlPoint(p1, p2, cp, tangent) {\n        if (p1.y < p2.y) {\n            if (p2.y < cp.y) {\n                cp.x = p1.x + (p2.y - p1.y) / tangent;\n                cp.y = p2.y;\n            } else if (cp.y < p1.y) {\n                cp.x = p2.x - (p2.y - p1.y) / tangent;\n                cp.y = p1.y;\n            }\n        } else {\n            if (cp.y < p2.y) {\n                cp.x = p1.x - (p1.y - p2.y) / tangent;\n                cp.y = p2.y;\n            } else if (p1.y < cp.y) {\n                cp.x = p2.x + (p1.y - p2.y) / tangent;\n                cp.y = p1.y;\n            }\n        }\n    }\n\n    tangent(p0, p1, xField, yField) {\n        const x = p1[xField] - p0[xField];\n        const y = p1[yField] - p0[yField];\n        let tangent;\n\n        if (x === 0) {\n            tangent = 0;\n        } else {\n            tangent = y / x;\n        }\n\n        return tangent;\n    }\n\n    isMonotonicByField(p0, p1, p2, field) {\n        return (p2[field] > p1[field] && p1[field] > p0[field]) ||\n                    (p2[field] < p1[field] && p1[field] < p0[field]);\n    }\n\n    firstControlPoint(tangent, p0, p3, xField, yField) {\n        const t1 = p0[xField];\n        const t2 = p3[xField];\n        const distance = (t2 - t1) * WEIGHT;\n\n        return this.point(t1 + distance, p0[yField] + distance * tangent, xField, yField);\n    }\n\n    secondControlPoint(tangent, p0, p3, xField, yField) {\n        const t1 = p0[xField];\n        const t2 = p3[xField];\n        const distance = (t2 - t1) * WEIGHT;\n\n        return this.point(t2 - distance, p3[yField] - distance * tangent, xField, yField);\n    }\n\n    point(xValue, yValue, xField, yField) {\n        const controlPoint = new main[\"b\" /* geometry */].Point();\n        controlPoint[xField] = xValue;\n        controlPoint[yField] = yValue;\n\n        return controlPoint;\n    }\n\n    calculateFunction(fn, x) {\n        const length = fn.length;\n        let result = 0;\n\n        for (let i = 0; i < length; i++) {\n            result += Math.pow(x,i) * fn[i];\n        }\n        return result;\n    }\n}\n\nfunction numberSign(value) {\n    return value <= 0 ? -1 : 1;\n}\n\n/* harmony default export */ var curve_processor = (curve_processor_CurveProcessor);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/core.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/api-elements/chart-axis.js\n\n\nclass chart_axis_ChartAxis extends common_class[\"a\" /* default */] {\n    constructor(axis) {\n        super();\n\n        this._axis = axis;\n        this.options = axis.options;\n    }\n\n    value(point) {\n        const axis = this._axis;\n        const value = axis.getCategory ? axis.getCategory(point) : axis.getValue(point);\n\n        return value;\n    }\n\n    slot(from, to, limit = true) {\n        return this._axis.slot(from, to, limit);\n    }\n\n    range() {\n        return this._axis.range();\n    }\n\n    valueRange() {\n        return this._axis.valueRange();\n    }\n}\n\n/* harmony default export */ var chart_axis = (chart_axis_ChartAxis);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/api-elements/find-axis-by-name.js\n\n\nfunction findAxisByName(name, axes) {\n    for (let idx = 0; idx < axes.length; idx++) {\n        if (axes[idx].options.name === name) {\n            axes[idx].prepareUserOptions();\n            return new chart_axis(axes[idx]);\n        }\n    }\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/api-elements/chart-pane.js\n\n\nclass chart_pane_ChartPane {\n    constructor(pane) {\n        this.visual = pane.visual;\n        this.chartsVisual = pane.chartContainer.visual;\n        this._pane = pane;\n    }\n\n    findAxisByName(name) {\n        return findAxisByName(name, this._pane.axes);\n    }\n}\n\n/* harmony default export */ var chart_pane = (chart_pane_ChartPane);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/api-elements/chart-plotarea.js\n\n\nclass chart_plotarea_ChartPlotArea extends common_class[\"a\" /* default */] {\n    constructor(plotArea) {\n        super();\n\n        this._plotArea = plotArea;\n        this.visual = plotArea.visual;\n        this.backgroundVisual = plotArea._bgVisual;\n    }\n}\n\n/* harmony default export */ var chart_plotarea = (chart_plotarea_ChartPlotArea);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/api-elements.js\n\n\n\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/utils/count-numbers.js\n\n\nfunction countNumbers(values) {\n    const length = values.length;\n    let count = 0;\n\n    for (let i = 0; i < length; i++) {\n        const num = values[i];\n        if (isNumber(num)) {\n            count++;\n        }\n    }\n\n    return count;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/aggregates/aggregates.js\n\n\n\n\n\nconst Aggregates = {\n    min: function(values) {\n        const length = values.length;\n        let min = MAX_VALUE;\n\n        for (let i = 0; i < length; i++) {\n            const value = values[i];\n            if (isNumber(value)) {\n                min = Math.min(min, value);\n            }\n        }\n\n        return min === MAX_VALUE ? values[0] : min;\n    },\n\n    max: function(values) {\n        const length = values.length;\n        let max = MIN_VALUE;\n\n        for (let i = 0; i < length; i++) {\n            const value = values[i];\n            if (isNumber(value)) {\n                max = Math.max(max, value);\n            }\n        }\n\n        return max === MIN_VALUE ? values[0] : max;\n    },\n\n    sum: function(values) {\n        const length = values.length;\n        let sum = 0;\n\n        for (let i = 0; i < length; i++) {\n            const value = values[i];\n            if (isNumber(value)) {\n                sum += value;\n            }\n        }\n\n        return sum;\n    },\n\n    sumOrNull: function(values) {\n        let result = null;\n\n        if (countNumbers(values)) {\n            result = Aggregates.sum(values);\n        }\n\n        return result;\n    },\n\n    count: function(values) {\n        const length = values.length;\n        let count = 0;\n\n        for (let i = 0; i < length; i++) {\n            const value = values[i];\n            if (value !== null && defined(value)) {\n                count++;\n            }\n        }\n\n        return count;\n    },\n\n    avg: function(values) {\n        const count = countNumbers(values);\n        let result = values[0];\n\n        if (count > 0) {\n            result = Aggregates.sum(values) / count;\n        }\n\n        return result;\n    },\n\n    first: function(values) {\n        const length = values.length;\n\n        for (let i = 0; i < length; i++) {\n            const value = values[i];\n            if (value !== null && defined(value)) {\n                return value;\n            }\n        }\n\n        return values[0];\n    }\n};\n\n/* harmony default export */ var aggregates = (Aggregates);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/utils/get-field.js\n\n\nfunction getField(field, row) {\n    if (row === null) {\n        return row;\n    }\n\n    const get = getter_getter(field, true);\n    return get(row);\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/series-binder.js\n\n\n\nlet series_binder_SeriesBinder = /*@__PURE__*/ (() => {\n    class SeriesBinder extends common_class[\"a\" /* default */] {\n        constructor() {\n            super();\n            this._valueFields = {};\n            this._otherFields = {};\n            this._nullValue = {};\n            this._undefinedValue = {};\n        }\n        register(seriesTypes, valueFields = [VALUE], otherFields = {}) {\n            for (let i = 0; i < seriesTypes.length; i++) {\n                const type = seriesTypes[i];\n                this._valueFields[type] = valueFields;\n                this._otherFields[type] = otherFields;\n                this._nullValue[type] = this._makeValue(valueFields, null);\n                this._undefinedValue[type] = this._makeValue(valueFields, undefined);\n            }\n        }\n        canonicalFields(series) {\n            return this.valueFields(series).concat(this.otherFields(series));\n        }\n        valueFields(series) {\n            return this._valueFields[series.type] || [VALUE];\n        }\n        otherFields(series) {\n            return this._otherFields[series.type] || [VALUE];\n        }\n        bindPoint(series, pointIx, item) {\n            const data = series.data;\n            const pointData = defined(item) ? item : data[pointIx];\n            const result = { valueFields: { value: pointData } };\n            const valueFields = this.valueFields(series);\n            const otherFields = this._otherFields[series.type];\n            let fields, value;\n            if (pointData === null) {\n                value = this._nullValue[series.type];\n            }\n            else if (!defined(pointData)) {\n                value = this._undefinedValue[series.type];\n            }\n            else if (Array.isArray(pointData)) {\n                const fieldData = pointData.slice(valueFields.length);\n                value = this._bindFromArray(pointData, valueFields);\n                fields = this._bindFromArray(fieldData, otherFields);\n            }\n            else if (typeof pointData === \"object\") {\n                const srcValueFields = this.sourceFields(series, valueFields);\n                const srcPointFields = this.sourceFields(series, otherFields);\n                value = this._bindFromObject(pointData, valueFields, srcValueFields);\n                fields = this._bindFromObject(pointData, otherFields, srcPointFields);\n            }\n            if (defined(value)) {\n                if (valueFields.length === 1) {\n                    result.valueFields.value = value[valueFields[0]];\n                }\n                else {\n                    result.valueFields = value;\n                }\n            }\n            result.fields = fields || {};\n            return result;\n        }\n        _makeValue(fields, initialValue) {\n            const value = {};\n            const length = fields.length;\n            for (let i = 0; i < length; i++) {\n                const fieldName = fields[i];\n                value[fieldName] = initialValue;\n            }\n            return value;\n        }\n        _bindFromArray(array, fields) {\n            const value = {};\n            if (fields) {\n                const length = Math.min(fields.length, array.length);\n                for (let i = 0; i < length; i++) {\n                    value[fields[i]] = array[i];\n                }\n            }\n            return value;\n        }\n        _bindFromObject(object, fields, srcFields = fields) {\n            const value = {};\n            if (fields) {\n                const length = fields.length;\n                for (let i = 0; i < length; i++) {\n                    const fieldName = fields[i];\n                    const srcFieldName = srcFields[i];\n                    if (srcFieldName !== null) {\n                        value[fieldName] = getField(srcFieldName, object);\n                    }\n                }\n            }\n            return value;\n        }\n        sourceFields(series, canonicalFields) {\n            const sourceFields = [];\n            if (canonicalFields) {\n                const length = canonicalFields.length;\n                for (let i = 0; i < length; i++) {\n                    const fieldName = canonicalFields[i];\n                    const sourceFieldName = fieldName === VALUE ? \"field\" : fieldName + \"Field\";\n                    sourceFields.push(series[sourceFieldName] !== null ? (series[sourceFieldName] || fieldName) : null);\n                }\n            }\n            return sourceFields;\n        }\n    }\n    SeriesBinder.current = new SeriesBinder();\n    return SeriesBinder;\n})();\n/* harmony default export */ var series_binder = (series_binder_SeriesBinder);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/error-bars/error-range-calculator.js\n\n\n\n\n\nconst STD_ERR = \"stderr\";\nconst STD_DEV = \"stddev\";\nconst percentRegex = /percent(?:\\w*)\\((\\d+)\\)/;\nconst standardDeviationRegex = new RegExp(\"^\" + STD_DEV + \"(?:\\\\((\\\\d+(?:\\\\.\\\\d+)?)\\\\))?$\");\n\nclass error_range_calculator_ErrorRangeCalculator extends common_class[\"a\" /* default */] {\n    constructor(errorValue, series, field) {\n        super();\n\n        this.initGlobalRanges(errorValue, series, field);\n    }\n\n    initGlobalRanges(errorValue, series, field) {\n        const data = series.data;\n        const deviationMatch = standardDeviationRegex.exec(errorValue);\n\n        if (deviationMatch) {\n            this.valueGetter = this.createValueGetter(series, field);\n\n            const average = this.getAverage(data);\n            const deviation = this.getStandardDeviation(data, average, false);\n            const multiple = deviationMatch[1] ? parseFloat(deviationMatch[1]) : 1;\n            const errorRange = { low: average.value - deviation * multiple, high: average.value + deviation * multiple };\n\n            this.globalRange = function() {\n                return errorRange;\n            };\n        } else if (errorValue.indexOf && errorValue.indexOf(STD_ERR) >= 0) {\n            this.valueGetter = this.createValueGetter(series, field);\n            const standardError = this.getStandardError(data, this.getAverage(data));\n\n            this.globalRange = function(value) {\n                return { low: value - standardError, high: value + standardError };\n            };\n        }\n    }\n\n    createValueGetter(series, field) {\n        const data = series.data;\n        const binder = series_binder.current;\n        const valueFields = binder.valueFields(series);\n        const item = defined(data[0]) ? data[0] : {};\n        let valueGetter;\n\n        if (isArray(item)) {\n            const index = field ? valueFields.indexOf(field) : 0;\n            valueGetter = getter_getter(\"[\" + index + \"]\");\n        } else if (isNumber(item)) {\n            valueGetter = getter_getter();\n        } else if (typeof item === OBJECT) {\n            const srcValueFields = binder.sourceFields(series, valueFields);\n            valueGetter = getter_getter(srcValueFields[valueFields.indexOf(field)]);\n        }\n\n        return valueGetter;\n    }\n\n    getErrorRange(pointValue, errorValue) {\n        let low, high, value;\n\n        if (!defined(errorValue)) {\n            return null;\n        }\n\n        if (this.globalRange) {\n            return this.globalRange(pointValue);\n        }\n\n        if (isArray(errorValue)) {\n            low = pointValue - errorValue[0];\n            high = pointValue + errorValue[1];\n        } else if (isNumber(value = parseFloat(errorValue))) {\n            low = pointValue - value;\n            high = pointValue + value;\n        } else if ((value = percentRegex.exec(errorValue))) {\n            const percentValue = pointValue * (parseFloat(value[1]) / 100);\n            low = pointValue - Math.abs(percentValue);\n            high = pointValue + Math.abs(percentValue);\n        } else {\n            throw new Error(\"Invalid ErrorBar value: \" + errorValue);\n        }\n\n        return { low: low, high: high };\n    }\n\n    getStandardError(data, average) {\n        return this.getStandardDeviation(data, average, true) / Math.sqrt(average.count);\n    }\n\n    getStandardDeviation(data, average, isSample) {\n        const length = data.length;\n        const total = isSample ? average.count - 1 : average.count;\n        let squareDifferenceSum = 0;\n\n        for (let idx = 0; idx < length; idx++) {\n            const value = this.valueGetter(data[idx]);\n            if (isNumber(value)) {\n                squareDifferenceSum += Math.pow(value - average.value, 2);\n            }\n        }\n\n        return Math.sqrt(squareDifferenceSum / total);\n    }\n\n    getAverage(data) {\n        const length = data.length;\n        let sum = 0;\n        let count = 0;\n\n        for (let idx = 0; idx < length; idx++) {\n            const value = this.valueGetter(data[idx]);\n            if (isNumber(value)) {\n                sum += value;\n                count++;\n            }\n        }\n\n        return {\n            value: sum / count,\n            count: count\n        };\n    }\n}\n\n/* harmony default export */ var error_range_calculator = (error_range_calculator_ErrorRangeCalculator);\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/common/support.js\nvar support = __webpack_require__(\"/EQf\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/constants.js\n\n\nconst browser = support[\"a\" /* default */].browser || {};\n\nconst INITIAL_ANIMATION_DURATION = 600;\nconst FADEIN = \"fadeIn\";\n\nconst GLASS = \"glass\";\nconst BORDER_BRIGHTNESS = 0.8;\nconst TOOLTIP_OFFSET = 5;\nconst START_SCALE = browser.msie ? 0.001 : 0;\nconst ERROR_LOW_FIELD = \"errorLow\";\nconst ERROR_HIGH_FIELD = \"errorHigh\";\nconst X_ERROR_LOW_FIELD = \"xErrorLow\";\nconst X_ERROR_HIGH_FIELD = \"xErrorHigh\";\nconst Y_ERROR_LOW_FIELD = \"yErrorLow\";\nconst Y_ERROR_HIGH_FIELD = \"yErrorHigh\";\nconst LINE_MARKER_SIZE = 8;\nconst ZERO = \"zero\";\nconst INTERPOLATE = \"interpolate\";\nconst GAP = \"gap\";\nconst ABOVE = \"above\";\nconst BELOW = \"below\";\n\nconst SMOOTH = \"smooth\";\nconst STEP = \"step\";\n\nconst AREA = \"area\";\nconst BAR = \"bar\";\nconst BOX_PLOT = \"boxPlot\";\nconst BUBBLE = \"bubble\";\nconst BULLET = \"bullet\";\nconst CANDLESTICK = \"candlestick\";\nconst COLUMN = \"column\";\nconst DONUT = \"donut\";\nconst FUNNEL = \"funnel\";\nconst HORIZONTAL_WATERFALL = \"horizontalWaterfall\";\nconst LINE = \"line\";\nconst OHLC = \"ohlc\";\nconst PIE = \"pie\";\nconst POLAR_AREA = \"polarArea\";\nconst POLAR_LINE = \"polarLine\";\nconst POLAR_SCATTER = \"polarScatter\";\nconst RADAR_AREA = \"radarArea\";\nconst RADAR_COLUMN = \"radarColumn\";\nconst RADAR_LINE = \"radarLine\";\nconst RANGE_AREA = \"rangeArea\";\nconst RANGE_BAR = \"rangeBar\";\nconst RANGE_COLUMN = \"rangeColumn\";\nconst SCATTER = \"scatter\";\nconst SCATTER_LINE = \"scatterLine\";\nconst VERTICAL_AREA = \"verticalArea\";\nconst VERTICAL_BOX_PLOT = \"verticalBoxPlot\";\nconst VERTICAL_BULLET = \"verticalBullet\";\nconst VERTICAL_LINE = \"verticalLine\";\nconst VERTICAL_RANGE_AREA = \"verticalRangeArea\";\nconst WATERFALL = \"waterfall\";\nconst EQUALLY_SPACED_SERIES = [\n    BAR, COLUMN, OHLC, CANDLESTICK, BOX_PLOT, VERTICAL_BOX_PLOT,\n    BULLET, RANGE_COLUMN, RANGE_BAR, WATERFALL, HORIZONTAL_WATERFALL\n];\n\nconst LEGEND_ITEM_CLICK = \"legendItemClick\";\nconst LEGEND_ITEM_HOVER = \"legendItemHover\";\nconst LEGEND_ITEM_LEAVE = \"legendItemLeave\";\nconst SERIES_CLICK = \"seriesClick\";\nconst SERIES_HOVER = \"seriesHover\";\nconst SERIES_OVER = \"seriesOver\";\nconst SERIES_LEAVE = \"seriesLeave\";\nconst PLOT_AREA_CLICK = \"plotAreaClick\";\nconst PLOT_AREA_HOVER = \"plotAreaHover\";\nconst PLOT_AREA_LEAVE = \"plotAreaLeave\";\nconst DRAG = \"drag\";\nconst DRAG_END = \"dragEnd\";\nconst DRAG_START = \"dragStart\";\nconst ZOOM_START = \"zoomStart\";\nconst ZOOM = \"zoom\";\nconst ZOOM_END = \"zoomEnd\";\nconst SELECT_START = \"selectStart\";\nconst SELECT = \"select\";\nconst SELECT_END = \"selectEnd\";\nconst RENDER = \"render\";\nconst SHOW_TOOLTIP = \"showTooltip\";\nconst HIDE_TOOLTIP = \"hideTooltip\";\nconst PANE_RENDER = \"paneRender\";\n\nconst LOGARITHMIC = \"log\";\nconst CATEGORY = \"category\";\n\nconst INSIDE_END = \"insideEnd\";\nconst INSIDE_BASE = \"insideBase\";\nconst OUTSIDE_END = \"outsideEnd\";\n\nconst MOUSEWHEEL = \"DOMMouseScroll mousewheel\";\nconst MOUSEWHEEL_DELAY = 150;\n\n\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/error-bars/error-bar-base.js\n\n\n\n\n\n\n\n\nconst DEFAULT_ERROR_BAR_WIDTH = 4;\n\nclass error_bar_base_ErrorBarBase extends chart_element {\n    constructor(low, high, isVertical, chart, series, options) {\n        super(options);\n\n        this.low = low;\n        this.high = high;\n        this.isVertical = isVertical;\n        this.chart = chart;\n        this.series = series;\n    }\n\n    reflow(targetBox) {\n        const endCaps = this.options.endCaps;\n        const isVertical = this.isVertical;\n        const axis = this.getAxis();\n        const valueBox = axis.getSlot(this.low, this.high);\n        const centerBox = targetBox.center();\n        const capsWidth = this.getCapsWidth(targetBox, isVertical);\n        const capValue = isVertical ? centerBox.x : centerBox.y;\n        const capStart = capValue - capsWidth;\n        const capEnd = capValue + capsWidth;\n        let linePoints;\n\n        if (isVertical) {\n            linePoints = [\n                new core_point(centerBox.x, valueBox.y1),\n                new core_point(centerBox.x, valueBox.y2)\n            ];\n            if (endCaps) {\n                linePoints.push(new core_point(capStart, valueBox.y1),\n                    new core_point(capEnd, valueBox.y1),\n                    new core_point(capStart, valueBox.y2),\n                    new core_point(capEnd, valueBox.y2));\n            }\n            this.box = new core_box(capStart, valueBox.y1, capEnd, valueBox.y2);\n        } else {\n            linePoints = [\n                new core_point(valueBox.x1, centerBox.y),\n                new core_point(valueBox.x2, centerBox.y)\n            ];\n            if (endCaps) {\n                linePoints.push(new core_point(valueBox.x1, capStart),\n                    new core_point(valueBox.x1, capEnd),\n                    new core_point(valueBox.x2, capStart),\n                    new core_point(valueBox.x2, capEnd));\n            }\n            this.box = new core_box(valueBox.x1, capStart, valueBox.x2, capEnd);\n        }\n\n        this.linePoints = linePoints;\n    }\n\n    getCapsWidth(box, isVertical) {\n        const boxSize = isVertical ? box.width() : box.height();\n        const capsWidth = Math.min(Math.floor(boxSize / 2), DEFAULT_ERROR_BAR_WIDTH) || DEFAULT_ERROR_BAR_WIDTH;\n\n        return capsWidth;\n    }\n\n    createVisual() {\n        const options = this.options;\n        const visual = options.visual;\n\n        if (visual) {\n            this.visual = visual({\n                low: this.low,\n                high: this.high,\n                rect: this.box.toRect(),\n                sender: this.getSender(),\n                options: {\n                    endCaps: options.endCaps,\n                    color: options.color,\n                    line: options.line\n                },\n                createVisual: () => {\n                    this.createDefaultVisual();\n                    const defaultVisual = this.visual;\n                    delete this.visual;\n                    return defaultVisual;\n                }\n            });\n        } else {\n            this.createDefaultVisual();\n        }\n    }\n\n    createDefaultVisual() {\n        const { options, linePoints } = this;\n        const lineOptions = {\n            stroke: {\n                color: options.color,\n                width: options.line.width,\n                dashType: options.line.dashType\n            }\n        };\n\n        super.createVisual();\n\n        for (let idx = 0; idx < linePoints.length; idx += 2) {\n            const line = new main[\"a\" /* drawing */].Path(lineOptions)\n                .moveTo(linePoints[idx].x, linePoints[idx].y)\n                .lineTo(linePoints[idx + 1].x, linePoints[idx + 1].y);\n\n            alignPathToPixel(line);\n            this.visual.append(line);\n        }\n    }\n}\n\nsetDefaultOptions(error_bar_base_ErrorBarBase, {\n    animation: {\n        type: FADEIN,\n        delay: INITIAL_ANIMATION_DURATION\n    },\n    endCaps: true,\n    line: {\n        width: 2\n    },\n    zIndex: 1\n});\n\n/* harmony default export */ var error_bar_base = (error_bar_base_ErrorBarBase);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/error-bars/categorical-error-bar.js\n\n\nclass categorical_error_bar_CategoricalErrorBar extends error_bar_base {\n    getAxis() {\n        const axis = this.chart.seriesValueAxis(this.series);\n\n        return axis;\n    }\n}\n\n/* harmony default export */ var categorical_error_bar = (categorical_error_bar_CategoricalErrorBar);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/utils/eval-options.js\n\n\nconst MAX_EXPAND_DEPTH = 5;\n\nfunction evalOptions(options, context, state = {}, dryRun = false) {\n    const defaults = state.defaults = state.defaults || {};\n    const depth = state.depth = state.depth || 0;\n    let needsEval = false;\n\n    state.excluded = state.excluded || [];\n\n    if (depth > MAX_EXPAND_DEPTH) {\n        return null;\n    }\n\n    for (let property in options) {\n        if (!inArray(property, state.excluded) && options.hasOwnProperty(property)) {\n            const propValue = options[property];\n            if (isFunction(propValue)) {\n                needsEval = true;\n                if (!dryRun) {\n                    options[property] = valueOrDefault(propValue(context), defaults[property]);\n                }\n            } else if (isObject(propValue)) {\n                if (!dryRun) {\n                    state.defaults = defaults[property];\n                }\n                state.depth++;\n                needsEval = evalOptions(propValue, context, state, dryRun) || needsEval;\n                state.depth--;\n            }\n        }\n    }\n\n    return needsEval;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/utils/categories-count.js\nfunction categoriesCount(series) {\n    const seriesCount = series.length;\n    let categories = 0;\n\n    for (let i = 0; i < seriesCount; i++) {\n        categories = Math.max(categories, series[i].data.length);\n    }\n\n    return categories;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/categorical-chart.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass categorical_chart_CategoricalChart extends chart_element {\n    constructor(plotArea, options) {\n        super(options);\n\n        this.plotArea = plotArea;\n        this.chartService = plotArea.chartService;\n        this.categoryAxis = plotArea.seriesCategoryAxis(options.series[0]);\n\n        // Value axis ranges grouped by axis name, e.g.:\n        // primary: { min: 0, max: 1 }\n        this.valueAxisRanges = {};\n\n        this.points = [];\n        this.categoryPoints = [];\n        this.seriesPoints = [];\n        this.seriesOptions = [];\n        this._evalSeries = [];\n\n        this.render();\n    }\n\n    render() {\n        this.traverseDataPoints(this.addValue.bind(this));\n    }\n\n    pointOptions(series, seriesIx) {\n        let options = this.seriesOptions[seriesIx];\n        if (!options) {\n            const defaults = this.pointType().prototype.defaults;\n            this.seriesOptions[seriesIx] = options = deepExtend({ }, defaults, {\n                vertical: !this.options.invertAxes\n            }, series);\n        }\n\n        return options;\n    }\n\n    plotValue(point) {\n        if (!point) {\n            return 0;\n        }\n\n        if (this.options.isStacked100 && isNumber(point.value)) {\n            const categoryIx = point.categoryIx;\n            const categoryPoints = this.categoryPoints[categoryIx];\n            const otherValues = [];\n            let categorySum = 0;\n\n            for (let i = 0; i < categoryPoints.length; i++) {\n                const other = categoryPoints[i];\n                if (other) {\n                    const stack = point.series.stack;\n                    const otherStack = other.series.stack;\n\n                    if ((stack && otherStack) && stack.group !== otherStack.group) {\n                        continue;\n                    }\n\n                    if (isNumber(other.value)) {\n                        categorySum += Math.abs(other.value);\n                        otherValues.push(Math.abs(other.value));\n                    }\n                }\n            }\n\n            if (categorySum > 0) {\n                return point.value / categorySum;\n            }\n        }\n\n        return point.value;\n    }\n\n    plotRange(point, startValue = 0) {\n        const categoryPoints = this.categoryPoints[point.categoryIx];\n\n        if (this.options.isStacked) {\n            let plotValue = this.plotValue(point);\n            const positive = plotValue >= 0;\n            let prevValue = startValue;\n            let isStackedBar = false;\n\n            for (let i = 0; i < categoryPoints.length; i++) {\n                const other = categoryPoints[i];\n\n                if (point === other) {\n                    break;\n                }\n\n                const stack = point.series.stack;\n                const otherStack = other.series.stack;\n                if (stack && otherStack) {\n                    if (typeof stack === STRING && stack !== otherStack) {\n                        continue;\n                    }\n\n                    if (stack.group && stack.group !== otherStack.group) {\n                        continue;\n                    }\n                }\n\n                const otherValue = this.plotValue(other);\n                if ((otherValue >= 0 && positive) ||\n                    (otherValue < 0 && !positive)) {\n                    prevValue += otherValue;\n                    plotValue += otherValue;\n                    isStackedBar = true;\n\n                    if (this.options.isStacked100) {\n                        plotValue = Math.min(plotValue, 1);\n                    }\n                }\n            }\n\n            if (isStackedBar) {\n                prevValue -= startValue;\n            }\n\n            return [ prevValue, plotValue ];\n        }\n\n        const series = point.series;\n        const valueAxis = this.seriesValueAxis(series);\n        const axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);\n\n        return [ axisCrossingValue, convertableToNumber(point.value) ? point.value : axisCrossingValue ];\n    }\n\n    stackLimits(axisName, stackName) {\n        let min = MAX_VALUE;\n        let max = MIN_VALUE;\n\n        for (let i = 0; i < this.categoryPoints.length; i++) {\n            const categoryPoints = this.categoryPoints[i];\n            if (!categoryPoints) {\n                continue;\n            }\n\n            for (let pIx = 0; pIx < categoryPoints.length; pIx++) {\n                const point = categoryPoints[pIx];\n                if (point) {\n                    if (point.series.stack === stackName || point.series.axis === axisName) {\n                        const to = this.plotRange(point, 0)[1];\n                        if (defined(to) && isFinite(to)) {\n                            max = Math.max(max, to);\n                            min = Math.min(min, to);\n                        }\n                    }\n                }\n            }\n        }\n\n        return { min: min, max: max };\n    }\n\n    updateStackRange() {\n        const { isStacked, series: chartSeries } = this.options;\n        const limitsCache = {};\n\n        if (isStacked) {\n            for (let i = 0; i < chartSeries.length; i++) {\n                const series = chartSeries[i];\n                const axisName = series.axis;\n                const key = axisName + series.stack;\n\n                let limits = limitsCache[key];\n                if (!limits) {\n                    limits = this.stackLimits(axisName, series.stack);\n\n                    const errorTotals = this.errorTotals;\n                    if (errorTotals) {\n                        if (errorTotals.negative.length) {\n                            limits.min = Math.min(limits.min, sparseArrayLimits(errorTotals.negative).min);\n                        }\n                        if (errorTotals.positive.length) {\n                            limits.max = Math.max(limits.max, sparseArrayLimits(errorTotals.positive).max);\n                        }\n                    }\n\n                    if (limits.min !== MAX_VALUE || limits.max !== MIN_VALUE) {\n                        limitsCache[key] = limits;\n                    } else {\n                        limits = null;\n                    }\n                }\n\n                if (limits) {\n                    this.valueAxisRanges[axisName] = limits;\n                }\n            }\n        }\n    }\n\n    addErrorBar(point, data, categoryIx) {\n        const { value, series, seriesIx } = point;\n        const errorBars = point.options.errorBars;\n        const lowValue = data.fields[ERROR_LOW_FIELD];\n        const highValue = data.fields[ERROR_HIGH_FIELD];\n        let errorRange;\n\n        if (isNumber(lowValue) && isNumber(highValue)) {\n            errorRange = { low: lowValue, high: highValue };\n        } else if (errorBars && defined(errorBars.value)) {\n            this.seriesErrorRanges = this.seriesErrorRanges || [];\n            this.seriesErrorRanges[seriesIx] = this.seriesErrorRanges[seriesIx] ||\n                new error_range_calculator(errorBars.value, series, VALUE);\n\n            errorRange = this.seriesErrorRanges[seriesIx].getErrorRange(value, errorBars.value);\n        }\n\n        if (errorRange) {\n            point.low = errorRange.low;\n            point.high = errorRange.high;\n            this.addPointErrorBar(point, categoryIx);\n        }\n    }\n\n    addPointErrorBar(point, categoryIx) {\n        const isVertical = !this.options.invertAxes;\n        const options = point.options.errorBars;\n        let { series, low, high } = point;\n\n        if (this.options.isStacked) {\n            const stackedErrorRange = this.stackedErrorRange(point, categoryIx);\n            low = stackedErrorRange.low;\n            high = stackedErrorRange.high;\n        } else {\n            const fields = { categoryIx: categoryIx, series: series };\n            this.updateRange({ value: low }, fields);\n            this.updateRange({ value: high }, fields);\n        }\n\n        const errorBar = new categorical_error_bar(low, high, isVertical, this, series, options);\n        point.errorBars = [ errorBar ];\n        point.append(errorBar);\n    }\n\n    stackedErrorRange(point, categoryIx) {\n        const plotValue = this.plotRange(point, 0)[1] - point.value;\n        const low = point.low + plotValue;\n        const high = point.high + plotValue;\n\n        this.errorTotals = this.errorTotals || { positive: [], negative: [] };\n\n        if (low < 0) {\n            this.errorTotals.negative[categoryIx] = Math.min(this.errorTotals.negative[categoryIx] || 0, low);\n        }\n\n        if (high > 0) {\n            this.errorTotals.positive[categoryIx] = Math.max(this.errorTotals.positive[categoryIx] || 0, high);\n        }\n\n        return { low: low, high: high };\n    }\n\n    addValue(data, fields) {\n        const { categoryIx, series, seriesIx } = fields;\n\n        let categoryPoints = this.categoryPoints[categoryIx];\n        if (!categoryPoints) {\n            this.categoryPoints[categoryIx] = categoryPoints = [];\n        }\n\n        let seriesPoints = this.seriesPoints[seriesIx];\n        if (!seriesPoints) {\n            this.seriesPoints[seriesIx] = seriesPoints = [];\n        }\n\n        const point = this.createPoint(data, fields);\n        if (point) {\n            Object.assign(point, fields);\n\n            point.owner = this;\n            point.noteText = data.fields.noteText;\n            if (!defined(point.dataItem)) {\n                point.dataItem = series.data[categoryIx];\n            }\n            this.addErrorBar(point, data, categoryIx);\n        }\n\n        this.points.push(point);\n        seriesPoints.push(point);\n        categoryPoints.push(point);\n\n        this.updateRange(data.valueFields, fields);\n    }\n\n    evalPointOptions(options, value, category, categoryIx, series, seriesIx) {\n        const state = { defaults: series._defaults, excluded: [ \"data\", \"aggregate\", \"_events\", \"tooltip\", \"content\", \"template\", \"visual\", \"toggle\", \"_outOfRangeMinPoint\", \"_outOfRangeMaxPoint\" ] };\n\n        let doEval = this._evalSeries[seriesIx];\n        if (!defined(doEval)) {\n            this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);\n        }\n\n        let pointOptions = options;\n        if (doEval) {\n            pointOptions = deepExtend({}, pointOptions);\n            evalOptions(pointOptions, {\n                value: value,\n                category: category,\n                index: categoryIx,\n                series: series,\n                dataItem: series.data[categoryIx]\n            }, state);\n        }\n\n        return pointOptions;\n    }\n\n    updateRange(data, fields) {\n        const axisName = fields.series.axis;\n        const value = data.value;\n        let axisRange = this.valueAxisRanges[axisName];\n\n        if (isFinite(value) && value !== null) {\n            axisRange = this.valueAxisRanges[axisName] =\n                axisRange || { min: MAX_VALUE, max: MIN_VALUE };\n\n            axisRange.min = Math.min(axisRange.min, value);\n            axisRange.max = Math.max(axisRange.max, value);\n        }\n    }\n\n    seriesValueAxis(series) {\n        const plotArea = this.plotArea;\n        const axisName = series.axis;\n        const axis = axisName ? plotArea.namedValueAxes[axisName] : plotArea.valueAxis;\n\n        if (!axis) {\n            throw new Error(\"Unable to locate value axis with name \" + axisName);\n        }\n\n        return axis;\n    }\n\n    reflow(targetBox) {\n        const categorySlots = this.categorySlots = [];\n        const chartPoints = this.points;\n        const categoryAxis = this.categoryAxis;\n        let pointIx = 0;\n\n        this.traverseDataPoints((data, fields) => {\n            const { categoryIx, series: currentSeries } = fields;\n\n            const valueAxis = this.seriesValueAxis(currentSeries);\n            const point = chartPoints[pointIx++];\n\n            let categorySlot = categorySlots[categoryIx];\n            if (!categorySlot) {\n                categorySlots[categoryIx] = categorySlot =\n                    this.categorySlot(categoryAxis, categoryIx, valueAxis);\n            }\n\n            if (point) {\n                const plotRange = this.plotRange(point, valueAxis.startValue());\n                const valueSlot = this.valueSlot(valueAxis, plotRange);\n                if (valueSlot) {\n                    const pointSlot = this.pointSlot(categorySlot, valueSlot);\n\n                    point.aboveAxis = this.aboveAxis(point, valueAxis);\n                    point.stackValue = plotRange[1];\n\n                    if (this.options.isStacked100) {\n                        point.percentage = this.plotValue(point);\n                    }\n\n                    this.reflowPoint(point, pointSlot);\n                } else {\n                    point.visible = false;\n                }\n            }\n        });\n\n        this.reflowCategories(categorySlots);\n        if (!this.options.clip && this.options.limitPoints && this.points.length) {\n            this.limitPoints();\n        }\n\n        this.box = targetBox;\n    }\n\n    valueSlot(valueAxis, plotRange) {\n        return valueAxis.getSlot(plotRange[0], plotRange[1], !this.options.clip);\n    }\n\n    limitPoints() {\n        const categoryPoints = this.categoryPoints;\n        const points = categoryPoints[0].concat(last(categoryPoints));\n        for (let idx = 0; idx < points.length; idx++) {\n            if (points[idx]) {\n                this.limitPoint(points[idx]);\n            }\n        }\n    }\n\n    limitPoint(point) {\n        const limittedSlot = this.categoryAxis.limitSlot(point.box);\n        if (!limittedSlot.equals(point.box)) {\n            point.reflow(limittedSlot);\n        }\n    }\n\n    aboveAxis(point, valueAxis) {\n        const axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);\n        const value = point.value;\n\n        return valueAxis.options.reverse ?\n            value < axisCrossingValue : value >= axisCrossingValue;\n    }\n\n    categoryAxisCrossingValue(valueAxis) {\n        const categoryAxis = this.categoryAxis;\n        const options = valueAxis.options;\n        const crossingValues = [].concat(\n            options.axisCrossingValues || options.axisCrossingValue\n        );\n\n        return crossingValues[categoryAxis.axisIndex || 0] || 0;\n    }\n\n    reflowPoint(point, pointSlot) {\n        point.reflow(pointSlot);\n    }\n\n    reflowCategories() { }\n\n    pointSlot(categorySlot, valueSlot) {\n        const options = this.options;\n        const invertAxes = options.invertAxes;\n        const slotX = invertAxes ? valueSlot : categorySlot;\n        const slotY = invertAxes ? categorySlot : valueSlot;\n\n        return new core_box(slotX.x1, slotY.y1, slotX.x2, slotY.y2);\n    }\n\n    categorySlot(categoryAxis, categoryIx) {\n        return categoryAxis.getSlot(categoryIx);\n    }\n\n    traverseDataPoints(callback) {\n        const series = this.options.series;\n        const count = categoriesCount(series);\n        const seriesCount = series.length;\n\n        for (let seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n            this._outOfRangeCallback(series[seriesIx], \"_outOfRangeMinPoint\", seriesIx, callback);\n        }\n\n        for (let categoryIx = 0; categoryIx < count; categoryIx++) {\n            for (let seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n                const currentSeries = series[seriesIx];\n                const currentCategory = this.categoryAxis.categoryAt(categoryIx);\n                const pointData = this._bindPoint(currentSeries, seriesIx, categoryIx);\n\n                callback(pointData, {\n                    category: currentCategory,\n                    categoryIx: categoryIx,\n                    categoriesCount: count,\n                    series: currentSeries,\n                    seriesIx: seriesIx\n                });\n            }\n        }\n\n        for (let seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n            this._outOfRangeCallback(series[seriesIx], \"_outOfRangeMaxPoint\", seriesIx, callback);\n        }\n    }\n\n    _outOfRangeCallback(series, field, seriesIx, callback) {\n        const outOfRangePoint = series[field];\n        if (outOfRangePoint) {\n            const categoryIx = outOfRangePoint.categoryIx;\n            const pointData = this._bindPoint(series, seriesIx, categoryIx, outOfRangePoint.item);\n\n            callback(pointData, {\n                category: outOfRangePoint.category,\n                categoryIx: categoryIx,\n                series: series,\n                seriesIx: seriesIx,\n                dataItem: outOfRangePoint.item\n            });\n        }\n    }\n\n    _bindPoint(series, seriesIx, categoryIx, item) {\n        if (!this._bindCache) {\n            this._bindCache = [];\n        }\n\n        let bindCache = this._bindCache[seriesIx];\n        if (!bindCache) {\n            bindCache = this._bindCache[seriesIx] = [];\n        }\n\n        let data = bindCache[categoryIx];\n        if (!data) {\n            data = bindCache[categoryIx] = series_binder.current.bindPoint(series, categoryIx, item);\n        }\n\n        return data;\n    }\n\n    formatPointValue(point, format) {\n        if (point.value === null) {\n            return \"\";\n        }\n\n        return this.chartService.format.auto(format, point.value);\n    }\n\n    pointValue(data) {\n        return data.valueFields.value;\n    }\n}\n\nsetDefaultOptions(categorical_chart_CategoricalChart, {\n    series: [],\n    invertAxes: false,\n    isStacked: false,\n    clip: true,\n    limitPoints: true\n});\n\n/* harmony default export */ var categorical_chart = (categorical_chart_CategoricalChart);\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/common/color/color.js\nvar color_color = __webpack_require__(\"QUbS\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/mixins/point-events-mixin.js\n\n\n\nconst PointEventsMixin = {\n    click: function(chart, e) {\n        return chart.trigger(\n            SERIES_CLICK,\n            this.eventArgs(e)\n        );\n    },\n\n    hover: function(chart, e) {\n        return chart.trigger(\n            SERIES_HOVER,\n            this.eventArgs(e)\n        );\n    },\n\n    over: function(chart, e) {\n        return chart.trigger(\n            SERIES_OVER,\n            this.eventArgs(e)\n        );\n    },\n\n    out: function(chart, e) {\n        return chart.trigger(\n            SERIES_LEAVE,\n            this.eventArgs(e)\n        );\n    },\n\n    eventArgs: function(e) {\n        return {\n            value: this.value,\n            percentage: this.percentage,\n            stackValue: this.stackValue,\n            category: this.category,\n            series: this.series,\n            dataItem: this.dataItem,\n            runningTotal: this.runningTotal,\n            total: this.total,\n            element: eventElement(e),\n            originalEvent: e,\n            point: this\n        };\n    }\n};\n\n/* harmony default export */ var point_events_mixin = (PointEventsMixin);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/mixins/note-mixin.js\n\n\n\nconst NoteMixin = {\n    createNote: function() {\n        const options = this.options.notes;\n        const text = this.noteText || options.label.text;\n\n        if (options.visible !== false && defined(text) && text !== null) {\n            this.note = new core_note({\n                value: this.value,\n                text: text,\n                dataItem: this.dataItem,\n                category: this.category,\n                series: this.series\n            }, this.options.notes, this.owner.chartService);\n\n            this.append(this.note);\n        }\n    }\n};\n\n/* harmony default export */ var note_mixin = (NoteMixin);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/line-chart/line-point.js\n\n\n\n\n\n\n\n\n\n\n\nclass line_point_LinePoint extends chart_element {\n    constructor(value, options) {\n        super();\n\n        this.value = value;\n        this.options = options;\n        this.aboveAxis = valueOrDefault(this.options.aboveAxis, true);\n        this.tooltipTracking = true;\n    }\n\n    render() {\n        const { markers, labels } = this.options;\n\n        if (this._rendered) {\n            return;\n        }\n\n        this._rendered = true;\n\n        if (markers.visible && markers.size) {\n            this.marker = this.createMarker();\n            this.append(this.marker);\n        }\n\n        if (labels.visible) {\n            const labelTemplate = getTemplate(labels);\n            const pointData = this.pointData();\n            let labelText = this.value;\n            if (labelTemplate) {\n                labelText = labelTemplate(pointData);\n            } else if (labels.format) {\n                labelText = this.formatValue(labels.format);\n            }\n            this.label = new text_box(labelText,\n                deepExtend({\n                    align: CENTER,\n                    vAlign: CENTER,\n                    margin: {\n                        left: 5,\n                        right: 5\n                    },\n                    zIndex: valueOrDefault(labels.zIndex, this.series.zIndex)\n                }, labels),\n                pointData\n            );\n            this.append(this.label);\n        }\n\n        this.createNote();\n\n        if (this.errorBar) {\n            this.append(this.errorBar);\n        }\n    }\n\n    markerBorder() {\n        const options = this.options.markers;\n        const background = options.background;\n        const border = deepExtend({ color: this.color }, options.border);\n\n        if (!defined(border.color)) {\n            border.color = new color_color[\"a\" /* default */](background).brightness(BORDER_BRIGHTNESS).toHex();\n        }\n\n        return border;\n    }\n\n    createVisual() {}\n\n    createMarker() {\n        const options = this.options.markers;\n        const marker = new shape_element({\n            type: options.type,\n            width: options.size,\n            height: options.size,\n            rotation: options.rotation,\n            background: options.background,\n            border: this.markerBorder(),\n            opacity: this.series.opacity || options.opacity,\n            zIndex: valueOrDefault(options.zIndex, this.series.zIndex),\n            animation: options.animation,\n            visual: options.visual\n        }, {\n            dataItem: this.dataItem,\n            value: this.value,\n            series: this.series,\n            category: this.category\n        });\n\n        return marker;\n    }\n\n    markerBox() {\n        if (!this.marker) {\n            this.marker = this.createMarker();\n            this.marker.reflow(this._childBox);\n        }\n\n        return this.marker.box;\n    }\n\n    reflow(targetBox) {\n        const { options, aboveAxis } = this;\n        const vertical = options.vertical;\n\n        this.render();\n\n        this.box = targetBox;\n        const childBox = targetBox.clone();\n\n        if (vertical) {\n            if (aboveAxis) {\n                childBox.y1 -= childBox.height();\n            } else {\n                childBox.y2 += childBox.height();\n            }\n        } else {\n            if (aboveAxis) {\n                childBox.x1 += childBox.width();\n            } else {\n                childBox.x2 -= childBox.width();\n            }\n        }\n\n        this._childBox = childBox;\n        if (this.marker) {\n            this.marker.reflow(childBox);\n        }\n\n        this.reflowLabel(childBox);\n\n        if (this.errorBars) {\n            for (let i = 0; i < this.errorBars.length; i++) {\n                this.errorBars[i].reflow(childBox);\n            }\n        }\n\n        if (this.note) {\n            let noteTargetBox = this.markerBox();\n\n            if (!(options.markers.visible && options.markers.size)) {\n                const center = noteTargetBox.center();\n                noteTargetBox = new core_box(center.x, center.y, center.x, center.y);\n            }\n\n            this.note.reflow(noteTargetBox);\n        }\n    }\n\n    reflowLabel(box) {\n        const { options, label } = this;\n        let anchor = options.labels.position;\n\n        if (label) {\n            anchor = anchor === ABOVE ? TOP : anchor;\n            anchor = anchor === BELOW ? BOTTOM : anchor;\n\n            label.reflow(box);\n            label.box.alignTo(this.markerBox(), anchor);\n            label.reflow(label.box);\n        }\n    }\n\n    createHighlight() {\n        const markers = this.options.highlight.markers;\n        const defaultColor = this.markerBorder().color;\n        const options = this.options.markers;\n        const size = options.size + (options.border.width || 0) + (markers.border.width || 0);\n\n        const shadow = new shape_element({\n            type: options.type,\n            width: size,\n            height: size,\n            rotation: options.rotation,\n            background: markers.color || defaultColor,\n            border: {\n                color: markers.border.color,\n                width: markers.border.width,\n                opacity: valueOrDefault(markers.border.opacity, 1)\n            },\n            opacity: valueOrDefault(markers.opacity, 1)\n        });\n        shadow.reflow(this._childBox);\n\n        return shadow.getElement();\n    }\n\n    highlightVisual() {\n        return (this.marker || {}).visual;\n    }\n\n    highlightVisualArgs() {\n        const marker = this.marker;\n        let visual, rect;\n\n        if (marker) {\n            rect = marker.paddingBox.toRect();\n            visual = marker.visual;\n        } else {\n            const size = this.options.markers.size;\n            const halfSize = size / 2;\n            const center = this.box.center();\n            rect = new main[\"b\" /* geometry */].Rect([ center.x - halfSize, center.y - halfSize ], [ size, size ]);\n        }\n\n        return {\n            options: this.options,\n            rect: rect,\n            visual: visual\n        };\n    }\n\n    tooltipAnchor() {\n        const markerBox = this.markerBox();\n        const clipBox = this.owner.pane.clipBox();\n        const showTooltip = !clipBox || clipBox.overlaps(markerBox);\n\n        if (showTooltip) {\n            const x = markerBox.x2 + TOOLTIP_OFFSET;\n            const horizontalAlign = LEFT;\n            let y, verticalAlign;\n\n            if (this.aboveAxis) {\n                y = markerBox.y1;\n                verticalAlign = BOTTOM;\n            } else {\n                y = markerBox.y2;\n                verticalAlign = TOP;\n            }\n\n            return {\n                point: new core_point(x, y),\n                align: {\n                    horizontal: horizontalAlign,\n                    vertical: verticalAlign\n                }\n            };\n        }\n    }\n\n    formatValue(format) {\n        return this.owner.formatPointValue(this, format);\n    }\n\n    overlapsBox(box) {\n        const markerBox = this.markerBox();\n        return markerBox.overlaps(box);\n    }\n\n    unclipElements() {\n        if (this.label) {\n            this.label.options.noclip = true;\n        }\n\n        if (this.note) {\n            this.note.options.noclip = true;\n        }\n    }\n\n    pointData() {\n        return {\n            dataItem: this.dataItem,\n            category: this.category,\n            value: this.value,\n            percentage: this.percentage,\n            stackValue: this.stackValue,\n            series: this.series\n        };\n    }\n}\n\nline_point_LinePoint.prototype.defaults = {\n    vertical: true,\n    markers: {\n        visible: true,\n        background: WHITE,\n        size: LINE_MARKER_SIZE,\n        type: CIRCLE,\n        border: {\n            width: 2\n        },\n        opacity: 1\n    },\n    labels: {\n        visible: false,\n        position: ABOVE,\n        margin: getSpacing(3),\n        padding: getSpacing(4),\n        animation: {\n            type: FADEIN,\n            delay: INITIAL_ANIMATION_DURATION\n        }\n    },\n    notes: {\n        label: {}\n    },\n    highlight: {\n        markers: {\n            border: {\n                color: \"#fff\",\n                width: 2\n            }\n        },\n        zIndex: HIGHLIGHT_ZINDEX\n    },\n    errorBars: {\n        line: {\n            width: 1\n        }\n    }\n};\n\ndeepExtend(line_point_LinePoint.prototype, point_events_mixin);\ndeepExtend(line_point_LinePoint.prototype, note_mixin);\n\n/* harmony default export */ var line_point = (line_point_LinePoint);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/line-chart/line-segment.js\n\n\n\n\n\n\nclass line_segment_LineSegment extends chart_element {\n    constructor(linePoints, series, seriesIx) {\n        super();\n\n        this.linePoints = linePoints;\n        this.series = series;\n        this.seriesIx = seriesIx;\n    }\n\n    points() {\n        return this.toGeometryPoints(this.linePoints);\n    }\n\n    toGeometryPoints(points) {\n        const result = [];\n        for (let i = 0, length = points.length; i < length; i++) {\n            if (points[i] && points[i].visible !== false) {\n                result.push(points[i]._childBox.toRect().center());\n            }\n        }\n\n        return result;\n    }\n\n    createVisual() {\n        const customVisual = this.series.visual;\n        if (customVisual) {\n            this.visual = customVisual({\n                points: this.toGeometryPoints(this.linePoints),\n                series: this.series,\n                sender: this.getSender(),\n                createVisual: () => {\n                    this.segmentVisual();\n\n                    return this.visual;\n                }\n            });\n            if (this.visual && !defined(this.visual.options.zIndex)) {\n                this.visual.options.zIndex = this.series.zIndex;\n            }\n        } else {\n            this.segmentVisual();\n        }\n    }\n\n    segmentVisual() {\n        const { options, series } = this;\n        let { color, _defaults: defaults } = series;\n\n        if (isFunction(color) && defaults) {\n            color = defaults.color;\n        }\n\n        const line = main[\"a\" /* drawing */].Path.fromPoints(this.points(), {\n            stroke: {\n                color: color,\n                width: series.width,\n                opacity: series.opacity,\n                dashType: series.dashType\n            },\n            zIndex: series.zIndex\n        });\n\n        if (options.closed) {\n            line.close();\n        }\n\n        this.visual = line;\n    }\n\n    aliasFor(e, coords) {\n        return this.parent.getNearestPoint(coords.x, coords.y, this.seriesIx);\n    }\n}\n\nsetDefaultOptions(line_segment_LineSegment, {\n    closed: false\n});\n\n/* harmony default export */ var line_segment = (line_segment_LineSegment);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/line-chart/step-line-mixin.js\n\n\n\n\n\nconst StepLineMixin = {\n    calculateStepPoints: function(points) {\n        const categoryAxis = this.parent.plotArea.seriesCategoryAxis(this.series);\n        const { justified, vertical, reverse } = categoryAxis.options;\n\n        const stepAxis = vertical ? X : Y;\n        const axis = vertical ? Y : X;\n        const stepDir = reverse ? 2 : 1;\n        const dir = stepDir;\n\n        let previousPoint = toGeometryPoint(points[0], stepAxis, stepDir, axis, dir);\n        const result = [ previousPoint ];\n\n        for (let idx = 1; idx < points.length; idx++) {\n            const point = toGeometryPoint(points[idx], stepAxis, stepDir, axis, dir);\n\n            if (previousPoint[stepAxis] !== point[stepAxis]) {\n                const stepPoint = new main[\"b\" /* geometry */].Point();\n                stepPoint[stepAxis] = previousPoint[stepAxis];\n                stepPoint[axis] = point[axis];\n\n                result.push(stepPoint, point);\n            }\n\n            previousPoint = point;\n        }\n\n        if (!justified) {\n            result.push(toGeometryPoint(last(points), stepAxis, stepDir, axis, reverse ? 1 : 2));\n        } else if (previousPoint !== last(result)) {\n            result.push(previousPoint);\n        }\n\n        return result;\n\n    }\n};\n\nfunction toGeometryPoint(lintPoint, stepAxis, stepDir, axis, dir) {\n    const box = lintPoint.box;\n    const result = new main[\"b\" /* geometry */].Point();\n\n    result[stepAxis] = box[stepAxis + stepDir];\n    result[axis] = box[axis + dir];\n\n    return result;\n}\n\n/* harmony default export */ var step_line_mixin = (StepLineMixin);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/line-chart/step-line-segment.js\n\n\n\n\nclass step_line_segment_StepLineSegment extends line_segment {\n    points() {\n        return this.calculateStepPoints(this.linePoints);\n    }\n}\n\ndeepExtend(step_line_segment_StepLineSegment.prototype, step_line_mixin);\n\n/* harmony default export */ var step_line_segment = (step_line_segment_StepLineSegment);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/line-chart/spline-segment.js\n\n\n\n\n\n\n\n\nclass spline_segment_SplineSegment extends line_segment {\n    segmentVisual() {\n        const series = this.series;\n        const defaults = series._defaults;\n        let color = series.color;\n\n        if (isFunction(color) && defaults) {\n            color = defaults.color;\n        }\n\n        const curveProcessor = new curve_processor(this.options.closed);\n        const segments = curveProcessor.process(this.points());\n        const curve = new main[\"a\" /* drawing */].Path({\n            stroke: {\n                color: color,\n                width: series.width,\n                opacity: series.opacity,\n                dashType: series.dashType\n            },\n            zIndex: series.zIndex\n        });\n\n        curve.segments.push.apply(curve.segments, segments);\n\n        this.visual = curve;\n    }\n}\n\n/* harmony default export */ var spline_segment = (spline_segment_SplineSegment);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/mixins/line-chart-mixin.js\n\n\n\n\n\n\nconst LineChartMixin = {\n    renderSegments: function() {\n        const { options, seriesPoints } = this;\n        const series = options.series;\n        const seriesCount = seriesPoints.length;\n        let lastSegment;\n\n        this._segments = [];\n\n        for (let seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n            const currentSeries = series[seriesIx];\n            const sortedPoints = this.sortPoints(seriesPoints[seriesIx]);\n            const pointCount = sortedPoints.length;\n            let linePoints = [];\n\n            for (let pointIx = 0; pointIx < pointCount; pointIx++) {\n                const point = sortedPoints[pointIx];\n                if (point) {\n                    linePoints.push(point);\n                } else if (this.seriesMissingValues(currentSeries) !== INTERPOLATE) {\n                    if (linePoints.length > 1) {\n                        lastSegment = this.createSegment(\n                            linePoints, currentSeries, seriesIx, lastSegment\n                        );\n                        this._addSegment(lastSegment);\n                    }\n                    linePoints = [];\n                }\n            }\n\n            if (linePoints.length > 1) {\n                lastSegment = this.createSegment(\n                    linePoints, currentSeries, seriesIx, lastSegment\n                );\n                this._addSegment(lastSegment);\n            }\n        }\n\n        this.children.unshift.apply(this.children, this._segments);\n    },\n\n    _addSegment: function(segment) {\n        this._segments.push(segment);\n        segment.parent = this;\n    },\n\n    sortPoints: function(points) {\n        return points;\n    },\n\n    seriesMissingValues: function(series) {\n        const missingValues = series.missingValues;\n        const assumeZero = !missingValues && this.options.isStacked;\n\n        return assumeZero ? ZERO : missingValues || INTERPOLATE;\n    },\n\n    getNearestPoint: function(x, y, seriesIx) {\n        const target = new core_point(x, y);\n        const allPoints = this.seriesPoints[seriesIx];\n        let nearestPointDistance = MAX_VALUE;\n        let nearestPoint;\n\n        for (let i = 0; i < allPoints.length; i++) {\n            const point = allPoints[i];\n\n            if (point && defined(point.value) && point.value !== null && point.visible !== false) {\n                const pointBox = point.box;\n                const pointDistance = pointBox.center().distanceTo(target);\n\n                if (pointDistance < nearestPointDistance) {\n                    nearestPoint = point;\n                    nearestPointDistance = pointDistance;\n                }\n            }\n        }\n\n        return nearestPoint;\n    }\n};\n\n/* harmony default export */ var line_chart_mixin = (LineChartMixin);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/animations/clip-animation.js\n\n\n\n\n\n\nclass clip_animation_ClipAnimation extends main[\"a\" /* drawing */].Animation {\n    setup() {\n        this._setEnd(this.options.box.x1);\n    }\n\n    step(pos) {\n        const box = this.options.box;\n        this._setEnd(interpolateValue(box.x1, box.x2, pos));\n    }\n\n    _setEnd(x) {\n        const element = this.element;\n        const segments = element.segments;\n        const topRight = segments[1].anchor();\n        const bottomRight = segments[2].anchor();\n\n        element.suspend();\n        topRight.setX(x);\n        element.resume();\n        bottomRight.setX(x);\n    }\n}\n\nsetDefaultOptions(clip_animation_ClipAnimation, {\n    duration: INITIAL_ANIMATION_DURATION\n});\n\nmain[\"a\" /* drawing */].AnimationFactory.current.register(\"clip\", clip_animation_ClipAnimation);\n\n/* harmony default export */ var clip_animation = (clip_animation_ClipAnimation);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/utils/any-has-z-index.js\n\n\nfunction anyHasZIndex(elements) {\n    for (let idx = 0; idx < elements.length; idx++) {\n        if (defined(elements[idx].zIndex)) {\n            return true;\n        }\n    }\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/mixins/clip-animation-mixin.js\n\n\n\n\n\n\nconst ClipAnimationMixin = {\n    createAnimation: function() {\n        const root = this.getRoot();\n        if (root && (root.options || {}).transitions !== false) {\n            const box = root.size();\n            const clipPath = main[\"a\" /* drawing */].Path.fromRect(box.toRect());\n            this.visual.clip(clipPath);\n            this.animation = new clip_animation(clipPath, {\n                box: box\n            });\n            if (anyHasZIndex(this.options.series)) {\n                this._setChildrenAnimation(clipPath);\n            }\n        }\n    },\n\n    _setChildrenAnimation: function(clipPath) {\n        const points = this.animationPoints();\n\n        for (let idx = 0; idx < points.length; idx++) {\n            const point = points[idx];\n            if (point && point.visual && defined(point.visual.options.zIndex)) {\n                point.visual.clip(clipPath);\n            }\n        }\n    }\n};\n\n/* harmony default export */ var clip_animation_mixin = (ClipAnimationMixin);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/line-chart/line-chart.js\n\n\n\n\n\n\n\n\n\nlet line_chart_LineChart = /*@__PURE__*/ (() => {\n    class LineChart extends categorical_chart {\n        render() {\n            super.render();\n            this.updateStackRange();\n            this.renderSegments();\n        }\n        pointType() {\n            return line_point;\n        }\n        createPoint(data, fields) {\n            const { categoryIx, category, series, seriesIx } = fields;\n            const missingValues = this.seriesMissingValues(series);\n            let value = data.valueFields.value;\n            if (!defined(value) || value === null) {\n                if (missingValues === ZERO) {\n                    value = 0;\n                }\n                else {\n                    return null;\n                }\n            }\n            let pointOptions = this.pointOptions(series, seriesIx);\n            pointOptions = this.evalPointOptions(pointOptions, value, category, categoryIx, series, seriesIx);\n            let color = data.fields.color || series.color;\n            if (isFunction(series.color)) {\n                color = pointOptions.color;\n            }\n            const point = new line_point(value, pointOptions);\n            point.color = color;\n            this.append(point);\n            return point;\n        }\n        plotRange(point) {\n            let plotValue = this.plotValue(point);\n            if (this.options.isStacked) {\n                const categoryIx = point.categoryIx;\n                const categoryPoints = this.categoryPoints[categoryIx];\n                for (let i = 0; i < categoryPoints.length; i++) {\n                    const other = categoryPoints[i];\n                    if (point === other) {\n                        break;\n                    }\n                    plotValue += this.plotValue(other);\n                    if (this.options.isStacked100) {\n                        plotValue = Math.min(plotValue, 1);\n                    }\n                }\n            }\n            return [plotValue, plotValue];\n        }\n        createSegment(linePoints, currentSeries, seriesIx) {\n            const style = currentSeries.style;\n            let pointType;\n            if (style === STEP) {\n                pointType = step_line_segment;\n            }\n            else if (style === SMOOTH) {\n                pointType = spline_segment;\n            }\n            else {\n                pointType = line_segment;\n            }\n            return new pointType(linePoints, currentSeries, seriesIx);\n        }\n        animationPoints() {\n            const points = this.points;\n            const result = [];\n            for (let idx = 0; idx < points.length; idx++) {\n                result.push((points[idx] || {}).marker);\n            }\n            return result.concat(this._segments);\n        }\n        supportsPointInactiveOpacity() {\n            return false;\n        }\n    }\n    deepExtend(LineChart.prototype, line_chart_mixin, clip_animation_mixin);\n    return LineChart;\n})();\n/* harmony default export */ var line_chart = (line_chart_LineChart);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/area-chart/area-segment.js\n\n\n\n\n\nclass area_segment_AreaSegment extends line_segment {\n    constructor(linePoints, currentSeries, seriesIx, prevSegment, stackPoints) {\n        super(linePoints, currentSeries, seriesIx);\n\n        this.prevSegment = prevSegment;\n        this.stackPoints = stackPoints;\n    }\n\n    createVisual() {\n        const series = this.series;\n        const defaults = series._defaults;\n        const lineOptions = series.line || {};\n        let color = series.color;\n\n        if (isFunction(color) && defaults) {\n            color = defaults.color;\n        }\n\n        this.visual = new main[\"a\" /* drawing */].Group({\n            zIndex: series.zIndex\n        });\n\n        this.createFill({\n            fill: {\n                color: color,\n                opacity: series.opacity\n            },\n            stroke: null\n        });\n\n        if (lineOptions.width > 0 && lineOptions.visible !== false) {\n            this.createStroke({\n                stroke: deepExtend({\n                    color: color,\n                    opacity: series.opacity,\n                    lineCap: \"butt\"\n                }, lineOptions)\n            });\n        }\n    }\n\n    strokeSegments() {\n        let segments = this._strokeSegments;\n\n        if (!segments) {\n            segments = this._strokeSegments = this.createStrokeSegments();\n        }\n\n        return segments;\n    }\n\n    createStrokeSegments() {\n        return this.segmentsFromPoints(this.points());\n    }\n\n    stackSegments() {\n        if (this.prevSegment) {\n            return this.prevSegment.createStackSegments(this.stackPoints);\n        }\n\n        return this.createStackSegments(this.stackPoints);\n    }\n\n    createStackSegments(stackPoints) {\n        return this.segmentsFromPoints(this.toGeometryPoints(stackPoints)).reverse();\n    }\n\n    segmentsFromPoints(points) {\n        return points.map((point) => new main[\"b\" /* geometry */].Segment(point));\n    }\n\n    createStroke(style) {\n        const stroke = new main[\"a\" /* drawing */].Path(style);\n        stroke.segments.push.apply(stroke.segments, this.strokeSegments());\n\n        this.visual.append(stroke);\n    }\n\n    hasStackSegment() {\n        return this.prevSegment || (this.stackPoints && this.stackPoints.length);\n    }\n\n    createFill(style) {\n        const strokeSegments = this.strokeSegments();\n        const fillSegments = strokeSegments.slice(0);\n        const hasStackSegments = this.hasStackSegment();\n\n        if (hasStackSegments) {\n            const stackSegments = this.stackSegments();\n\n            append(fillSegments, stackSegments);\n        }\n\n        const fill = new main[\"a\" /* drawing */].Path(style);\n        fill.segments.push.apply(fill.segments, fillSegments);\n\n        if (!hasStackSegments && strokeSegments.length > 1) {\n            this.fillToAxes(fill);\n        }\n\n        this.visual.append(fill);\n    }\n\n    fillToAxes(fillPath) {\n        const chart = this.parent;\n        const invertAxes = chart.options.invertAxes;\n        const valueAxis = chart.seriesValueAxis(this.series);\n        const crossingValue = chart.categoryAxisCrossingValue(valueAxis);\n        const endSlot = valueAxis.getSlot(crossingValue, crossingValue, true);\n        const segments = this.strokeSegments();\n        const firstPoint = segments[0].anchor();\n        const lastPoint = last(segments).anchor();\n        let end = invertAxes ? endSlot.x1 : endSlot.y1;\n\n        if (invertAxes) {\n            fillPath.lineTo(end, lastPoint.y)\n                    .lineTo(end, firstPoint.y);\n        } else {\n            fillPath.lineTo(lastPoint.x, end)\n                    .lineTo(firstPoint.x, end);\n        }\n    }\n}\n\n/* harmony default export */ var area_segment = (area_segment_AreaSegment);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/area-chart/step-area-segment.js\n\n\n\n\n\nclass step_area_segment_StepAreaSegment extends area_segment {\n\n    createStrokeSegments() {\n        return this.segmentsFromPoints(this.calculateStepPoints(this.linePoints));\n    }\n\n    createStackSegments(stackPoints) {\n        return this.segmentsFromPoints(this.calculateStepPoints(stackPoints)).reverse();\n    }\n}\n\ndeepExtend(step_area_segment_StepAreaSegment.prototype, step_line_mixin);\n\n/* harmony default export */ var step_area_segment = (step_area_segment_StepAreaSegment);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/area-chart/spline-area-segment.js\n\n\n\n\n\nclass spline_area_segment_SplineAreaSegment extends area_segment {\n\n    createStrokeSegments() {\n        const curveProcessor = new curve_processor(this.options.closed);\n        const linePoints = this.points();\n\n        return curveProcessor.process(linePoints);\n    }\n\n    createStackSegments() {\n        const strokeSegments = this.strokeSegments();\n        const stackSegments = [];\n        for (let idx = strokeSegments.length - 1; idx >= 0; idx--) {\n            const segment = strokeSegments[idx];\n            stackSegments.push(new main[\"b\" /* geometry */].Segment(\n                segment.anchor(),\n                segment.controlOut(),\n                segment.controlIn()\n            ));\n        }\n\n        return stackSegments;\n    }\n}\n\n/* harmony default export */ var spline_area_segment = (spline_area_segment_SplineAreaSegment);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/area-chart/area-chart.js\n\n\n\n\n\n\n\n\n\nclass area_chart_AreaChart extends line_chart {\n    createSegment(linePoints, currentSeries, seriesIx, prevSegment) {\n        const isStacked = this.options.isStacked;\n        const style = (currentSeries.line || {}).style;\n        let previousSegment;\n\n        let stackPoints;\n        if (isStacked && seriesIx > 0 && prevSegment) {\n            const missingValues = this.seriesMissingValues(currentSeries);\n            if (missingValues !== \"gap\") {\n                stackPoints = prevSegment.linePoints;\n                previousSegment = prevSegment;\n            } else {\n                stackPoints = this._gapStackPoints(linePoints, seriesIx, style);\n            }\n        }\n\n        let pointType;\n        if (style === STEP) {\n            pointType = step_area_segment;\n        } else if (style === SMOOTH) {\n            pointType = spline_area_segment;\n        } else {\n            pointType = area_segment;\n        }\n\n        return new pointType(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);\n    }\n\n    reflow(targetBox) {\n        super.reflow(targetBox);\n\n        const stackPoints = this._stackPoints;\n        if (stackPoints) {\n            for (let idx = 0; idx < stackPoints.length; idx++) {\n                const stackPoint = stackPoints[idx];\n                const pointSlot = this.categoryAxis.getSlot(stackPoint.categoryIx);\n                stackPoint.reflow(pointSlot);\n            }\n        }\n    }\n\n    _gapStackPoints(linePoints, seriesIx, style) {\n        const seriesPoints = this.seriesPoints;\n        let startIdx = linePoints[0].categoryIx;\n        let length = linePoints.length;\n        if (startIdx < 0) {\n            startIdx = 0;\n            length--;\n        }\n\n        const endIdx = startIdx + length;\n        const pointOffset = this.seriesOptions[0]._outOfRangeMinPoint ? 1 : 0;\n        const stackPoints = [];\n\n        this._stackPoints = this._stackPoints || [];\n        for (let categoryIx = startIdx; categoryIx < endIdx; categoryIx++) {\n            const pointIx = categoryIx + pointOffset;\n            let currentSeriesIx = seriesIx;\n            let point;\n\n            do {\n                currentSeriesIx--;\n                point = seriesPoints[currentSeriesIx][pointIx];\n            } while (currentSeriesIx > 0 && !point);\n\n            if (point) {\n                if (style !== STEP && categoryIx > startIdx && !seriesPoints[currentSeriesIx][pointIx - 1]) {\n                    stackPoints.push(this._previousSegmentPoint(categoryIx, pointIx, pointIx - 1, currentSeriesIx));\n                }\n\n                stackPoints.push(point);\n\n                if (style !== STEP && categoryIx + 1 < endIdx && !seriesPoints[currentSeriesIx][pointIx + 1]) {\n                    stackPoints.push(this._previousSegmentPoint(categoryIx, pointIx, pointIx + 1, currentSeriesIx));\n                }\n            } else {\n                const gapStackPoint = this._createGapStackPoint(categoryIx);\n                this._stackPoints.push(gapStackPoint);\n                stackPoints.push(gapStackPoint);\n            }\n        }\n\n        return stackPoints;\n    }\n\n    _previousSegmentPoint(categoryIx, pointIx, segmentIx, seriesIdx) {\n        const seriesPoints = this.seriesPoints;\n        let index = seriesIdx;\n        let point;\n\n        while (index > 0 && !point) {\n            index--;\n            point = seriesPoints[index][segmentIx];\n        }\n\n        if (!point) {\n            point = this._createGapStackPoint(categoryIx);\n            this._stackPoints.push(point);\n        } else {\n            point = seriesPoints[index][pointIx];\n        }\n\n        return point;\n    }\n\n    _createGapStackPoint(categoryIx) {\n        const options = this.pointOptions({}, 0);\n        const point = new line_point(0, options);\n        point.categoryIx = categoryIx;\n        point.series = {};\n\n        return point;\n    }\n\n    seriesMissingValues(series) {\n        return series.missingValues || ZERO;\n    }\n\n    supportsPointInactiveOpacity() {\n        return false;\n    }\n}\n\n/* harmony default export */ var area_chart = (area_chart_AreaChart);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/axis-group-range-tracker.js\n\n\n\nclass axis_group_range_tracker_AxisGroupRangeTracker extends common_class[\"a\" /* default */] {\n    constructor() {\n        super();\n\n        this.axisRanges = {};\n    }\n\n    update(chartAxisRanges) {\n        const axisRanges = this.axisRanges;\n\n        for (let axisName in chartAxisRanges) {\n            const chartRange = chartAxisRanges[axisName];\n            let range = axisRanges[axisName];\n            axisRanges[axisName] = range = range || { min: MAX_VALUE, max: MIN_VALUE };\n\n            range.min = Math.min(range.min, chartRange.min);\n            range.max = Math.max(range.max, chartRange.max);\n        }\n    }\n\n    reset(axisName) {\n        this.axisRanges[axisName] = undefined;\n    }\n\n    query(axisName) {\n        return this.axisRanges[axisName];\n    }\n}\n\n/* harmony default export */ var axis_group_range_tracker = (axis_group_range_tracker_AxisGroupRangeTracker);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/bar-chart/bar-label.js\n\n\n\n\n\n\nclass bar_label_BarLabel extends chart_element {\n    constructor(content, options, pointData) {\n        super(options);\n\n        this.textBox = new text_box(content, this.options, pointData);\n        this.append(this.textBox);\n    }\n\n    createVisual() {\n        this.textBox.options.noclip = this.options.noclip;\n    }\n\n    reflow(targetBox) {\n        const options = this.options;\n        const { vertical, aboveAxis } = options;\n        const text = this.children[0];\n        const textOptions = text.options;\n        const box = text.box;\n        const padding = text.options.padding;\n        let labelBox = targetBox;\n\n        textOptions.align = vertical ? CENTER : LEFT;\n        textOptions.vAlign = vertical ? TOP : CENTER;\n\n        if (options.position === INSIDE_END) {\n            if (vertical) {\n                textOptions.vAlign = TOP;\n\n                if (!aboveAxis && box.height() < targetBox.height()) {\n                    textOptions.vAlign = BOTTOM;\n                }\n            } else {\n                textOptions.align = aboveAxis ? RIGHT : LEFT;\n            }\n        } else if (options.position === CENTER) {\n            textOptions.vAlign = CENTER;\n            textOptions.align = CENTER;\n        } else if (options.position === INSIDE_BASE) {\n            if (vertical) {\n                textOptions.vAlign = aboveAxis ? BOTTOM : TOP;\n            } else {\n                textOptions.align = aboveAxis ? LEFT : RIGHT;\n            }\n        } else if (options.position === OUTSIDE_END) {\n            if (vertical) {\n                if (aboveAxis) {\n                    labelBox = new core_box(\n                        targetBox.x1, targetBox.y1 - box.height(),\n                        targetBox.x2, targetBox.y1\n                    );\n                } else {\n                    labelBox = new core_box(\n                        targetBox.x1, targetBox.y2,\n                        targetBox.x2, targetBox.y2 + box.height()\n                    );\n                }\n            } else {\n                textOptions.align = CENTER;\n                if (aboveAxis) {\n                    labelBox = new core_box(\n                        targetBox.x2, targetBox.y1,\n                        targetBox.x2 + box.width(), targetBox.y2\n                    );\n                } else {\n                    labelBox = new core_box(\n                        targetBox.x1 - box.width(), targetBox.y1,\n                        targetBox.x1, targetBox.y2\n                    );\n                }\n            }\n        }\n\n        if (!options.rotation) {\n            if (vertical) {\n                padding.left = padding.right =\n                    (labelBox.width() - text.contentBox.width()) / 2;\n            } else {\n                padding.top = padding.bottom =\n                    (labelBox.height() - text.contentBox.height()) / 2;\n            }\n        }\n\n        text.reflow(labelBox);\n    }\n\n    alignToClipBox(clipBox) {\n        const vertical = this.options.vertical;\n        const field = vertical ? Y : X;\n        const start = field + \"1\";\n        const end = field + \"2\";\n        const text = this.children[0];\n        const parentBox = this.parent.box;\n\n        if (parentBox[start] < clipBox[start] || clipBox[end] < parentBox[end]) {\n            const targetBox = text.paddingBox.clone();\n            targetBox[start] = Math.max(parentBox[start], clipBox[start]);\n            targetBox[end] = Math.min(parentBox[end], clipBox[end]);\n\n            this.reflow(targetBox);\n        }\n    }\n}\n\nsetDefaultOptions(bar_label_BarLabel, {\n    position: OUTSIDE_END,\n    margin: getSpacing(3),\n    padding: getSpacing(4),\n    color: BLACK,\n    background: \"\",\n    border: {\n        width: 1,\n        color: \"\"\n    },\n    aboveAxis: true,\n    vertical: false,\n    animation: {\n        type: FADEIN,\n        delay: INITIAL_ANIMATION_DURATION\n    },\n    zIndex: 2\n});\n\n/* harmony default export */ var bar_label = (bar_label_BarLabel);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/utils/has-gradient-overlay.js\nfunction hasGradientOverlay(options) {\n    const overlay = options.overlay;\n\n    return overlay && overlay.gradient && overlay.gradient !== \"none\";\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/bar-chart/bar.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst BAR_ALIGN_MIN_WIDTH = 6;\n\nclass bar_Bar extends chart_element {\n    constructor(value, options) {\n        super();\n\n        this.options = options;\n        this.color = options.color || WHITE;\n        this.aboveAxis = valueOrDefault(this.options.aboveAxis, true);\n        this.value = value;\n    }\n\n    render() {\n        if (this._rendered) {\n            return;\n        }\n\n        this._rendered = true;\n\n        this.createLabel();\n        this.createNote();\n\n        if (this.errorBar) {\n            this.append(this.errorBar);\n        }\n    }\n\n    createLabel() {\n        const options = this.options;\n        const labels = options.labels;\n\n        if (labels.visible) {\n            const pointData = this.pointData();\n            let labelTemplate = getTemplate(labels);\n            let labelText;\n\n            if (labelTemplate) {\n                labelText = labelTemplate(pointData);\n            } else {\n                labelText = this.formatValue(labels.format);\n            }\n\n            this.label = new bar_label(labelText,\n                deepExtend({\n                    vertical: options.vertical\n                },\n                labels\n            ), pointData);\n            this.append(this.label);\n        }\n    }\n\n    formatValue(format) {\n        return this.owner.formatPointValue(this, format);\n    }\n\n    reflow(targetBox) {\n        this.render();\n\n        const label = this.label;\n\n        this.box = targetBox;\n\n        if (label) {\n            label.options.aboveAxis = this.aboveAxis;\n            label.reflow(targetBox);\n        }\n\n        if (this.note) {\n            this.note.reflow(targetBox);\n        }\n\n        if (this.errorBars) {\n            for (let i = 0; i < this.errorBars.length; i++) {\n                this.errorBars[i].reflow(targetBox);\n            }\n        }\n    }\n\n    createVisual() {\n        const { box, options } = this;\n        const customVisual = options.visual;\n\n        if (this.visible !== false) {\n            super.createVisual();\n\n            if (customVisual) {\n                const visual = this.rectVisual = customVisual({\n                    category: this.category,\n                    dataItem: this.dataItem,\n                    value: this.value,\n                    sender: this.getSender(),\n                    series: this.series,\n                    percentage: this.percentage,\n                    stackValue: this.stackValue,\n                    runningTotal: this.runningTotal,\n                    total: this.total,\n                    rect: box.toRect(),\n                    createVisual: () => {\n                        const group = new main[\"a\" /* drawing */].Group();\n                        this.createRect(group);\n                        return group;\n                    },\n                    options: options\n                });\n\n                if (visual) {\n                    this.visual.append(visual);\n                }\n            } else if (box.width() > 0 && box.height() > 0) {\n                this.createRect(this.visual);\n            }\n        }\n    }\n\n    createRect(visual) {\n        const options = this.options;\n        const border = options.border;\n        const strokeOpacity = defined(border.opacity) ? border.opacity : options.opacity;\n        const rect = this.box.toRect();\n\n        rect.size.width = Math.round(rect.size.width);\n\n        const path = this.rectVisual = main[\"a\" /* drawing */].Path.fromRect(rect, {\n            fill: {\n                color: this.color,\n                opacity: options.opacity\n            },\n            stroke: {\n                color: this.getBorderColor(),\n                width: border.width,\n                opacity: strokeOpacity,\n                dashType: border.dashType\n            }\n        });\n\n        const width = this.box.width();\n        const height = this.box.height();\n\n        const size = options.vertical ? width : height;\n\n        if (size > BAR_ALIGN_MIN_WIDTH) {\n            alignPathToPixel(path);\n\n            // Fixes lineJoin issue in firefox when the joined lines are parallel\n            if (width < 1 || height < 1) {\n                path.options.stroke.lineJoin = \"round\";\n            }\n        }\n\n        visual.append(path);\n\n        if (hasGradientOverlay(options)) {\n            const overlay = this.createGradientOverlay(path, { baseColor: this.color }, deepExtend({\n                end: !options.vertical ? [ 0, 1 ] : undefined\n            }, options.overlay));\n\n            visual.append(overlay);\n        }\n    }\n\n    createHighlight(style) {\n        const highlight = main[\"a\" /* drawing */].Path.fromRect(this.box.toRect(), style);\n\n        return alignPathToPixel(highlight);\n    }\n\n    highlightVisual() {\n        return this.rectVisual;\n    }\n\n    highlightVisualArgs() {\n        return {\n            options: this.options,\n            rect: this.box.toRect(),\n            visual: this.rectVisual\n        };\n    }\n\n    getBorderColor() {\n        const color = this.color;\n        const border = this.options.border;\n        const brightness = border._brightness || BORDER_BRIGHTNESS;\n        let borderColor = border.color;\n\n        if (!defined(borderColor)) {\n            borderColor = new color_color[\"a\" /* default */](color).brightness(brightness).toHex();\n        }\n\n        return borderColor;\n    }\n\n    tooltipAnchor() {\n        const { options, box, aboveAxis } = this;\n        const clipBox = this.owner.pane.clipBox() || box;\n        let horizontalAlign = LEFT;\n        let verticalAlign = TOP;\n        let x, y;\n\n        if (options.vertical) {\n            x = Math.min(box.x2, clipBox.x2) + TOOLTIP_OFFSET;\n            if (aboveAxis) {\n                y = Math.max(box.y1, clipBox.y1);\n            } else {\n                y = Math.min(box.y2, clipBox.y2);\n                verticalAlign = BOTTOM;\n            }\n        } else {\n            const x1 = Math.max(box.x1, clipBox.x1);\n            const x2 = Math.min(box.x2, clipBox.x2);\n\n            if (options.isStacked) {\n                verticalAlign = BOTTOM;\n                if (aboveAxis) {\n                    horizontalAlign = RIGHT;\n                    x = x2;\n                } else {\n                    x = x1;\n                }\n                y = Math.max(box.y1, clipBox.y1) - TOOLTIP_OFFSET;\n            } else {\n                if (aboveAxis) {\n                    x = x2 + TOOLTIP_OFFSET;\n                } else {\n                    x = x1 - TOOLTIP_OFFSET;\n                    horizontalAlign = RIGHT;\n                }\n                y = Math.max(box.y1, clipBox.y1);\n            }\n        }\n\n        return {\n            point: new core_point(x, y),\n            align: {\n                horizontal: horizontalAlign,\n                vertical: verticalAlign\n            }\n        };\n    }\n\n    overlapsBox(box) {\n        return this.box.overlaps(box);\n    }\n\n    pointData() {\n        return {\n            dataItem: this.dataItem,\n            category: this.category,\n            value: this.value,\n            percentage: this.percentage,\n            stackValue: this.stackValue,\n            runningTotal: this.runningTotal,\n            total: this.total,\n            series: this.series\n        };\n    }\n}\n\ndeepExtend(bar_Bar.prototype, point_events_mixin);\ndeepExtend(bar_Bar.prototype, note_mixin);\n\nbar_Bar.prototype.defaults = {\n    border: {\n        width: 1\n    },\n    vertical: true,\n    overlay: {\n        gradient: \"glass\"\n    },\n    labels: {\n        visible: false,\n        format: \"{0}\"\n    },\n    opacity: 1,\n    notes: {\n        label: {}\n    }\n};\n\n/* harmony default export */ var bar = (bar_Bar);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/layout/utils.js\nfunction forEach(elements, callback) {\n    elements.forEach(callback);\n}\n\nfunction forEachReverse(elements, callback) {\n    const length = elements.length;\n\n    for (let idx = length - 1; idx >= 0; idx--) {\n        callback(elements[idx], idx - length - 1);\n    }\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/layout/cluster-layout.js\n\n\n\n\n\n\nclass cluster_layout_ClusterLayout extends chart_element {\n    constructor(options) {\n        super(options);\n\n        this.forEach = options.rtl ? forEachReverse : forEach;\n    }\n\n    reflow(box) {\n        const { vertical, gap, spacing } = this.options;\n        const children = this.children;\n        const count = children.length;\n        const axis = vertical ? Y : X;\n        const slots = count + gap + (spacing * (count - 1));\n        const slotSize = (vertical ? box.height() : box.width()) / slots;\n        let position = box[axis + 1] + slotSize * (gap / 2);\n\n        this.forEach(children, (child, idx) => {\n            const childBox = (child.box || box).clone();\n\n            childBox[axis + 1] = position;\n            childBox[axis + 2] = position + slotSize;\n\n            child.reflow(childBox);\n            if (idx < count - 1) {\n                position += (slotSize * spacing);\n            }\n\n            position += slotSize;\n        });\n    }\n}\n\nsetDefaultOptions(cluster_layout_ClusterLayout, {\n    vertical: false,\n    gap: 0,\n    spacing: 0\n});\n\n/* harmony default export */ var cluster_layout = (cluster_layout_ClusterLayout);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/layout/stack-wrap.js\n\n\n\n\n\nclass stack_wrap_StackWrap extends chart_element {\n    reflow(targetBox) {\n        const positionAxis = this.options.vertical ? X : Y;\n        const children = this.children;\n        const childrenCount = children.length;\n        let box = this.box = new core_box();\n\n        for (let i = 0; i < childrenCount; i++) {\n            const currentChild = children[i];\n\n            if (currentChild.visible !== false) {\n                const childBox = currentChild.box.clone();\n                childBox.snapTo(targetBox, positionAxis);\n\n                if (i === 0) {\n                    box = this.box = childBox.clone();\n                }\n\n                currentChild.reflow(childBox);\n                box.wrap(childBox);\n            }\n        }\n    }\n}\n\nsetDefaultOptions(stack_wrap_StackWrap, {\n    vertical: true\n});\n\n/* harmony default export */ var stack_wrap = (stack_wrap_StackWrap);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/bar-chart/bar-chart.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass bar_chart_BarChart extends categorical_chart {\n\n    render() {\n        super.render();\n        this.updateStackRange();\n    }\n\n    pointType() {\n        return bar;\n    }\n\n    clusterType() {\n        return cluster_layout;\n    }\n\n    stackType() {\n        return stack_wrap;\n    }\n\n    stackLimits(axisName, stackName) {\n        const limits = super.stackLimits(axisName, stackName);\n\n        return limits;\n    }\n\n    createPoint(data, fields) {\n        const { categoryIx, category, series, seriesIx } = fields;\n        const { options, children } = this;\n        const isStacked = options.isStacked;\n        const value = this.pointValue(data);\n        let pointOptions = this.pointOptions(series, seriesIx);\n\n        const labelOptions = pointOptions.labels;\n        if (isStacked) {\n            if (labelOptions.position === OUTSIDE_END) {\n                labelOptions.position = INSIDE_END;\n            }\n        }\n\n        pointOptions.isStacked = isStacked;\n\n        let color = data.fields.color || series.color;\n        if (value < 0 && pointOptions.negativeColor) {\n            color = pointOptions.negativeColor;\n        }\n\n        pointOptions = this.evalPointOptions(\n            pointOptions, value, category, categoryIx, series, seriesIx\n        );\n\n        if (isFunction(series.color)) {\n            color = pointOptions.color;\n        }\n\n        const pointType = this.pointType();\n        const point = new pointType(value, pointOptions);\n        point.color = color;\n\n        let cluster = children[categoryIx];\n        if (!cluster) {\n            const clusterType = this.clusterType();\n            cluster = new clusterType({\n                vertical: options.invertAxes,\n                gap: options.gap,\n                spacing: options.spacing,\n                rtl: !options.invertAxes && (this.chartService || {}).rtl\n            });\n            this.append(cluster);\n        }\n\n        if (isStacked) {\n            const stackWrap = this.getStackWrap(series, cluster);\n            stackWrap.append(point);\n        } else {\n            cluster.append(point);\n        }\n\n        return point;\n    }\n\n    getStackWrap(series, cluster) {\n        const stack = series.stack;\n        const stackGroup = stack ? stack.group || stack : stack;\n        const wraps = cluster.children;\n        let stackWrap;\n\n        if (typeof stackGroup === STRING) {\n            for (let i = 0; i < wraps.length; i++) {\n                if (wraps[i]._stackGroup === stackGroup) {\n                    stackWrap = wraps[i];\n                    break;\n                }\n            }\n        } else {\n            stackWrap = wraps[0];\n        }\n\n        if (!stackWrap) {\n            const stackType = this.stackType();\n            stackWrap = new stackType({\n                vertical: !this.options.invertAxes\n            });\n            stackWrap._stackGroup = stackGroup;\n            cluster.append(stackWrap);\n        }\n\n        return stackWrap;\n    }\n\n    categorySlot(categoryAxis, categoryIx, valueAxis) {\n        const options = this.options;\n        const categorySlot = categoryAxis.getSlot(categoryIx);\n        const startValue = valueAxis.startValue();\n\n        if (options.isStacked) {\n            const zeroSlot = valueAxis.getSlot(startValue, startValue, true);\n            const stackAxis = options.invertAxes ? X : Y;\n            categorySlot[stackAxis + 1] = categorySlot[stackAxis + 2] = zeroSlot[stackAxis + 1];\n        }\n\n        return categorySlot;\n    }\n\n    reflowCategories(categorySlots) {\n        const children = this.children;\n        const childrenLength = children.length;\n\n        for (let i = 0; i < childrenLength; i++) {\n            children[i].reflow(categorySlots[i]);\n        }\n    }\n\n    createAnimation() {\n        this._setAnimationOptions();\n        super.createAnimation();\n\n        if (anyHasZIndex(this.options.series)) {\n            this._setChildrenAnimation();\n        }\n    }\n\n    _setChildrenAnimation() {\n        const points = this.points;\n\n        for (let idx = 0; idx < points.length; idx++) {\n            const point = points[idx];\n            const pointVisual = point.visual;\n            if (pointVisual && defined(pointVisual.options.zIndex)) {\n                point.options.animation = this.options.animation;\n                point.createAnimation();\n            }\n        }\n    }\n\n    _setAnimationOptions() {\n        const options = this.options;\n        const animation = options.animation || {};\n        let origin;\n\n        if (options.isStacked) {\n            const valueAxis = this.seriesValueAxis(options.series[0]);\n            origin = valueAxis.getSlot(valueAxis.startValue());\n        } else {\n            origin = this.categoryAxis.getSlot(0);\n        }\n\n        animation.origin = new main[\"b\" /* geometry */].Point(origin.x1, origin.y1);\n        animation.vertical = !options.invertAxes;\n    }\n}\n\nsetDefaultOptions(bar_chart_BarChart, {\n    animation: {\n        type: BAR\n    }\n});\n\n/* harmony default export */ var bar_chart = (bar_chart_BarChart);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/candlestick-chart/candlestick.js\n\n\n\n\n\n\n\n\n\n\n\n\nclass candlestick_Candlestick extends chart_element {\n    constructor(value, options) {\n        super(options);\n        this.value = value;\n    }\n\n    reflow(box) {\n        const { options, value, owner: chart } = this;\n        const valueAxis = chart.seriesValueAxis(options);\n        const ocSlot = valueAxis.getSlot(value.open, value.close);\n        const lhSlot = valueAxis.getSlot(value.low, value.high);\n\n        ocSlot.x1 = lhSlot.x1 = box.x1;\n        ocSlot.x2 = lhSlot.x2 = box.x2;\n\n        this.realBody = ocSlot;\n\n        const mid = lhSlot.center().x;\n        const points = [];\n\n        points.push([ [ mid, lhSlot.y1 ], [ mid, ocSlot.y1 ] ]);\n        points.push([ [ mid, ocSlot.y2 ], [ mid, lhSlot.y2 ] ]);\n\n        this.lines = points;\n\n        this.box = lhSlot.clone().wrap(ocSlot);\n\n        if (!this._rendered) {\n            this._rendered = true;\n            this.createNote();\n        }\n\n        this.reflowNote();\n    }\n\n    reflowNote() {\n        if (this.note) {\n            this.note.reflow(this.box);\n        }\n    }\n\n    createVisual() {\n        super.createVisual();\n        this._mainVisual = this.mainVisual(this.options);\n        this.visual.append(\n            this._mainVisual\n        );\n\n        this.createOverlay();\n    }\n\n    mainVisual(options) {\n        const group = new main[\"a\" /* drawing */].Group();\n\n        this.createBody(group, options);\n        this.createLines(group, options);\n\n        return group;\n    }\n\n    createBody(container, options) {\n        const body = main[\"a\" /* drawing */].Path.fromRect(this.realBody.toRect(), {\n            fill: {\n                color: this.color,\n                opacity: options.opacity\n            },\n            stroke: null\n        });\n\n        if (options.border.width > 0) {\n            body.options.set(\"stroke\", {\n                color: this.getBorderColor(),\n                width: options.border.width,\n                dashType: options.border.dashType,\n                opacity: valueOrDefault(options.border.opacity, options.opacity)\n            });\n        }\n\n        alignPathToPixel(body);\n        container.append(body);\n\n        if (hasGradientOverlay(options)) {\n            container.append(this.createGradientOverlay(body, { baseColor: this.color }, deepExtend({\n                end: !options.vertical ? [ 0, 1 ] : undefined\n            }, options.overlay)));\n        }\n    }\n\n    createLines(container, options) {\n        this.drawLines(container, options, this.lines, options.line);\n    }\n\n    drawLines(container, options, lines, lineOptions) {\n        if (!lines) {\n            return;\n        }\n\n        const lineStyle = {\n            stroke: {\n                color: lineOptions.color || this.color,\n                opacity: valueOrDefault(lineOptions.opacity, options.opacity),\n                width: lineOptions.width,\n                dashType: lineOptions.dashType,\n                lineCap: \"butt\"\n            }\n        };\n\n        for (let i = 0; i < lines.length; i++) {\n            const line = main[\"a\" /* drawing */].Path.fromPoints(lines[i], lineStyle);\n            alignPathToPixel(line);\n            container.append(line);\n        }\n    }\n\n    getBorderColor() {\n        const border = this.options.border;\n        let borderColor = border.color;\n\n        if (!defined(borderColor)) {\n            borderColor = new color_color[\"a\" /* default */](this.color).brightness(border._brightness).toHex();\n        }\n\n        return borderColor;\n    }\n\n    createOverlay() {\n        const overlay = main[\"a\" /* drawing */].Path.fromRect(this.box.toRect(), {\n            fill: {\n                color: WHITE,\n                opacity: 0\n            },\n            stroke: null\n        });\n\n        this.visual.append(overlay);\n    }\n\n    createHighlight() {\n        const highlight = this.options.highlight;\n        const normalColor = this.color;\n\n        this.color = highlight.color || this.color;\n        const overlay = this.mainVisual(\n            deepExtend({}, this.options, {\n                line: {\n                    color: this.getBorderColor()\n                }\n            }, highlight)\n        );\n        this.color = normalColor;\n\n        return overlay;\n    }\n\n    highlightVisual() {\n        return this._mainVisual;\n    }\n\n    highlightVisualArgs() {\n        return {\n            options: this.options,\n            rect: this.box.toRect(),\n            visual: this._mainVisual\n        };\n    }\n\n    tooltipAnchor() {\n        const box = this.box;\n        const clipBox = this.owner.pane.clipBox() || box;\n\n        return {\n            point: new core_point(box.x2 + TOOLTIP_OFFSET, Math.max(box.y1, clipBox.y1) + TOOLTIP_OFFSET),\n            align: {\n                horizontal: LEFT,\n                vertical: TOP\n            }\n        };\n    }\n\n    formatValue(format) {\n        return this.owner.formatPointValue(this, format);\n    }\n\n    overlapsBox(box) {\n        return this.box.overlaps(box);\n    }\n}\n\nsetDefaultOptions(candlestick_Candlestick, {\n    vertical: true,\n    border: {\n        _brightness: 0.8\n    },\n    line: {\n        width: 2\n    },\n    overlay: {\n        gradient: \"glass\"\n    },\n    tooltip: {\n        format: \"<table>\" +\n                    \"<tr><th colspan='2'>{4:d}</th></tr>\" +\n                    \"<tr><td>Open:</td><td>{0:C}</td></tr>\" +\n                    \"<tr><td>High:</td><td>{1:C}</td></tr>\" +\n                    \"<tr><td>Low:</td><td>{2:C}</td></tr>\" +\n                    \"<tr><td>Close:</td><td>{3:C}</td></tr>\" +\n                \"</table>\"\n    },\n    highlight: {\n        opacity: 1,\n        border: {\n            width: 1,\n            opacity: 1\n        },\n        line: {\n            width: 1,\n            opacity: 1\n        }\n    },\n    notes: {\n        visible: true,\n        label: {}\n    }\n});\n\ndeepExtend(candlestick_Candlestick.prototype, point_events_mixin);\ndeepExtend(candlestick_Candlestick.prototype, note_mixin);\n\n/* harmony default export */ var candlestick = (candlestick_Candlestick);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/utils/are-numbers.js\n\n\nfunction areNumbers(values) {\n    return countNumbers(values) === values.length;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/candlestick-chart/candlestick-chart.js\n\n\n\n\n\n\n\n\n\n\n\nclass candlestick_chart_CandlestickChart extends categorical_chart {\n\n    reflowCategories(categorySlots) {\n        const children = this.children;\n        const childrenLength = children.length;\n\n        for (let i = 0; i < childrenLength; i++) {\n            children[i].reflow(categorySlots[i]);\n        }\n    }\n\n    addValue(data, fields) {\n        const { categoryIx, category, series, seriesIx } = fields;\n        const { children, options } = this;\n        const value = data.valueFields;\n        const valueParts = this.splitValue(value);\n        const hasValue = areNumbers(valueParts);\n        const dataItem = series.data[categoryIx];\n        let categoryPoints = this.categoryPoints[categoryIx];\n        let point;\n\n        if (!categoryPoints) {\n            this.categoryPoints[categoryIx] = categoryPoints = [];\n        }\n\n        if (hasValue) {\n            point = this.createPoint(data, fields);\n        }\n\n        let cluster = children[categoryIx];\n        if (!cluster) {\n            cluster = new cluster_layout({\n                vertical: options.invertAxes,\n                gap: options.gap,\n                spacing: options.spacing,\n                rtl: !options.invertAxes && (this.chartService || {}).rtl\n            });\n            this.append(cluster);\n        }\n\n        if (point) {\n            this.updateRange(value, fields);\n\n            cluster.append(point);\n\n            point.categoryIx = categoryIx;\n            point.category = category;\n            point.series = series;\n            point.seriesIx = seriesIx;\n            point.owner = this;\n            point.dataItem = dataItem;\n            point.noteText = data.fields.noteText;\n        }\n\n        this.points.push(point);\n        categoryPoints.push(point);\n    }\n\n    pointType() {\n        return candlestick;\n    }\n\n    createPoint(data, fields) {\n        const { categoryIx, category, series, seriesIx } = fields;\n        const pointType = this.pointType();\n        const value = data.valueFields;\n        let pointOptions = deepExtend({}, series);\n        let color = data.fields.color || series.color;\n\n        pointOptions = this.evalPointOptions(\n            pointOptions, value, category, categoryIx, series, seriesIx\n        );\n\n        if (series.type === CANDLESTICK) {\n            if (value.open > value.close) {\n                color = data.fields.downColor || series.downColor || series.color;\n            }\n        }\n\n        if (isFunction(series.color)) {\n            color = pointOptions.color;\n        }\n\n        pointOptions.vertical = !this.options.invertAxes;\n\n        const point = new pointType(value, pointOptions);\n        point.color = color;\n\n        return point;\n    }\n\n    splitValue(value) {\n        return [ value.low, value.open, value.close, value.high ];\n    }\n\n    updateRange(value, fields) {\n        const axisName = fields.series.axis;\n        const parts = this.splitValue(value);\n        let axisRange = this.valueAxisRanges[axisName];\n\n        axisRange = this.valueAxisRanges[axisName] =\n            axisRange || { min: MAX_VALUE, max: MIN_VALUE };\n\n        axisRange = this.valueAxisRanges[axisName] = {\n            min: Math.min.apply(Math, parts.concat([ axisRange.min ])),\n            max: Math.max.apply(Math, parts.concat([ axisRange.max ]))\n        };\n    }\n\n    formatPointValue(point, format) {\n        const value = point.value;\n\n        return this.chartService.format.auto(format,\n            value.open, value.high,\n            value.low, value.close, point.category\n        );\n    }\n\n    animationPoints() {\n        return this.points;\n    }\n}\n\ndeepExtend(candlestick_chart_CandlestickChart.prototype, clip_animation_mixin);\n\n/* harmony default export */ var candlestick_chart = (candlestick_chart_CandlestickChart);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/box-plot-chart/box-plot.js\n\n\n\n\n\n\n\n\n\n\n\nclass box_plot_BoxPlot extends candlestick {\n    constructor(value, options) {\n        super(value, options);\n\n        this.createNote();\n    }\n\n    reflow(box) {\n        const { options, value, owner: chart } = this;\n        const valueAxis = chart.seriesValueAxis(options);\n        let whiskerSlot, boxSlot;\n\n        this.boxSlot = boxSlot = valueAxis.getSlot(value.q1, value.q3);\n        this.realBody = boxSlot;\n        this.reflowBoxSlot(box);\n\n        this.whiskerSlot = whiskerSlot = valueAxis.getSlot(value.lower, value.upper);\n        this.reflowWhiskerSlot(box);\n\n        const medianSlot = valueAxis.getSlot(value.median);\n\n        if (value.mean) {\n            const meanSlot = valueAxis.getSlot(value.mean);\n            this.meanPoints = this.calcMeanPoints(box, meanSlot);\n        }\n\n        this.whiskerPoints = this.calcWhiskerPoints(boxSlot, whiskerSlot);\n        this.medianPoints = this.calcMedianPoints(box, medianSlot);\n\n        this.box = whiskerSlot.clone().wrap(boxSlot);\n        this.reflowNote();\n    }\n\n    reflowBoxSlot(box) {\n        this.boxSlot.x1 = box.x1;\n        this.boxSlot.x2 = box.x2;\n    }\n\n    reflowWhiskerSlot(box) {\n        this.whiskerSlot.x1 = box.x1;\n        this.whiskerSlot.x2 = box.x2;\n    }\n\n    calcMeanPoints(box, meanSlot) {\n        return [\n            [ [ box.x1, meanSlot.y1 ], [ box.x2, meanSlot.y1 ] ]\n        ];\n    }\n\n    calcWhiskerPoints(boxSlot, whiskerSlot) {\n        const mid = whiskerSlot.center().x;\n        return [ [\n            [ mid - 5, whiskerSlot.y1 ], [ mid + 5, whiskerSlot.y1 ],\n            [ mid, whiskerSlot.y1 ], [ mid, boxSlot.y1 ]\n        ], [\n            [ mid - 5, whiskerSlot.y2 ], [ mid + 5, whiskerSlot.y2 ],\n            [ mid, whiskerSlot.y2 ], [ mid, boxSlot.y2 ]\n        ] ];\n    }\n\n    calcMedianPoints(box, medianSlot) {\n        return [\n            [ [ box.x1, medianSlot.y1 ], [ box.x2, medianSlot.y1 ] ]\n        ];\n    }\n\n    renderOutliers(options) {\n        const value = this.value;\n        const outliers = value.outliers || [];\n        const outerFence = Math.abs(value.q3 - value.q1) * 3;\n        const elements = [];\n        let markers = options.markers || {};\n\n        for (let i = 0; i < outliers.length; i++) {\n            const outlierValue = outliers[i];\n            if (outlierValue < value.q3 + outerFence && outlierValue > value.q1 - outerFence) {\n                markers = options.outliers;\n            } else {\n                markers = options.extremes;\n            }\n            let markersBorder = deepExtend({}, markers.border);\n\n            if (!defined(markersBorder.color)) {\n                if (defined(this.color)) {\n                    markersBorder.color = this.color;\n                } else {\n                    markersBorder.color =\n                        new color_color[\"a\" /* default */](markers.background).brightness(BORDER_BRIGHTNESS).toHex();\n                }\n            }\n\n            const shape = new shape_element({\n                type: markers.type,\n                width: markers.size,\n                height: markers.size,\n                rotation: markers.rotation,\n                background: markers.background,\n                border: markersBorder,\n                opacity: markers.opacity\n            });\n\n            shape.value = outlierValue;\n\n            elements.push(shape);\n        }\n\n        this.reflowOutliers(elements);\n        return elements;\n    }\n\n    reflowOutliers(outliers) {\n        const valueAxis = this.owner.seriesValueAxis(this.options);\n        const center = this.box.center();\n\n        for (let i = 0; i < outliers.length; i++) {\n            const outlierValue = outliers[i].value;\n            const markerBox = valueAxis.getSlot(outlierValue);\n\n            if (this.options.vertical) {\n                markerBox.move(center.x);\n            } else {\n                markerBox.move(undefined, center.y);\n            }\n\n            this.box = this.box.wrap(markerBox);\n            outliers[i].reflow(markerBox);\n        }\n    }\n\n    mainVisual(options) {\n        const group = super.mainVisual(options);\n        const outliers = this.renderOutliers(options);\n\n        for (let i = 0; i < outliers.length; i++) {\n            const element = outliers[i].getElement();\n            if (element) {\n                group.append(element);\n            }\n        }\n\n        return group;\n    }\n\n    createLines(container, options) {\n        this.drawLines(container, options, this.whiskerPoints, options.whiskers);\n        this.drawLines(container, options, this.medianPoints, options.median);\n        this.drawLines(container, options, this.meanPoints, options.mean);\n    }\n\n    getBorderColor() {\n        if ((this.options.border || {}).color) {\n            return this.options.border.color;\n        }\n\n        if (this.color) {\n            return this.color;\n        }\n\n        return super.getBorderColor();\n    }\n}\n\nsetDefaultOptions(box_plot_BoxPlot, {\n    border: {\n        _brightness: 0.8\n    },\n    line: {\n        width: 2\n    },\n    median: {\n        color: \"#f6f6f6\"\n    },\n    mean: {\n        width: 2,\n        dashType: \"dash\",\n        color: \"#f6f6f6\"\n    },\n    overlay: {\n        gradient: \"glass\"\n    },\n    tooltip: {\n        format: \"<table>\" +\n                    \"<tr><th colspan='2'>{6:d}</th></tr>\" +\n                    \"<tr><td>Lower:</td><td>{0:C}</td></tr>\" +\n                    \"<tr><td>Q1:</td><td>{1:C}</td></tr>\" +\n                    \"<tr><td>Median:</td><td>{2:C}</td></tr>\" +\n                    \"<tr><td>Mean:</td><td>{5:C}</td></tr>\" +\n                    \"<tr><td>Q3:</td><td>{3:C}</td></tr>\" +\n                    \"<tr><td>Upper:</td><td>{4:C}</td></tr>\" +\n                \"</table>\"\n    },\n    highlight: {\n        opacity: 1,\n        border: {\n            width: 1,\n            opacity: 1\n        },\n        line: {\n            width: 1,\n            opacity: 1\n        }\n    },\n    notes: {\n        visible: true,\n        label: {}\n    },\n    outliers: {\n        visible: true,\n        size: LINE_MARKER_SIZE,\n        type: CROSS,\n        background: WHITE,\n        border: {\n            width: 2,\n            opacity: 1\n        },\n        opacity: 0\n    },\n    extremes: {\n        visible: true,\n        size: LINE_MARKER_SIZE,\n        type: CIRCLE,\n        background: WHITE,\n        border: {\n            width: 2,\n            opacity: 1\n        },\n        opacity: 0\n    }\n});\n\ndeepExtend(box_plot_BoxPlot.prototype, point_events_mixin);\n\n/* harmony default export */ var box_plot = (box_plot_BoxPlot);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/box-plot-chart/vertical-box-plot.js\n\n\nclass vertical_box_plot_VerticalBoxPlot extends box_plot {\n    reflowBoxSlot(box) {\n        this.boxSlot.y1 = box.y1;\n        this.boxSlot.y2 = box.y2;\n    }\n\n    reflowWhiskerSlot(box) {\n        this.whiskerSlot.y1 = box.y1;\n        this.whiskerSlot.y2 = box.y2;\n    }\n\n    calcMeanPoints(box, meanSlot) {\n        return [\n            [ [ meanSlot.x1, box.y1 ], [ meanSlot.x1, box.y2 ] ]\n        ];\n    }\n\n    calcWhiskerPoints(boxSlot, whiskerSlot) {\n        const mid = whiskerSlot.center().y;\n        return [ [\n            [ whiskerSlot.x1, mid - 5 ], [ whiskerSlot.x1, mid + 5 ],\n            [ whiskerSlot.x1, mid ], [ boxSlot.x1, mid ]\n        ], [\n            [ whiskerSlot.x2, mid - 5 ], [ whiskerSlot.x2, mid + 5 ],\n            [ whiskerSlot.x2, mid ], [ boxSlot.x2, mid ]\n        ] ];\n    }\n\n    calcMedianPoints(box, medianSlot) {\n        return [\n            [ [ medianSlot.x1, box.y1 ], [ medianSlot.x1, box.y2 ] ]\n        ];\n    }\n}\n\n/* harmony default export */ var vertical_box_plot = (vertical_box_plot_VerticalBoxPlot);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/box-plot-chart/box-plot-chart.js\n\n\n\n\n\n\n\n\n\n\nclass box_plot_chart_BoxPlotChart extends candlestick_chart {\n    addValue(data, fields) {\n        const { categoryIx, category, series, seriesIx } = fields;\n        const { children, options } = this;\n        const value = data.valueFields;\n        const valueParts = this.splitValue(value);\n        const hasValue = areNumbers(valueParts);\n        const dataItem = series.data[categoryIx];\n        let categoryPoints = this.categoryPoints[categoryIx];\n        let point;\n\n        if (!categoryPoints) {\n            this.categoryPoints[categoryIx] = categoryPoints = [];\n        }\n\n        if (hasValue) {\n            point = this.createPoint(data, fields);\n        }\n\n        let cluster = children[categoryIx];\n        if (!cluster) {\n            cluster = new cluster_layout({\n                vertical: options.invertAxes,\n                gap: options.gap,\n                spacing: options.spacing,\n                rtl: !options.invertAxes && (this.chartService || {}).rtl\n            });\n            this.append(cluster);\n        }\n\n        if (point) {\n            this.updateRange(value, fields);\n\n            cluster.append(point);\n\n            point.categoryIx = categoryIx;\n            point.category = category;\n            point.series = series;\n            point.seriesIx = seriesIx;\n            point.owner = this;\n            point.dataItem = dataItem;\n        }\n\n        this.points.push(point);\n        categoryPoints.push(point);\n    }\n\n    pointType() {\n        if (this.options.invertAxes) {\n            return vertical_box_plot;\n        }\n\n        return box_plot;\n    }\n\n    splitValue(value) {\n        return [\n            value.lower, value.q1, value.median,\n            value.q3, value.upper\n        ];\n    }\n\n    updateRange(value, fields) {\n        const axisName = fields.series.axis;\n        let axisRange = this.valueAxisRanges[axisName];\n        let parts = this.splitValue(value).concat(this.filterOutliers(value.outliers));\n\n        if (defined(value.mean)) {\n            parts = parts.concat(value.mean);\n        }\n\n        axisRange = this.valueAxisRanges[axisName] =\n            axisRange || { min: MAX_VALUE, max: MIN_VALUE };\n\n        axisRange = this.valueAxisRanges[axisName] = {\n            min: Math.min.apply(Math, parts.concat([ axisRange.min ])),\n            max: Math.max.apply(Math, parts.concat([ axisRange.max ]))\n        };\n    }\n\n    formatPointValue(point, format) {\n        const value = point.value;\n\n        return this.chartService.format.auto(format,\n            value.lower, value.q1, value.median,\n            value.q3, value.upper, value.mean, point.category\n        );\n    }\n\n    filterOutliers(items) {\n        const length = (items || []).length;\n        const result = [];\n\n        for (let i = 0; i < length; i++) {\n            const item = items[i];\n            if (defined(item) && item !== null) {\n                result.push(item);\n            }\n        }\n\n        return result;\n    }\n\n    supportsPointInactiveOpacity() {\n        return false;\n    }\n}\n\n/* harmony default export */ var box_plot_chart = (box_plot_chart_BoxPlotChart);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/error-bars/scatter-error-bar.js\n\n\nclass scatter_error_bar_ScatterErrorBar extends error_bar_base {\n    getAxis() {\n        const axes = this.chart.seriesAxes(this.series);\n        const axis = this.isVertical ? axes.y : axes.x;\n\n        return axis;\n    }\n}\n\n/* harmony default export */ var scatter_error_bar = (scatter_error_bar_ScatterErrorBar);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/utils/has-value.js\n\n\nfunction has_value_hasValue(value) {\n    return defined(value) && value !== null;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/scatter-charts/scatter-chart.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass scatter_chart_ScatterChart extends chart_element {\n    constructor(plotArea, options) {\n\n        super(options);\n\n        this.plotArea = plotArea;\n        this.chartService = plotArea.chartService;\n        this._initFields();\n\n        this.render();\n    }\n\n    _initFields() {\n        // X and Y axis ranges grouped by name, e.g.:\n        // primary: { min: 0, max: 1 }\n        this.xAxisRanges = {};\n        this.yAxisRanges = {};\n\n        this.points = [];\n        this.seriesPoints = [];\n        this.seriesOptions = [];\n        this._evalSeries = [];\n    }\n\n    render() {\n        this.traverseDataPoints(this.addValue.bind(this));\n    }\n\n    addErrorBar(point, field, fields) {\n        const value = point.value[field];\n        const valueErrorField = field + \"Value\";\n        const lowField = field + \"ErrorLow\";\n        const highField = field + \"ErrorHigh\";\n        const { seriesIx, series } = fields;\n        const errorBars = point.options.errorBars;\n        const lowValue = fields[lowField];\n        const highValue = fields[highField];\n\n        if (isNumber(value)) {\n            let errorRange;\n            if (isNumber(lowValue) && isNumber(highValue)) {\n                errorRange = { low: lowValue, high: highValue };\n            }\n\n            if (errorBars && defined(errorBars[valueErrorField])) {\n                this.seriesErrorRanges = this.seriesErrorRanges || { x: [], y: [] };\n                this.seriesErrorRanges[field][seriesIx] = this.seriesErrorRanges[field][seriesIx] ||\n                    new error_range_calculator(errorBars[valueErrorField], series, field);\n\n                errorRange = this.seriesErrorRanges[field][seriesIx].getErrorRange(value, errorBars[valueErrorField]);\n            }\n\n            if (errorRange) {\n                this.addPointErrorBar(errorRange, point, field);\n            }\n        }\n    }\n\n    addPointErrorBar(errorRange, point, field) {\n        const { low, high } = errorRange;\n        const { series, options: { errorBars: options } } = point;\n        const isVertical = field === Y;\n        const item = {};\n\n        point[field + \"Low\"] = low;\n        point[field + \"High\"] = high;\n\n        point.errorBars = point.errorBars || [];\n        const errorBar = new scatter_error_bar(low, high, isVertical, this, series, options);\n        point.errorBars.push(errorBar);\n        point.append(errorBar);\n\n        item[field] = low;\n        this.updateRange(item, series);\n        item[field] = high;\n        this.updateRange(item, series);\n    }\n\n    addValue(value, fields) {\n        const { x, y } = value;\n        const seriesIx = fields.seriesIx;\n        const series = this.options.series[seriesIx];\n        const missingValues = this.seriesMissingValues(series);\n        const seriesPoints = this.seriesPoints[seriesIx];\n\n        let pointValue = value;\n        if (!(has_value_hasValue(x) && has_value_hasValue(y))) {\n            pointValue = this.createMissingValue(pointValue, missingValues);\n        }\n\n        let point;\n        if (pointValue) {\n            point = this.createPoint(pointValue, fields);\n            if (point) {\n                Object.assign(point, fields);\n                this.addErrorBar(point, X, fields);\n                this.addErrorBar(point, Y, fields);\n            }\n            this.updateRange(pointValue, fields.series);\n        }\n\n        this.points.push(point);\n        seriesPoints.push(point);\n    }\n\n    seriesMissingValues(series) {\n        return series.missingValues;\n    }\n\n    createMissingValue() {}\n\n    updateRange(value, series) {\n        const intlService = this.chartService.intl;\n        const { xAxis: xAxisName, yAxis: yAxisName } = series;\n        let { x, y } = value;\n        let xAxisRange = this.xAxisRanges[xAxisName];\n        let yAxisRange = this.yAxisRanges[yAxisName];\n\n        if (has_value_hasValue(x)) {\n            xAxisRange = this.xAxisRanges[xAxisName] =\n                xAxisRange || { min: MAX_VALUE, max: MIN_VALUE };\n\n            if (isString(x)) {\n                x = parse_date_parseDate(intlService, x);\n            }\n\n            xAxisRange.min = Math.min(xAxisRange.min, x);\n            xAxisRange.max = Math.max(xAxisRange.max, x);\n        }\n\n        if (has_value_hasValue(y)) {\n            yAxisRange = this.yAxisRanges[yAxisName] =\n                yAxisRange || { min: MAX_VALUE, max: MIN_VALUE };\n\n            if (isString(y)) {\n                y = parse_date_parseDate(intlService, y);\n            }\n\n            yAxisRange.min = Math.min(yAxisRange.min, y);\n            yAxisRange.max = Math.max(yAxisRange.max, y);\n        }\n    }\n\n    evalPointOptions(options, value, fields) {\n        const { series, seriesIx } = fields;\n        const state = { defaults: series._defaults, excluded: [ \"data\", \"tooltip\", \"content\", \"template\", \"visual\", \"toggle\", \"_outOfRangeMinPoint\", \"_outOfRangeMaxPoint\" ] };\n\n        let doEval = this._evalSeries[seriesIx];\n        if (!defined(doEval)) {\n            this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);\n        }\n\n        let pointOptions = options;\n        if (doEval) {\n            pointOptions = deepExtend({}, options);\n            evalOptions(pointOptions, {\n                value: value,\n                series: series,\n                dataItem: fields.dataItem\n            }, state);\n        }\n\n        return pointOptions;\n    }\n\n    pointType() {\n        return line_point;\n    }\n\n    pointOptions(series, seriesIx) {\n        let options = this.seriesOptions[seriesIx];\n        if (!options) {\n            const defaults = this.pointType().prototype.defaults;\n            this.seriesOptions[seriesIx] = options = deepExtend({}, defaults, {\n                markers: {\n                    opacity: series.opacity\n                },\n                tooltip: {\n                    format: this.options.tooltip.format\n                },\n                labels: {\n                    format: this.options.labels.format\n                }\n            }, series);\n        }\n\n        return options;\n    }\n\n    createPoint(value, fields) {\n        const series = fields.series;\n        let pointOptions = this.pointOptions(series, fields.seriesIx);\n        let color = fields.color || series.color;\n\n        pointOptions = this.evalPointOptions(pointOptions, value, fields);\n\n        if (isFunction(series.color)) {\n            color = pointOptions.color;\n        }\n\n        const point = new line_point(value, pointOptions);\n        point.color = color;\n\n        this.append(point);\n\n        return point;\n    }\n\n    seriesAxes(series) {\n        const { xAxis: xAxisName, yAxis: yAxisName } = series;\n        const plotArea = this.plotArea;\n        const xAxis = xAxisName ? plotArea.namedXAxes[xAxisName] : plotArea.axisX;\n        const yAxis = yAxisName ? plotArea.namedYAxes[yAxisName] : plotArea.axisY;\n\n        if (!xAxis) {\n            throw new Error(\"Unable to locate X axis with name \" + xAxisName);\n        }\n\n        if (!yAxis) {\n            throw new Error(\"Unable to locate Y axis with name \" + yAxisName);\n        }\n\n        return {\n            x: xAxis,\n            y: yAxis\n        };\n    }\n\n    reflow(targetBox) {\n        const chartPoints = this.points;\n        const limit = !this.options.clip;\n        let pointIx = 0;\n\n\n        this.traverseDataPoints((value, fields) => {\n            const point = chartPoints[pointIx++];\n            const seriesAxes = this.seriesAxes(fields.series);\n            const slotX = seriesAxes.x.getSlot(value.x, value.x, limit);\n            const slotY = seriesAxes.y.getSlot(value.y, value.y, limit);\n\n            if (point) {\n                if (slotX && slotY) {\n                    const pointSlot = this.pointSlot(slotX, slotY);\n                    point.reflow(pointSlot);\n                } else {\n                    point.visible = false;\n                }\n            }\n        });\n\n        this.box = targetBox;\n    }\n\n    pointSlot(slotX, slotY) {\n        return new core_box(slotX.x1, slotY.y1, slotX.x2, slotY.y2);\n    }\n\n    traverseDataPoints(callback) {\n        const { options: { series }, seriesPoints } = this;\n\n        for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {\n            const currentSeries = series[seriesIx];\n            const currentSeriesPoints = seriesPoints[seriesIx];\n            if (!currentSeriesPoints) {\n                seriesPoints[seriesIx] = [];\n            }\n\n            for (let pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {\n                const { valueFields: value, fields } = this._bindPoint(currentSeries, seriesIx, pointIx);\n\n                callback(value, deepExtend({\n                    pointIx: pointIx,\n                    series: currentSeries,\n                    seriesIx: seriesIx,\n                    dataItem: currentSeries.data[pointIx],\n                    owner: this\n                }, fields));\n            }\n        }\n    }\n\n    formatPointValue(point, format) {\n        const value = point.value;\n        return this.chartService.format.auto(format, value.x, value.y);\n    }\n\n    animationPoints() {\n        const points = this.points;\n        const result = [];\n        for (let idx = 0; idx < points.length; idx++) {\n            result.push((points[idx] || {}).marker);\n        }\n        return result;\n    }\n}\nsetDefaultOptions(scatter_chart_ScatterChart, {\n    series: [],\n    tooltip: {\n        format: \"{0}, {1}\"\n    },\n    labels: {\n        format: \"{0}, {1}\"\n    },\n    clip: true\n});\ndeepExtend(scatter_chart_ScatterChart.prototype, clip_animation_mixin, {\n    _bindPoint: categorical_chart.prototype._bindPoint\n});\n\n/* harmony default export */ var scatter_chart = (scatter_chart_ScatterChart);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/bubble-chart/bubble.js\n\n\n\n\n\n\n\n\nclass bubble_Bubble extends line_point {\n    constructor(value, options) {\n        super(value, options);\n\n        this.category = value.category;\n    }\n\n    createHighlight() {\n        const highlight = this.options.highlight;\n        const border = highlight.border;\n        const markers = this.options.markers;\n        const center = this.box.center();\n        const radius = (markers.size + markers.border.width + border.width) / 2;\n        const highlightGroup = new main[\"a\" /* drawing */].Group();\n        const shadow = new main[\"a\" /* drawing */].Circle(new main[\"b\" /* geometry */].Circle([ center.x, center.y + radius / 5 + border.width / 2 ], radius + border.width / 2), {\n            stroke: {\n                color: 'none'\n            },\n            fill: this.createGradient({\n                gradient: 'bubbleShadow',\n                color: markers.background,\n                stops: [ {\n                    offset: 0,\n                    color: markers.background,\n                    opacity: 0.3\n                }, {\n                    offset: 1,\n                    color: markers.background,\n                    opacity: 0\n                } ]\n            })\n        });\n        const overlay = new main[\"a\" /* drawing */].Circle(new main[\"b\" /* geometry */].Circle([ center.x, center.y ], radius), {\n            stroke: {\n                color: border.color ||\n                    new color_color[\"a\" /* default */](markers.background).brightness(BORDER_BRIGHTNESS).toHex(),\n                width: border.width,\n                opacity: border.opacity\n            },\n            fill: {\n                color: markers.background,\n                opacity: highlight.opacity\n            }\n        });\n\n        highlightGroup.append(shadow, overlay);\n\n        return highlightGroup;\n    }\n}\n\nbubble_Bubble.prototype.defaults = deepExtend({}, bubble_Bubble.prototype.defaults, {\n    labels: {\n        position: CENTER\n    },\n    highlight: {\n        opacity: 1,\n        border: {\n            color: \"#fff\",\n            width: 2,\n            opacity: 1\n        }\n    }\n});\n\nbubble_Bubble.prototype.defaults.highlight.zIndex = undefined;\n\n/* harmony default export */ var bubble = (bubble_Bubble);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/bubble-chart/bubble-chart.js\n\n\n\n\n\n\n\n\nclass bubble_chart_BubbleChart extends scatter_chart {\n    _initFields() {\n        this._maxSize = MIN_VALUE;\n        super._initFields();\n    }\n\n    addValue(value, fields) {\n        if (value.size !== null && (value.size > 0 || (value.size < 0 && fields.series.negativeValues.visible))) {\n            this._maxSize = Math.max(this._maxSize, Math.abs(value.size));\n            super.addValue(value, fields);\n        } else {\n            this.points.push(null);\n            this.seriesPoints[fields.seriesIx].push(null);\n        }\n    }\n\n    reflow(box) {\n        this.updateBubblesSize(box);\n        super.reflow(box);\n    }\n\n    pointType() {\n        return bubble;\n    }\n\n    createPoint(value, fields) {\n        const series = fields.series;\n        const pointsCount = series.data.length;\n        const delay = fields.pointIx * (INITIAL_ANIMATION_DURATION / pointsCount);\n        const animationOptions = {\n            delay: delay,\n            duration: INITIAL_ANIMATION_DURATION - delay,\n            type: BUBBLE\n        };\n\n        let color = fields.color || series.color;\n        if (value.size < 0 && series.negativeValues.visible) {\n            color = valueOrDefault(\n                series.negativeValues.color, color\n            );\n        }\n\n        let pointOptions = deepExtend({\n            labels: {\n                animation: {\n                    delay: delay,\n                    duration: INITIAL_ANIMATION_DURATION - delay\n                }\n            }\n        }, this.pointOptions(series, fields.seriesIx), {\n            markers: {\n                type: CIRCLE,\n                border: series.border,\n                opacity: series.opacity,\n                animation: animationOptions\n            }\n        });\n\n        pointOptions = this.evalPointOptions(pointOptions, value, fields);\n        if (isFunction(series.color)) {\n            color = pointOptions.color;\n        }\n\n        pointOptions.markers.background = color;\n\n        const point = new bubble(value, pointOptions);\n        point.color = color;\n\n        this.append(point);\n\n        return point;\n    }\n\n    updateBubblesSize(box) {\n        const { options: { series } } = this;\n        const boxSize = Math.min(box.width(), box.height());\n\n        for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {\n            const currentSeries = series[seriesIx];\n            const seriesPoints = this.seriesPoints[seriesIx];\n            const minSize = currentSeries.minSize || Math.max(boxSize * 0.02, 10);\n            const maxSize = currentSeries.maxSize || boxSize * 0.2;\n            const minR = minSize / 2;\n            const maxR = maxSize / 2;\n            const minArea = Math.PI * minR * minR;\n            const maxArea = Math.PI * maxR * maxR;\n            const areaRange = maxArea - minArea;\n            const areaRatio = areaRange / this._maxSize;\n\n            for (let pointIx = 0; pointIx < seriesPoints.length; pointIx++) {\n                const point = seriesPoints[pointIx];\n                if (point) {\n                    const area = Math.abs(point.value.size) * areaRatio;\n                    const radius = Math.sqrt((minArea + area) / Math.PI);\n                    const baseZIndex = valueOrDefault(point.options.zIndex, 0);\n                    const zIndex = baseZIndex + (1 - radius / maxR);\n\n                    deepExtend(point.options, {\n                        zIndex: zIndex,\n                        markers: {\n                            size: radius * 2,\n                            zIndex: zIndex\n                        },\n                        labels: {\n                            zIndex: zIndex + 1\n                        }\n                    });\n                }\n            }\n        }\n    }\n\n    formatPointValue(point, format) {\n        const value = point.value;\n        return this.chartService.format.auto(format, value.x, value.y, value.size, point.category);\n    }\n\n    createAnimation() {}\n    createVisual() {}\n}\n\nsetDefaultOptions(bubble_chart_BubbleChart, {\n    tooltip: {\n        format: \"{3}\"\n    },\n    labels: {\n        format: \"{3}\"\n    }\n});\n\n/* harmony default export */ var bubble_chart = (bubble_chart_BubbleChart);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/bullet-chart/target.js\n\n\n\n\nclass target_Target extends shape_element { }\n\ndeepExtend(target_Target.prototype, point_events_mixin);\n\n/* harmony default export */ var bullet_chart_target = (target_Target);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/bullet-chart/bullet.js\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass bullet_Bullet extends chart_element {\n    constructor(value, options) {\n        super(options);\n\n        this.aboveAxis = this.options.aboveAxis;\n        this.color = options.color || WHITE;\n        this.value = value;\n    }\n\n    render() {\n        const options = this.options;\n\n        if (!this._rendered) {\n            this._rendered = true;\n\n            if (defined(this.value.target)) {\n                this.target = new bullet_chart_target({\n                    type: options.target.shape,\n                    background: options.target.color || this.color,\n                    opacity: options.opacity,\n                    zIndex: options.zIndex,\n                    border: options.target.border,\n                    vAlign: TOP,\n                    align: RIGHT\n                });\n\n                this.target.value = this.value;\n                this.target.dataItem = this.dataItem;\n                this.target.series = this.series;\n\n                this.append(this.target);\n            }\n\n            this.createNote();\n        }\n    }\n\n    reflow(box) {\n        this.render();\n\n        const { options, target, owner: chart } = this;\n        const invertAxes = options.invertAxes;\n        const valueAxis = chart.seriesValueAxis(this.options);\n        const categorySlot = chart.categorySlot(chart.categoryAxis, options.categoryIx, valueAxis);\n        const targetValueSlot = valueAxis.getSlot(this.value.target);\n        const targetSlotX = invertAxes ? targetValueSlot : categorySlot;\n        const targetSlotY = invertAxes ? categorySlot : targetValueSlot;\n\n        if (target) {\n            const targetSlot = new core_box(\n                targetSlotX.x1, targetSlotY.y1,\n                targetSlotX.x2, targetSlotY.y2\n            );\n            target.options.height = invertAxes ? targetSlot.height() : options.target.line.width;\n            target.options.width = invertAxes ? options.target.line.width : targetSlot.width();\n            target.reflow(targetSlot);\n        }\n\n        if (this.note) {\n            this.note.reflow(box);\n        }\n\n        this.box = box;\n    }\n\n    createVisual() {\n        super.createVisual();\n\n        const options = this.options;\n        const body = main[\"a\" /* drawing */].Path.fromRect(this.box.toRect(), {\n            fill: {\n                color: this.color,\n                opacity: options.opacity\n            },\n            stroke: null\n        });\n\n        if (options.border.width > 0) {\n            body.options.set(\"stroke\", {\n                color: options.border.color || this.color,\n                width: options.border.width,\n                dashType: options.border.dashType,\n                opacity: valueOrDefault(options.border.opacity, options.opacity)\n            });\n        }\n\n        this.bodyVisual = body;\n\n        alignPathToPixel(body);\n        this.visual.append(body);\n    }\n\n    createAnimation() {\n        if (this.bodyVisual) {\n            this.animation = main[\"a\" /* drawing */].Animation.create(\n                this.bodyVisual, this.options.animation\n            );\n        }\n    }\n\n    createHighlight(style) {\n        return main[\"a\" /* drawing */].Path.fromRect(this.box.toRect(), style);\n    }\n\n    highlightVisual() {\n        return this.bodyVisual;\n    }\n\n    highlightVisualArgs() {\n        return {\n            rect: this.box.toRect(),\n            visual: this.bodyVisual,\n            options: this.options\n        };\n    }\n\n    formatValue(format) {\n        return this.owner.formatPointValue(this, format);\n    }\n}\n\nbullet_Bullet.prototype.tooltipAnchor = bar.prototype.tooltipAnchor;\n\nsetDefaultOptions(bullet_Bullet, {\n    border: {\n        width: 1\n    },\n    vertical: false,\n    opacity: 1,\n    target: {\n        shape: \"\",\n        border: {\n            width: 0,\n            color: \"green\"\n        },\n        line: {\n            width: 2\n        }\n    },\n    tooltip: {\n        format: \"Current: {0}<br />Target: {1}\"\n    }\n});\n\ndeepExtend(bullet_Bullet.prototype, point_events_mixin);\ndeepExtend(bullet_Bullet.prototype, note_mixin);\n\n/* harmony default export */ var bullet_chart_bullet = (bullet_Bullet);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/bullet-chart/bullet-chart.js\n\n\n\n\n\n\n\n\n\n\nclass bullet_chart_BulletChart extends categorical_chart {\n    constructor(plotArea, options) {\n\n        wrapData(options);\n\n        super(plotArea, options);\n    }\n\n    reflowCategories(categorySlots) {\n        const children = this.children;\n        const childrenLength = children.length;\n\n        for (let i = 0; i < childrenLength; i++) {\n            children[i].reflow(categorySlots[i]);\n        }\n    }\n\n    plotRange(point) {\n        const series = point.series;\n        const valueAxis = this.seriesValueAxis(series);\n        const axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);\n\n        return [ axisCrossingValue, point.value.current || axisCrossingValue ];\n    }\n\n    createPoint(data, fields) {\n        const { categoryIx, category, series, seriesIx } = fields;\n        const { options, children } = this;\n        const value = data.valueFields;\n\n        let bulletOptions = deepExtend({\n            vertical: !options.invertAxes,\n            overlay: series.overlay,\n            categoryIx: categoryIx,\n            invertAxes: options.invertAxes\n        }, series);\n\n        let color = data.fields.color || series.color;\n        bulletOptions = this.evalPointOptions(\n            bulletOptions, value, category, categoryIx, series, seriesIx\n        );\n\n        if (isFunction(series.color)) {\n            color = bulletOptions.color;\n        }\n\n        const bullet = new bullet_chart_bullet(value, bulletOptions);\n        bullet.color = color;\n\n        let cluster = children[categoryIx];\n        if (!cluster) {\n            cluster = new cluster_layout({\n                vertical: options.invertAxes,\n                gap: options.gap,\n                spacing: options.spacing,\n                rtl: !options.invertAxes && (this.chartService || {}).rtl\n            });\n            this.append(cluster);\n        }\n\n        cluster.append(bullet);\n\n        return bullet;\n    }\n\n    updateRange(value, fields) {\n        const { current, target } = value;\n        const axisName = fields.series.axis;\n        let axisRange = this.valueAxisRanges[axisName];\n\n        if (defined(current) && !isNaN(current) && defined(target && !isNaN(target))) {\n            axisRange = this.valueAxisRanges[axisName] =\n                axisRange || { min: MAX_VALUE, max: MIN_VALUE };\n\n            axisRange.min = Math.min(axisRange.min, current, target);\n            axisRange.max = Math.max(axisRange.max, current, target);\n        }\n    }\n\n    formatPointValue(point, format) {\n        return this.chartService.format.auto(format, point.value.current, point.value.target);\n    }\n\n    pointValue(data) {\n        return data.valueFields.current;\n    }\n\n    aboveAxis(point) {\n        const value = point.value.current;\n\n        return value > 0;\n    }\n\n    createAnimation() {\n        const points = this.points;\n\n        this._setAnimationOptions();\n\n        for (let idx = 0; idx < points.length; idx++) {\n            const point = points[idx];\n            point.options.animation = this.options.animation;\n            point.createAnimation();\n        }\n    }\n}\n\nbullet_chart_BulletChart.prototype._setAnimationOptions = bar_chart.prototype._setAnimationOptions;\n\nsetDefaultOptions(bullet_chart_BulletChart, {\n    animation: {\n        type: BAR\n    }\n});\n\nfunction wrapData(options) {\n    const series = options.series;\n\n    for (let i = 0; i < series.length; i++) {\n        const seriesItem = series[i];\n        const data = seriesItem.data;\n        if (data && !isArray(data[0]) && !isObject(data[0])) {\n            seriesItem.data = [ data ];\n        }\n    }\n}\n\n/* harmony default export */ var bullet_chart = (bullet_chart_BulletChart);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/tooltip/base-tooltip.js\n\n\n\n\n\nclass base_tooltip_BaseTooltip extends common_class[\"a\" /* default */] {\n    constructor(chartService, options) {\n        super();\n\n        this.chartService = chartService;\n        this.options = deepExtend({}, this.options, options);\n    }\n\n    getStyle(options, point) {\n        let { background, border: { color: border } } = options;\n\n        if (point) {\n            const pointColor = point.color || point.options.color;\n            background = valueOrDefault(background, pointColor);\n            border = valueOrDefault(border, pointColor);\n        }\n\n        const padding = getSpacing(options.padding || {}, \"auto\");\n\n        return {\n            backgroundColor: background,\n            borderColor: border,\n            font: options.font,\n            color: options.color,\n            opacity: options.opacity,\n            borderWidth: styleValue(options.border.width),\n            paddingTop: styleValue(padding.top),\n            paddingBottom: styleValue(padding.bottom),\n            paddingLeft: styleValue(padding.left),\n            paddingRight: styleValue(padding.right)\n        };\n    }\n\n    show(options, tooltipOptions, point) {\n        options.format = tooltipOptions.format;\n\n        const style = this.getStyle(tooltipOptions, point);\n        options.style = style;\n\n        if (!defined(tooltipOptions.color) && new color_color[\"a\" /* default */](style.backgroundColor).percBrightness() > 180) {\n            options.className = \"k-chart-tooltip-inverse\";\n        }\n\n        this.chartService.notify(SHOW_TOOLTIP, options);\n\n        this.visible = true;\n    }\n\n    hide() {\n        if (this.chartService) {\n            this.chartService.notify(HIDE_TOOLTIP);\n        }\n\n        this.visible = false;\n    }\n\n    destroy() {\n        delete this.chartService;\n    }\n}\n\nsetDefaultOptions(base_tooltip_BaseTooltip, {\n    border: {\n        width: 1\n    },\n    opacity: 1\n});\n\n/* harmony default export */ var base_tooltip = (base_tooltip_BaseTooltip);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/crosshair/crosshair-tooltip.js\n\n\n\n\n\n\nclass crosshair_tooltip_CrosshairTooltip extends base_tooltip {\n    constructor(chartService, crosshair, options) {\n        super(chartService, options);\n\n        this.crosshair = crosshair;\n        this.formatService = chartService.format;\n        this.initAxisName();\n    }\n\n    initAxisName() {\n        const axis = this.crosshair.axis;\n        const plotArea = axis.plotArea;\n        let name;\n        if (plotArea.categoryAxis) {\n            name = axis.getCategory ? \"categoryAxis\" : \"valueAxis\";\n        } else {\n            name = axis.options.vertical ? \"yAxis\" : \"xAxis\";\n        }\n        this.axisName = name;\n    }\n\n    showAt(point) {\n        const { crosshair: { axis }, options } = this;\n        let value = axis[options.stickyMode ? \"getCategory\" : \"getValue\"](point);\n        let formattedValue = value;\n\n        if (options.format) {\n            formattedValue = this.formatService.auto(options.format, value);\n        } else if (axis.options.type === DATE) {\n            formattedValue = this.formatService.auto(axis.options.labels.dateFormats[axis.options.baseUnit], value);\n        }\n\n        this.show({\n            point: point,\n            anchor: this.getAnchor(),\n            crosshair: this.crosshair,\n            value: formattedValue,\n            axisName: this.axisName,\n            axisIndex: this.crosshair.axis.axisIndex\n        }, this.options);\n    }\n\n    hide() {\n        this.chartService.notify(HIDE_TOOLTIP, {\n            crosshair: this.crosshair,\n            axisName: this.axisName,\n            axisIndex: this.crosshair.axis.axisIndex\n        });\n    }\n\n    getAnchor() {\n        const { crosshair, options: { position, padding } } = this;\n        const vertical = !crosshair.axis.options.vertical;\n        const lineBox = crosshair.line.bbox();\n        let horizontalAlign, verticalAlign, point;\n\n        if (vertical) {\n            horizontalAlign = CENTER;\n            if (position === BOTTOM) {\n                verticalAlign = TOP;\n                point = lineBox.bottomLeft().translate(0, padding);\n            } else {\n                verticalAlign = BOTTOM;\n                point = lineBox.topLeft().translate(0, -padding);\n            }\n        } else {\n            verticalAlign = CENTER;\n            if (position === LEFT) {\n                horizontalAlign = RIGHT;\n                point = lineBox.topLeft().translate(-padding, 0);\n            } else {\n                horizontalAlign = LEFT;\n                point = lineBox.topRight().translate(padding, 0);\n            }\n        }\n\n        return {\n            point: point,\n            align: {\n                horizontal: horizontalAlign,\n                vertical: verticalAlign\n            }\n        };\n    }\n}\n\nsetDefaultOptions(crosshair_tooltip_CrosshairTooltip, {\n    padding: 10\n});\n\n/* harmony default export */ var crosshair_tooltip = (crosshair_tooltip_CrosshairTooltip);\n\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/crosshair/crosshair.js\n\n\n\n\n\n\n\n\nclass crosshair_Crosshair extends chart_element {\n    constructor(chartService, axis, options) {\n        super(options);\n\n        this.axis = axis;\n        this.stickyMode = axis instanceof category_axis;\n\n        const tooltipOptions = this.options.tooltip;\n\n        if (tooltipOptions.visible) {\n            this.tooltip = new crosshair_tooltip(chartService, this,\n                deepExtend({}, tooltipOptions, { stickyMode: this.stickyMode })\n            );\n        }\n    }\n\n    showAt(point) {\n        this.point = point;\n        this.moveLine();\n        this.line.visible(true);\n\n        if (this.tooltip) {\n            this.tooltip.showAt(point);\n        }\n    }\n\n    hide() {\n        this.line.visible(false);\n\n        if (this.tooltip) {\n            this.tooltip.hide();\n        }\n    }\n\n    moveLine() {\n        const { axis, point } = this;\n        const vertical = axis.options.vertical;\n        const box = this.getBox();\n        const dim = vertical ? Y : X;\n        const lineStart = new main[\"b\" /* geometry */].Point(box.x1, box.y1);\n        let lineEnd;\n\n        if (vertical) {\n            lineEnd = new main[\"b\" /* geometry */].Point(box.x2, box.y1);\n        } else {\n            lineEnd = new main[\"b\" /* geometry */].Point(box.x1, box.y2);\n        }\n\n        if (point) {\n            if (this.stickyMode) {\n                const slot = axis.getSlot(axis.pointCategoryIndex(point));\n                lineStart[dim] = lineEnd[dim] = slot.center()[dim];\n            } else {\n                lineStart[dim] = lineEnd[dim] = point[dim];\n            }\n        }\n\n        this.box = box;\n\n        this.line.moveTo(lineStart).lineTo(lineEnd);\n    }\n\n    getBox() {\n        const axis = this.axis;\n        const axes = axis.pane.axes;\n        const length = axes.length;\n        const vertical = axis.options.vertical;\n        const box = axis.lineBox().clone();\n        const dim = vertical ? X : Y;\n        let axisLineBox;\n\n        for (let i = 0; i < length; i++) {\n            const currentAxis = axes[i];\n            if (currentAxis.options.vertical !== vertical) {\n                if (!axisLineBox) {\n                    axisLineBox = currentAxis.lineBox().clone();\n                } else {\n                    axisLineBox.wrap(currentAxis.lineBox());\n                }\n            }\n        }\n\n        box[dim + 1] = axisLineBox[dim + 1];\n        box[dim + 2] = axisLineBox[dim + 2];\n\n        return box;\n    }\n\n    createVisual() {\n        super.createVisual();\n\n        const options = this.options;\n        this.line = new main[\"a\" /* drawing */].Path({\n            stroke: {\n                color: options.color,\n                width: options.width,\n                opacity: options.opacity,\n                dashType: options.dashType\n            },\n            visible: false\n        });\n\n        this.moveLine();\n        this.visual.append(this.line);\n    }\n\n    destroy() {\n        if (this.tooltip) {\n            this.tooltip.destroy();\n        }\n\n        super.destroy();\n    }\n}\n\nsetDefaultOptions(crosshair_Crosshair, {\n    color: BLACK,\n    width: 2,\n    zIndex: -1,\n    tooltip: {\n        visible: false\n    }\n});\n\n/* harmony default export */ var crosshair_crosshair = (crosshair_Crosshair);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/chart-container.js\n\n\n\n\n\nclass chart_container_ChartContainer extends chart_element {\n    constructor(options, pane) {\n        super(options);\n        this.pane = pane;\n    }\n\n    shouldClip() {\n        const children = this.children;\n        const length = children.length;\n\n        for (let i = 0; i < length; i++) {\n            if (children[i].options.clip === true) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    _clipBox() {\n        return this.pane.chartsBox();\n    }\n\n    createVisual() {\n        this.visual = new main[\"a\" /* drawing */].Group({\n            zIndex: 0\n        });\n\n        if (this.shouldClip()) {\n            const clipBox = this.clipBox = this._clipBox();\n            const clipRect = clipBox.toRect();\n            const clipPath = main[\"a\" /* drawing */].Path.fromRect(clipRect);\n            alignPathToPixel(clipPath);\n\n            this.visual.clip(clipPath);\n            this.unclipLabels();\n        }\n    }\n\n    stackRoot() {\n        return this;\n    }\n\n    unclipLabels() {\n        const { children: charts, clipBox } = this;\n\n        for (let i = 0; i < charts.length; i++) {\n            const points = charts[i].points || {};\n            const length = points.length;\n\n            for (let j = 0; j < length; j++) {\n                const point = points[j];\n                if (point && point.visible !== false && point.overlapsBox && point.overlapsBox(clipBox)) {\n                    if (point.unclipElements) {\n                        point.unclipElements();\n                    } else {\n                        const { label, note } = point;\n\n                        if (label && label.options.visible) {\n                            if (label.alignToClipBox) {\n                                label.alignToClipBox(clipBox);\n                            }\n                            label.options.noclip = true;\n                        }\n\n                        if (note && note.options.visible) {\n                            note.options.noclip = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    destroy() {\n        super.destroy();\n\n        delete this.parent;\n    }\n}\n\nchart_container_ChartContainer.prototype.isStackRoot = true;\n\n/* harmony default export */ var chart_container = (chart_container_ChartContainer);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/pane.js\n\n\n\n\n\n\n\n\nclass pane_Pane extends box_element {\n    constructor(options) {\n        super(options);\n\n        this.id = paneID();\n\n        this.createTitle();\n\n        this.content = new chart_element();\n\n        this.chartContainer = new chart_container({}, this);\n        this.append(this.content);\n\n        this.axes = [];\n        this.charts = [];\n    }\n\n    createTitle() {\n        let titleOptions = this.options.title;\n        if (isObject(titleOptions)) {\n            titleOptions = deepExtend({}, titleOptions, {\n                align: titleOptions.position,\n                position: TOP\n            });\n        }\n\n        this.title = core_title.buildTitle(titleOptions, this, pane_Pane.prototype.options.title);\n    }\n\n    appendAxis(axis) {\n        this.content.append(axis);\n        this.axes.push(axis);\n        axis.pane = this;\n    }\n\n    appendAxisAt(axis, pos) {\n        this.content.append(axis);\n        this.axes.splice(pos, 0, axis);\n        axis.pane = this;\n    }\n\n    appendChart(chart) {\n        if (this.chartContainer.parent !== this.content) {\n            this.content.append(this.chartContainer);\n        }\n\n        this.charts.push(chart);\n        this.chartContainer.append(chart);\n        chart.pane = this;\n    }\n\n    empty() {\n        const plotArea = this.parent;\n\n        if (plotArea) {\n            for (let i = 0; i < this.axes.length; i++) {\n                plotArea.removeAxis(this.axes[i]);\n            }\n\n            for (let i = 0; i < this.charts.length; i++) {\n                plotArea.removeChart(this.charts[i]);\n            }\n        }\n\n        this.axes = [];\n        this.charts = [];\n\n        this.content.destroy();\n        this.content.children = [];\n        this.chartContainer.children = [];\n    }\n\n    reflow(targetBox) {\n        // Content (such as charts) is rendered, but excluded from reflows\n        let content;\n        if (last(this.children) === this.content) {\n            content = this.children.pop();\n        }\n\n        super.reflow(targetBox);\n\n        if (content) {\n            this.children.push(content);\n        }\n\n        if (this.title) {\n            this.contentBox.y1 += this.title.box.height();\n        }\n    }\n\n    visualStyle() {\n        const style = super.visualStyle();\n        style.zIndex = -10;\n\n        return style;\n    }\n\n    renderComplete() {\n        if (this.options.visible) {\n            this.createGridLines();\n        }\n    }\n\n    stackRoot() {\n        return this;\n    }\n\n    clipRoot() {\n        return this;\n    }\n\n    createGridLines() {\n        const axes = this.axes;\n        const allAxes = axes.concat(this.parent.axes);\n        const vGridLines = [];\n        const hGridLines = [];\n\n        // TODO\n        // Is full combination really necessary?\n        for (let i = 0; i < axes.length; i++) {\n            const axis = axes[i];\n            const vertical = axis.options.vertical;\n            const gridLines = vertical ? vGridLines : hGridLines;\n            for (let j = 0; j < allAxes.length; j++) {\n                if (gridLines.length === 0) {\n                    const altAxis = allAxes[j];\n                    if (vertical !== altAxis.options.vertical) {\n                        append(gridLines, axis.createGridLines(altAxis));\n                    }\n                }\n            }\n        }\n    }\n\n    refresh() {\n        this.visual.clear();\n\n        this.content.parent = null;\n        this.content.createGradient = this.createGradient.bind(this);\n        this.content.renderVisual();\n        this.content.parent = this;\n\n        if (this.title) {\n            this.visual.append(this.title.visual);\n        }\n\n        this.visual.append(this.content.visual);\n\n        this.renderComplete();\n        this.notifyRender();\n    }\n\n    chartsBox() {\n        const axes = this.axes;\n        const length = axes.length;\n        const chartsBox = new core_box();\n\n        for (let idx = 0; idx < length; idx++) {\n            const axis = axes[idx];\n            const axisValueField = axis.options.vertical ? Y : X;\n            const lineBox = axis.lineBox();\n            chartsBox[axisValueField + 1] = lineBox[axisValueField + 1];\n            chartsBox[axisValueField + 2] = lineBox[axisValueField + 2];\n        }\n\n        if (chartsBox.x2 === 0) {\n            const allAxes = this.parent.axes;\n            const length = allAxes.length;\n\n            for (let idx = 0; idx < length; idx++) {\n                const axis = allAxes[idx];\n                if (!axis.options.vertical) {\n                    const lineBox = axis.lineBox();\n                    chartsBox.x1 = lineBox.x1;\n                    chartsBox.x2 = lineBox.x2;\n                }\n            }\n        }\n        return chartsBox;\n    }\n\n    clipBox() {\n        return this.chartContainer.clipBox;\n    }\n\n    notifyRender() {\n        const service = this.getService();\n        if (service) {\n            service.notify(PANE_RENDER, {\n                pane: new chart_pane(this),\n                index: this.paneIndex,\n                name: this.options.name\n            });\n        }\n    }\n}\n\nlet ID = 1;\n\nfunction paneID() {\n    return \"pane\" + ID++;\n}\n\npane_Pane.prototype.isStackRoot = true;\n\nsetDefaultOptions(pane_Pane, {\n    zIndex: -1,\n    shrinkToFit: true,\n    title: {\n        align: LEFT\n    },\n    visible: true\n});\n\n/* harmony default export */ var es2015_chart_pane = (pane_Pane);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/utils/append-if-not-null.js\nfunction appendIfNotNull(array, element) {\n    if (element !== null) {\n        array.push(element);\n    }\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/utils/segment-visible.js\n\n\nfunction segmentVisible(series, fields, index) {\n    const visible = fields.visible;\n    if (defined(visible)) {\n        return visible;\n    }\n\n    const pointVisibility = series.pointVisibility;\n    if (pointVisibility) {\n        return pointVisibility[index];\n    }\n}\n\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/utils/bind-segments.js\n\n\n\n\nfunction bindSegments(series) {\n    const data = series.data;\n    const points = [];\n    let sum = 0;\n    let count = 0;\n\n    for (let idx = 0; idx < data.length; idx++) {\n        const pointData = series_binder.current.bindPoint(series, idx);\n        let value = pointData.valueFields.value;\n\n\n        if (isString(value)) {\n            value = parseFloat(value);\n        }\n\n        if (isNumber(value)) {\n            pointData.visible = segmentVisible(series, pointData.fields, idx) !== false;\n\n            pointData.value = Math.abs(value);\n            points.push(pointData);\n\n            if (pointData.visible) {\n                sum += pointData.value;\n            }\n\n            if (value !== 0) {\n                count++;\n            }\n        } else {\n            points.push(null);\n        }\n    }\n\n    return {\n        total: sum,\n        points: points,\n        count: count\n    };\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/utils/equals-ignore-case.js\nfunction equalsIgnoreCase(a, b) {\n    if (a && b) {\n        return a.toLowerCase() === b.toLowerCase();\n    }\n\n    return a === b;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/utils/filter-series-by-type.js\n\n\nfunction filterSeriesByType(series, types) {\n    const result = [];\n\n    const seriesTypes = [].concat(types);\n    for (let idx = 0; idx < series.length; idx++) {\n        const currentSeries = series[idx];\n        if (inArray(currentSeries.type, seriesTypes)) {\n            result.push(currentSeries);\n        }\n    }\n\n    return result;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/utils/get-date-field.js\n\n\n\nfunction getDateField(field, row, intlService) {\n    if (row === null) {\n        return row;\n    }\n\n    const key = \"_date_\" + field;\n    let value = row[key];\n\n    if (!value) {\n        value = parse_date_parseDate(intlService, getter_getter(field, true)(row));\n        row[key] = value;\n    }\n\n    return value;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/utils/is-date-axis.js\n\n\n\n\nfunction isDateAxis(axisOptions, sampleCategory) {\n    const type = axisOptions.type;\n    const dateCategory = sampleCategory instanceof Date;\n\n    return (!type && dateCategory) || equalsIgnoreCase(type, DATE);\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/utils/single-item-or-array.js\nfunction singleItemOrArray(array) {\n    return array.length === 1 ? array[0] : array;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/utils/create-out-of-range-points.js\n\n\n\n\nconst AREA_REGEX = /area/i;\n\nfunction seriesMissingValues(series) {\n    if (series.missingValues) {\n        return series.missingValues;\n    }\n\n    return AREA_REGEX.test(series.type) || series.stack ? ZERO : INTERPOLATE;\n}\n\nfunction create_out_of_range_points_hasValue(series, item) {\n    const fields = series_binder.current.bindPoint(series, null, item);\n    const valueFields = fields.valueFields;\n\n    for (let field in valueFields) {\n        if (convertableToNumber(valueFields[field])) {\n            return true;\n        }\n    }\n}\n\nfunction findNext({ start, dir, min, max, getter, hasItem, series }) {\n    let pointHasValue, outPoint;\n    let idx = start;\n    do {\n        idx += dir;\n        //aggregating and binding the item takes too much time for large number of categories\n        //will assume that if the aggregation does not create value for a missing item for one it will not create for others\n        if (hasItem(idx)) {\n            outPoint = getter(idx);\n            pointHasValue = create_out_of_range_points_hasValue(series, outPoint.item);\n        }\n    } while (min <= idx && idx <= max && !pointHasValue);\n\n    if (pointHasValue) {\n        return outPoint;\n    }\n}\n\nfunction createOutOfRangePoints(series, range, count, getter, hasItem) {\n    const { min, max } = range;\n    const hasMinPoint = min > 0 && min < count;\n    const hasMaxPoint = max + 1 < count;\n\n    if (hasMinPoint || hasMaxPoint) {\n        const missingValues = seriesMissingValues(series);\n        let minPoint, maxPoint;\n        if (missingValues !== INTERPOLATE) {\n            if (hasMinPoint) {\n                minPoint = getter(min - 1);\n            }\n\n            if (hasMaxPoint) {\n                maxPoint = getter(max + 1);\n            }\n        } else {\n            let outPoint, pointHasValue;\n            if (hasMinPoint) {\n                outPoint = getter(min - 1);\n                pointHasValue = create_out_of_range_points_hasValue(series, outPoint.item);\n                if (!pointHasValue) {\n                    minPoint = findNext({\n                        start: min,\n                        dir: -1,\n                        min: 0,\n                        max: count - 1,\n                        getter: getter,\n                        hasItem: hasItem,\n                        series: series\n                    });\n                } else {\n                    minPoint = outPoint;\n                }\n            }\n\n            if (hasMaxPoint) {\n                outPoint = getter(max + 1);\n                pointHasValue = create_out_of_range_points_hasValue(series, outPoint.item);\n                if (!pointHasValue) {\n                    maxPoint = findNext({\n                        start: max,\n                        dir: 1,\n                        min: 0,\n                        max: count - 1,\n                        getter: getter,\n                        hasItem: hasItem,\n                        series: series\n                    });\n                } else {\n                    maxPoint = outPoint;\n                }\n            }\n        }\n\n        if (minPoint) {\n            series._outOfRangeMinPoint = minPoint;\n        }\n\n        if (maxPoint) {\n            series._outOfRangeMaxPoint = maxPoint;\n        }\n    }\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/utils.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/plotarea/plotarea-base.js\n\n\n\n\n\n\n\n\n\n\nclass plotarea_base_PlotAreaBase extends chart_element {\n    constructor(series, options, chartService) {\n        super(options);\n\n        this.initFields(series, options);\n        this.series = series;\n        this.initSeries();\n        this.charts = [];\n        this.options.legend = this.options.legend || {};\n        this.options.legend.items = [];\n        this.axes = [];\n        this.crosshairs = [];\n        this.chartService = chartService;\n        this.originalOptions = options;\n\n        this.createPanes();\n        this.render();\n        this.createCrosshairs();\n    }\n\n    initFields() { }\n\n    initSeries() {\n        const series = this.series;\n\n        for (let i = 0; i < series.length; i++) {\n            series[i].index = i;\n        }\n    }\n\n    createPanes() {\n        const titleOptions = this.options.title || {};\n        const paneDefaults = this.options.paneDefaults;\n        const paneOptions = this.options.panes || [];\n        const panesLength = Math.max(paneOptions.length, 1);\n        const panes = [];\n\n        const defaults = deepExtend({\n            title: {\n                color: titleOptions.color\n            }\n        }, paneDefaults);\n\n        for (let i = 0; i < panesLength; i++) {\n            const options = deepExtend({}, defaults, paneOptions[i]);\n            if (isString(options.title)) {\n                options.title = deepExtend({ text: options.title }, defaults.title);\n            }\n\n            const currentPane = new es2015_chart_pane(options);\n            currentPane.paneIndex = i;\n\n            panes.push(currentPane);\n            this.append(currentPane);\n        }\n\n        this.panes = panes;\n    }\n\n    createCrosshairs(panes = this.panes) {\n        for (let i = 0; i < panes.length; i++) {\n            const pane = panes[i];\n            for (let j = 0; j < pane.axes.length; j++) {\n                const axis = pane.axes[j];\n                if (axis.options.crosshair && axis.options.crosshair.visible) {\n                    const currentCrosshair = new crosshair_crosshair(this.chartService, axis, axis.options.crosshair);\n\n                    this.crosshairs.push(currentCrosshair);\n                    pane.content.append(currentCrosshair);\n                }\n            }\n        }\n    }\n\n    removeCrosshairs(pane) {\n        const crosshairs = this.crosshairs;\n        const axes = pane.axes;\n\n        for (let i = crosshairs.length - 1; i >= 0; i--) {\n            for (let j = 0; j < axes.length; j++) {\n                if (crosshairs[i].axis === axes[j]) {\n                    crosshairs.splice(i, 1);\n                    break;\n                }\n            }\n        }\n    }\n\n    hideCrosshairs() {\n        const crosshairs = this.crosshairs;\n        for (let idx = 0; idx < crosshairs.length; idx++) {\n            crosshairs[idx].hide();\n        }\n    }\n\n    findPane(name) {\n        const panes = this.panes;\n        let matchingPane;\n\n        for (let i = 0; i < panes.length; i++) {\n            if (panes[i].options.name === name) {\n                matchingPane = panes[i];\n                break;\n            }\n        }\n\n        return matchingPane || panes[0];\n    }\n\n    findPointPane(point) {\n        const panes = this.panes;\n        let matchingPane;\n\n        for (let i = 0; i < panes.length; i++) {\n            if (panes[i].box.containsPoint(point)) {\n                matchingPane = panes[i];\n                break;\n            }\n        }\n\n        return matchingPane;\n    }\n\n    appendAxis(axis) {\n        const pane = this.findPane(axis.options.pane);\n\n        pane.appendAxis(axis);\n        this.axes.push(axis);\n        axis.plotArea = this;\n    }\n\n    removeAxis(axisToRemove) {\n        const filteredAxes = [];\n\n        for (let i = 0; i < this.axes.length; i++) {\n            const axis = this.axes[i];\n            if (axisToRemove !== axis) {\n                filteredAxes.push(axis);\n            } else {\n                axis.destroy();\n            }\n        }\n\n        this.axes = filteredAxes;\n    }\n\n    appendChart(chart, pane) {\n        this.charts.push(chart);\n        if (pane) {\n            pane.appendChart(chart);\n        } else {\n            this.append(chart);\n        }\n    }\n\n    removeChart(chartToRemove) {\n        const filteredCharts = [];\n\n        for (let i = 0; i < this.charts.length; i++) {\n            const chart = this.charts[i];\n            if (chart !== chartToRemove) {\n                filteredCharts.push(chart);\n            } else {\n                chart.destroy();\n            }\n        }\n\n        this.charts = filteredCharts;\n    }\n\n    addToLegend(series) {\n        const count = series.length;\n        const legend = this.options.legend;\n        const labels = legend.labels || {};\n        const inactiveItems = legend.inactiveItems || {};\n        const inactiveItemsLabels = inactiveItems.labels || {};\n        const data = [];\n\n        for (let i = 0; i < count; i++) {\n            const currentSeries = series[i];\n            const seriesVisible = currentSeries.visible !== false;\n            if (currentSeries.visibleInLegend === false) {\n                continue;\n            }\n\n            let text = currentSeries.name;\n            const labelTemplate = seriesVisible ? getTemplate(labels) : getTemplate(inactiveItemsLabels) || getTemplate(labels);\n            if (labelTemplate) {\n                text = labelTemplate({\n                    text: has_value_hasValue(text) ? text : \"\",\n                    series: currentSeries\n                });\n            }\n\n            const defaults = currentSeries._defaults;\n            let color = currentSeries.color;\n            if (isFunction(color) && defaults) {\n                color = defaults.color;\n            }\n\n            let itemLabelOptions, markerColor;\n            if (seriesVisible) {\n                itemLabelOptions = {};\n                markerColor = color;\n            } else {\n                itemLabelOptions = {\n                    color: inactiveItemsLabels.color,\n                    font: inactiveItemsLabels.font\n                };\n                markerColor = inactiveItems.markers.color;\n            }\n\n            if (has_value_hasValue(text) && text !== \"\") {\n                data.push({\n                    text: text,\n                    labels: itemLabelOptions,\n                    markerColor: markerColor,\n                    series: currentSeries,\n                    active: seriesVisible\n                });\n            }\n        }\n\n        append(legend.items, data);\n    }\n\n    groupAxes(panes) {\n        const xAxes = [];\n        const yAxes = [];\n\n        for (let paneIx = 0; paneIx < panes.length; paneIx++) {\n            const paneAxes = panes[paneIx].axes;\n            for (let axisIx = 0; axisIx < paneAxes.length; axisIx++) {\n                const axis = paneAxes[axisIx];\n                if (axis.options.vertical) {\n                    yAxes.push(axis);\n                } else {\n                    xAxes.push(axis);\n                }\n            }\n        }\n\n        return { x: xAxes, y: yAxes, any: xAxes.concat(yAxes) };\n    }\n\n    groupSeriesByPane() {\n        const series = this.series;\n        const seriesByPane = {};\n\n        for (let i = 0; i < series.length; i++) {\n            const currentSeries = series[i];\n            const pane = this.seriesPaneName(currentSeries);\n\n            if (seriesByPane[pane]) {\n                seriesByPane[pane].push(currentSeries);\n            } else {\n                seriesByPane[pane] = [ currentSeries ];\n            }\n        }\n\n        return seriesByPane;\n    }\n\n    filterVisibleSeries(series) {\n        const result = [];\n\n        for (let i = 0; i < series.length; i++) {\n            const currentSeries = series[i];\n            if (currentSeries.visible !== false) {\n                result.push(currentSeries);\n            }\n        }\n\n        return result;\n    }\n\n    reflow(targetBox) {\n        const options = this.options.plotArea;\n        const panes = this.panes;\n        const margin = getSpacing(options.margin);\n\n        this.box = targetBox.clone().unpad(margin);\n        this.reflowPanes();\n\n        this.detachLabels();\n        this.reflowAxes(panes);\n        this.reflowCharts(panes);\n    }\n\n    redraw(panes) {\n        const panesArray = [].concat(panes);\n        this.initSeries();\n\n        //prevents leak during partial redraws. the cached gradients observers retain reference to the destroyed elements.\n        const root = this.getRoot();\n        if (root) {\n            root.cleanGradients();\n        }\n\n        for (let i = 0; i < panesArray.length; i++) {\n            this.removeCrosshairs(panesArray[i]);\n            panesArray[i].empty();\n        }\n\n        this.render(panesArray);\n        this.detachLabels();\n        this.reflowAxes(this.panes);\n        this.reflowCharts(panesArray);\n\n        this.createCrosshairs(panesArray);\n\n        for (let i = 0; i < panesArray.length; i++) {\n            panesArray[i].refresh();\n        }\n    }\n\n    axisCrossingValues(axis, crossingAxes) {\n        const options = axis.options;\n        const crossingValues = [].concat(\n            options.axisCrossingValues || options.axisCrossingValue\n        );\n        const valuesToAdd = crossingAxes.length - crossingValues.length;\n        const defaultValue = crossingValues[0] || 0;\n\n        for (let i = 0; i < valuesToAdd; i++) {\n            crossingValues.push(defaultValue);\n        }\n\n        return crossingValues;\n    }\n\n    alignAxisTo(axis, targetAxis, crossingValue, targetCrossingValue) {\n        const slot = axis.getSlot(crossingValue, crossingValue, true);\n        const slotEdge = axis.options.reverse ? 2 : 1;\n        const targetSlot = targetAxis.getSlot(targetCrossingValue, targetCrossingValue, true);\n        const targetEdge = targetAxis.options.reverse ? 2 : 1;\n        const axisBox = axis.box.translate(\n            targetSlot[X + targetEdge] - slot[X + slotEdge],\n            targetSlot[Y + targetEdge] - slot[Y + slotEdge]\n        );\n\n        if (axis.pane !== targetAxis.pane) {\n            axisBox.translate(0, axis.pane.box.y1 - targetAxis.pane.box.y1);\n        }\n\n        axis.reflow(axisBox);\n    }\n\n    alignAxes(xAxes, yAxes) {\n        const xAnchor = xAxes[0];\n        const yAnchor = yAxes[0];\n        const xAnchorCrossings = this.axisCrossingValues(xAnchor, yAxes);\n        const yAnchorCrossings = this.axisCrossingValues(yAnchor, xAxes);\n        const leftAnchors = {};\n        const rightAnchors = {};\n        const topAnchors = {};\n        const bottomAnchors = {};\n\n        for (let i = 0; i < yAxes.length; i++) {\n            const axis = yAxes[i];\n            const pane = axis.pane;\n            const paneId = pane.id;\n            const visible = axis.options.visible !== false;\n\n            // Locate pane anchor, if any, and use its axisCrossingValues\n            const anchor = paneAnchor(xAxes, pane) || xAnchor;\n            let anchorCrossings = xAnchorCrossings;\n\n            if (anchor !== xAnchor) {\n                anchorCrossings = this.axisCrossingValues(anchor, yAxes);\n            }\n\n            this.alignAxisTo(axis, anchor, yAnchorCrossings[i], anchorCrossings[i]);\n\n            if (axis.options._overlap) {\n                continue;\n            }\n\n            if (round(axis.lineBox().x1) === round(anchor.lineBox().x1)) {\n                // Push the axis to the left the previous y-axis so they don't overlap\n                if (leftAnchors[paneId]) {\n                    axis.reflow(axis.box\n                        .alignTo(leftAnchors[paneId].box, LEFT)\n                        .translate(-axis.options.margin, 0)\n                    );\n                }\n\n                if (visible) {\n                    leftAnchors[paneId] = axis;\n                }\n            }\n\n            if (round(axis.lineBox().x2) === round(anchor.lineBox().x2)) {\n                // Flip the labels on the right if we're at the right end of the pane\n                if (!axis._mirrored) {\n                    axis.options.labels.mirror = !axis.options.labels.mirror;\n                    axis._mirrored = true;\n                }\n\n                this.alignAxisTo(axis, anchor, yAnchorCrossings[i], anchorCrossings[i]);\n\n                // Push the axis to the right the previous y-axis so they don't overlap\n                if (rightAnchors[paneId]) {\n                    axis.reflow(axis.box\n                        .alignTo(rightAnchors[paneId].box, RIGHT)\n                        .translate(axis.options.margin, 0)\n                    );\n                }\n\n                if (visible) {\n                    rightAnchors[paneId] = axis;\n                }\n            }\n\n            if (i !== 0 && yAnchor.pane === axis.pane) {\n                axis.alignTo(yAnchor);\n                axis.reflow(axis.box);\n            }\n        }\n\n        for (let i = 0; i < xAxes.length; i++) {\n            const axis = xAxes[i];\n            const pane = axis.pane;\n            const paneId = pane.id;\n            const visible = axis.options.visible !== false;\n\n            // Locate pane anchor and use its axisCrossingValues\n            const anchor = paneAnchor(yAxes, pane) || yAnchor;\n            let anchorCrossings = yAnchorCrossings;\n            if (anchor !== yAnchor) {\n                anchorCrossings = this.axisCrossingValues(anchor, xAxes);\n            }\n\n            this.alignAxisTo(axis, anchor, xAnchorCrossings[i], anchorCrossings[i]);\n\n            if (axis.options._overlap) {\n                continue;\n            }\n\n            if (round(axis.lineBox().y1) === round(anchor.lineBox().y1)) {\n                // Flip the labels on top if we're at the top of the pane\n                if (!axis._mirrored) {\n                    axis.options.labels.mirror = !axis.options.labels.mirror;\n                    axis._mirrored = true;\n                }\n                this.alignAxisTo(axis, anchor, xAnchorCrossings[i], anchorCrossings[i]);\n\n                // Push the axis above the previous x-axis so they don't overlap\n                if (topAnchors[paneId]) {\n                    axis.reflow(axis.box\n                        .alignTo(topAnchors[paneId].box, TOP)\n                        .translate(0, -axis.options.margin)\n                    );\n                }\n\n                if (visible) {\n                    topAnchors[paneId] = axis;\n                }\n            }\n\n            if (round(axis.lineBox().y2, COORD_PRECISION) === round(anchor.lineBox().y2, COORD_PRECISION)) {\n                // Push the axis below the previous x-axis so they don't overlap\n                if (bottomAnchors[paneId]) {\n                    axis.reflow(axis.box\n                        .alignTo(bottomAnchors[paneId].box, BOTTOM)\n                        .translate(0, axis.options.margin)\n                    );\n                }\n\n                if (visible) {\n                    bottomAnchors[paneId] = axis;\n                }\n            }\n\n            if (i !== 0) {\n                axis.alignTo(xAnchor);\n                axis.reflow(axis.box);\n            }\n        }\n    }\n\n    shrinkAxisWidth(panes) {\n        const axes = this.groupAxes(panes).any;\n        const axisBox = axisGroupBox(axes);\n        let overflowX = 0;\n\n        for (let i = 0; i < panes.length; i++) {\n            const currentPane = panes[i];\n\n            if (currentPane.axes.length > 0) {\n                overflowX = Math.max(\n                    overflowX,\n                    axisBox.width() - currentPane.contentBox.width()\n                );\n            }\n        }\n\n        if (overflowX !== 0) {\n            for (let i = 0; i < axes.length; i++) {\n                const currentAxis = axes[i];\n\n                if (!currentAxis.options.vertical) {\n                    currentAxis.reflow(currentAxis.box.shrink(overflowX, 0));\n                }\n            }\n        }\n    }\n\n    shrinkAxisHeight(panes) {\n        let shrinked;\n\n        for (let i = 0; i < panes.length; i++) {\n            const currentPane = panes[i];\n            const axes = currentPane.axes;\n            const overflowY = Math.max(0, axisGroupBox(axes).height() - currentPane.contentBox.height());\n\n            if (overflowY !== 0) {\n                for (let j = 0; j < axes.length; j++) {\n                    const currentAxis = axes[j];\n\n                    if (currentAxis.options.vertical) {\n                        currentAxis.reflow(\n                            currentAxis.box.shrink(0, overflowY)\n                        );\n                    }\n                }\n                shrinked = true;\n            }\n        }\n\n        return shrinked;\n    }\n\n    fitAxes(panes) {\n        const axes = this.groupAxes(panes).any;\n        let offsetX = 0;\n\n        for (let i = 0; i < panes.length; i++) {\n            const currentPane = panes[i];\n            const paneAxes = currentPane.axes;\n            const paneBox = currentPane.contentBox;\n\n            if (paneAxes.length > 0) {\n                const axisBox = axisGroupBox(paneAxes);\n                // OffsetY is calculated and applied per pane\n                const offsetY = Math.max(paneBox.y1 - axisBox.y1, paneBox.y2 - axisBox.y2);\n\n                // OffsetX is calculated and applied globally\n                offsetX = Math.max(offsetX, paneBox.x1 - axisBox.x1);\n\n\n                for (let j = 0; j < paneAxes.length; j++) {\n                    const currentAxis = paneAxes[j];\n\n                    currentAxis.reflow(\n                        currentAxis.box.translate(0, offsetY)\n                    );\n                }\n            }\n        }\n\n        for (let i = 0; i < axes.length; i++) {\n            const currentAxis = axes[i];\n\n            currentAxis.reflow(\n                currentAxis.box.translate(offsetX, 0)\n            );\n        }\n    }\n\n    reflowAxes(panes) {\n        const axes = this.groupAxes(panes);\n\n        for (let i = 0; i < panes.length; i++) {\n            this.reflowPaneAxes(panes[i]);\n        }\n\n        if (axes.x.length > 0 && axes.y.length > 0) {\n            this.alignAxes(axes.x, axes.y);\n            this.shrinkAxisWidth(panes);\n\n            this.autoRotateAxisLabels(axes);\n\n            this.alignAxes(axes.x, axes.y);\n            if (this.shrinkAxisWidth(panes)) {\n                this.alignAxes(axes.x, axes.y);\n            }\n\n            this.shrinkAxisHeight(panes);\n            this.alignAxes(axes.x, axes.y);\n\n            if (this.shrinkAxisHeight(panes)) {\n                this.alignAxes(axes.x, axes.y);\n            }\n\n            this.fitAxes(panes);\n        }\n    }\n\n    autoRotateAxisLabels(groupedAxes) {\n        const { panes } = this;\n        const axes = allPaneAxes(panes);\n        let rotated;\n\n        for (let idx = 0; idx < axes.length; idx++) {\n            const axis = axes[idx];\n            if (axis.autoRotateLabels()) {\n                rotated = true;\n            }\n        }\n\n        if (rotated) {\n            for (let idx = 0; idx < panes.length; idx++) {\n                this.reflowPaneAxes(panes[idx]);\n            }\n\n            if (groupedAxes.x.length > 0 && groupedAxes.y.length > 0) {\n                this.alignAxes(groupedAxes.x, groupedAxes.y);\n                this.shrinkAxisWidth(panes);\n            }\n        }\n    }\n\n    reflowPaneAxes(pane) {\n        const axes = pane.axes;\n        const length = axes.length;\n\n        if (length > 0) {\n            for (let i = 0; i < length; i++) {\n                axes[i].reflow(pane.contentBox);\n            }\n        }\n    }\n\n    reflowCharts(panes) {\n        const charts = this.charts;\n        const count = charts.length;\n        const box = this.box;\n\n        for (let i = 0; i < count; i++) {\n            const chartPane = charts[i].pane;\n            if (!chartPane || inArray(chartPane, panes)) {\n                charts[i].reflow(box);\n            }\n        }\n    }\n\n    reflowPanes() {\n        const { box, panes } = this;\n        const panesLength = panes.length;\n        let remainingHeight = box.height();\n        let remainingPanes = panesLength;\n        let autoHeightPanes = 0;\n        let top = box.y1;\n\n        for (let i = 0; i < panesLength; i++) {\n            const currentPane = panes[i];\n            const height = currentPane.options.height;\n\n            currentPane.options.width = box.width();\n\n            if (!currentPane.options.height) {\n                autoHeightPanes++;\n            } else {\n                if (height.indexOf && height.indexOf(\"%\")) {\n                    const percents = parseInt(height, 10) / 100;\n                    currentPane.options.height = percents * box.height();\n                }\n\n                currentPane.reflow(box.clone());\n\n                remainingHeight -= currentPane.options.height;\n            }\n        }\n\n        for (let i = 0; i < panesLength; i++) {\n            const currentPane = panes[i];\n\n            if (!currentPane.options.height) {\n                currentPane.options.height = remainingHeight / autoHeightPanes;\n            }\n        }\n\n        for (let i = 0; i < panesLength; i++) {\n            const currentPane = panes[i];\n            const paneBox = box\n                .clone()\n                .move(box.x1, top);\n\n            currentPane.reflow(paneBox);\n\n            remainingPanes--;\n            top += currentPane.options.height;\n        }\n    }\n\n    backgroundBox() {\n        const axes = this.axes;\n        const axesCount = axes.length;\n        let box;\n\n        for (let i = 0; i < axesCount; i++) {\n            const axisA = axes[i];\n\n            for (let j = 0; j < axesCount; j++) {\n                const axisB = axes[j];\n\n                if (axisA.options.vertical !== axisB.options.vertical) {\n                    const lineBox = axisA.lineBox().clone().wrap(axisB.lineBox());\n\n                    if (!box) {\n                        box = lineBox;\n                    } else {\n                        box = box.wrap(lineBox);\n                    }\n                }\n            }\n        }\n\n        return box || this.box;\n    }\n\n    chartsBoxes() {\n        const panes = this.panes;\n        const boxes = [];\n\n        for (let idx = 0; idx < panes.length; idx++) {\n            boxes.push(panes[idx].chartsBox());\n        }\n\n        return boxes;\n    }\n\n    addBackgroundPaths(multipath) {\n        const boxes = this.chartsBoxes();\n        for (let idx = 0; idx < boxes.length; idx++) {\n            multipath.paths.push(main[\"a\" /* drawing */].Path.fromRect(boxes[idx].toRect()));\n        }\n    }\n\n    backgroundContainsPoint(point) {\n        const boxes = this.chartsBoxes();\n        for (let idx = 0; idx < boxes.length; idx++) {\n            if (boxes[idx].containsPoint(point)) {\n                return true;\n            }\n        }\n    }\n\n    createVisual() {\n        super.createVisual();\n\n        const options = this.options.plotArea;\n        let { opacity, background, border = {} } = options;\n        if (isTransparent(background)) {\n            background = WHITE;\n            opacity = 0;\n        }\n\n        const bg = this._bgVisual = new main[\"a\" /* drawing */].MultiPath({\n            fill: {\n                color: background,\n                opacity: opacity\n            },\n            stroke: {\n                color: border.width ? border.color : \"\",\n                width: border.width,\n                dashType: border.dashType\n            },\n            zIndex: -1\n        });\n\n        this.addBackgroundPaths(bg);\n\n        this.appendVisual(bg);\n    }\n\n    pointsByCategoryIndex(categoryIndex) {\n        const charts = this.charts;\n        const result = [];\n\n        if (categoryIndex !== null) {\n            for (let i = 0; i < charts.length; i++) {\n                const chart = charts[i];\n                if (chart.pane.options.name === \"_navigator\") {\n                    continue;\n                }\n\n                const points = charts[i].categoryPoints[categoryIndex];\n                if (points && points.length) {\n                    for (let j = 0; j < points.length; j++) {\n                        const point = points[j];\n                        if (point && defined(point.value) && point.value !== null) {\n                            result.push(point);\n                        }\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    pointsBySeriesIndex(seriesIndex) {\n        return this.filterPoints(function(point) {\n            return point.series.index === seriesIndex;\n        });\n    }\n\n    pointsBySeriesName(name) {\n        return this.filterPoints(function(point) {\n            return point.series.name === name;\n        });\n    }\n\n    filterPoints(callback) {\n        const charts = this.charts;\n        const result = [];\n\n        for (let i = 0; i < charts.length; i++) {\n            const chart = charts[i];\n            const points = chart.points;\n            for (let j = 0; j < points.length; j++) {\n                const point = points[j];\n                if (point && point.visible !== false && callback(point)) {\n                    result.push(point);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    findPoint(callback) {\n        const charts = this.charts;\n\n        for (let i = 0; i < charts.length; i++) {\n            const chart = charts[i];\n            const points = chart.points;\n            for (let j = 0; j < points.length; j++) {\n                const point = points[j];\n                if (point && point.visible !== false && callback(point)) {\n                    return point;\n                }\n            }\n        }\n    }\n\n    paneByPoint(point) {\n        const panes = this.panes;\n\n        for (let i = 0; i < panes.length; i++) {\n            const pane = panes[i];\n            if (pane.box.containsPoint(point)) {\n                return pane;\n            }\n        }\n    }\n\n    detachLabels() {\n        const axes = this.groupAxes(this.panes);\n        const xAxes = axes.x;\n        const yAxes = axes.y;\n\n        this.detachAxisGroupLabels(yAxes, xAxes);\n        this.detachAxisGroupLabels(xAxes, yAxes);\n    }\n\n    detachAxisGroupLabels(axes, crossingAxes) {\n        let labelAxisCount = 0;\n\n        for (let i = 0; i < axes.length; i++) {\n            const axis = axes[i];\n            const pane = axis.pane;\n            const anchor = paneAnchor(crossingAxes, pane) || crossingAxes[0];\n            const axisIndex = i + labelAxisCount;\n            const labelAxis = this.createLabelAxis(axis, axisIndex, anchor);\n\n            if (labelAxis) {\n                labelAxisCount++;\n\n                const pos = pane.axes.indexOf(axis) + labelAxisCount;\n                pane.appendAxisAt(labelAxis, pos);\n            }\n        }\n    }\n\n    createLabelAxis(axis, axisIndex, anchor) {\n        const labelOptions = axis.options.labels;\n        const position = labelOptions.position;\n        const onAxis = position !== END && position !== START;\n        const visible = labelOptions.visible;\n\n        if (onAxis || visible === false) {\n            return null;\n        }\n\n        const allAxes = this.groupAxes(this.panes);\n        const crossingAxes = anchor.options.vertical ? allAxes.x : allAxes.y;\n        const anchorCrossings = this.axisCrossingValues(anchor, crossingAxes);\n        const end = position === END;\n        const range = anchor.range();\n        const edge = end ? range.max : range.min;\n        const crossingValue = limitValue(anchorCrossings[axisIndex], range.min, range.max);\n\n        if (crossingValue - edge === 0) {\n            return null;\n        }\n\n        anchorCrossings.splice(axisIndex + 1, 0, edge);\n        anchor.options.axisCrossingValues = anchorCrossings;\n\n        const labelAxis = axis.clone();\n        axis.clear();\n\n        labelAxis.options.name = undefined;\n        labelAxis.options.line.visible = false;\n\n        labelAxis.options.crosshair = undefined;\n        labelAxis.options.notes = undefined;\n        labelAxis.options.plotBands = undefined;\n\n        return labelAxis;\n    }\n}\n\nfunction isSingleAxis(axis) {\n    return !axis.pane.axes.some((a) =>\n        a.options.vertical === axis.options.vertical && a !== axis && a.options.visible !== false\n    );\n}\n\nfunction axisGroupBox(axes) {\n    const length = axes.length;\n    let box;\n\n    for (let i = 0; i < length; i++) {\n        const axis = axes[i];\n        const visible = axis.options.visible !== false;\n        if (visible || isSingleAxis(axis)) {\n            const axisBox = visible ? axis.contentBox() : axis.lineBox();\n\n            if (!box) {\n                box = axisBox.clone();\n            } else {\n                box.wrap(axisBox);\n            }\n        }\n    }\n\n    return box || new core_box();\n}\n\nfunction paneAnchor(axes, pane) {\n    for (let i = 0; i < axes.length; i++) {\n        const anchor = axes[i];\n        if (anchor && anchor.pane === pane) {\n            return anchor;\n        }\n    }\n}\n\nfunction isTransparent(color) {\n    return color === \"\" || color === null || color === \"none\" || color === \"transparent\" || !defined(color);\n}\n\nconst allPaneAxes = (panes) => panes.reduce((acc, pane) => acc.concat(pane.axes), []);\n\nsetDefaultOptions(plotarea_base_PlotAreaBase, {\n    series: [],\n    plotArea: {\n        margin: {}\n    },\n    background: \"\",\n    border: {\n        color: BLACK,\n        width: 0\n    },\n    paneDefaults: {\n        title: {}\n    },\n    legend: {\n        inactiveItems: {\n            labels: {\n                color: \"#919191\"\n            },\n            markers: {\n                color: \"#919191\"\n            }\n        }\n    }\n});\n\n/* harmony default export */ var plotarea_base = (plotarea_base_PlotAreaBase);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/mixins/plotarea-events-mixin.js\n\n\nconst PlotAreaEventsMixin = {\n    hover: function(chart, e) {\n        this._dispatchEvent(chart, e, PLOT_AREA_HOVER);\n    },\n\n    click: function(chart, e) {\n        this._dispatchEvent(chart, e, PLOT_AREA_CLICK);\n    }\n};\n\n/* harmony default export */ var plotarea_events_mixin = (PlotAreaEventsMixin);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/aggregates/series-aggregator.js\n\n\n\n\nclass series_aggregator_SeriesAggregator extends common_class[\"a\" /* default */] {\n    constructor(series, binder, defaultAggregates) {\n        super();\n\n        const canonicalFields = binder.canonicalFields(series);\n        const valueFields = binder.valueFields(series);\n        const sourceFields = binder.sourceFields(series, canonicalFields);\n        const seriesFields = this._seriesFields = [];\n        const defaults = defaultAggregates.query(series.type);\n        const rootAggregate = series.aggregate || defaults;\n\n        this._series = series;\n        this._binder = binder;\n\n        for (let i = 0; i < canonicalFields.length; i++) {\n            const field = canonicalFields[i];\n            let fieldAggregate;\n\n            if (isObject(rootAggregate)) {\n                fieldAggregate = rootAggregate[field];\n            } else if (i === 0 || inArray(field, valueFields)) {\n                fieldAggregate = rootAggregate;\n            } else {\n                break;\n            }\n\n            if (fieldAggregate) {\n                seriesFields.push({\n                    canonicalName: field,\n                    name: sourceFields[i],\n                    transform: isFunction(fieldAggregate) ? fieldAggregate : aggregates[fieldAggregate]\n                });\n            }\n        }\n    }\n\n    aggregatePoints(srcPoints, group) {\n        const { _series: series, _seriesFields: seriesFields } = this;\n        const data = this._bindPoints(srcPoints || []);\n        const firstDataItem = data.dataItems[0];\n        let result = {};\n\n        if (firstDataItem && !isNumber(firstDataItem) && !isArray(firstDataItem)) {\n            const fn = function() {};\n            fn.prototype = firstDataItem;\n            result = new fn();\n        }\n\n        for (let i = 0; i < seriesFields.length; i++) {\n            const field = seriesFields[i];\n            const srcValues = this._bindField(data.values, field.canonicalName);\n            const value = field.transform(srcValues, series, data.dataItems, group);\n\n            if (value !== null && isObject(value) && !defined(value.length) && !(value instanceof Date)) {\n                result = value;\n                break;\n            } else {\n                if (defined(value)) {\n                    setValue(field.name, result, value);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    _bindPoints(points) {\n        const { _binder: binder, _series: series } = this;\n        const values = [];\n        const dataItems = [];\n\n        for (let i = 0; i < points.length; i++) {\n            const pointIx = points[i];\n\n            values.push(binder.bindPoint(series, pointIx));\n            dataItems.push(series.data[pointIx]);\n        }\n\n        return {\n            values: values,\n            dataItems: dataItems\n        };\n    }\n\n    _bindField(data, field) {\n        const values = [];\n        const count = data.length;\n\n        for (let i = 0; i < count; i++) {\n            const item = data[i];\n            const valueFields = item.valueFields;\n            let value;\n\n            if (defined(valueFields[field])) {\n                value = valueFields[field];\n            } else {\n                value = item.fields[field];\n            }\n\n            values.push(value);\n        }\n\n        return values;\n    }\n}\n\nfunction setValue(fieldName, target, value) {\n    let parentObj = target;\n    let field = fieldName;\n\n    if (fieldName.indexOf(\".\") > -1) {\n        const parts = fieldName.split(\".\");\n\n        while (parts.length > 1) {\n            field = parts.shift();\n            if (!defined(parentObj[field])) {\n                parentObj[field] = {};\n            }\n            parentObj = parentObj[field];\n        }\n        field = parts.shift();\n    }\n\n    parentObj[field] = value;\n}\n\n/* harmony default export */ var series_aggregator = (series_aggregator_SeriesAggregator);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/aggregates/default-aggregates.js\n\nlet default_aggregates_DefaultAggregates = /*@__PURE__*/ (() => {\n    class DefaultAggregates extends common_class[\"a\" /* default */] {\n        constructor() {\n            super();\n            this._defaults = {};\n        }\n        register(seriesTypes, aggregates) {\n            for (let i = 0; i < seriesTypes.length; i++) {\n                this._defaults[seriesTypes[i]] = aggregates;\n            }\n        }\n        query(seriesType) {\n            return this._defaults[seriesType];\n        }\n    }\n    DefaultAggregates.current = new DefaultAggregates();\n    return DefaultAggregates;\n})();\n/* harmony default export */ var default_aggregates = (default_aggregates_DefaultAggregates);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/range-bar-chart/range-bar.js\n\n\n\n\n\nclass range_bar_RangeBar extends bar {\n    createLabel() {\n        const labels = this.options.labels;\n        const fromOptions = deepExtend({}, labels, labels.from);\n        const toOptions = deepExtend({}, labels, labels.to);\n\n        if (fromOptions.visible) {\n            this.labelFrom = this._createLabel(fromOptions);\n            this.append(this.labelFrom);\n        }\n\n        if (toOptions.visible) {\n            this.labelTo = this._createLabel(toOptions);\n            this.append(this.labelTo);\n        }\n    }\n\n    _createLabel(options) {\n        const labelTemplate = getTemplate(options);\n        const pointData = this.pointData();\n\n        let labelText;\n\n        if (labelTemplate) {\n            labelText = labelTemplate(pointData);\n        } else {\n            labelText = this.formatValue(options.format);\n        }\n\n        return new bar_label(labelText,\n            deepExtend({\n                vertical: this.options.vertical\n            },\n            options\n        ), pointData);\n    }\n\n    reflow(targetBox) {\n        this.render();\n\n        const { labelFrom, labelTo, value } = this;\n\n        this.box = targetBox;\n\n        if (labelFrom) {\n            labelFrom.options.aboveAxis = value.from > value.to;\n            labelFrom.reflow(targetBox);\n        }\n\n        if (labelTo) {\n            labelTo.options.aboveAxis = value.to > value.from;\n            labelTo.reflow(targetBox);\n        }\n\n        if (this.note) {\n            this.note.reflow(targetBox);\n        }\n    }\n}\n\nrange_bar_RangeBar.prototype.defaults = deepExtend({}, range_bar_RangeBar.prototype.defaults, {\n    labels: {\n        format: \"{0} - {1}\"\n    },\n    tooltip: {\n        format: \"{1}\"\n    }\n});\n\n/* harmony default export */ var range_bar = (range_bar_RangeBar);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/range-bar-chart/range-bar-chart.js\n\n\n\n\n\n\n\nclass range_bar_chart_RangeBarChart extends bar_chart {\n    pointType() {\n        return range_bar;\n    }\n\n    pointValue(data) {\n        return data.valueFields;\n    }\n\n    formatPointValue(point, format) {\n        if (point.value.from === null && point.value.to === null) {\n            return \"\";\n        }\n\n        return this.chartService.format.auto(format, point.value.from, point.value.to);\n    }\n\n    plotRange(point) {\n        if (!point) {\n            return 0;\n        }\n\n        return [ point.value.from, point.value.to ];\n    }\n\n    updateRange(value, fields) {\n        const axisName = fields.series.axis;\n        const { from, to } = value;\n        let axisRange = this.valueAxisRanges[axisName];\n\n        if (value !== null && isNumber(from) && isNumber(to)) {\n            axisRange = this.valueAxisRanges[axisName] = axisRange || { min: MAX_VALUE, max: MIN_VALUE };\n\n            axisRange.min = Math.min(axisRange.min, from);\n            axisRange.max = Math.max(axisRange.max, from);\n\n            axisRange.min = Math.min(axisRange.min, to);\n            axisRange.max = Math.max(axisRange.max, to);\n        }\n    }\n\n    aboveAxis(point) {\n        const value = point.value;\n        return value.from < value.to;\n    }\n}\n\nrange_bar_chart_RangeBarChart.prototype.plotLimits = categorical_chart.prototype.plotLimits;\n\n/* harmony default export */ var range_bar_chart = (range_bar_chart_RangeBarChart);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/range-area-chart/range-line-point.js\n\n\nclass range_line_point_RangeLinePoint extends line_point {\n    aliasFor() {\n        return this.parent;\n    }\n}\n\n/* harmony default export */ var range_line_point = (range_line_point_RangeLinePoint);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/range-area-chart/range-area-point.js\n\n\n\n\n\n\n\n\n\n\n\nconst range_area_point_AUTO = 'auto';\nconst DEFAULT_FROM_FORMAT = '{0}';\nconst DEFAULT_TO_FORMAT = '{1}';\n\nclass range_area_point_RangeAreaPoint extends chart_element {\n    constructor(value, options) {\n        super();\n\n        this.value = value;\n        this.options = options;\n        this.aboveAxis = valueOrDefault(this.options.aboveAxis, true);\n        this.tooltipTracking = true;\n        this.initLabelsFormat();\n    }\n\n    render() {\n        if (this._rendered) {\n            return;\n        }\n\n        this._rendered = true;\n\n        const { markers, labels } = this.options;\n        const value = this.value;\n\n        const fromPoint = this.fromPoint = new range_line_point(value, deepExtend({}, this.options, {\n            labels: labels.from,\n            markers: markers.from\n        }));\n\n        const toPoint = this.toPoint = new range_line_point(value, deepExtend({}, this.options, {\n            labels: labels.to,\n            markers: markers.to\n        }));\n\n        this.copyFields(fromPoint);\n        this.copyFields(toPoint);\n\n        this.append(fromPoint);\n        this.append(toPoint);\n    }\n\n    reflow(targetBox) {\n        this.render();\n\n        const { from: fromBox, to: toBox } = targetBox;\n\n        this.positionLabels(fromBox, toBox);\n\n        this.fromPoint.reflow(fromBox);\n        this.toPoint.reflow(toBox);\n\n        this.box = this.fromPoint.markerBox().clone().wrap(this.toPoint.markerBox());\n    }\n\n    createHighlight() {\n        const group = new main[\"a\" /* drawing */].Group();\n        group.append(this.fromPoint.createHighlight());\n        group.append(this.toPoint.createHighlight());\n\n        return group;\n    }\n\n    highlightVisual() {\n        return this.visual;\n    }\n\n    highlightVisualArgs() {\n        return {\n            options: this.options,\n            from: this.fromPoint.highlightVisualArgs(),\n            to: this.toPoint.highlightVisualArgs()\n        };\n    }\n\n    tooltipAnchor() {\n        const clipBox = this.owner.pane.clipBox();\n        const showTooltip = !clipBox || clipBox.overlaps(this.box);\n\n        if (showTooltip) {\n            const box = this.box;\n            const center = box.center();\n            const horizontalAlign = LEFT;\n            let x, y, verticalAlign;\n\n            if (this.options.vertical) {\n                x = center.x;\n                y = box.y1 - TOOLTIP_OFFSET;\n                verticalAlign = BOTTOM;\n            } else {\n                x = box.x2 + TOOLTIP_OFFSET;\n                y = center.y;\n                verticalAlign = CENTER;\n            }\n\n            return {\n                point: new core_point(x, y),\n                align: {\n                    horizontal: horizontalAlign,\n                    vertical: verticalAlign\n                }\n            };\n        }\n    }\n\n    formatValue(format) {\n        return this.owner.formatPointValue(this, format);\n    }\n\n    overlapsBox(box) {\n        return this.box.overlaps(box);\n    }\n\n    unclipElements() {\n        this.fromPoint.unclipElements();\n        this.toPoint.unclipElements();\n    }\n\n    initLabelsFormat() {\n        const labels = this.options.labels;\n        if (!labels.format) {\n            if (!labels.from || !labels.from.format) {\n                labels.from = Object.assign({}, labels.from, {\n                    format: DEFAULT_FROM_FORMAT\n                });\n            }\n\n            if (!labels.to || !labels.to.format) {\n                labels.to = Object.assign({}, labels.to, {\n                    format: DEFAULT_TO_FORMAT\n                });\n            }\n        }\n    }\n\n    positionLabels(fromBox, toBox) {\n        const { labels, vertical } = this.options;\n\n        if (labels.position === range_area_point_AUTO) {\n            let fromLabelPosition, toLabelPosition;\n            if (vertical) {\n                if (toBox.y1 <= fromBox.y1) {\n                    toLabelPosition = ABOVE;\n                    fromLabelPosition = BELOW;\n                } else {\n                    toLabelPosition = BELOW;\n                    fromLabelPosition = ABOVE;\n                }\n            } else {\n                if (toBox.x1 <= fromBox.x1) {\n                    toLabelPosition = LEFT;\n                    fromLabelPosition = RIGHT;\n                } else {\n                    toLabelPosition = RIGHT;\n                    fromLabelPosition = LEFT;\n                }\n            }\n\n            if (!labels.from || !labels.from.position) {\n                this.fromPoint.options.labels.position = fromLabelPosition;\n            }\n\n            if (!labels.to || !labels.to.position) {\n                this.toPoint.options.labels.position = toLabelPosition;\n            }\n        }\n    }\n\n    copyFields(point) {\n        point.dataItem = this.dataItem;\n        point.category = this.category;\n        point.series = this.series;\n        point.color = this.color;\n        point.owner = this.owner;\n    }\n}\n\ndeepExtend(range_area_point_RangeAreaPoint.prototype, point_events_mixin);\ndeepExtend(range_area_point_RangeAreaPoint.prototype, note_mixin);\n\nrange_area_point_RangeAreaPoint.prototype.defaults = {\n    markers: {\n        visible: false,\n        background: WHITE,\n        size: LINE_MARKER_SIZE,\n        type: CIRCLE,\n        border: {\n            width: 2\n        },\n        opacity: 1\n    },\n    labels: {\n        visible: false,\n        margin: getSpacing(3),\n        padding: getSpacing(4),\n        animation: {\n            type: FADEIN,\n            delay: INITIAL_ANIMATION_DURATION\n        },\n        position: range_area_point_AUTO\n    },\n    notes: {\n        label: {}\n    },\n    highlight: {\n        markers: {\n            border: {\n                color: WHITE,\n                width: 2\n            }\n        },\n        zIndex: HIGHLIGHT_ZINDEX\n    },\n    tooltip: {\n        format: '{0} - {1}'\n    }\n};\n\n/* harmony default export */ var range_area_point = (range_area_point_RangeAreaPoint);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/range-area-chart/range-area-segment.js\n\n\n\nclass range_area_segment_RangeAreaSegment extends area_segment {\n\n    createStrokeSegments() {\n        return this.segmentsFromPoints(this.toGeometryPoints(this.toPoints()));\n    }\n\n    stackSegments() {\n        let fromSegments = this.fromSegments;\n        if (!this.fromSegments) {\n            fromSegments = this.fromSegments = this.segmentsFromPoints(this.toGeometryPoints(this.fromPoints().reverse()));\n        }\n\n        return fromSegments;\n    }\n\n    createStroke(style) {\n        const toPath = new main[\"a\" /* drawing */].Path(style);\n        const fromPath = new main[\"a\" /* drawing */].Path(style);\n\n        toPath.segments.push.apply(toPath.segments, this.strokeSegments());\n        fromPath.segments.push.apply(fromPath.segments, this.stackSegments());\n\n        this.visual.append(toPath);\n        this.visual.append(fromPath);\n    }\n\n    hasStackSegment() {\n        return true;\n    }\n\n    fromPoints() {\n        return this.linePoints.map(point => point.fromPoint);\n    }\n\n    toPoints() {\n        return this.linePoints.map(point => point.toPoint);\n    }\n}\n\n/* harmony default export */ var range_area_segment = (range_area_segment_RangeAreaSegment);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/range-area-chart/spline-range-area-segment.js\n\n\n\n\nclass spline_range_area_segment_SplineRangeAreaSegment extends range_area_segment {\n\n    createStrokeSegments() {\n        return this.createCurveSegments(this.toPoints());\n    }\n\n    stackSegments() {\n        let fromSegments = this.fromSegments;\n        if (!this.fromSegments) {\n            fromSegments = this.fromSegments = this.createCurveSegments(this.fromPoints().reverse());\n        }\n\n        return fromSegments;\n    }\n\n    createCurveSegments(points) {\n        const curveProcessor = new curve_processor();\n\n        return curveProcessor.process(this.toGeometryPoints(points));\n    }\n\n\n}\n\n/* harmony default export */ var spline_range_area_segment = (spline_range_area_segment_SplineRangeAreaSegment);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/range-area-chart/step-range-area-segment.js\n\n\n\n\nclass step_range_area_segment_StepRangeAreaSegment extends range_area_segment {\n\n    createStrokeSegments() {\n        return this.segmentsFromPoints(this.calculateStepPoints(this.toPoints()));\n    }\n\n    stackSegments() {\n        let fromSegments = this.fromSegments;\n        if (!this.fromSegments) {\n            fromSegments = this.fromSegments = this.segmentsFromPoints(this.calculateStepPoints(this.fromPoints()));\n            fromSegments.reverse();\n        }\n\n        return fromSegments;\n    }\n}\n\ndeepExtend(step_range_area_segment_StepRangeAreaSegment.prototype, step_line_mixin);\n\n/* harmony default export */ var step_range_area_segment = (step_range_area_segment_StepRangeAreaSegment);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/range-area-chart/range-area-chart.js\n\n\n\n\n\n\n\n\n\n\n\n\n\nlet range_area_chart_RangeAreaChart = /*@__PURE__*/ (() => {\n    class RangeAreaChart extends categorical_chart {\n        render() {\n            super.render();\n            this.renderSegments();\n        }\n        pointType() {\n            return range_area_point;\n        }\n        createPoint(data, fields) {\n            const { categoryIx, category, series, seriesIx } = fields;\n            let value = data.valueFields;\n            if (!has_value_hasValue(value.from) && !has_value_hasValue(value.to)) {\n                if (this.seriesMissingValues(series) === ZERO) {\n                    value = {\n                        from: 0,\n                        to: 0\n                    };\n                }\n                else {\n                    return null;\n                }\n            }\n            let pointOptions = this.pointOptions(series, seriesIx);\n            pointOptions = this.evalPointOptions(pointOptions, value, category, categoryIx, series, seriesIx);\n            let color = data.fields.color || series.color;\n            if (isFunction(series.color)) {\n                color = pointOptions.color;\n            }\n            const point = new range_area_point(value, pointOptions);\n            point.color = color;\n            this.append(point);\n            return point;\n        }\n        createSegment(linePoints, currentSeries, seriesIx) {\n            const style = (currentSeries.line || {}).style;\n            let segmentType;\n            if (style === \"smooth\") {\n                segmentType = spline_range_area_segment;\n            }\n            else if (style === \"step\") {\n                segmentType = step_range_area_segment;\n            }\n            else {\n                segmentType = range_area_segment;\n            }\n            return new segmentType(linePoints, currentSeries, seriesIx);\n        }\n        plotRange(point, startValue) {\n            if (!point) {\n                return [startValue, startValue];\n            }\n            return [point.value.from, point.value.to];\n        }\n        valueSlot(valueAxis, plotRange) {\n            const fromSlot = valueAxis.getSlot(plotRange[0], plotRange[0], !this.options.clip);\n            const toSlot = valueAxis.getSlot(plotRange[1], plotRange[1], !this.options.clip);\n            if (fromSlot && toSlot) {\n                return {\n                    from: fromSlot,\n                    to: toSlot\n                };\n            }\n        }\n        pointSlot(categorySlot, valueSlot) {\n            const { from, to } = valueSlot;\n            let fromSlot, toSlot;\n            if (this.options.invertAxes) {\n                fromSlot = new core_box(from.x1, categorySlot.y1, from.x2, categorySlot.y2);\n                toSlot = new core_box(to.x1, categorySlot.y1, to.x2, categorySlot.y2);\n            }\n            else {\n                fromSlot = new core_box(categorySlot.x1, from.y1, categorySlot.x2, from.y2);\n                toSlot = new core_box(categorySlot.x1, to.y1, categorySlot.x2, to.y2);\n            }\n            return {\n                from: fromSlot,\n                to: toSlot\n            };\n        }\n        addValue(data, fields) {\n            const valueFields = data.valueFields;\n            if (!isNumber(valueFields.from)) {\n                valueFields.from = valueFields.to;\n            }\n            if (!isNumber(valueFields.to)) {\n                valueFields.to = valueFields.from;\n            }\n            super.addValue(data, fields);\n        }\n        updateRange(value, fields) {\n            if (value !== null && isNumber(value.from) && isNumber(value.to)) {\n                const axisName = fields.series.axis;\n                const axisRange = this.valueAxisRanges[axisName] = this.valueAxisRanges[axisName] || { min: MAX_VALUE, max: MIN_VALUE };\n                const { from, to } = value;\n                axisRange.min = Math.min(axisRange.min, from, to);\n                axisRange.max = Math.max(axisRange.max, from, to);\n            }\n        }\n        formatPointValue(point, format) {\n            const value = point.value;\n            return this.chartService.format.auto(format, value.from, value.to);\n        }\n        animationPoints() {\n            const points = this.points;\n            const result = [];\n            for (let idx = 0; idx < points.length; idx++) {\n                const point = points[idx];\n                if (point) {\n                    result.push((point.fromPoint || {}).marker);\n                    result.push((point.toPoint || {}).marker);\n                }\n            }\n            return result.concat(this._segments);\n        }\n    }\n    deepExtend(RangeAreaChart.prototype, line_chart_mixin, clip_animation_mixin);\n    return RangeAreaChart;\n})();\n/* harmony default export */ var range_area_chart = (range_area_chart_RangeAreaChart);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/ohlc-chart/ohlc-point.js\n\n\nclass ohlc_point_OHLCPoint extends candlestick {\n    reflow(box) {\n        const { options, value, owner: chart } = this;\n        const valueAxis = chart.seriesValueAxis(options);\n        const oPoints = [];\n        const cPoints = [];\n        const lhPoints = [];\n\n        const lhSlot = valueAxis.getSlot(value.low, value.high);\n        const oSlot = valueAxis.getSlot(value.open, value.open);\n        const cSlot = valueAxis.getSlot(value.close, value.close);\n\n        oSlot.x1 = cSlot.x1 = lhSlot.x1 = box.x1;\n        oSlot.x2 = cSlot.x2 = lhSlot.x2 = box.x2;\n\n        const mid = lhSlot.center().x;\n\n        oPoints.push([ oSlot.x1, oSlot.y1 ]);\n        oPoints.push([ mid, oSlot.y1 ]);\n        cPoints.push([ mid, cSlot.y1 ]);\n        cPoints.push([ cSlot.x2, cSlot.y1 ]);\n        lhPoints.push([ mid, lhSlot.y1 ]);\n        lhPoints.push([ mid, lhSlot.y2 ]);\n\n        this.lines = [\n            oPoints, cPoints, lhPoints\n        ];\n\n        this.box = lhSlot.clone().wrap(oSlot.clone().wrap(cSlot));\n\n        this.reflowNote();\n    }\n\n    createBody() {}\n}\n\n/* harmony default export */ var ohlc_point = (ohlc_point_OHLCPoint);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/ohlc-chart/ohlc-chart.js\n\n\n\nclass ohlc_chart_OHLCChart extends candlestick_chart {\n    pointType() {\n        return ohlc_point;\n    }\n}\n\n/* harmony default export */ var ohlc_chart = (ohlc_chart_OHLCChart);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/waterfall-chart/waterfall-segment.js\n\n\n\n\n\n\n\n\nclass waterfall_segment_WaterfallSegment extends chart_element {\n    constructor(from, to, series) {\n        super();\n\n        this.from = from;\n        this.to = to;\n        this.series = series;\n    }\n\n    linePoints() {\n        const from = this.from;\n        const { from: { box: fromBox }, to: { box: toBox } } = this;\n        const points = [];\n\n        if (from.isVertical) {\n            const y = from.aboveAxis ? fromBox.y1 : fromBox.y2;\n            points.push(\n                [ fromBox.x1, y ],\n                [ toBox.x2, y ]\n            );\n        } else {\n            const x = from.aboveAxis ? fromBox.x2 : fromBox.x1;\n            points.push(\n                [ x, fromBox.y1 ],\n                [ x, toBox.y2 ]\n            );\n        }\n\n        return points;\n    }\n\n    createVisual() {\n        super.createVisual();\n\n        const line = this.series.line || {};\n\n        const path = main[\"a\" /* drawing */].Path.fromPoints(this.linePoints(), {\n            stroke: {\n                color: line.color,\n                width: line.width,\n                opacity: line.opacity,\n                dashType: line.dashType\n            }\n        });\n\n        alignPathToPixel(path);\n        this.visual.append(path);\n    }\n}\n\nsetDefaultOptions(waterfall_segment_WaterfallSegment, {\n    animation: {\n        type: FADEIN,\n        delay: INITIAL_ANIMATION_DURATION\n    }\n});\n\n/* harmony default export */ var waterfall_segment = (waterfall_segment_WaterfallSegment);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/waterfall-chart/waterfall-chart.js\n\n\n\n\n\n\n\n\nclass waterfall_chart_WaterfallChart extends bar_chart {\n    render() {\n        super.render();\n        this.createSegments();\n    }\n\n    traverseDataPoints(callback) {\n        const series = this.options.series;\n        const totalCategories = categoriesCount(series);\n        const isVertical = !this.options.invertAxes;\n\n        for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {\n            const currentSeries = series[seriesIx];\n            let total = 0;\n            let runningTotal = 0;\n\n            for (let categoryIx = 0; categoryIx < totalCategories; categoryIx++) {\n                const data = series_binder.current.bindPoint(currentSeries, categoryIx);\n                const value = data.valueFields.value;\n                const summary = data.fields.summary;\n                let from = total;\n                let to;\n\n                if (summary) {\n                    if (summary.toLowerCase() === \"total\") {\n                        data.valueFields.value = total;\n                        from = 0;\n                        to = total;\n                    } else {\n                        data.valueFields.value = runningTotal;\n                        to = from - runningTotal;\n                        runningTotal = 0;\n                    }\n                } else if (isNumber(value)) {\n                    runningTotal += value;\n                    total += value;\n                    to = total;\n                }\n\n                callback(data, {\n                    category: this.categoryAxis.categoryAt(categoryIx),\n                    categoryIx: categoryIx,\n                    series: currentSeries,\n                    seriesIx: seriesIx,\n                    total: total,\n                    runningTotal: runningTotal,\n                    from: from,\n                    to: to,\n                    isVertical: isVertical\n                });\n            }\n        }\n    }\n\n    updateRange(value, fields) {\n        super.updateRange({ value: fields.to }, fields);\n    }\n\n    aboveAxis(point) {\n        return point.value >= 0;\n    }\n\n    plotRange(point) {\n        return [ point.from, point.to ];\n    }\n\n    createSegments() {\n        const series = this.options.series;\n        const seriesPoints = this.seriesPoints;\n        const segments = this.segments = [];\n\n        for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {\n            const currentSeries = series[seriesIx];\n            const points = seriesPoints[seriesIx];\n\n            if (points) {\n                let prevPoint;\n                for (let pointIx = 0; pointIx < points.length; pointIx++) {\n                    const point = points[pointIx];\n\n                    if (point && prevPoint) {\n                        const segment = new waterfall_segment(prevPoint, point, currentSeries);\n                        segments.push(segment);\n                        this.append(segment);\n                    }\n\n                    prevPoint = point;\n                }\n            }\n        }\n    }\n}\n\n/* harmony default export */ var waterfall_chart = (waterfall_chart_WaterfallChart);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/plotarea/categorical-plotarea.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst AREA_SERIES = [ AREA, VERTICAL_AREA, RANGE_AREA, VERTICAL_RANGE_AREA ];\nconst OUT_OF_RANGE_SERIES = [ LINE, VERTICAL_LINE ].concat(AREA_SERIES);\n\nclass categorical_plotarea_CategoricalPlotArea extends plotarea_base {\n\n    initFields(series) {\n        this.namedCategoryAxes = {};\n        this.namedValueAxes = {};\n        this.valueAxisRangeTracker = new axis_group_range_tracker();\n\n        if (series.length > 0) {\n            this.invertAxes = inArray(\n                series[0].type, [ BAR, BULLET, VERTICAL_LINE, VERTICAL_AREA, VERTICAL_RANGE_AREA,\n                                 RANGE_BAR, HORIZONTAL_WATERFALL, VERTICAL_BOX_PLOT ]\n            );\n\n            for (let i = 0; i < series.length; i++) {\n                const stack = series[i].stack;\n                if (stack && stack.type === \"100%\") {\n                    this.stack100 = true;\n                    break;\n                }\n            }\n        }\n\n    }\n\n    render(panes = this.panes) {\n        this.createCategoryAxes(panes);\n        this.aggregateCategories(panes);\n        this.createCategoryAxesLabels(panes);\n        this.createCharts(panes);\n        this.createValueAxes(panes);\n    }\n\n    removeAxis(axis) {\n        const axisName = axis.options.name;\n\n        super.removeAxis(axis);\n\n        if (axis instanceof category_axis) {\n            delete this.namedCategoryAxes[axisName];\n        } else {\n            this.valueAxisRangeTracker.reset(axisName);\n            delete this.namedValueAxes[axisName];\n        }\n\n        if (axis === this.categoryAxis) {\n            delete this.categoryAxis;\n        }\n\n        if (axis === this.valueAxis) {\n            delete this.valueAxis;\n        }\n    }\n\n    createCharts(panes) {\n        const seriesByPane = this.groupSeriesByPane();\n\n        for (let i = 0; i < panes.length; i++) {\n            const pane = panes[i];\n            const paneSeries = seriesByPane[pane.options.name || \"default\"] || [];\n            this.addToLegend(paneSeries);\n\n            const visibleSeries = this.filterVisibleSeries(paneSeries);\n            if (!visibleSeries) {\n                continue;\n            }\n\n            const groups = this.groupSeriesByCategoryAxis(visibleSeries);\n            for (let groupIx = 0; groupIx < groups.length; groupIx++) {\n                this.createChartGroup(groups[groupIx], pane);\n            }\n        }\n    }\n\n    createChartGroup(series, pane) {\n        this.createAreaChart(\n            filterSeriesByType(series, [ AREA, VERTICAL_AREA ]), pane\n        );\n\n        this.createRangeAreaChart(\n            filterSeriesByType(series, [ RANGE_AREA, VERTICAL_RANGE_AREA ]), pane\n        );\n\n        this.createBarChart(\n            filterSeriesByType(series, [ COLUMN, BAR ]), pane\n        );\n\n        this.createRangeBarChart(\n            filterSeriesByType(series, [ RANGE_COLUMN, RANGE_BAR ]), pane\n        );\n\n        this.createBulletChart(\n            filterSeriesByType(series, [ BULLET, VERTICAL_BULLET ]), pane\n        );\n\n        this.createCandlestickChart(\n            filterSeriesByType(series, CANDLESTICK), pane\n        );\n\n        this.createBoxPlotChart(\n            filterSeriesByType(series, [ BOX_PLOT, VERTICAL_BOX_PLOT ]), pane\n        );\n\n        this.createOHLCChart(\n            filterSeriesByType(series, OHLC), pane\n        );\n\n        this.createWaterfallChart(\n            filterSeriesByType(series, [ WATERFALL, HORIZONTAL_WATERFALL ]), pane\n        );\n\n        this.createLineChart(\n            filterSeriesByType(series, [ LINE, VERTICAL_LINE ]), pane\n        );\n    }\n\n    aggregateCategories(panes) {\n        const series = this.srcSeries || this.series;\n        const processedSeries = [];\n        this._currentPointsCache = {};\n        this._seriesPointsCache = this._seriesPointsCache || {};\n\n        for (let i = 0; i < series.length; i++) {\n            let currentSeries = series[i];\n            const categoryAxis = this.seriesCategoryAxis(currentSeries);\n            const axisPane = this.findPane(categoryAxis.options.pane);\n            const dateAxis = equalsIgnoreCase(categoryAxis.options.type, DATE);\n\n            if ((dateAxis || currentSeries.categoryField) && inArray(axisPane, panes)) {\n                currentSeries = this.aggregateSeries(currentSeries, categoryAxis);\n            } else {\n                currentSeries = this.filterSeries(currentSeries, categoryAxis);\n            }\n\n            processedSeries.push(currentSeries);\n        }\n\n        this._seriesPointsCache = this._currentPointsCache;\n        this._currentPointsCache = null;\n\n        this.srcSeries = series;\n        this.series = processedSeries;\n    }\n\n    filterSeries(series, categoryAxis) {\n        const dataLength = (series.data || {}).length;\n        categoryAxis._seriesMax = Math.max(categoryAxis._seriesMax || 0, dataLength);\n\n        if (!(isNumber(categoryAxis.options.min) || isNumber(categoryAxis.options.max))) {\n            return series;\n        }\n\n        const range = categoryAxis.currentRangeIndices();\n        const outOfRangePoints = inArray(series.type, OUT_OF_RANGE_SERIES);\n        const currentSeries = deepExtend({}, series);\n\n        currentSeries.data = (currentSeries.data || []).slice(range.min, range.max + 1);\n\n        if (outOfRangePoints) {\n            createOutOfRangePoints(currentSeries, range, dataLength, (idx) => ({\n                item: series.data[idx],\n                category: categoryAxis.categoryAt(idx, true),\n                categoryIx: idx - range.min\n            }), (idx) => defined(series.data[idx]));\n        }\n\n        return currentSeries;\n    }\n\n    clearSeriesPointsCache() {\n        this._seriesPointsCache = {};\n    }\n\n    seriesSourcePoints(series, categoryAxis) {\n        const key = `${ series.index };${ categoryAxis.categoriesHash() }`;\n        if (this._seriesPointsCache[key]) {\n            this._currentPointsCache[key] = this._seriesPointsCache[key];\n            return this._seriesPointsCache[key];\n        }\n\n        const axisOptions = categoryAxis.options;\n        const srcCategories = axisOptions.srcCategories;\n        const dateAxis = equalsIgnoreCase(axisOptions.type, DATE);\n        const srcData = series.data;\n        const getFn = dateAxis ? getDateField : getField;\n        const result = [];\n        if (!dateAxis) {\n            categoryAxis.mapCategories();//fixes major performance issue caused by searching for the index for large data\n        }\n\n        for (let idx = 0; idx < srcData.length; idx++) {\n            let category;\n            if (series.categoryField) {\n                category = getFn(series.categoryField, srcData[idx], this.chartService.intl);\n            } else {\n                category = srcCategories[idx];\n            }\n\n            if (defined(category) && category !== null) {\n                const categoryIx = categoryAxis.totalIndex(category);\n                result[categoryIx] = result[categoryIx] || { items: [], category: category };\n                result[categoryIx].items.push(idx);\n            }\n        }\n\n        this._currentPointsCache[key] = result;\n\n        return result;\n    }\n\n    aggregateSeries(series, categoryAxis) {\n        const srcData = series.data;\n        if (!srcData.length) {\n            return series;\n        }\n\n        const srcPoints = this.seriesSourcePoints(series, categoryAxis);\n        const result = deepExtend({}, series);\n        const aggregator = new series_aggregator(deepExtend({}, series), series_binder.current, default_aggregates.current);\n        const data = result.data = [];\n        const dataItems = categoryAxis.options.dataItems || [];\n\n        const range = categoryAxis.currentRangeIndices();\n        const categoryItem = (idx) => {\n            const categoryIdx = idx - range.min;\n            let point = srcPoints[idx];\n            if (!point) {\n                point = srcPoints[idx] = {};\n            }\n\n            point.categoryIx = categoryIdx;\n\n            if (!point.item) {\n                const category = categoryAxis.categoryAt(idx, true);\n                point.category = category;\n                point.item = aggregator.aggregatePoints(point.items, category);\n            }\n\n            return point;\n        };\n\n        for (let idx = range.min; idx <= range.max; idx++) {\n            const point = categoryItem(idx);\n            data[point.categoryIx] = point.item;\n\n            if (point.items && point.items.length) {\n                dataItems[point.categoryIx] = point.item;\n            }\n        }\n\n        if (inArray(result.type, OUT_OF_RANGE_SERIES)) {\n            createOutOfRangePoints(result, range, categoryAxis.totalCount(), categoryItem, (idx) => srcPoints[idx]);\n        }\n\n        categoryAxis.options.dataItems = dataItems;\n\n        return result;\n    }\n\n    appendChart(chart, pane) {\n        const series = chart.options.series;\n        const categoryAxis = this.seriesCategoryAxis(series[0]);\n        let categories = categoryAxis.options.categories;\n        let categoriesToAdd = Math.max(0, categoriesCount(series) - categories.length);\n\n        if (categoriesToAdd > 0) {//consider setting an option to axis instead of adding fake categories\n            categories = categoryAxis.options.categories = categoryAxis.options.categories.slice(0);\n            while (categoriesToAdd--) {\n                categories.push(\"\");\n            }\n        }\n\n        this.valueAxisRangeTracker.update(chart.valueAxisRanges);\n\n        super.appendChart(chart, pane);\n    }\n\n    // TODO: Refactor, optionally use series.pane option\n    seriesPaneName(series) {\n        const options = this.options;\n        const axisName = series.axis;\n        const axisOptions = [].concat(options.valueAxis);\n        const axis = grep(axisOptions, function(a) { return a.name === axisName; })[0];\n        const panes = options.panes || [ {} ];\n        const defaultPaneName = (panes[0] || {}).name || \"default\";\n        const paneName = (axis || {}).pane || defaultPaneName;\n\n        return paneName;\n    }\n\n    seriesCategoryAxis(series) {\n        const axisName = series.categoryAxis;\n        const axis = axisName ? this.namedCategoryAxes[axisName] : this.categoryAxis;\n\n        if (!axis) {\n            throw new Error(\"Unable to locate category axis with name \" + axisName);\n        }\n\n        return axis;\n    }\n\n    stackableChartOptions(firstSeries, pane) {\n        const stack = firstSeries.stack;\n        const isStacked100 = stack && stack.type === \"100%\";\n        const clip = pane.options.clip;\n\n        return {\n            isStacked: stack,\n            isStacked100: isStacked100,\n            clip: clip\n        };\n    }\n\n    groupSeriesByCategoryAxis(series) {\n        const categoryAxes = [];\n        const unique = {};\n        for (let idx = 0; idx < series.length; idx++) {\n            const name = series[idx].categoryAxis || \"$$default$$\";\n            if (!unique.hasOwnProperty(name)) {\n                unique[name] = true;\n                categoryAxes.push(name);\n            }\n        }\n\n        const groups = [];\n        for (let axisIx = 0; axisIx < categoryAxes.length; axisIx++) {\n            const axis = categoryAxes[axisIx];\n            const axisSeries = groupSeries(series, axis, axisIx);\n            if (axisSeries.length === 0) {\n                continue;\n            }\n\n            groups.push(axisSeries);\n        }\n\n        return groups;\n    }\n\n    createBarChart(series, pane) {\n        if (series.length === 0) {\n            return;\n        }\n\n        const firstSeries = series[0];\n        const barChart = new bar_chart(this, Object.assign({\n            series: series,\n            invertAxes: this.invertAxes,\n            gap: firstSeries.gap,\n            spacing: firstSeries.spacing\n        }, this.stackableChartOptions(firstSeries, pane)));\n\n        this.appendChart(barChart, pane);\n    }\n\n    createRangeBarChart(series, pane) {\n        if (series.length === 0) {\n            return;\n        }\n\n        const firstSeries = series[0];\n        const rangeColumnChart = new range_bar_chart(this, {\n            series: series,\n            invertAxes: this.invertAxes,\n            gap: firstSeries.gap,\n            spacing: firstSeries.spacing\n        });\n\n        this.appendChart(rangeColumnChart, pane);\n    }\n\n    createBulletChart(series, pane) {\n        if (series.length === 0) {\n            return;\n        }\n\n        const firstSeries = series[0];\n        const bulletChart = new bullet_chart(this, {\n            series: series,\n            invertAxes: this.invertAxes,\n            gap: firstSeries.gap,\n            spacing: firstSeries.spacing,\n            clip: pane.options.clip\n        });\n\n        this.appendChart(bulletChart, pane);\n    }\n\n    createLineChart(series, pane) {\n        if (series.length === 0) {\n            return;\n        }\n\n        const firstSeries = series[0];\n        const lineChart = new line_chart(this, Object.assign({\n            invertAxes: this.invertAxes,\n            series: series\n        }, this.stackableChartOptions(firstSeries, pane)));\n\n        this.appendChart(lineChart, pane);\n    }\n\n    createAreaChart(series, pane) {\n        if (series.length === 0) {\n            return;\n        }\n\n        const firstSeries = series[0];\n        const areaChart = new area_chart(this, Object.assign({\n            invertAxes: this.invertAxes,\n            series: series\n        }, this.stackableChartOptions(firstSeries, pane)));\n\n        this.appendChart(areaChart, pane);\n    }\n\n    createRangeAreaChart(series, pane) {\n        if (series.length === 0) {\n            return;\n        }\n\n        const rangeAreaChart = new range_area_chart(this, {\n            invertAxes: this.invertAxes,\n            series: series,\n            clip: pane.options.clip\n        });\n\n        this.appendChart(rangeAreaChart, pane);\n    }\n\n    createOHLCChart(series, pane) {\n        if (series.length === 0) {\n            return;\n        }\n\n        const firstSeries = series[0];\n        const chart = new ohlc_chart(this, {\n            invertAxes: this.invertAxes,\n            gap: firstSeries.gap,\n            series: series,\n            spacing: firstSeries.spacing,\n            clip: pane.options.clip\n        });\n\n        this.appendChart(chart, pane);\n    }\n\n    createCandlestickChart(series, pane) {\n        if (series.length === 0) {\n            return;\n        }\n\n        const firstSeries = series[0];\n        const chart = new candlestick_chart(this, {\n            invertAxes: this.invertAxes,\n            gap: firstSeries.gap,\n            series: series,\n            spacing: firstSeries.spacing,\n            clip: pane.options.clip\n        });\n\n        this.appendChart(chart, pane);\n    }\n\n    createBoxPlotChart(series, pane) {\n        if (series.length === 0) {\n            return;\n        }\n\n        const firstSeries = series[0];\n        const chart = new box_plot_chart(this, {\n            invertAxes: this.invertAxes,\n            gap: firstSeries.gap,\n            series: series,\n            spacing: firstSeries.spacing,\n            clip: pane.options.clip\n        });\n\n        this.appendChart(chart, pane);\n    }\n\n    createWaterfallChart(series, pane) {\n        if (series.length === 0) {\n            return;\n        }\n\n        const firstSeries = series[0];\n        const waterfallChart = new waterfall_chart(this, {\n            series: series,\n            invertAxes: this.invertAxes,\n            gap: firstSeries.gap,\n            spacing: firstSeries.spacing\n        });\n\n        this.appendChart(waterfallChart, pane);\n    }\n\n    axisRequiresRounding(categoryAxisName, categoryAxisIndex) {\n        const centeredSeries = filterSeriesByType(this.series, EQUALLY_SPACED_SERIES);\n\n        for (let seriesIx = 0; seriesIx < this.series.length; seriesIx++) {\n            const currentSeries = this.series[seriesIx];\n            if (inArray(currentSeries.type, AREA_SERIES)) {\n                const line = currentSeries.line;\n                if (line && line.style === STEP) {\n                    centeredSeries.push(currentSeries);\n                }\n            }\n        }\n\n        for (let seriesIx = 0; seriesIx < centeredSeries.length; seriesIx++) {\n            const seriesAxis = centeredSeries[seriesIx].categoryAxis || \"\";\n            if (seriesAxis === categoryAxisName || (!seriesAxis && categoryAxisIndex === 0)) {\n                return true;\n            }\n        }\n    }\n\n    aggregatedAxis(categoryAxisName, categoryAxisIndex) {\n        const series = this.series;\n\n        for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {\n            const seriesAxis = series[seriesIx].categoryAxis || \"\";\n            if ((seriesAxis === categoryAxisName || (!seriesAxis && categoryAxisIndex === 0)) && series[seriesIx].categoryField) {\n                return true;\n            }\n        }\n    }\n\n    createCategoryAxesLabels() {\n        const axes = this.axes;\n        for (let i = 0; i < axes.length; i++) {\n            if (axes[i] instanceof category_axis) {\n                axes[i].createLabels();\n            }\n        }\n    }\n\n    createCategoryAxes(panes) {\n        const invertAxes = this.invertAxes;\n        const definitions = [].concat(this.options.categoryAxis);\n        const axes = [];\n\n        for (let i = 0; i < definitions.length; i++) {\n            let axisOptions = definitions[i];\n            const axisPane = this.findPane(axisOptions.pane);\n\n            if (inArray(axisPane, panes)) {\n                const { name, categories = [] } = axisOptions;\n                axisOptions = deepExtend({\n                    vertical: invertAxes,\n                    reverse: !invertAxes && this.chartService.rtl,\n                    axisCrossingValue: invertAxes ? MAX_VALUE : 0\n                }, axisOptions);\n\n                if (!defined(axisOptions.justified)) {\n                    axisOptions.justified = this.isJustified();\n                }\n\n                if (this.axisRequiresRounding(name, i)) {\n                    axisOptions.justified = false;\n                }\n\n                let categoryAxis;\n\n                if (isDateAxis(axisOptions, categories[0])) {\n                    categoryAxis = new date_category_axis(axisOptions, this.chartService);\n                } else {\n                    categoryAxis = new category_axis(axisOptions, this.chartService);\n                }\n\n                definitions[i].categories = categoryAxis.options.srcCategories;\n\n                if (name) {\n                    if (this.namedCategoryAxes[name]) {\n                        throw new Error(`Category axis with name ${ name } is already defined`);\n                    }\n                    this.namedCategoryAxes[name] = categoryAxis;\n                }\n\n                categoryAxis.axisIndex = i;\n                axes.push(categoryAxis);\n                this.appendAxis(categoryAxis);\n            }\n        }\n\n        const primaryAxis = this.categoryAxis || axes[0];\n        this.categoryAxis = primaryAxis;\n\n        if (invertAxes) {\n            this.axisY = primaryAxis;\n        } else {\n            this.axisX = primaryAxis;\n        }\n    }\n\n    isJustified() {\n        const series = this.series;\n\n        for (let i = 0; i < series.length; i++) {\n            const currentSeries = series[i];\n            if (!inArray(currentSeries.type, AREA_SERIES)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    createValueAxes(panes) {\n        const tracker = this.valueAxisRangeTracker;\n        const defaultRange = tracker.query();\n        const definitions = [].concat(this.options.valueAxis);\n        const invertAxes = this.invertAxes;\n        const baseOptions = { vertical: !invertAxes, reverse: invertAxes && this.chartService.rtl };\n        const axes = [];\n\n        if (this.stack100) {\n            baseOptions.roundToMajorUnit = false;\n            baseOptions.labels = { format: \"P0\" };\n        }\n\n        for (let i = 0; i < definitions.length; i++) {\n            const axisOptions = definitions[i];\n            const axisPane = this.findPane(axisOptions.pane);\n\n            if (inArray(axisPane, panes)) {\n                const name = axisOptions.name;\n                const defaultAxisRange = equalsIgnoreCase(axisOptions.type, LOGARITHMIC) ? { min: 0.1, max: 1 } : { min: 0, max: 1 };\n                const range = tracker.query(name) || defaultRange || defaultAxisRange;\n\n                if (i === 0 && range && defaultRange) {\n                    range.min = Math.min(range.min, defaultRange.min);\n                    range.max = Math.max(range.max, defaultRange.max);\n                }\n\n                let axisType;\n                if (equalsIgnoreCase(axisOptions.type, LOGARITHMIC)) {\n                    axisType = logarithmic_axis;\n                } else {\n                    axisType = numeric_axis;\n                }\n\n                const valueAxis = new axisType(range.min, range.max,\n                    deepExtend({}, baseOptions, axisOptions),\n                    this.chartService\n                );\n\n                if (name) {\n                    if (this.namedValueAxes[name]) {\n                        throw new Error(`Value axis with name ${ name } is already defined`);\n                    }\n                    this.namedValueAxes[name] = valueAxis;\n                }\n                valueAxis.axisIndex = i;\n\n                axes.push(valueAxis);\n                this.appendAxis(valueAxis);\n            }\n        }\n\n        const primaryAxis = this.valueAxis || axes[0];\n        this.valueAxis = primaryAxis;\n\n        if (invertAxes) {\n            this.axisX = primaryAxis;\n        } else {\n            this.axisY = primaryAxis;\n        }\n    }\n\n    _dispatchEvent(chart, e, eventType) {\n        const coords = chart._eventCoordinates(e);\n        const point = new core_point(coords.x, coords.y);\n        const pane = this.pointPane(point);\n        const categories = [];\n        const values = [];\n\n        if (!pane) {\n            return;\n        }\n\n        const allAxes = pane.axes;\n        for (let i = 0; i < allAxes.length; i++) {\n            const axis = allAxes[i];\n            if (axis.getValue) {\n                appendIfNotNull(values, axis.getValue(point));\n            } else {\n                appendIfNotNull(categories, axis.getCategory(point));\n            }\n        }\n\n        if (categories.length === 0) {\n            appendIfNotNull(categories, this.categoryAxis.getCategory(point));\n        }\n\n        if (categories.length > 0 && values.length > 0) {\n            chart.trigger(eventType, {\n                element: eventElement(e),\n                originalEvent: e,\n                category: singleItemOrArray(categories),\n                value: singleItemOrArray(values)\n            });\n        }\n    }\n\n    pointPane(point) {\n        const panes = this.panes;\n\n        for (let i = 0; i < panes.length; i++) {\n            const currentPane = panes[i];\n            if (currentPane.contentBox.containsPoint(point)) {\n                return currentPane;\n            }\n        }\n    }\n\n    updateAxisOptions(axis, options) {\n        updateAxisOptions(this.options, axis, options);\n        updateAxisOptions(this.originalOptions, axis, options);\n    }\n}\n\nfunction updateAxisOptions(targetOptions, axis, options) {\n    const axesOptions = axis instanceof category_axis ? [].concat(targetOptions.categoryAxis) : [].concat(targetOptions.valueAxis);\n    deepExtend(axesOptions[axis.axisIndex], options);\n}\n\nfunction groupSeries(series, axis, axisIx) {\n    return grep(series, function(s) {\n        return (axisIx === 0 && !s.categoryAxis) || (s.categoryAxis === axis);\n    });\n}\n\nsetDefaultOptions(categorical_plotarea_CategoricalPlotArea, {\n    categoryAxis: {},\n    valueAxis: {}\n});\n\ndeepExtend(categorical_plotarea_CategoricalPlotArea.prototype, plotarea_events_mixin);\n\n/* harmony default export */ var categorical_plotarea = (categorical_plotarea_CategoricalPlotArea);\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/common/throttle.js\nvar throttle = __webpack_require__(\"6BXq\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/highlight.js\n\n\nclass highlight_Highlight extends common_class[\"a\" /* default */] {\n    constructor() {\n        super();\n\n        this._points = [];\n    }\n\n    destroy() {\n        this._points = [];\n    }\n\n    show(points, opacity) {\n        const arrayPoints = [].concat(points);\n        this.hide();\n\n        for (let i = 0; i < arrayPoints.length; i++) {\n            const point = arrayPoints[i];\n            if (point && point.toggleHighlight && point.hasHighlight()) {\n                this.togglePointHighlight(point, true, opacity);\n                this._points.push(point);\n            }\n        }\n    }\n\n    togglePointHighlight(point, show, opacity) {\n        const toggleHandler = (point.options.highlight || {}).toggle;\n        if (toggleHandler) {\n            const eventArgs = {\n                category: point.category,\n                series: point.series,\n                dataItem: point.dataItem,\n                value: point.value,\n                stackValue: point.stackValue,\n                preventDefault: preventDefault,\n                visual: point.highlightVisual(),\n                show: show\n            };\n            toggleHandler(eventArgs);\n            if (!eventArgs._defaultPrevented) {\n                point.toggleHighlight(show, opacity);\n            }\n        } else {\n            point.toggleHighlight(show, opacity);\n        }\n    }\n\n    hide() {\n        const points = this._points;\n        while (points.length) {\n            this.togglePointHighlight(points.pop(), false);\n        }\n    }\n\n    isHighlighted(element) {\n        const points = this._points;\n\n        for (let i = 0; i < points.length; i++) {\n            const point = points[i];\n            if (element === point) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n\nfunction preventDefault() {\n    this._defaultPrevented = true;\n}\n\n/* harmony default export */ var chart_highlight = (highlight_Highlight);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/pan-and-zoom/accept-key.js\nfunction acceptKey(e, mouseKey) {\n    const key = (mouseKey || \"\").toLowerCase();\n    const event = e.event;\n    const accept = (key === \"none\" && !(event.ctrlKey || event.shiftKey || event.altKey)) || event[key + \"Key\"];\n\n    return accept;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/pan-and-zoom/to-chart-axis-ranges.js\nfunction toChartAxisRanges(axisRanges) {\n    const ranges = {};\n    for (let idx = 0; idx < axisRanges.length; idx++) {\n        const axisRange = axisRanges[idx];\n        if (axisRange.axis.options.name) {\n            ranges[axisRange.axis.options.name] = {\n                min: axisRange.range.min,\n                max: axisRange.range.max\n            };\n        }\n    }\n    return ranges;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/pan-and-zoom/pannable.js\n\n\n\n\n\n\nclass pannable_Pannable extends common_class[\"a\" /* default */] {\n    constructor(plotArea, options) {\n        super();\n\n        this.plotArea = plotArea;\n        this.options = deepExtend({}, this.options, options);\n    }\n\n    start(e) {\n        this._active = acceptKey(e, this.options.key);\n        return this._active;\n    }\n\n    move(e) {\n        if (this._active) {\n            const axisRanges = this.axisRanges = this._panAxes(e, X).concat(this._panAxes(e, Y));\n            if (axisRanges.length) {\n                this.axisRanges = axisRanges;\n                return toChartAxisRanges(axisRanges);\n            }\n        }\n    }\n\n    end() {\n        const active = this._active;\n        this._active = false;\n\n        return active;\n    }\n\n    pan() {\n        const { plotArea, axisRanges } = this;\n        if (axisRanges.length) {\n            for (let idx = 0; idx < axisRanges.length; idx++) {\n                const range = axisRanges[idx];\n                plotArea.updateAxisOptions(range.axis, range.range);\n            }\n            plotArea.redraw(plotArea.panes);\n        }\n    }\n\n    destroy() {\n        delete this.plotArea;\n    }\n\n    _panAxes(e, position) {\n        const plotArea = this.plotArea;\n        const delta = -e[position].delta;\n        const lock = (this.options.lock || \"\").toLowerCase();\n        const updatedAxes = [];\n\n        if (delta !== 0 && (lock || \"\").toLowerCase() !== position) {\n            const axes = plotArea.axes;\n            for (let idx = 0; idx < axes.length; idx++) {\n                const axis = axes[idx];\n\n                if (position === X && !axis.options.vertical || position === Y && axis.options.vertical) {\n                    const range = axis.pan(delta);\n\n                    if (range) {\n                        range.limitRange = true;\n                        updatedAxes.push({\n                            axis: axis,\n                            range: range\n                        });\n                    }\n                }\n            }\n        }\n\n        return updatedAxes;\n    }\n}\n\npannable_Pannable.prototype.options = {\n    key: \"none\",\n    lock: \"none\"\n};\n\n/* harmony default export */ var pan_and_zoom_pannable = (pannable_Pannable);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/pan-and-zoom/zoom-selection.js\n\n\n\n\n\n\nclass zoom_selection_ZoomSelection extends common_class[\"a\" /* default */] {\n    constructor(chart, options) {\n        super();\n\n        this.chart = chart;\n        this.options = deepExtend({}, this.options, options);\n        this.createElement();\n    }\n\n    createElement() {\n        const marquee = this._marquee = document.createElement(\"div\");\n        marquee.className = \"k-marquee\";\n        const marqueeColor = document.createElement(\"div\");\n        marqueeColor.className = \"k-marquee-color\";\n        marquee.appendChild(marqueeColor);\n    }\n\n    removeElement() {\n        if (this._marquee.parentNode) {\n            this._marquee.parentNode.removeChild(this._marquee);\n        }\n    }\n\n    setStyles(styles) {\n        element_styles_elementStyles(this._marquee, styles);\n    }\n\n    start(e) {\n        if (acceptKey(e, this.options.key)) {\n            const chart = this.chart;\n            const point = chart._eventCoordinates(e);\n            const zoomPane = this._zoomPane = chart._plotArea.paneByPoint(point);\n            const clipBox = zoomPane ? zoomPane.chartsBox().clone() : null;\n\n            if (zoomPane && clipBox) {\n                const offset = this._elementOffset();\n\n                clipBox.translate(offset.left, offset.top);\n                this._zoomPaneClipBox = clipBox;\n\n                document.body.appendChild(this._marquee);\n                this.setStyles({\n                    left: e.pageX + 1,\n                    top: e.pageY + 1,\n                    width: 0,\n                    height: 0\n                });\n\n                return true;\n            }\n        }\n        return false;\n    }\n\n    _elementOffset() {\n        const chartElement = this.chart.element;\n        const { paddingLeft, paddingTop } = element_styles_elementStyles(chartElement, [ \"paddingLeft\", \"paddingTop\" ]);\n        const offset = drawing_utils_elementOffset(chartElement);\n\n        return {\n            left: paddingLeft + offset.left,\n            top: paddingTop + offset.top\n        };\n    }\n\n    move(e) {\n        const zoomPane = this._zoomPane;\n        if (zoomPane) {\n            this.setStyles(this._selectionPosition(e));\n        }\n    }\n\n    end(e) {\n        const zoomPane = this._zoomPane;\n        if (zoomPane) {\n            const elementOffset = this._elementOffset();\n            const selectionPosition = this._selectionPosition(e);\n            selectionPosition.left -= elementOffset.left;\n            selectionPosition.top -= elementOffset.top;\n\n            const start = { x: selectionPosition.left, y: selectionPosition.top };\n            const end = { x: selectionPosition.left + selectionPosition.width, y: selectionPosition.top + selectionPosition.height };\n            this._updateAxisRanges(start, end);\n\n            this.removeElement();\n            delete this._zoomPane;\n\n            return toChartAxisRanges(this.axisRanges);\n        }\n    }\n\n    zoom() {\n        const axisRanges = this.axisRanges;\n        if (axisRanges && axisRanges.length) {\n            const plotArea = this.chart._plotArea;\n            for (let idx = 0; idx < axisRanges.length; idx++) {\n                const axisRange = axisRanges[idx];\n                plotArea.updateAxisOptions(axisRange.axis, axisRange.range);\n            }\n            plotArea.redraw(plotArea.panes);\n        }\n    }\n\n    destroy() {\n        this.removeElement();\n        delete this._marquee;\n        delete this.chart;\n    }\n\n    _updateAxisRanges(start, end) {\n        const lock = (this.options.lock || \"\").toLowerCase();\n        const axisRanges = [];\n\n        const axes = this._zoomPane.axes;\n        for (let idx = 0; idx < axes.length; idx++) {\n            const axis = axes[idx];\n            const vertical = axis.options.vertical;\n            if (!(lock === X && !vertical) && !(lock === Y && vertical) && defined(axis.axisIndex)) {\n                const range = axis.pointsRange(start, end);\n                if (range) {\n                    axisRanges.push({\n                        axis: axis,\n                        range: range\n                    });\n                }\n            }\n        }\n\n        this.axisRanges = axisRanges;\n    }\n\n    _selectionPosition(e) {\n        const clipBox = this._zoomPaneClipBox;\n        const startLocation = {\n            x: e.x.startLocation,\n            y: e.y.startLocation\n        };\n        const { x: { location: pageX }, y: { location: pageY } } = e;\n        const lock = (this.options.lock || \"\").toLowerCase();\n        let left = Math.min(startLocation.x, pageX);\n        let top = Math.min(startLocation.y, pageY);\n        let width = Math.abs(startLocation.x - pageX);\n        let height = Math.abs(startLocation.y - pageY);\n\n        if (lock === X) {\n            left = clipBox.x1;\n            width = clipBox.width();\n        }\n        if (lock === Y) {\n            top = clipBox.y1;\n            height = clipBox.height();\n        }\n\n        if (pageX > clipBox.x2) {\n            width = clipBox.x2 - startLocation.x;\n        }\n\n        if (pageX < clipBox.x1) {\n            width = startLocation.x - clipBox.x1;\n        }\n\n        if (pageY > clipBox.y2) {\n            height = clipBox.y2 - startLocation.y;\n        }\n\n        if (pageY < clipBox.y1) {\n            height = startLocation.y - clipBox.y1;\n        }\n\n        return {\n            left: Math.max(left, clipBox.x1),\n            top: Math.max(top, clipBox.y1),\n            width: width,\n            height: height\n        };\n    }\n}\n\nzoom_selection_ZoomSelection.prototype.options = {\n    key: \"shift\",\n    lock: \"none\"\n};\n\n/* harmony default export */ var zoom_selection = (zoom_selection_ZoomSelection);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/pan-and-zoom/mousewheel-zoom.js\n\n\n\n\n\n\nclass mousewheel_zoom_MousewheelZoom extends common_class[\"a\" /* default */] {\n    constructor(chart, options) {\n        super();\n\n        this.chart = chart;\n        this.options = deepExtend({}, this.options, options);\n    }\n\n    updateRanges(delta) {\n        const lock = (this.options.lock || \"\").toLowerCase();\n        const axisRanges = [];\n        const axes = this.chart._plotArea.axes;\n\n        for (let idx = 0; idx < axes.length; idx++) {\n            const axis = axes[idx];\n            const vertical = axis.options.vertical;\n\n            if (!(lock === X && !vertical) && !(lock === Y && vertical) && axis.zoomRange) {\n                const range = axis.zoomRange(-delta);\n\n                if (range) {\n                    axisRanges.push({\n                        axis: axis,\n                        range: range\n                    });\n                }\n            }\n        }\n\n        this.axisRanges = axisRanges;\n        return toChartAxisRanges(axisRanges);\n    }\n\n    zoom() {\n        const axisRanges = this.axisRanges;\n        const plotArea = this.chart._plotArea;\n\n        if (axisRanges && axisRanges.length && plotArea.updateAxisOptions) {\n            for (let idx = 0; idx < axisRanges.length; idx++) {\n                const axisRange = axisRanges[idx];\n                plotArea.updateAxisOptions(axisRange.axis, axisRange.range);\n            }\n            plotArea.redraw(plotArea.panes);\n        }\n    }\n\n    destroy() {\n        delete this.chart;\n    }\n}\n\n/* harmony default export */ var mousewheel_zoom = (mousewheel_zoom_MousewheelZoom);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/legend/legend-layout.js\n\n\n\n\nclass legend_layout_LegendLayout extends chart_element {\n\n    constructor(options, chartService) {\n        super(options);\n\n        this.chartService = chartService;\n    }\n\n    render() {\n        const { children, options } = this;\n        const vertical = options.vertical;\n\n        this.visual = new main[\"a\" /* drawing */].Layout(null, {\n            spacing: vertical ? 0 : options.spacing,\n            lineSpacing: vertical ? options.spacing : 0,\n            orientation: vertical ? \"vertical\" : \"horizontal\",\n            reverse: options.rtl,\n            alignItems: vertical ? \"start\" : \"center\"\n        });\n\n        for (let idx = 0; idx < children.length; idx++) {\n            let legendItem = children[idx];\n            legendItem.reflow(new core_box());\n            legendItem.renderVisual();\n        }\n    }\n\n    reflow(box) {\n        this.visual.rect(box.toRect());\n        this.visual.reflow();\n        const bbox = this.visual.clippedBBox();\n\n        if (bbox) {\n            this.box = rectToBox(bbox);\n        } else {\n            this.box = new core_box();\n        }\n    }\n\n    renderVisual() {\n        this.addVisual();\n    }\n\n    createVisual() {}\n}\n\n/* harmony default export */ var legend_layout = (legend_layout_LegendLayout);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/legend/legend-item.js\n\n\n\n\n\n\n\nclass legend_item_LegendItem extends box_element {\n    constructor(options) {\n        super(options);\n\n        this.createContainer();\n        if (!options.rtl) {\n            this.createMarker();\n            this.createLabel();\n        } else {\n            this.createLabel();\n            this.createMarker();\n        }\n    }\n\n    createContainer() {\n        this.container = new float_element({ vertical: false, wrap: false, align: CENTER, spacing: this.options.spacing });\n        this.append(this.container);\n    }\n\n    createMarker() {\n        this.container.append(new shape_element(this.markerOptions()));\n    }\n\n    markerOptions() {\n        const options = this.options;\n        const markerColor = options.markerColor;\n        return deepExtend({}, options.markers, {\n            background: markerColor,\n            border: {\n                color: markerColor\n            }\n        });\n    }\n\n    createLabel() {\n        const options = this.options;\n        const labelOptions = deepExtend({}, options.labels);\n\n        this.container.append(new text_box(options.text, labelOptions));\n    }\n\n    renderComplete() {\n        super.renderComplete();\n\n        const cursor = this.options.cursor || {};\n        const eventSink = this._itemOverlay = main[\"a\" /* drawing */].Path.fromRect(this.container.box.toRect(), {\n            fill: {\n                color: WHITE,\n                opacity: 0\n            },\n            stroke: null,\n            cursor: cursor.style || cursor\n        });\n\n        this.appendVisual(eventSink);\n    }\n\n    click(widget, e) {\n        const args = this.eventArgs(e);\n\n        if (!widget.trigger(LEGEND_ITEM_CLICK, args) && e && e.type === 'contextmenu') {\n            e.preventDefault();\n        }\n    }\n\n    over(widget, e) {\n        const args = this.eventArgs(e);\n\n        if (!widget.trigger(LEGEND_ITEM_HOVER, args)) {\n            widget._legendItemHover(args.seriesIndex, args.pointIndex);\n        }\n\n        // Don't trigger point hover for legend items\n        return true;\n    }\n\n    out(widget, e) {\n        widget._unsetActivePoint();\n\n        widget.trigger(LEGEND_ITEM_LEAVE, this.eventArgs(e));\n    }\n\n    eventArgs(e) {\n        const options = this.options;\n\n        return {\n            element: eventElement(e),\n            text: options.text,\n            series: options.series,\n            seriesIndex: options.series.index,\n            pointIndex: options.pointIndex\n        };\n    }\n\n    renderVisual() {\n        const options = this.options;\n        const customVisual = options.visual;\n\n        if (customVisual) {\n            this.visual = customVisual({\n                active: options.active,\n                series: options.series,\n                sender: this.getSender(),\n                pointIndex: options.pointIndex,\n                options: {\n                    markers: this.markerOptions(),\n                    labels: options.labels\n                },\n                createVisual: () => {\n                    this.createVisual();\n                    this.renderChildren();\n                    this.renderComplete();\n\n                    const defaultVisual = this.visual;\n\n                    delete this.visual;\n\n                    return defaultVisual;\n                }\n            });\n            this.addVisual();\n        } else {\n            super.renderVisual();\n        }\n    }\n}\n\n/* harmony default export */ var legend_item = (legend_item_LegendItem);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/legend/legend.js\n\n\n\n\n\n\n\n\nconst HORIZONTAL = \"horizontal\";\nconst POINTER = \"pointer\";\nconst CUSTOM = \"custom\";\n\nclass legend_Legend extends chart_element {\n    constructor(options, chartService = {}) {\n        super(options);\n\n        this.chartService = chartService;\n\n        if (!inArray(this.options.position, [ TOP, RIGHT, BOTTOM, LEFT, CUSTOM ])) {\n            this.options.position = RIGHT;\n        }\n\n        this.createContainers();\n\n        this.createLegendTitle(options.title);\n\n        this.createItems();\n    }\n\n    createContainers() {\n        const options = this.options;\n        const { position, align: userAlign } = options;\n        let align = position;\n        let vAlign = CENTER;\n\n        if (position === CUSTOM) {\n            align = LEFT;\n        } else if (inArray(position, [ TOP, BOTTOM ])) {\n            if (userAlign === \"start\") {\n                align = LEFT;\n            } else if (userAlign === \"end\") {\n                align = RIGHT;\n            } else {\n                align = CENTER;\n            }\n            vAlign = position;\n        } else if (userAlign) {\n            if (userAlign === \"start\") {\n                vAlign = TOP;\n            } else if (userAlign === \"end\") {\n                vAlign = BOTTOM;\n            }\n        }\n\n        this.container = new box_element({\n            margin: options.margin,\n            padding: options.padding,\n            background: options.background,\n            border: options.border,\n            vAlign: vAlign,\n            align: align,\n            zIndex: options.zIndex,\n            shrinkToFit: true\n        });\n\n        if (this.hasTitle()) {\n            this.itemsContainer = new box_element({\n                vAlign: vAlign,\n                align: align,\n                zIndex: options.zIndex,\n                shrinkToFit: true\n            });\n        } else {\n            this.itemsContainer = this.container;\n        }\n\n        this.append(this.container);\n    }\n\n    createItems() {\n        const chartService = this.getService();\n        const options = this.options;\n        const vertical = this.isVertical();\n        const innerElement = new legend_layout({\n            vertical: vertical,\n            spacing: options.spacing,\n            rtl: chartService.rtl\n        }, chartService);\n        let items = options.items;\n\n        if (options.reverse) {\n            items = items.slice(0).reverse();\n        }\n\n        const count = items.length;\n\n        for (let i = 0; i < count; i++) {\n            let item = items[i];\n\n            innerElement.append(new legend_item(deepExtend({}, {\n                markers: options.markers,\n                labels: options.labels,\n                rtl: chartService.rtl\n            }, options.item, item)));\n        }\n\n        innerElement.render();\n        this.itemsContainer.append(innerElement);\n    }\n\n    isVertical() {\n        const { orientation, position } = this.options;\n        const vertical = (position === CUSTOM && orientation !== HORIZONTAL) ||\n               (defined(orientation) ? orientation !== HORIZONTAL : inArray(position, [ LEFT, RIGHT ]));\n\n        return vertical;\n    }\n\n    hasItems() {\n        return this.container.children[0].children.length > 0;\n    }\n\n    reflow(targetBox) {\n        const options = this.options;\n        const legendBox = targetBox.clone();\n\n        if (!this.hasItems()) {\n            this.box = legendBox;\n            return;\n        }\n\n        if (options.position === CUSTOM) {\n            this.containerCustomReflow(legendBox);\n            this.box = legendBox;\n        } else {\n            this.containerReflow(legendBox);\n        }\n\n        if (this.hasTitle()) {\n            this.title.reflow(new core_box(this.container.box.x1, this.title.box.y1, this.container.box.x2, this.title.box.y2));\n        }\n    }\n\n    containerReflow(targetBox) {\n        const { options, container } = this;\n        const { position, width, height } = options;\n        const pos = position === TOP || position === BOTTOM ? X : Y;\n        const vertical = this.isVertical();\n        const alignTarget = targetBox.clone();\n        let containerBox = targetBox.clone();\n\n        if (position === LEFT || position === RIGHT) {\n            containerBox.y1 = alignTarget.y1 = 0;\n        }\n\n        if (vertical && height) {\n            containerBox.y2 = containerBox.y1 + height;\n            containerBox.align(alignTarget, Y, container.options.vAlign);\n        } else if (!vertical && width) {\n            containerBox.x2 = containerBox.x1 + width;\n            containerBox.align(alignTarget, X, container.options.align);\n        }\n\n        container.reflow(containerBox);\n        containerBox = container.box;\n\n        const box = containerBox.clone();\n\n        if (options.offsetX || options.offsetY) {\n            containerBox.translate(options.offsetX, options.offsetY);\n            container.reflow(containerBox);\n        }\n\n        box[pos + 1] = targetBox[pos + 1];\n        box[pos + 2] = targetBox[pos + 2];\n\n        this.box = box;\n    }\n\n    containerCustomReflow(targetBox) {\n        const { options, container } = this;\n        const { offsetX, offsetY, width, height } = options;\n        const vertical = this.isVertical();\n        let containerBox = targetBox.clone();\n\n        if (vertical && height) {\n            containerBox.y2 = containerBox.y1 + height;\n        } else if (!vertical && width) {\n            containerBox.x2 = containerBox.x1 + width;\n        }\n        container.reflow(containerBox);\n        containerBox = container.box;\n\n        container.reflow(new core_box(\n            offsetX, offsetY,\n            offsetX + containerBox.width(), offsetY + containerBox.height()\n        ));\n    }\n\n    renderVisual() {\n        if (this.hasItems()) {\n            super.renderVisual();\n        }\n    }\n\n    createLegendTitle(title) {\n        let titleOptions = deepExtend({}, {\n            color: BLACK,\n            position: TOP,\n            align: CENTER\n        }, title);\n        let text = titleOptions.text;\n\n        if (!title || title.visible === false) {\n            return;\n        }\n\n        if (defined(titleOptions) && titleOptions.visible) {\n            const labelTemplate = getTemplate(titleOptions);\n            if (labelTemplate) {\n                text = labelTemplate({ text: text });\n            } else if (titleOptions.format) {\n                text = this.chartService.format.auto(titleOptions.format, text);\n            }\n        }\n\n        this.title = new text_box(text, titleOptions);\n\n        this.createTitleLayout();\n\n        this.appendTitleLayoutContent();\n    }\n\n    createTitleLayout() {\n        this.layout = new float_element({\n            vertical: true,\n            wrap: false\n        });\n\n        this.container.append(this.layout);\n    }\n\n    hasTitle() {\n        return Boolean(this.options.title && this.options.title.visible !== false);\n    }\n\n    appendTitleLayoutContent() {\n        const options = this.options;\n\n        if (options.title.position === BOTTOM) {\n            this.layout.append(this.itemsContainer);\n            this.layout.append(this.title);\n        } else {\n            this.layout.append(this.title);\n            this.layout.append(this.itemsContainer);\n        }\n    }\n}\n\nsetDefaultOptions(legend_Legend, {\n    position: RIGHT,\n    items: [],\n    offsetX: 0,\n    offsetY: 0,\n    margin: getSpacing(5),\n    padding: getSpacing(5),\n    border: {\n        color: BLACK,\n        width: 0\n    },\n    item: {\n        cursor: POINTER,\n        spacing: 6\n    },\n    spacing: 6,\n    background: \"\",\n    zIndex: 1,\n    markers: {\n        border: {\n            width: 0\n        },\n        width: 15,\n        height: 3,\n        type: \"rect\",\n        align: LEFT,\n        vAlign: CENTER\n    }\n});\n\n/* harmony default export */ var legend_legend = (legend_Legend);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/plotarea/plotarea-factory.js\n\n\nlet plotarea_factory_PlotAreaFactory = /*@__PURE__*/ (() => {\n    class PlotAreaFactory extends common_class[\"a\" /* default */] {\n        constructor() {\n            super();\n            this._registry = [];\n        }\n        register(type, seriesTypes) {\n            this._registry.push({\n                type: type,\n                seriesTypes: seriesTypes\n            });\n        }\n        create(srcSeries, options, chartService) {\n            const registry = this._registry;\n            let match = registry[0];\n            let series;\n            for (let idx = 0; idx < registry.length; idx++) {\n                const entry = registry[idx];\n                series = filterSeriesByType(srcSeries, entry.seriesTypes);\n                if (series.length > 0) {\n                    match = entry;\n                    break;\n                }\n            }\n            return new match.type(series, options, chartService);\n        }\n    }\n    PlotAreaFactory.current = new PlotAreaFactory();\n    return PlotAreaFactory;\n})();\n/* harmony default export */ var plotarea_factory = (plotarea_factory_PlotAreaFactory);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/selection.js\n\n\n\n\n\n\n\n\n\n\nconst ZOOM_ACCELERATION = 3;\nconst SELECTOR_HEIGHT_ADJUST = 0.1;\n\nfunction createDiv(className) {\n    const element = document.createElement(\"div\");\n    if (className) {\n        element.className = className;\n    }\n\n    return element;\n}\n\nfunction closestHandle(element) {\n    let current = element;\n    while (current && !hasClasses(current, \"k-handle\")) {\n        current = current.parentNode;\n    }\n\n    return current;\n}\n\nclass selection_Selection extends common_class[\"a\" /* default */] {\n    constructor(chart, categoryAxis, options, observer) {\n        super();\n\n        const chartElement = chart.element;\n\n        this.options = deepExtend({}, this.options, options);\n        this.chart = chart;\n        this.observer = observer;\n        this.chartElement = chartElement;\n        this.categoryAxis = categoryAxis;\n        this._dateAxis = this.categoryAxis instanceof date_category_axis;\n\n        this.initOptions();\n\n        this.visible = this.options.visible && chartElement.offsetHeight;\n\n        if (this.visible) {\n            this.createElements();\n\n            this.set(this._index(this.options.from), this._index(this.options.to));\n\n            this.bindEvents();\n        }\n    }\n\n    onPane(pane) {\n        return this.categoryAxis.pane === pane;\n    }\n\n    createElements() {\n        const options = this.options;\n        const wrapper = this.wrapper = createDiv(\"k-selector\");\n        element_styles_elementStyles(wrapper, {\n            top: options.offset.top,\n            left: options.offset.left,\n            width: options.width,\n            height: options.height,\n            direction: 'ltr'\n        });\n        const selection = this.selection = createDiv(\"k-selection\");\n        this.leftMask = createDiv(\"k-mask\");\n        this.rightMask = createDiv(\"k-mask\");\n\n        wrapper.appendChild(this.leftMask);\n        wrapper.appendChild(this.rightMask);\n        wrapper.appendChild(selection);\n\n        selection.appendChild(createDiv(\"k-selection-bg\"));\n\n        const leftHandle = this.leftHandle = createDiv(\"k-handle k-left-handle\");\n        const rightHandle = this.rightHandle = createDiv(\"k-handle k-right-handle\");\n        leftHandle.appendChild(createDiv());\n        rightHandle.appendChild(createDiv());\n\n        selection.appendChild(leftHandle);\n        selection.appendChild(rightHandle);\n\n        this.chartElement.appendChild(wrapper);\n        const selectionStyles = element_styles_elementStyles(selection, [ \"borderLeftWidth\", \"borderRightWidth\", \"height\" ]);\n        const leftHandleHeight = element_styles_elementStyles(leftHandle, \"height\").height;\n        const rightHandleHeight = element_styles_elementStyles(rightHandle, \"height\").height;\n\n        options.selection = {\n            border: {\n                left: selectionStyles.borderLeftWidth,\n                right: selectionStyles.borderRightWidth\n            }\n        };\n\n        element_styles_elementStyles(leftHandle, {\n            top: (selectionStyles.height - leftHandleHeight) / 2\n        });\n\n        element_styles_elementStyles(rightHandle, {\n            top: (selectionStyles.height - rightHandleHeight) / 2\n        });\n\n        wrapper.style.cssText = wrapper.style.cssText;\n    }\n\n    bindEvents() {\n        if (this.options.mousewheel !== false) {\n            this._mousewheelHandler = this._mousewheel.bind(this);\n            bindEvents(this.wrapper, {\n                [ MOUSEWHEEL ]: this._mousewheelHandler\n            });\n        }\n\n        this._domEvents = dom_events_builder.create(this.wrapper, {\n            stopPropagation: true, // applicable for the jQuery UserEvents\n            start: this._start.bind(this),\n            move: this._move.bind(this),\n            end: this._end.bind(this),\n            tap: this._tap.bind(this),\n            press: this._press.bind(this),\n            gesturestart: this._gesturestart.bind(this),\n            gesturechange: this._gesturechange.bind(this),\n            gestureend: this._gestureend.bind(this)\n        });\n    }\n\n    initOptions() {\n        const { options, categoryAxis } = this;\n        const box = categoryAxis.pane.chartsBox();\n        const intlService = this.chart.chartService.intl;\n\n        if (this._dateAxis) {\n            deepExtend(options, {\n                min: parse_date_parseDate(intlService, options.min),\n                max: parse_date_parseDate(intlService, options.max),\n                from: parse_date_parseDate(intlService, options.from),\n                to: parse_date_parseDate(intlService, options.to)\n            });\n        }\n\n        const { paddingLeft, paddingTop } = element_styles_elementStyles(this.chartElement, [ \"paddingLeft\", \"paddingTop\" ]);\n\n        this.options = deepExtend({}, {\n            width: box.width(),\n            height: box.height() + SELECTOR_HEIGHT_ADJUST, //workaround for sub-pixel hover on the paths in chrome\n            padding: {\n                left: paddingLeft,\n                top: paddingTop\n            },\n            offset: {\n                left: box.x1 + paddingLeft,\n                top: box.y1 + paddingTop\n            },\n            from: options.min,\n            to: options.max\n        }, options);\n    }\n\n    destroy() {\n        if (this._domEvents) {\n            this._domEvents.destroy();\n            delete this._domEvents;\n        }\n\n        clearTimeout(this._mwTimeout);\n        this._state = null;\n\n        if (this.wrapper) {\n            if (this._mousewheelHandler) {\n                unbindEvents(this.wrapper, {\n                    [ MOUSEWHEEL ]: this._mousewheelHandler\n                });\n                this._mousewheelHandler = null;\n            }\n            this.chartElement.removeChild(this.wrapper);\n            this.wrapper = null;\n        }\n    }\n\n    _rangeEventArgs(range) {\n\n        return {\n            axis: this.categoryAxis.options,\n            from: this._value(range.from),\n            to: this._value(range.to)\n        };\n    }\n\n    _start(e) {\n        const options = this.options;\n        const target = eventElement(e);\n\n        if (this._state || !target) {\n            return;\n        }\n\n        this.chart._unsetActivePoint();\n        this._state = {\n            moveTarget: closestHandle(target) || target,\n            startLocation: e.x ? e.x.location : 0,\n            range: {\n                from: this._index(options.from),\n                to: this._index(options.to)\n            }\n        };\n\n        const args = this._rangeEventArgs({\n            from: this._index(options.from),\n            to: this._index(options.to)\n        });\n\n        if (this.trigger(SELECT_START, args)) {\n            this._state = null;\n        }\n    }\n\n    _press(e) {\n        let handle;\n        if (this._state) {\n            handle = this._state.moveTarget;\n        } else {\n            handle = closestHandle(eventElement(e));\n        }\n        if (handle) {\n            addClass(handle, \"k-handle-active\");\n        }\n    }\n\n    _move(e) {\n        if (!this._state) {\n            return;\n        }\n\n        const { _state: state, options, categoryAxis } = this;\n        const { range, moveTarget: target } = state;\n        const reverse = categoryAxis.options.reverse;\n        const from = this._index(options.from);\n        const to = this._index(options.to);\n        const min = this._index(options.min);\n        const max = this._index(options.max);\n        const delta = state.startLocation - e.x.location;\n        const oldRange = { from: range.from, to: range.to };\n        const span = range.to - range.from;\n        const scale = element_styles_elementStyles(this.wrapper, \"width\").width / (categoryAxis.categoriesCount() - 1);\n        const offset = Math.round(delta / scale) * (reverse ? -1 : 1);\n\n        if (!target) {\n            return;\n        }\n\n        const leftHandle = hasClasses(target, \"k-left-handle\");\n        const rightHandle = hasClasses(target, \"k-right-handle\");\n\n        if (hasClasses(target, \"k-selection k-selection-bg\")) {\n            range.from = Math.min(\n                Math.max(min, from - offset),\n                max - span\n            );\n            range.to = Math.min(\n                range.from + span,\n                max\n            );\n        } else if ((leftHandle && !reverse) || (rightHandle && reverse)) {\n            range.from = Math.min(\n                Math.max(min, from - offset),\n                max - 1\n            );\n            range.to = Math.max(range.from + 1, range.to);\n        } else if ((leftHandle && reverse) || (rightHandle && !reverse)) {\n            range.to = Math.min(\n                Math.max(min + 1, to - offset),\n                max\n            );\n            range.from = Math.min(range.to - 1, range.from);\n        }\n\n        if (range.from !== oldRange.from || range.to !== oldRange.to) {\n            this.move(range.from, range.to);\n            this.trigger(SELECT, this._rangeEventArgs(range));\n        }\n    }\n\n    _end() {\n        if (this._state) {\n            const moveTarget = this._state.moveTarget;\n            if (moveTarget) {\n                removeClass(moveTarget, \"k-handle-active\");\n            }\n\n            const range = this._state.range;\n            this.set(range.from, range.to);\n            this.trigger(SELECT_END, this._rangeEventArgs(range));\n\n            delete this._state;\n        }\n    }\n\n    _tap(e) {\n        const { options, categoryAxis } = this;\n        const coords = this.chart._eventCoordinates(e);\n        const categoryIx = categoryAxis.pointCategoryIndex(new core_point(coords.x, categoryAxis.box.y1));\n        const from = this._index(options.from);\n        const to = this._index(options.to);\n        const min = this._index(options.min);\n        const max = this._index(options.max);\n        const span = to - from;\n        const mid = from + span / 2;\n        const range = {};\n        const rightClick = e.event.which === 3;\n        let offset = Math.round(mid - categoryIx);\n\n        if (this._state || rightClick) {\n            return;\n        }\n\n\n        this.chart._unsetActivePoint();\n\n        if (!categoryAxis.options.justified) {\n            offset--;\n        }\n\n        range.from = Math.min(\n            Math.max(min, from - offset),\n            max - span\n        );\n\n        range.to = Math.min(range.from + span, max);\n\n        this._start(e);\n        if (this._state) {\n            this._state.range = range;\n            this.trigger(SELECT, this._rangeEventArgs(range));\n            this._end();\n        }\n    }\n\n    _mousewheel(e) {\n        let delta = mousewheelDelta(e);\n\n        this._start({ target: this.selection });\n\n        if (this._state) {\n            const range = this._state.range;\n\n            e.preventDefault();\n            e.stopPropagation();\n\n            if (Math.abs(delta) > 1) {\n                delta *= ZOOM_ACCELERATION;\n            }\n\n            if (this.options.mousewheel.reverse) {\n                delta *= -1;\n            }\n\n            if (this.expand(delta)) {\n                this.trigger(SELECT, {\n                    axis: this.categoryAxis.options,\n                    delta: delta,\n                    originalEvent: e,\n                    from: this._value(range.from),\n                    to: this._value(range.to)\n                });\n            }\n\n            if (this._mwTimeout) {\n                clearTimeout(this._mwTimeout);\n            }\n\n            this._mwTimeout = setTimeout(() => {\n                this._end();\n            }, MOUSEWHEEL_DELAY);\n        }\n    }\n\n    _gesturestart(e) {\n        const options = this.options;\n\n        this._state = {\n            range: {\n                from: this._index(options.from),\n                to: this._index(options.to)\n            }\n        };\n        const args = this._rangeEventArgs(this._state.range);\n\n        if (this.trigger(SELECT_START, args)) {\n            this._state = null;\n        } else {\n            e.preventDefault();\n        }\n    }\n\n    _gestureend() {\n        if (this._state) {\n            this.trigger(SELECT_END, this._rangeEventArgs(this._state.range));\n            delete this._state;\n        }\n    }\n\n    _gesturechange(e) {\n        const { chart, _state: state, options, categoryAxis } = this;\n        const range = state.range;\n        const p0 = chart._toModelCoordinates(e.touches[0].x.location).x;\n        const p1 = chart._toModelCoordinates(e.touches[1].x.location).x;\n        const left = Math.min(p0, p1);\n        const right = Math.max(p0, p1);\n\n        e.preventDefault();\n\n        range.from = categoryAxis.pointCategoryIndex(new core_point(left)) || options.min;\n\n        range.to = categoryAxis.pointCategoryIndex(new core_point(right)) || options.max;\n\n        this.move(range.from, range.to);\n\n        this.trigger(SELECT, this._rangeEventArgs(range));\n    }\n\n    _index(value) {\n        let index = value;\n\n        if (value instanceof Date) {\n            index = this.categoryAxis.categoryIndex(value);\n        }\n\n        return index;\n    }\n\n    _value(index) {\n        let value = index;\n        if (this._dateAxis) {\n            value = this.categoryAxis.categoryAt(index);\n            if (value > this.options.max) {\n                value = this.options.max;\n            }\n        }\n\n        return value;\n    }\n\n    _slot(value) {\n        const categoryAxis = this.categoryAxis;\n        const index = this._index(value);\n\n        return categoryAxis.getSlot(index, index, true);\n    }\n\n    move(from, to) {\n        const options = this.options;\n        const reverse = this.categoryAxis.options.reverse;\n        const { offset, padding, selection: { border } } = options;\n        const left = reverse ? to : from;\n        const right = reverse ? from : to;\n        const edge = 'x' + (reverse ? 2 : 1);\n\n        let box = this._slot(left);\n        const leftMaskWidth = round(box[edge] - offset.left + padding.left);\n\n        element_styles_elementStyles(this.leftMask, {\n            width: leftMaskWidth\n        });\n        element_styles_elementStyles(this.selection, {\n            left: leftMaskWidth\n        });\n\n        box = this._slot(right);\n\n        const rightMaskWidth = round(options.width - (box[edge] - offset.left + padding.left));\n        element_styles_elementStyles(this.rightMask, {\n            width: rightMaskWidth\n        });\n\n        let distance = options.width - rightMaskWidth;\n        if (distance !== options.width) {\n            distance += border.right;\n        }\n\n        element_styles_elementStyles(this.rightMask, {\n            left: distance\n        });\n        element_styles_elementStyles(this.selection, {\n            width: Math.max(options.width - (leftMaskWidth + rightMaskWidth) - border.right, 0)\n        });\n    }\n\n    set(from, to) {\n        const options = this.options;\n        const min = this._index(options.min);\n        const max = this._index(options.max);\n        const fromValue = limitValue(this._index(from), min, max);\n        const toValue = limitValue(this._index(to), fromValue + 1, max);\n\n        if (options.visible) {\n            this.move(fromValue, toValue);\n        }\n\n        options.from = this._value(fromValue);\n        options.to = this._value(toValue);\n    }\n\n    expand(delta) {\n        const options = this.options;\n        const min = this._index(options.min);\n        const max = this._index(options.max);\n        const zDir = options.mousewheel.zoom;\n        const from = this._index(options.from);\n        const to = this._index(options.to);\n        let range = { from: from, to: to };\n        const oldRange = deepExtend({}, range);\n\n        if (this._state) {\n            range = this._state.range;\n        }\n\n        if (zDir !== RIGHT) {\n            range.from = limitValue(\n                limitValue(from - delta, 0, to - 1),\n                min, max\n            );\n        }\n\n        if (zDir !== LEFT) {\n            range.to = limitValue(\n                limitValue(to + delta, range.from + 1, max),\n                min,\n                max\n             );\n        }\n\n        if (range.from !== oldRange.from || range.to !== oldRange.to) {\n            this.set(range.from, range.to);\n            return true;\n        }\n    }\n\n    trigger(name, args) {\n        return (this.observer || this.chart).trigger(name, args);\n    }\n}\n\nsetDefaultOptions(selection_Selection, {\n    visible: true,\n    mousewheel: {\n        zoom: \"both\"\n    },\n    min: MIN_VALUE,\n    max: MAX_VALUE\n});\n\n/* harmony default export */ var chart_selection = (selection_Selection);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/tooltip/tooltip.js\n\n\n\n\nclass tooltip_Tooltip extends base_tooltip {\n    show(point) {\n        if (!point || !point.tooltipAnchor || (this._current && this._current === point)) {\n            return;\n        }\n\n        const options = deepExtend({}, this.options, point.options.tooltip);\n        const anchor = point.tooltipAnchor();\n\n        if (anchor) {\n            this._current = point;\n            super.show({\n                point: point,\n                anchor: anchor\n            }, options, point);\n        } else {\n            this.hide();\n        }\n    }\n\n    hide() {\n        delete this._current;\n        super.hide();\n    }\n}\n\n/* harmony default export */ var tooltip_tooltip = (tooltip_Tooltip);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/tooltip/shared-tooltip.js\n\n\n\n\n\nclass shared_tooltip_SharedTooltip extends base_tooltip {\n    constructor(plotArea, options) {\n        super(plotArea.chartService, options);\n\n        this.plotArea = plotArea;\n        this.formatService = plotArea.chartService.format;\n    }\n\n    showAt(points, coords) {\n        const tooltipPoints = grep(points, function(point) {\n            const tooltip = point.series.tooltip;\n            const excluded = tooltip && tooltip.visible === false;\n\n            return !excluded;\n        });\n\n        if (tooltipPoints.length > 0) {\n            const point = tooltipPoints[0];\n            const slot = this.plotArea.categoryAxis.getSlot(point.categoryIx);\n\n            const anchor = coords ? this._slotAnchor(coords, slot) : this._defaultAnchor(point, slot);\n\n            this.show({\n                anchor: anchor,\n                shared: true,\n                points: points,\n                category: point.category,\n                categoryText: this.formatService.auto(this.options.categoryFormat, point.category),\n                series: this.plotArea.series\n            }, this.options);\n        }\n    }\n\n    _slotAnchor(point, slot) {\n        const axis = this.plotArea.categoryAxis;\n        const align = {\n            horizontal: \"left\",\n            vertical: \"center\"\n        };\n\n        if (!axis.options.vertical) {\n            point.x = slot.center().x;\n        }\n\n        return {\n            point: point,\n            align: align\n        };\n    }\n\n    _defaultAnchor(point, slot) {\n        const box = point.owner.pane.chartsBox();\n        const vertical = this.plotArea.categoryAxis.options.vertical;\n        const center = box.center();\n        const slotCenter = slot.center();\n        const align = {\n            horizontal: \"center\",\n            vertical: \"center\"\n        };\n\n        let centerPoint;\n        if (vertical) {\n            centerPoint = new core_point(center.x, slotCenter.y);\n        } else {\n            centerPoint = new core_point(slotCenter.x, center.y);\n        }\n\n        return {\n            point: centerPoint,\n            align: align\n        };\n    }\n}\n\nsetDefaultOptions(shared_tooltip_SharedTooltip, {\n    categoryFormat: '{0:d}'\n});\n\n/* harmony default export */ var shared_tooltip = (shared_tooltip_SharedTooltip);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/animations/bar-chart-animation.js\n\n\n\n\n\n\n\nclass bar_chart_animation_BarChartAnimation extends main[\"a\" /* drawing */].Animation {\n\n    setup() {\n        const { element, options } = this;\n        const bbox = element.bbox();\n\n        if (bbox) {\n            this.origin = options.origin;\n            const axis = options.vertical ? Y : X;\n\n            const fromScale = this.fromScale = new main[\"b\" /* geometry */].Point(1, 1);\n            fromScale[axis] = START_SCALE;\n\n            element.transform(main[\"b\" /* geometry */].transform()\n                .scale(fromScale.x, fromScale.y)\n            );\n        } else {\n            this.abort();\n        }\n    }\n\n    step(pos) {\n        const scaleX = interpolateValue(this.fromScale.x, 1, pos);\n        const scaleY = interpolateValue(this.fromScale.y, 1, pos);\n\n        this.element.transform(main[\"b\" /* geometry */].transform()\n            .scale(scaleX, scaleY, this.origin)\n        );\n    }\n\n    abort() {\n        super.abort();\n        this.element.transform(null);\n    }\n}\n\nsetDefaultOptions(bar_chart_animation_BarChartAnimation, {\n    duration: INITIAL_ANIMATION_DURATION\n});\n\nmain[\"a\" /* drawing */].AnimationFactory.current.register(BAR, bar_chart_animation_BarChartAnimation);\n\n/* harmony default export */ var bar_chart_animation = (bar_chart_animation_BarChartAnimation);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/animations/bubble-animation.js\n\n\n\n\n\n\nclass bubble_animation_BubbleAnimation extends main[\"a\" /* drawing */].Animation {\n    setup() {\n        const center = this.center = this.element.bbox().center();\n        this.element.transform(main[\"b\" /* geometry */].transform()\n            .scale(START_SCALE, START_SCALE, center)\n        );\n    }\n\n    step(pos) {\n        this.element.transform(main[\"b\" /* geometry */].transform()\n            .scale(pos, pos, this.center)\n        );\n    }\n}\n\nsetDefaultOptions(bubble_animation_BubbleAnimation, {\n    easing: \"easeOutElastic\"\n});\n\nmain[\"a\" /* drawing */].AnimationFactory.current.register(BUBBLE, bubble_animation_BubbleAnimation);\n\n/* harmony default export */ var bubble_animation = (bubble_animation_BubbleAnimation);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/animations/fade-in-animation.js\n\n\n\n\n\n\nclass fade_in_animation_FadeInAnimation extends main[\"a\" /* drawing */].Animation {\n    setup() {\n        this.fadeTo = this.element.opacity();\n        this.element.opacity(0);\n    }\n\n    step(pos) {\n        this.element.opacity(pos * this.fadeTo);\n    }\n}\n\nsetDefaultOptions(fade_in_animation_FadeInAnimation, {\n    duration: 200,\n    easing: \"linear\"\n});\n\nmain[\"a\" /* drawing */].AnimationFactory.current.register(FADEIN, fade_in_animation_FadeInAnimation);\n\n/* harmony default export */ var fade_in_animation = (fade_in_animation_FadeInAnimation);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/animations/pie-animation.js\n\n\n\n\n\n\nclass pie_animation_PieAnimation extends main[\"a\" /* drawing */].Animation {\n    setup() {\n        this.element.transform(main[\"b\" /* geometry */].transform()\n            .scale(START_SCALE, START_SCALE, this.options.center)\n        );\n    }\n\n    step(pos) {\n        this.element.transform(main[\"b\" /* geometry */].transform()\n            .scale(pos, pos, this.options.center)\n        );\n    }\n}\n\nsetDefaultOptions(pie_animation_PieAnimation, {\n    easing: \"easeOutElastic\",\n    duration: INITIAL_ANIMATION_DURATION\n});\n\nmain[\"a\" /* drawing */].AnimationFactory.current.register(PIE, pie_animation_PieAnimation);\n\n/* harmony default export */ var pie_animation = (pie_animation_PieAnimation);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/animations.js\n\n\n\n\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/scatter-charts/scatter-line-chart.js\n\n\n\n\n\n\n\n\n\n\n\nclass scatter_line_chart_ScatterLineChart extends scatter_chart {\n    render() {\n        super.render();\n\n        this.renderSegments();\n    }\n\n    createSegment(linePoints, currentSeries, seriesIx) {\n        const style = currentSeries.style;\n        let pointType;\n\n        if (style === SMOOTH) {\n            pointType = spline_segment;\n        } else {\n            pointType = line_segment;\n        }\n\n        return new pointType(linePoints, currentSeries, seriesIx);\n    }\n\n    animationPoints() {\n        const points = super.animationPoints();\n        return points.concat(this._segments);\n    }\n\n    createMissingValue(value, missingValues) {\n        if (missingValues === ZERO) {\n            const missingValue = {\n                x: value.x,\n                y: value.y\n            };\n            if (!has_value_hasValue(missingValue.x)) {\n                missingValue.x = 0;\n            }\n            if (!has_value_hasValue(missingValue.y)) {\n                missingValue.y = 0;\n            }\n            return missingValue;\n        }\n    }\n}\n\ndeepExtend(scatter_line_chart_ScatterLineChart.prototype, line_chart_mixin);\n\n/* harmony default export */ var scatter_line_chart = (scatter_line_chart_ScatterLineChart);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/plotarea/xy-plotarea.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass xy_plotarea_XYPlotArea extends plotarea_base {\n    initFields() {\n        this.namedXAxes = {};\n        this.namedYAxes = {};\n\n        this.xAxisRangeTracker = new axis_group_range_tracker();\n        this.yAxisRangeTracker = new axis_group_range_tracker();\n    }\n\n    render(panes = this.panes) {\n        const seriesByPane = this.groupSeriesByPane();\n\n        for (let i = 0; i < panes.length; i++) {\n            const pane = panes[i];\n            const paneSeries = seriesByPane[pane.options.name || \"default\"] || [];\n            this.addToLegend(paneSeries);\n            const filteredSeries = this.filterVisibleSeries(paneSeries);\n\n            if (!filteredSeries) {\n                continue;\n            }\n\n            this.createScatterChart(\n                filterSeriesByType(filteredSeries, SCATTER),\n                pane\n            );\n\n            this.createScatterLineChart(\n                filterSeriesByType(filteredSeries, SCATTER_LINE),\n                pane\n            );\n\n            this.createBubbleChart(\n                filterSeriesByType(filteredSeries, BUBBLE),\n                pane\n            );\n        }\n\n        this.createAxes(panes);\n    }\n\n    appendChart(chart, pane) {\n        this.xAxisRangeTracker.update(chart.xAxisRanges);\n        this.yAxisRangeTracker.update(chart.yAxisRanges);\n\n        super.appendChart(chart, pane);\n    }\n\n    removeAxis(axis) {\n        const axisName = axis.options.name;\n\n        super.removeAxis(axis);\n\n        if (axis.options.vertical) {\n            this.yAxisRangeTracker.reset(axisName);\n            delete this.namedYAxes[axisName];\n        } else {\n            this.xAxisRangeTracker.reset(axisName);\n            delete this.namedXAxes[axisName];\n        }\n\n        if (axis === this.axisX) {\n            delete this.axisX;\n        }\n\n        if (axis === this.axisY) {\n            delete this.axisY;\n        }\n    }\n\n    // TODO: Refactor, optionally use series.pane option\n    seriesPaneName(series) {\n        const options = this.options;\n        const xAxisName = series.xAxis;\n        const xAxisOptions = [].concat(options.xAxis);\n        const xAxis = grep(xAxisOptions, function(a) { return a.name === xAxisName; })[0];\n        const yAxisName = series.yAxis;\n        const yAxisOptions = [].concat(options.yAxis);\n        const yAxis = grep(yAxisOptions, function(a) { return a.name === yAxisName; })[0];\n        const panes = options.panes || [ {} ];\n        const defaultPaneName = panes[0].name || \"default\";\n        const paneName = (xAxis || {}).pane || (yAxis || {}).pane || defaultPaneName;\n\n        return paneName;\n    }\n\n    createScatterChart(series, pane) {\n        if (series.length > 0) {\n            this.appendChart(\n                new scatter_chart(this, { series: series, clip: pane.options.clip }),\n                pane\n            );\n        }\n    }\n\n    createScatterLineChart(series, pane) {\n        if (series.length > 0) {\n            this.appendChart(\n                new scatter_line_chart(this, { series: series, clip: pane.options.clip }),\n                pane\n            );\n        }\n    }\n\n    createBubbleChart(series, pane) {\n        if (series.length > 0) {\n            this.appendChart(\n                new bubble_chart(this, { series: series, clip: pane.options.clip }),\n                pane\n            );\n        }\n    }\n\n    createXYAxis(options, vertical, axisIndex) {\n        const axisName = options.name;\n        const namedAxes = vertical ? this.namedYAxes : this.namedXAxes;\n        const tracker = vertical ? this.yAxisRangeTracker : this.xAxisRangeTracker;\n        const axisOptions = deepExtend({ reverse: !vertical && this.chartService.rtl }, options, { vertical: vertical });\n        const isLog = equalsIgnoreCase(axisOptions.type, LOGARITHMIC);\n        const defaultRange = tracker.query();\n        const defaultAxisRange = isLog ? { min: 0.1, max: 1 } : { min: 0, max: 1 };\n        const range = tracker.query(axisName) || defaultRange || defaultAxisRange;\n        const typeSamples = [ axisOptions.min, axisOptions.max ];\n        const series = this.series;\n\n        for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {\n            const currentSeries = series[seriesIx];\n            const seriesAxisName = currentSeries[vertical ? \"yAxis\" : \"xAxis\"];\n            if ((seriesAxisName === axisOptions.name) || (axisIndex === 0 && !seriesAxisName)) {\n                const firstPointValue = series_binder.current.bindPoint(currentSeries, 0).valueFields;\n                typeSamples.push(firstPointValue[vertical ? \"y\" : \"x\"]);\n\n                break;\n            }\n        }\n\n        if (axisIndex === 0 && defaultRange) {\n            range.min = Math.min(range.min, defaultRange.min);\n            range.max = Math.max(range.max, defaultRange.max);\n        }\n\n        let inferredDate;\n\n        for (let i = 0; i < typeSamples.length; i++) {\n            if (typeSamples[i] instanceof Date) {\n                inferredDate = true;\n                break;\n            }\n        }\n\n        let axisType;\n        if (equalsIgnoreCase(axisOptions.type, DATE) || (!axisOptions.type && inferredDate)) {\n            axisType = date_value_axis;\n        } else if (isLog) {\n            axisType = logarithmic_axis;\n        } else {\n            axisType = numeric_axis;\n        }\n\n        const axis = new axisType(range.min, range.max, axisOptions, this.chartService);\n        axis.axisIndex = axisIndex;\n\n        if (axisName) {\n            if (namedAxes[axisName]) {\n                throw new Error(`${ vertical ? \"Y\" : \"X\" } axis with name ${ axisName } is already defined`);\n            }\n            namedAxes[axisName] = axis;\n        }\n\n        this.appendAxis(axis);\n\n        return axis;\n    }\n\n    createAxes(panes) {\n        const options = this.options;\n        const xAxesOptions = [].concat(options.xAxis);\n        const xAxes = [];\n        const yAxesOptions = [].concat(options.yAxis);\n        const yAxes = [];\n\n        for (let idx = 0; idx < xAxesOptions.length; idx++) {\n            const axisPane = this.findPane(xAxesOptions[idx].pane);\n            if (inArray(axisPane, panes)) {\n                xAxes.push(this.createXYAxis(xAxesOptions[idx], false, idx));\n            }\n        }\n\n        for (let idx = 0; idx < yAxesOptions.length; idx++) {\n            const axisPane = this.findPane(yAxesOptions[idx].pane);\n            if (inArray(axisPane, panes)) {\n                yAxes.push(this.createXYAxis(yAxesOptions[idx], true, idx));\n            }\n        }\n\n        this.axisX = this.axisX || xAxes[0];\n        this.axisY = this.axisY || yAxes[0];\n    }\n\n    _dispatchEvent(chart, e, eventType) {\n        const coords = chart._eventCoordinates(e);\n        const point = new core_point(coords.x, coords.y);\n        const allAxes = this.axes;\n        const length = allAxes.length;\n        const xValues = [];\n        const yValues = [];\n\n        for (let i = 0; i < length; i++) {\n            const axis = allAxes[i];\n            const values = axis.options.vertical ? yValues : xValues;\n            const currentValue = axis.getValue(point);\n            if (currentValue !== null) {\n                values.push(currentValue);\n            }\n        }\n\n        if (xValues.length > 0 && yValues.length > 0) {\n            chart.trigger(eventType, {\n                element: eventElement(e),\n                originalEvent: e,\n                x: singleItemOrArray(xValues),\n                y: singleItemOrArray(yValues)\n            });\n        }\n    }\n\n    updateAxisOptions(axis, options) {\n        const vertical = axis.options.vertical;\n        const axes = this.groupAxes(this.panes);\n        const index = (vertical ? axes.y : axes.x).indexOf(axis);\n\n        xy_plotarea_updateAxisOptions(this.options, index, vertical, options);\n        xy_plotarea_updateAxisOptions(this.originalOptions, index, vertical, options);\n    }\n}\n\nfunction xy_plotarea_updateAxisOptions(targetOptions, axisIndex, vertical, options) {\n    const axisOptions = ([].concat(vertical ? targetOptions.yAxis : targetOptions.xAxis))[axisIndex];\n    deepExtend(axisOptions, options);\n}\n\nsetDefaultOptions(xy_plotarea_XYPlotArea, {\n    xAxis: {},\n    yAxis: {}\n});\n\ndeepExtend(xy_plotarea_XYPlotArea.prototype, plotarea_events_mixin);\n\n/* harmony default export */ var xy_plotarea = (xy_plotarea_XYPlotArea);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/pie-chart/pie-segment.js\n\n\n\n\n\n\n\n\n\n\n\n\nclass pie_segment_PieSegment extends chart_element {\n    constructor(value, sector, options) {\n        super(options);\n\n        this.value = value;\n        this.sector = sector;\n    }\n\n    render() {\n        const labels = this.options.labels;\n        const chartService = this.owner.chartService;\n        let labelText = this.value;\n\n        if (this._rendered || this.visible === false) {\n            return;\n        }\n        this._rendered = true;\n\n        const labelTemplate = getTemplate(labels);\n        const pointData = this.pointData();\n\n        if (labelTemplate) {\n            labelText = labelTemplate(pointData);\n        } else if (labels.format) {\n            labelText = chartService.format.auto(labels.format, labelText);\n        }\n\n        if (labels.visible && (labelText || labelText === 0)) {\n            if (labels.position === CENTER || labels.position === INSIDE_END) {\n                if (!labels.color) {\n                    const brightnessValue = new color_color[\"a\" /* default */](this.options.color).percBrightness();\n                    if (brightnessValue > 180) {\n                        labels.color = BLACK;\n                    } else {\n                        labels.color = WHITE;\n                    }\n                }\n                if (!labels.background) {\n                    labels.background = this.options.color;\n                }\n            } else {\n                const themeLabels = chartService.theme.seriesDefaults.labels;\n                labels.color = labels.color || themeLabels.color;\n                labels.background = labels.background || themeLabels.background;\n            }\n\n\n            this.label = new text_box(labelText, deepExtend({}, labels, {\n                align: CENTER,\n                vAlign: \"\",\n                animation: {\n                    type: FADEIN,\n                    delay: this.animationDelay\n                }\n            }), pointData);\n\n            this.append(this.label);\n        }\n    }\n\n    reflow(targetBox) {\n        this.render();\n        this.box = targetBox;\n        this.reflowLabel();\n    }\n\n    reflowLabel() {\n        const { options: { labels: labelsOptions }, label } = this;\n        const sector = this.sector.clone();\n        const labelsDistance = labelsOptions.distance;\n        const angle = sector.middle();\n\n        if (label) {\n            const labelHeight = label.box.height();\n            const labelWidth = label.box.width();\n            let lp;\n\n            if (labelsOptions.position === CENTER) {\n                sector.radius = Math.abs((sector.radius - labelHeight) / 2) + labelHeight;\n                lp = sector.point(angle);\n                label.reflow(new core_box(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));\n            } else if (labelsOptions.position === INSIDE_END) {\n                sector.radius = sector.radius - labelHeight / 2;\n                lp = sector.point(angle);\n                label.reflow(new core_box(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));\n            } else {\n                let x1;\n                lp = sector.clone().expand(labelsDistance).point(angle);\n                if (lp.x >= sector.center.x) {\n                    x1 = lp.x + labelWidth;\n                    label.orientation = RIGHT;\n                } else {\n                    x1 = lp.x - labelWidth;\n                    label.orientation = LEFT;\n                }\n                label.reflow(new core_box(x1, lp.y - labelHeight, lp.x, lp.y));\n            }\n        }\n    }\n\n    createVisual() {\n        const { sector, options } = this;\n\n        super.createVisual();\n\n        if (this.value) {\n            if (options.visual) {\n                const startAngle = (sector.startAngle + 180) % 360;\n                const visual = options.visual({\n                    category: this.category,\n                    dataItem: this.dataItem,\n                    value: this.value,\n                    series: this.series,\n                    percentage: this.percentage,\n                    center: new main[\"b\" /* geometry */].Point(sector.center.x, sector.center.y),\n                    radius: sector.radius,\n                    innerRadius: sector.innerRadius,\n                    startAngle: startAngle,\n                    endAngle: startAngle + sector.angle,\n                    options: options,\n                    sender: this.getSender(),\n                    createVisual: () => {\n                        const group = new main[\"a\" /* drawing */].Group();\n                        this.createSegmentVisual(group);\n\n                        return group;\n                    }\n                });\n\n                if (visual) {\n                    this.visual.append(visual);\n                }\n            } else {\n                this.createSegmentVisual(this.visual);\n            }\n        }\n    }\n\n    createSegmentVisual(group) {\n        const { sector, options } = this;\n        const borderOptions = options.border || {};\n        const border = borderOptions.width > 0 ? {\n            stroke: {\n                color: borderOptions.color,\n                width: borderOptions.width,\n                opacity: borderOptions.opacity,\n                dashType: borderOptions.dashType\n            }\n        } : {};\n        const color = options.color;\n        const fill = {\n            color: color,\n            opacity: options.opacity\n        };\n        const visual = this.createSegment(sector, deepExtend({\n            fill: fill,\n            stroke: {\n                opacity: options.opacity\n            },\n            zIndex: options.zIndex\n        }, border));\n\n        group.append(visual);\n\n        if (hasGradientOverlay(options)) {\n            group.append(this.createGradientOverlay(visual, {\n                baseColor: color,\n                fallbackFill: fill\n            }, deepExtend({\n                center: [ sector.center.x, sector.center.y ],\n                innerRadius: sector.innerRadius,\n                radius: sector.radius,\n                userSpace: true\n            }, options.overlay)));\n        }\n    }\n\n    createSegment(sector, options) {\n        if (options.singleSegment) {\n            return new main[\"a\" /* drawing */].Circle(new main[\"b\" /* geometry */].Circle(new main[\"b\" /* geometry */].Point(sector.center.x, sector.center.y), sector.radius), options);\n        }\n\n        return shape_builder.current.createRing(sector, options);\n    }\n\n    createAnimation() {\n        const { options, sector: { center } } = this;\n\n        deepExtend(options, {\n            animation: {\n                center: [ center.x, center.y ],\n                delay: this.animationDelay\n            }\n        });\n\n        super.createAnimation();\n    }\n\n    createHighlight(options) {\n        const highlight = this.options.highlight || {};\n        const border = highlight.border || {};\n\n        return this.createSegment(this.sector, deepExtend({}, options, {\n            fill: {\n                color: highlight.color,\n                opacity: highlight.opacity\n            },\n            stroke: {\n                opacity: border.opacity,\n                width: border.width,\n                color: border.color\n            }\n        }));\n    }\n\n    highlightVisual() {\n        return this.visual.children[0];\n    }\n\n    highlightVisualArgs() {\n        const sector = this.sector;\n\n        return {\n            options: this.options,\n            radius: sector.radius,\n            innerRadius: sector.innerRadius,\n            center: new main[\"b\" /* geometry */].Point(sector.center.x, sector.center.y),\n            startAngle: sector.startAngle,\n            endAngle: sector.angle + sector.startAngle,\n            visual: this.visual\n        };\n    }\n\n    tooltipAnchor() {\n        const sector = this.sector.clone().expand(TOOLTIP_OFFSET);\n        const midAndle = sector.middle();\n        const midPoint = sector.point(midAndle);\n\n        return {\n            point: midPoint,\n            align: tooltipAlignment(midAndle + 180)\n        };\n    }\n\n    formatValue(format) {\n        return this.owner.formatPointValue(this, format);\n    }\n\n    pointData() {\n        return {\n            dataItem: this.dataItem,\n            category: this.category,\n            value: this.value,\n            series: this.series,\n            percentage: this.percentage\n        };\n    }\n}\n\nconst RAD_30 = round(rad(30), DEFAULT_PRECISION);\nconst RAD_60 = round(rad(60), DEFAULT_PRECISION);\n\nfunction tooltipAlignment(angle) {\n    const radians = rad(angle);\n    const sine = round(Math.sin(radians), DEFAULT_PRECISION);\n    const cosine = round(Math.cos(radians), DEFAULT_PRECISION);\n\n\n    let horizontal;\n    if (Math.abs(sine) > RAD_60) {\n        horizontal = CENTER;\n    } else if (cosine < 0) {\n        horizontal = RIGHT;\n    } else {\n        horizontal = LEFT;\n    }\n\n    let vertical;\n    if (Math.abs(sine) < RAD_30) {\n        vertical = CENTER;\n    } else if (sine < 0) {\n        vertical = BOTTOM;\n    } else {\n        vertical = TOP;\n    }\n\n    return {\n        horizontal: horizontal,\n        vertical: vertical\n    };\n}\n\nsetDefaultOptions(pie_segment_PieSegment, {\n    color: WHITE,\n    overlay: {\n        gradient: \"roundedBevel\"\n    },\n    border: {\n        width: 0.5\n    },\n    labels: {\n        visible: false,\n        distance: 35,\n        font: DEFAULT_FONT,\n        margin: getSpacing(0.5),\n        align: CIRCLE,\n        zIndex: 1,\n        position: OUTSIDE_END\n    },\n    animation: {\n        type: PIE\n    },\n    highlight: {\n        visible: true,\n        border: {\n            width: 1\n        }\n    },\n    visible: true\n});\n\ndeepExtend(pie_segment_PieSegment.prototype, point_events_mixin);\n\n/* harmony default export */ var pie_segment = (pie_segment_PieSegment);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/mixins/pie-chart-mixin.js\n\n\n\nconst PieChartMixin = {\n    createLegendItem: function(value, point, options) {\n        const legendOptions = this.options.legend || {};\n        const labelsOptions = legendOptions.labels || {};\n        const inactiveItems = legendOptions.inactiveItems || {};\n        const inactiveItemsLabels = inactiveItems.labels || {};\n\n        if (options && options.visibleInLegend !== false) {\n            const pointVisible = options.visible !== false;\n            const labelTemplate = pointVisible ? getTemplate(labelsOptions) :\n                getTemplate(inactiveItemsLabels) || getTemplate(labelsOptions);\n            let text = options.category;\n\n            if (labelTemplate) {\n                text = labelTemplate({\n                    text: text,\n                    series: options.series,\n                    dataItem: options.dataItem,\n                    percentage: options.percentage,\n                    value: value\n                });\n            }\n\n            let itemLabelOptions, markerColor;\n            if (pointVisible) {\n                itemLabelOptions = {};\n                markerColor = point.color;\n            } else {\n                itemLabelOptions = {\n                    color: inactiveItemsLabels.color,\n                    font: inactiveItemsLabels.font\n                };\n                markerColor = (inactiveItems.markers || {}).color;\n            }\n\n            if (has_value_hasValue(text) && text !== \"\") {\n                this.legendItems.push({\n                    active: pointVisible,\n                    pointIndex: options.index,\n                    text: text,\n                    series: options.series,\n                    markerColor: markerColor,\n                    labels: itemLabelOptions\n                });\n            }\n        }\n    }\n};\n\n/* harmony default export */ var pie_chart_mixin = (PieChartMixin);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/pie-chart/pie-chart.js\n\n\n\n\n\n\n\n\n\n\n\n\nconst PIE_SECTOR_ANIM_DELAY = 70;\n\nclass pie_chart_PieChart extends chart_element {\n    constructor(plotArea, options) {\n        super(options);\n\n        this.plotArea = plotArea;\n        this.chartService = plotArea.chartService;\n        this.points = [];\n        this.legendItems = [];\n        this.render();\n    }\n\n    render() {\n        this.traverseDataPoints(this.addValue.bind(this));\n    }\n\n    traverseDataPoints(callback) {\n        const { options, plotArea: { options: { seriesColors = [] } } } = this;\n        const colorsCount = seriesColors.length;\n        const series = options.series;\n        const seriesCount = series.length;\n\n        for (let seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n            const currentSeries = series[seriesIx];\n            const data = currentSeries.data;\n            const { total, points, count } = bindSegments(currentSeries);\n            const anglePerValue = 360 / total;\n            let constantAngle;\n            if (!isFinite(anglePerValue)) {\n                constantAngle = 360 / count;\n            }\n            let currentAngle;\n\n            if (defined(currentSeries.startAngle)) {\n                currentAngle = currentSeries.startAngle;\n            } else {\n                currentAngle = options.startAngle;\n            }\n\n            if (seriesIx !== seriesCount - 1) {\n                if (currentSeries.labels.position === OUTSIDE_END) {\n                    currentSeries.labels.position = CENTER;\n                }\n            }\n\n            for (let i = 0; i < points.length; i++) {\n                const pointData = points[i];\n                if (!pointData) {\n                    continue;\n                }\n\n                const { fields, value, visible } = pointData;\n                const angle = value !== 0 ? (constantAngle || (value * anglePerValue)) : 0;\n                const explode = data.length !== 1 && Boolean(fields.explode);\n\n                if (!isFunction(currentSeries.color)) {\n                    currentSeries.color = fields.color || seriesColors[i % colorsCount];\n                }\n\n                callback(pointData.valueFields.value, new core_ring(null, 0, 0, currentAngle, angle), {\n                    owner: this,\n                    category: defined(fields.category) ? fields.category : \"\",\n                    index: i,\n                    series: currentSeries,\n                    seriesIx: seriesIx,\n                    dataItem: data[i],\n                    percentage: total !== 0 ? value / total : 0,\n                    explode: explode,\n                    visibleInLegend: fields.visibleInLegend,\n                    visible: visible,\n                    zIndex: seriesCount - seriesIx,\n                    animationDelay: this.animationDelay(i, seriesIx, seriesCount)\n                });\n\n                if (visible !== false) {\n                    currentAngle += angle;\n                }\n            }\n        }\n    }\n\n    evalSegmentOptions(options, value, fields) {\n        const series = fields.series;\n\n        evalOptions(options, {\n            value: value,\n            series: series,\n            dataItem: fields.dataItem,\n            category: fields.category,\n            percentage: fields.percentage\n        }, { defaults: series._defaults, excluded: [ \"data\", \"content\", \"template\", \"visual\", \"toggle\" ] });\n    }\n\n    addValue(value, sector, fields) {\n        const segmentOptions = deepExtend({}, fields.series, { index: fields.index });\n        this.evalSegmentOptions(segmentOptions, value, fields);\n\n        this.createLegendItem(value, segmentOptions, fields);\n\n        if (fields.visible === false) {\n            return;\n        }\n\n        const segment = new pie_segment(value, sector, segmentOptions);\n        Object.assign(segment, fields);\n        this.append(segment);\n        this.points.push(segment);\n    }\n\n    reflow(targetBox) {\n        const { options, points, seriesConfigs = [] } = this;\n        const count = points.length;\n        const box = targetBox.clone();\n        const space = 5;\n        const minWidth = Math.min(box.width(), box.height());\n        const halfMinWidth = minWidth / 2;\n        const defaultPadding = minWidth - minWidth * 0.85;\n        const newBox = new core_box(box.x1, box.y1, box.x1 + minWidth, box.y1 + minWidth);\n        const newBoxCenter = newBox.center();\n        const boxCenter = box.center();\n        const seriesCount = options.series.length;\n        const leftSideLabels = [];\n        const rightSideLabels = [];\n        let padding = valueOrDefault(options.padding, defaultPadding);\n\n        this.targetBox = targetBox;\n\n        padding = padding > halfMinWidth - space ? halfMinWidth - space : padding;\n        newBox.translate(boxCenter.x - newBoxCenter.x, boxCenter.y - newBoxCenter.y);\n\n        const radius = halfMinWidth - padding;\n        const center = new core_point(\n            radius + newBox.x1 + padding,\n            radius + newBox.y1 + padding\n        );\n\n        for (let i = 0; i < count; i++) {\n            const segment = points[i];\n            const sector = segment.sector;\n            const seriesIndex = segment.seriesIx;\n            sector.radius = radius;\n            sector.center = center;\n\n            if (seriesConfigs.length) {\n                const seriesConfig = seriesConfigs[seriesIndex];\n                sector.innerRadius = seriesConfig.innerRadius;\n                sector.radius = seriesConfig.radius;\n            }\n\n            if (seriesIndex === seriesCount - 1 && segment.explode) {\n                sector.center = sector.clone().setRadius(sector.radius * 0.15).point(sector.middle());\n            }\n\n            segment.reflow(newBox);\n\n            const label = segment.label;\n            if (label) {\n                if (label.options.position === OUTSIDE_END) {\n                    if (seriesIndex === seriesCount - 1) {\n                        if (label.orientation === RIGHT) {\n                            rightSideLabels.push(label);\n                        } else {\n                            leftSideLabels.push(label);\n                        }\n                    }\n                }\n            }\n        }\n\n        if (leftSideLabels.length > 0) {\n            leftSideLabels.sort(this.labelComparator(true));\n            this.leftLabelsReflow(leftSideLabels);\n        }\n\n        if (rightSideLabels.length > 0) {\n            rightSideLabels.sort(this.labelComparator(false));\n            this.rightLabelsReflow(rightSideLabels);\n        }\n\n        this.box = newBox;\n    }\n\n    leftLabelsReflow(labels) {\n        const distances = this.distanceBetweenLabels(labels);\n\n        this.distributeLabels(distances, labels);\n    }\n\n    rightLabelsReflow(labels) {\n        const distances = this.distanceBetweenLabels(labels);\n\n        this.distributeLabels(distances, labels);\n    }\n\n    distanceBetweenLabels(labels) {\n        const segment = last(this.points);\n        const sector = segment.sector;\n        const count = labels.length - 1;\n        const lr = sector.radius + segment.options.labels.distance;\n        const distances = [];\n        let firstBox = labels[0].box;\n        let distance = round(firstBox.y1 - (sector.center.y - lr - firstBox.height() - firstBox.height() / 2));\n\n        distances.push(distance);\n\n        for (let i = 0; i < count; i++) {\n            const secondBox = labels[i + 1].box;\n\n            firstBox = labels[i].box;\n            distance = round(secondBox.y1 - firstBox.y2);\n            distances.push(distance);\n        }\n        distance = round(sector.center.y + lr - labels[count].box.y2 - labels[count].box.height() / 2);\n        distances.push(distance);\n\n        return distances;\n    }\n\n    distributeLabels(distances, labels) {\n        const count = distances.length;\n        let left, right, remaining;\n\n        for (let i = 0; i < count; i++) {\n            remaining = -distances[i];\n            left = right = i;\n\n            while (remaining > 0 && (left >= 0 || right < count)) {\n                remaining = this._takeDistance(distances, i, --left, remaining);\n                remaining = this._takeDistance(distances, i, ++right, remaining);\n            }\n        }\n\n        this.reflowLabels(distances, labels);\n    }\n\n    _takeDistance(distances, anchor, position, amount) {\n        let result = amount;\n        if (distances[position] > 0) {\n            const available = Math.min(distances[position], result);\n            result -= available;\n            distances[position] -= available;\n            distances[anchor] += available;\n        }\n\n        return result;\n    }\n\n    reflowLabels(distances, labels) {\n        const segment = last(this.points);\n        const sector = segment.sector;\n        const labelOptions = segment.options.labels;\n        const labelsCount = labels.length;\n        const labelDistance = labelOptions.distance;\n        let boxY = sector.center.y - (sector.radius + labelDistance) - labels[0].box.height();\n        let boxX;\n\n        distances[0] += 2;\n        for (let i = 0; i < labelsCount; i++) {\n            const label = labels[i];\n            const box = label.box;\n\n            boxY += distances[i];\n            boxX = this.hAlignLabel(\n                box.x2,\n                sector.clone().expand(labelDistance),\n                boxY,\n                boxY + box.height(),\n                label.orientation === RIGHT);\n\n            if (label.orientation === RIGHT) {\n                if (labelOptions.align !== CIRCLE) {\n                    boxX = sector.radius + sector.center.x + labelDistance;\n                }\n                label.reflow(new core_box(boxX + box.width(), boxY, boxX, boxY));\n            } else {\n                if (labelOptions.align !== CIRCLE) {\n                    boxX = sector.center.x - sector.radius - labelDistance;\n                }\n                label.reflow(new core_box(boxX - box.width(), boxY, boxX, boxY));\n            }\n\n            boxY += box.height();\n        }\n    }\n\n    createVisual() {\n        const { options: { connectors }, points } = this;\n        const count = points.length;\n        const space = 4;\n\n        super.createVisual();\n\n        this._connectorLines = [];\n\n        for (let i = 0; i < count; i++) {\n            const segment = points[i];\n            const { sector, label } = segment;\n            const angle = sector.middle();\n            const connectorsColor = (segment.options.connectors || {}).color || connectors.color;\n\n            if (label) {\n                const connectorLine = new main[\"a\" /* drawing */].Path({\n                    stroke: {\n                        color: connectorsColor,\n                        width: connectors.width\n                    },\n                    animation: {\n                        type: FADEIN,\n                        delay: segment.animationDelay\n                    }\n                });\n\n                if (label.options.position === OUTSIDE_END) {\n                    const box = label.box;\n                    const centerPoint = sector.center;\n                    let start = sector.point(angle);\n                    let middle = new core_point(box.x1, box.center().y);\n                    let sr, end, crossing;\n\n                    start = sector.clone().expand(connectors.padding).point(angle);\n                    connectorLine.moveTo(start.x, start.y);\n                    // TODO: Extract into a method to remove duplication\n                    if (label.orientation === RIGHT) {\n                        end = new core_point(box.x1 - connectors.padding, box.center().y);\n                        crossing = intersection(centerPoint, start, middle, end);\n                        middle = new core_point(end.x - space, end.y);\n                        crossing = crossing || middle;\n                        crossing.x = Math.min(crossing.x, middle.x);\n\n                        if (this.pointInCircle(crossing, sector.center, sector.radius + space) ||\n                            crossing.x < sector.center.x) {\n                            sr = sector.center.x + sector.radius + space;\n                            if (segment.options.labels.align !== COLUMN) {\n                                if (sr < middle.x) {\n                                    connectorLine.lineTo(sr, start.y);\n                                } else {\n                                    connectorLine.lineTo(start.x + space * 2, start.y);\n                                }\n                            } else {\n                                connectorLine.lineTo(sr, start.y);\n                            }\n                            connectorLine.lineTo(middle.x, end.y);\n                        } else {\n                            crossing.y = end.y;\n                            connectorLine.lineTo(crossing.x, crossing.y);\n                        }\n                    } else {\n                        end = new core_point(box.x2 + connectors.padding, box.center().y);\n                        crossing = intersection(centerPoint, start, middle, end);\n                        middle = new core_point(end.x + space, end.y);\n                        crossing = crossing || middle;\n                        crossing.x = Math.max(crossing.x, middle.x);\n\n                        if (this.pointInCircle(crossing, sector.center, sector.radius + space) ||\n                            crossing.x > sector.center.x) {\n                            sr = sector.center.x - sector.radius - space;\n                            if (segment.options.labels.align !== COLUMN) {\n                                if (sr > middle.x) {\n                                    connectorLine.lineTo(sr, start.y);\n                                } else {\n                                    connectorLine.lineTo(start.x - space * 2, start.y);\n                                }\n                            } else {\n                                connectorLine.lineTo(sr, start.y);\n                            }\n                            connectorLine.lineTo(middle.x, end.y);\n                        } else {\n                            crossing.y = end.y;\n                            connectorLine.lineTo(crossing.x, crossing.y);\n                        }\n                    }\n\n                    connectorLine.lineTo(end.x, end.y);\n\n                    this._connectorLines.push(connectorLine);\n                    this.visual.append(connectorLine);\n                }\n            }\n        }\n    }\n\n    renderVisual() {\n        super.renderVisual();\n\n        if (find(this.options.series, options => options.autoFit)) {\n            const targetBox = this.targetBox;\n            const pieCenter = this.box.center();\n            const bbox = this.visual.bbox();\n            if (!bbox) {\n                return;\n            }\n\n            const bboxBottom = bbox.bottomRight();\n\n            const scale = Math.min(\n                (pieCenter.y - targetBox.y1) / (pieCenter.y - bbox.origin.y),\n                (targetBox.y2 - pieCenter.y) / (bboxBottom.y - pieCenter.y),\n                (pieCenter.x - targetBox.x1) / (pieCenter.x - bbox.origin.x),\n                (targetBox.x2 - pieCenter.x) / (bboxBottom.x - pieCenter.x)\n            );\n\n            if (scale < 1) {\n                this.visual.transform(main[\"b\" /* geometry */].transform().scale(scale, scale, [ pieCenter.x, pieCenter.y ]));\n            }\n        }\n    }\n\n    labelComparator(reverse) {\n        const reverseValue = reverse ? -1 : 1;\n\n        return function(a, b) {\n            const first = (a.parent.sector.middle() + 270) % 360;\n            const second = (b.parent.sector.middle() + 270) % 360;\n            return (first - second) * reverseValue;\n        };\n    }\n\n    hAlignLabel(originalX, sector, y1, y2, direction) {\n        const { radius, center: { x: cx, y: cy } } = sector;\n        const t = Math.min(Math.abs(cy - y1), Math.abs(cy - y2));\n\n        if (t > radius) {\n            return originalX;\n        }\n\n        return cx + Math.sqrt((radius * radius) - (t * t)) * (direction ? 1 : -1);\n    }\n\n    pointInCircle(point, center, radius) {\n        return Math.pow(center.x - point.x, 2) + Math.pow(center.y - point.y, 2) < Math.pow(radius, 2);\n    }\n\n    formatPointValue(point, format) {\n        return this.chartService.format.auto(format, point.value);\n    }\n\n    animationDelay(categoryIndex) {\n        return categoryIndex * PIE_SECTOR_ANIM_DELAY;\n    }\n\n    stackRoot() {\n        return this;\n    }\n}\n\nfunction intersection(a1, a2, b1, b2) {\n    const uat = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);\n    const ub = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);\n\n    let result;\n    if (ub !== 0) {\n        const ua = (uat / ub);\n\n        result = new core_point(\n            a1.x + ua * (a2.x - a1.x),\n            a1.y + ua * (a2.y - a1.y)\n        );\n    }\n\n    return result;\n}\n\nsetDefaultOptions(pie_chart_PieChart, {\n    startAngle: 90,\n    connectors: {\n        width: 2,\n        color: \"#939393\",\n        padding: 8\n    },\n    inactiveItems: {\n        markers: {},\n        labels: {}\n    }\n});\n\ndeepExtend(pie_chart_PieChart.prototype, pie_chart_mixin);\n\npie_chart_PieChart.prototype.isStackRoot = true;\n\n/* harmony default export */ var pie_chart = (pie_chart_PieChart);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/plotarea/pie-plotarea.js\n\n\n\n\n\nclass pie_plotarea_PiePlotArea extends plotarea_base {\n    render() {\n        this.createPieChart(this.series);\n    }\n\n    createPieChart(series) {\n        const firstSeries = series[0];\n        const pieChart = new pie_chart(this, {\n            series: series,\n            padding: firstSeries.padding,\n            startAngle: firstSeries.startAngle,\n            connectors: firstSeries.connectors,\n            legend: this.options.legend\n        });\n\n        this.appendChart(pieChart);\n    }\n\n    appendChart(chart, pane) {\n        super.appendChart(chart, pane);\n        append(this.options.legend.items, chart.legendItems);\n    }\n}\n\n/* harmony default export */ var pie_plotarea = (pie_plotarea_PiePlotArea);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/donut-chart/donut-segment.js\n\n\n\n\n\n\n\n\n\n\nclass donut_segment_DonutSegment extends pie_segment {\n    reflowLabel() {\n        const { options: { labels: labelsOptions }, label } = this;\n        const sector = this.sector.clone();\n        const angle = sector.middle();\n\n        if (label) {\n            const labelHeight = label.box.height();\n            if (labelsOptions.position === CENTER) {\n                sector.radius -= (sector.radius - sector.innerRadius) / 2;\n\n                const lp = sector.point(angle);\n\n                label.reflow(new core_box(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));\n            } else {\n                super.reflowLabel();\n            }\n        }\n    }\n\n    createSegment(sector, options) {\n        return shape_builder.current.createRing(sector, options);\n    }\n}\n\nsetDefaultOptions(donut_segment_DonutSegment, {\n    overlay: {\n        gradient: \"roundedGlass\"\n    },\n    labels: {\n        position: CENTER\n    },\n    animation: {\n        type: PIE\n    }\n});\n\ndeepExtend(donut_segment_DonutSegment.prototype, point_events_mixin);\n\n\n/* harmony default export */ var donut_segment = (donut_segment_DonutSegment);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/donut-chart/donut-chart.js\n\n\n\n\n\n\n\nconst DONUT_SECTOR_ANIM_DELAY = 50;\n\nclass donut_chart_DonutChart extends pie_chart {\n    addValue(value, sector, fields) {\n        const segmentOptions = deepExtend({}, fields.series, { index: fields.index });\n        this.evalSegmentOptions(segmentOptions, value, fields);\n\n        this.createLegendItem(value, segmentOptions, fields);\n\n        if (!value || fields.visible === false) {\n            return;\n        }\n\n        const segment = new donut_segment(value, sector, segmentOptions);\n\n        Object.assign(segment, fields);\n        this.append(segment);\n        this.points.push(segment);\n    }\n\n    reflow(targetBox) {\n        const options = this.options;\n        const box = targetBox.clone();\n        const space = 5;\n        const minWidth = Math.min(box.width(), box.height());\n        const halfMinWidth = minWidth / 2;\n        const defaultPadding = minWidth - minWidth * 0.85;\n        const series = options.series;\n        const seriesCount = series.length;\n\n        let padding = valueOrDefault(options.padding, defaultPadding);\n        padding = padding > halfMinWidth - space ? halfMinWidth - space : padding;\n\n        let totalSize = halfMinWidth - padding;\n        let seriesWithoutSize = 0;\n        let holeSize;\n\n        for (let i = 0; i < seriesCount; i++) {\n            const currentSeries = series[i];\n            if (i === 0) {\n                if (defined(currentSeries.holeSize)) {\n                    holeSize = currentSeries.holeSize;\n                    totalSize -= currentSeries.holeSize;\n                }\n            }\n\n            if (defined(currentSeries.size)) {\n                totalSize -= currentSeries.size;\n            } else {\n                seriesWithoutSize++;\n            }\n\n            if (defined(currentSeries.margin) && i !== seriesCount - 1) {\n                totalSize -= currentSeries.margin;\n            }\n        }\n\n        if (!defined(holeSize)) {\n            const currentSize = (halfMinWidth - padding) / (seriesCount + 0.75);\n            holeSize = currentSize * 0.75;\n            totalSize -= holeSize;\n        }\n\n        let innerRadius = holeSize;\n        let margin = 0;\n        let size, radius;\n\n        this.seriesConfigs = [];\n\n        for (let i = 0; i < seriesCount; i++) {\n            const currentSeries = series[i];\n            size = valueOrDefault(currentSeries.size, totalSize / seriesWithoutSize);\n            innerRadius += margin;\n            radius = innerRadius + size;\n            this.seriesConfigs.push({ innerRadius: innerRadius, radius: radius });\n            margin = currentSeries.margin || 0;\n            innerRadius = radius;\n        }\n\n        super.reflow(targetBox);\n    }\n\n    animationDelay(categoryIndex, seriesIndex, seriesCount) {\n        return categoryIndex * DONUT_SECTOR_ANIM_DELAY +\n            (INITIAL_ANIMATION_DURATION * (seriesIndex + 1) / (seriesCount + 1));\n    }\n}\n\n\nsetDefaultOptions(donut_chart_DonutChart, {\n    startAngle: 90,\n    connectors: {\n        width: 2,\n        color: \"#939393\",\n        padding: 8\n    }\n});\n\n/* harmony default export */ var donut_chart = (donut_chart_DonutChart);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/plotarea/donut-plotarea.js\n\n\n\nclass donut_plotarea_DonutPlotArea extends pie_plotarea {\n    render() {\n        this.createDonutChart(this.series);\n    }\n\n    createDonutChart(series) {\n        const firstSeries = series[0];\n        const donutChart = new donut_chart(this, {\n            series: series,\n            padding: firstSeries.padding,\n            connectors: firstSeries.connectors,\n            legend: this.options.legend\n        });\n\n        this.appendChart(donutChart);\n    }\n}\n\n/* harmony default export */ var donut_plotarea = (donut_plotarea_DonutPlotArea);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/plotarea/polar-plotarea-base.js\n\n\n\n\n\n\n\n\n\nconst DEFAULT_PADDING = 0.15;\n\nclass polar_plotarea_base_PolarPlotAreaBase extends plotarea_base {\n    initFields() {\n        this.valueAxisRangeTracker = new axis_group_range_tracker();\n    }\n\n    render() {\n        this.addToLegend(this.series);\n        this.createPolarAxis();\n        this.createCharts();\n        this.createValueAxis();\n    }\n\n    alignAxes() {\n        const axis = this.valueAxis;\n        const range = axis.range();\n        const crossingValue = axis.options.reverse ? range.max : range.min;\n        const slot = axis.getSlot(crossingValue);\n        const center = this.polarAxis.getSlot(0).center;\n        const axisBox = axis.box.translate(\n            center.x - slot.x1,\n            center.y - slot.y1\n        );\n\n        axis.reflow(axisBox);\n    }\n\n    createValueAxis() {\n        const tracker = this.valueAxisRangeTracker;\n        const defaultRange = tracker.query();\n        const axisOptions = this.valueAxisOptions({\n            roundToMajorUnit: false,\n            zIndex: -1\n        });\n        let axisType, axisDefaultRange;\n\n        if (axisOptions.type === LOGARITHMIC) {\n            axisType = radar_logarithmic_axis;\n            axisDefaultRange = { min: 0.1, max: 1 };\n        } else {\n            axisType = radar_numeric_axis;\n            axisDefaultRange = { min: 0, max: 1 };\n        }\n\n        const range = tracker.query(name) || defaultRange || axisDefaultRange;\n\n        if (range && defaultRange) {\n            range.min = Math.min(range.min, defaultRange.min);\n            range.max = Math.max(range.max, defaultRange.max);\n        }\n\n        const valueAxis = new axisType(\n            range.min, range.max,\n            axisOptions,\n            this.chartService\n        );\n\n        this.valueAxis = valueAxis;\n        this.appendAxis(valueAxis);\n    }\n\n    reflowAxes() {\n        const { options: { plotArea: options }, valueAxis, polarAxis, box } = this;\n        const defaultPadding = Math.min(box.width(), box.height()) * DEFAULT_PADDING;\n        const padding = getSpacing(options.padding || {}, defaultPadding);\n        const paddingBox = box.clone().unpad(padding);\n        const axisBox = paddingBox.clone();\n\n        axisBox.y2 = axisBox.y1 + Math.min(axisBox.width(), axisBox.height());\n        axisBox.align(paddingBox, Y, CENTER);\n\n        const valueAxisBox = axisBox.clone().shrink(0, axisBox.height() / 2);\n\n        polarAxis.reflow(axisBox);\n        valueAxis.reflow(valueAxisBox);\n        const heightDiff = valueAxis.lineBox().height() - valueAxis.box.height();\n        valueAxis.reflow(valueAxis.box.unpad({ top: heightDiff }));\n\n        this.axisBox = axisBox;\n        this.alignAxes(axisBox);\n    }\n\n    backgroundBox() {\n        return this.box;\n    }\n\n    detachLabels() {}\n}\n\n/* harmony default export */ var polar_plotarea_base = (polar_plotarea_base_PolarPlotAreaBase);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/polar-scatter-chart/polar-scatter-chart.js\n\n\n\n\n\n\nclass polar_scatter_chart_PolarScatterChart extends scatter_chart {\n    pointSlot(slotX, slotY) {\n        const valueRadius = slotX.center.y - slotY.y1;\n        const slot = core_point.onCircle(slotX.center, slotX.startAngle, valueRadius);\n\n        return new core_box(slot.x, slot.y, slot.x, slot.y);\n    }\n}\n\nsetDefaultOptions(polar_scatter_chart_PolarScatterChart, {\n    clip: false\n});\n\n/* harmony default export */ var polar_scatter_chart = (polar_scatter_chart_PolarScatterChart);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/polar-line-chart/polar-line-chart.js\n\n\n\n\n\nclass polar_line_chart_PolarLineChart extends scatter_line_chart {\n}\n\npolar_line_chart_PolarLineChart.prototype.pointSlot = polar_scatter_chart.prototype.pointSlot;\n\nsetDefaultOptions(polar_line_chart_PolarLineChart, {\n    clip: false\n});\n\n/* harmony default export */ var polar_line_chart = (polar_line_chart_PolarLineChart);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/polar-area-chart/spline-polar-area-segment.js\n\n\n\nclass spline_polar_area_segment_SplinePolarAreaSegment extends spline_area_segment {\n    fillToAxes(fillPath) {\n        const center = this._polarAxisCenter();\n        fillPath.lineTo(center.x, center.y);\n    }\n\n    _polarAxisCenter() {\n        const polarAxis = this.parent.plotArea.polarAxis;\n        const center = polarAxis.box.center();\n        return center;\n    }\n\n    strokeSegments() {\n        let segments = this._strokeSegments;\n\n        if (!segments) {\n            const center = this._polarAxisCenter();\n            const curveProcessor = new curve_processor(false);\n            const linePoints = this.points();\n\n            linePoints.push(center);\n            segments = this._strokeSegments = curveProcessor.process(linePoints);\n            segments.pop();\n        }\n\n        return segments;\n    }\n}\n\n/* harmony default export */ var spline_polar_area_segment = (spline_polar_area_segment_SplinePolarAreaSegment);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/polar-area-chart/polar-area-segment.js\n\n\n\nclass polar_area_segment_PolarAreaSegment extends area_segment {\n    fillToAxes(fillPath) {\n        const polarAxis = this.parent.plotArea.polarAxis;\n        const center = polarAxis.box.center();\n        const centerSegment = new main[\"b\" /* geometry */].Segment([ center.x, center.y ]);\n\n        fillPath.segments.unshift(centerSegment);\n        fillPath.segments.push(centerSegment);\n    }\n}\n\n/* harmony default export */ var polar_area_segment = (polar_area_segment_PolarAreaSegment);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/polar-area-chart/polar-area-chart.js\n\n\n\n\n\n\n\n\nclass polar_area_chart_PolarAreaChart extends polar_line_chart {\n    createSegment(linePoints, currentSeries, seriesIx) {\n        const style = (currentSeries.line || {}).style;\n        let segment;\n\n        if (style === SMOOTH) {\n            segment = new spline_polar_area_segment(linePoints, currentSeries, seriesIx);\n        } else {\n            segment = new polar_area_segment(linePoints, currentSeries, seriesIx);\n        }\n        return segment;\n    }\n\n    createMissingValue(value, missingValues) {\n        let missingValue;\n\n        if (has_value_hasValue(value.x) && missingValues !== INTERPOLATE) {\n            missingValue = {\n                x: value.x,\n                y: value.y\n            };\n            if (missingValues === ZERO) {\n                missingValue.y = 0;\n            }\n        }\n\n        return missingValue;\n    }\n\n    seriesMissingValues(series) {\n        return series.missingValues || ZERO;\n    }\n\n    _hasMissingValuesGap() {\n        const series = this.options.series;\n\n        for (let idx = 0; idx < series.length; idx++) {\n            if (this.seriesMissingValues(series[idx]) === GAP) {\n                return true;\n            }\n        }\n    }\n\n    sortPoints(points) {\n        points.sort(xComparer);\n\n        if (this._hasMissingValuesGap()) {\n            for (let idx = 0; idx < points.length; idx++) {\n                const point = points[idx];\n                if (point) {\n                    const value = point.value;\n                    if (!has_value_hasValue(value.y) && this.seriesMissingValues(point.series) === GAP) {\n                        delete points[idx];\n                    }\n                }\n            }\n        }\n\n        return points;\n    }\n}\n\nfunction xComparer(a, b) {\n    return a.value.x - b.value.x;\n}\n\n/* harmony default export */ var polar_area_chart = (polar_area_chart_PolarAreaChart);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/plotarea/polar-plotarea.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass polar_plotarea_PolarPlotArea extends polar_plotarea_base {\n    createPolarAxis() {\n        const polarAxis = new polar_axis(this.options.xAxis, this.chartService);\n\n        this.polarAxis = polarAxis;\n        this.axisX = polarAxis;\n        this.appendAxis(polarAxis);\n    }\n\n    valueAxisOptions(defaults) {\n        return deepExtend(defaults, {\n            majorGridLines: { type: ARC },\n            minorGridLines: { type: ARC }\n        }, this.options.yAxis);\n    }\n\n    createValueAxis() {\n        super.createValueAxis();\n        this.axisY = this.valueAxis;\n    }\n\n    appendChart(chart, pane) {\n        this.valueAxisRangeTracker.update(chart.yAxisRanges);\n\n        plotarea_base.prototype.appendChart.call(this, chart, pane);\n    }\n\n    createCharts() {\n        const series = this.filterVisibleSeries(this.series);\n        const pane = this.panes[0];\n\n        this.createLineChart(\n            filterSeriesByType(series, [ POLAR_LINE ]),\n            pane\n        );\n\n        this.createScatterChart(\n            filterSeriesByType(series, [ POLAR_SCATTER ]),\n            pane\n        );\n\n        this.createAreaChart(\n            filterSeriesByType(series, [ POLAR_AREA ]),\n            pane\n        );\n    }\n\n    createLineChart(series, pane) {\n        if (series.length === 0) {\n            return;\n        }\n\n        const lineChart = new polar_line_chart(this, { series: series });\n\n        this.appendChart(lineChart, pane);\n    }\n\n    createScatterChart(series, pane) {\n        if (series.length === 0) {\n            return;\n        }\n\n        const scatterChart = new polar_scatter_chart(this, { series: series });\n\n        this.appendChart(scatterChart, pane);\n    }\n\n    createAreaChart(series, pane) {\n        if (series.length === 0) {\n            return;\n        }\n\n        const areaChart = new polar_area_chart(this, { series: series });\n\n        this.appendChart(areaChart, pane);\n    }\n\n    _dispatchEvent(chart, e, eventType) {\n        const coords = chart._eventCoordinates(e);\n        const point = new core_point(coords.x, coords.y);\n        const xValue = this.axisX.getValue(point);\n        const yValue = this.axisY.getValue(point);\n\n        if (xValue !== null && yValue !== null) {\n            chart.trigger(eventType, {\n                element: eventElement(e),\n                x: xValue,\n                y: yValue\n            });\n        }\n    }\n\n    createCrosshairs() {}\n}\n\nsetDefaultOptions(polar_plotarea_PolarPlotArea, {\n    xAxis: {},\n    yAxis: {}\n});\n\ndeepExtend(polar_plotarea_PolarPlotArea.prototype, plotarea_events_mixin);\n\n/* harmony default export */ var polar_plotarea = (polar_plotarea_PolarPlotArea);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/radar-line-chart/radar-line-chart.js\n\n\n\n\n\n\n\n\n\n\nfunction groupBySeriesIx(segments) {\n    const seriesSegments = [];\n    for (let idx = 0; idx < segments.length; idx++) {\n        const segment = segments[idx];\n        seriesSegments[segment.seriesIx] = seriesSegments[segment.seriesIx] || [];\n        seriesSegments[segment.seriesIx].push(segment);\n    }\n\n    return seriesSegments;\n}\n\nclass radar_line_chart_RadarLineChart extends line_chart {\n\n    pointSlot(categorySlot, valueSlot) {\n        const valueRadius = categorySlot.center.y - valueSlot.y1;\n        const slot = core_point.onCircle(categorySlot.center, categorySlot.middle(), valueRadius);\n\n        return new core_box(slot.x, slot.y, slot.x, slot.y);\n    }\n\n    renderSegments() {\n        super.renderSegments();\n\n        if (this._segments && this._segments.length > 1) {\n            const seriesSegments = groupBySeriesIx(this._segments);\n\n            for (let idx = 0; idx < seriesSegments.length; idx++) {\n                const segments = seriesSegments[idx];\n                if (segments && segments.length > 1) {\n                    const firstPoint = segments[0].linePoints[0];\n                    const lastSegment = last(segments);\n                    const lastPoint = last(lastSegment.linePoints);\n                    const isFirstDataPoint = firstPoint.categoryIx === 0;\n                    const isLastDataPoint = lastPoint.categoryIx === lastPoint.categoriesCount - 1;\n                    if (isFirstDataPoint && isLastDataPoint) {\n                        last(segments).linePoints.push(firstPoint);\n                    }\n                }\n            }\n        }\n    }\n\n    createSegment(linePoints, currentSeries, seriesIx) {\n        const style = currentSeries.style;\n        let pointType;\n\n        if (style === SMOOTH) {\n            pointType = spline_segment;\n        } else {\n            pointType = line_segment;\n        }\n\n        const segment = new pointType(linePoints, currentSeries, seriesIx);\n        const missingValues = this.seriesMissingValues(currentSeries);\n\n        if (linePoints.length === currentSeries.data.length || missingValues === INTERPOLATE) {\n            segment.options.closed = true;\n        }\n\n        return segment;\n    }\n}\n\nsetDefaultOptions(radar_line_chart_RadarLineChart, {\n    clip: false,\n    limitPoints: false\n});\n\n/* harmony default export */ var radar_line_chart = (radar_line_chart_RadarLineChart);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/radar-area-chart/spline-radar-area-segment.js\n\n\nclass spline_radar_area_segment_SplineRadarAreaSegment extends spline_area_segment {\n    fillToAxes() {}\n}\n\n/* harmony default export */ var spline_radar_area_segment = (spline_radar_area_segment_SplineRadarAreaSegment);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/radar-area-chart/radar-area-segment.js\n\n\nclass radar_area_segment_RadarAreaSegment extends area_segment {\n    fillToAxes() {}\n}\n\n/* harmony default export */ var radar_area_segment = (radar_area_segment_RadarAreaSegment);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/radar-area-chart/radar-area-chart.js\n\n\n\n\n\n\nclass radar_area_chart_RadarAreaChart extends radar_line_chart {\n    createSegment(linePoints, currentSeries, seriesIx, prevSegment) {\n        const isStacked = this.options.isStacked;\n        const style = (currentSeries.line || {}).style;\n        let previousSegment;\n        let stackPoints;\n        let segment;\n\n        if (isStacked && seriesIx > 0 && prevSegment) {\n            stackPoints = prevSegment.linePoints.slice(0);\n            previousSegment = prevSegment;\n        }\n\n        if (style === SMOOTH) {\n            segment = new spline_radar_area_segment(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);\n            segment.options.closed = true;\n        } else {\n            linePoints.push(linePoints[0]);\n            segment = new radar_area_segment(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);\n        }\n\n        return segment;\n    }\n\n    seriesMissingValues(series) {\n        return series.missingValues || ZERO;\n    }\n}\n\n/* harmony default export */ var radar_area_chart = (radar_area_chart_RadarAreaChart);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/radar-bar-chart/radar-segment.js\n\n\n\n\nclass radar_segment_RadarSegment extends donut_segment {\n    constructor(value, options) {\n        super(value, null, options);\n    }\n}\n\nsetDefaultOptions(radar_segment_RadarSegment, {\n    overlay: {\n        gradient: \"none\"\n    },\n    labels: {\n        distance: 10\n    }\n});\n\n/* harmony default export */ var radar_segment = (radar_segment_RadarSegment);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/layout/radar-cluster-layout.js\n\n\n\n\n\n\nclass radar_cluster_layout_RadarClusterLayout extends chart_element {\n    constructor(options) {\n        super(options);\n\n        this.forEach = options.rtl ? forEachReverse : forEach;\n    }\n\n    reflow(sector) {\n        const { options, children } = this;\n        const { gap, spacing } = options;\n        const count = children.length;\n        const slots = count + gap + (spacing * (count - 1));\n        const slotAngle = sector.angle / slots;\n        let angle = sector.startAngle + slotAngle * (gap / 2);\n\n        this.forEach(children, (child) => {\n            const slotSector = sector.clone();\n            slotSector.startAngle = angle;\n            slotSector.angle = slotAngle;\n\n            if (child.sector) {\n                slotSector.radius = child.sector.radius;\n            }\n\n            child.reflow(slotSector);\n            child.sector = slotSector;\n\n            angle += slotAngle + (slotAngle * spacing);\n        });\n    }\n}\n\nsetDefaultOptions(radar_cluster_layout_RadarClusterLayout, {\n    gap: 1,\n    spacing: 0\n});\n\n/* harmony default export */ var radar_cluster_layout = (radar_cluster_layout_RadarClusterLayout);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/layout/radar-stack-layout.js\n\n\nclass radar_stack_layout_RadarStackLayout extends chart_element {\n    reflow(sector) {\n        const { options: { reverse }, children } = this;\n        const childrenCount = children.length;\n        const first = reverse ? childrenCount - 1 : 0;\n        const step = reverse ? -1 : 1;\n\n        this.box = new core_box();\n\n        for (let i = first; i >= 0 && i < childrenCount; i += step) {\n            const childSector = children[i].sector;\n            childSector.startAngle = sector.startAngle;\n            childSector.angle = sector.angle;\n        }\n    }\n}\n\n/* harmony default export */ var radar_stack_layout = (radar_stack_layout_RadarStackLayout);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/radar-bar-chart/radar-bar-chart.js\n\n\n\n\n\n\n\n\nclass radar_bar_chart_RadarBarChart extends bar_chart {\n    pointType() {\n        return radar_segment;\n    }\n\n    clusterType() {\n        return radar_cluster_layout;\n    }\n\n    stackType() {\n        return radar_stack_layout;\n    }\n\n    categorySlot(categoryAxis, categoryIx) {\n        return categoryAxis.getSlot(categoryIx);\n    }\n\n    pointSlot(categorySlot, valueSlot) {\n        const slot = categorySlot.clone();\n        const y = categorySlot.center.y;\n\n        slot.radius = y - valueSlot.y1;\n        slot.innerRadius = y - valueSlot.y2;\n\n        return slot;\n    }\n\n    reflowPoint(point, pointSlot) {\n        point.sector = pointSlot;\n        point.reflow();\n    }\n\n    createAnimation() {\n        this.options.animation.center = this.box.toRect().center();\n        super.createAnimation();\n    }\n}\n\nradar_bar_chart_RadarBarChart.prototype.reflow = categorical_chart.prototype.reflow;\n\nsetDefaultOptions(radar_bar_chart_RadarBarChart, {\n    clip: false,\n    limitPoints: false,\n    animation: {\n        type: \"pie\"\n    }\n});\n\n/* harmony default export */ var radar_bar_chart = (radar_bar_chart_RadarBarChart);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/plotarea/radar-plotarea.js\n\n\n\n\n\n\n\n\n\n\n\nlet radar_plotarea_RadarPlotArea = /*@__PURE__*/ (() => {\n    class RadarPlotArea extends polar_plotarea_base {\n        createPolarAxis() {\n            const categoryAxis = new radar_category_axis(this.options.categoryAxis, this.chartService);\n            this.polarAxis = categoryAxis;\n            this.categoryAxis = categoryAxis;\n            this.appendAxis(categoryAxis);\n            this.aggregateCategories();\n            this.createCategoryAxesLabels();\n        }\n        valueAxisOptions(defaults) {\n            if (this._hasBarCharts) {\n                deepExtend(defaults, {\n                    majorGridLines: { type: ARC },\n                    minorGridLines: { type: ARC }\n                });\n            }\n            if (this._isStacked100) {\n                deepExtend(defaults, {\n                    roundToMajorUnit: false,\n                    labels: { format: \"P0\" }\n                });\n            }\n            return deepExtend(defaults, this.options.valueAxis);\n        }\n        aggregateCategories() {\n            // No separate panes in radar charts\n            categorical_plotarea.prototype.aggregateCategories.call(this, this.panes);\n        }\n        createCategoryAxesLabels() {\n            categorical_plotarea.prototype.createCategoryAxesLabels.call(this, this.panes);\n        }\n        filterSeries(currentSeries) {\n            // Not supported for radar charts\n            return currentSeries;\n        }\n        createCharts() {\n            const series = this.filterVisibleSeries(this.series);\n            const pane = this.panes[0];\n            this.createAreaChart(filterSeriesByType(series, [RADAR_AREA]), pane);\n            this.createLineChart(filterSeriesByType(series, [RADAR_LINE]), pane);\n            this.createBarChart(filterSeriesByType(series, [RADAR_COLUMN]), pane);\n        }\n        chartOptions(series) {\n            const options = { series: series };\n            const firstSeries = series[0];\n            if (firstSeries) {\n                const filteredSeries = this.filterVisibleSeries(series);\n                const stack = firstSeries.stack;\n                options.isStacked = stack && filteredSeries.length > 1;\n                options.isStacked100 = stack && stack.type === \"100%\" && filteredSeries.length > 1;\n                if (options.isStacked100) {\n                    this._isStacked100 = true;\n                }\n            }\n            return options;\n        }\n        createAreaChart(series, pane) {\n            if (series.length === 0) {\n                return;\n            }\n            const areaChart = new radar_area_chart(this, this.chartOptions(series));\n            this.appendChart(areaChart, pane);\n        }\n        createLineChart(series, pane) {\n            if (series.length === 0) {\n                return;\n            }\n            const lineChart = new radar_line_chart(this, this.chartOptions(series));\n            this.appendChart(lineChart, pane);\n        }\n        createBarChart(series, pane) {\n            if (series.length === 0) {\n                return;\n            }\n            const firstSeries = series[0];\n            const options = this.chartOptions(series);\n            options.gap = firstSeries.gap;\n            options.spacing = firstSeries.spacing;\n            const barChart = new radar_bar_chart(this, options);\n            this.appendChart(barChart, pane);\n            this._hasBarCharts = true;\n        }\n        seriesCategoryAxis() {\n            return this.categoryAxis;\n        }\n        _dispatchEvent(chart, e, eventType) {\n            const coords = chart._eventCoordinates(e);\n            const point = new core_point(coords.x, coords.y);\n            const category = this.categoryAxis.getCategory(point);\n            const value = this.valueAxis.getValue(point);\n            if (category !== null && value !== null) {\n                chart.trigger(eventType, {\n                    element: eventElement(e),\n                    category: category,\n                    value: value\n                });\n            }\n        }\n        createCrosshairs() { }\n    }\n    deepExtend(RadarPlotArea.prototype, plotarea_events_mixin, {\n        appendChart: categorical_plotarea.prototype.appendChart,\n        aggregateSeries: categorical_plotarea.prototype.aggregateSeries,\n        seriesSourcePoints: categorical_plotarea.prototype.seriesSourcePoints\n    });\n    return RadarPlotArea;\n})();\nsetDefaultOptions(radar_plotarea_RadarPlotArea, {\n    categoryAxis: {\n        categories: []\n    },\n    valueAxis: {}\n});\n/* harmony default export */ var radar_plotarea = (radar_plotarea_RadarPlotArea);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/funnel-chart/funnel-segment.js\n\n\n\n\n\n\n\n\nclass funnel_segment_FunnelSegment extends chart_element {\n    constructor(value, options, segmentOptions) {\n        super(options);\n\n        this.value = value;\n        this.options.index = segmentOptions.index;\n    }\n\n    reflow(chartBox) {\n        const points = this.points;\n        const label = this.children[0];\n\n        this.box = new core_box(points[0].x, points[0].y, points[1].x, points[2].y);\n\n        if (label) {\n            label.reflow(new core_box(chartBox.x1, points[0].y, chartBox.x2, points[2].y));\n        }\n    }\n\n    createVisual() {\n        const options = this.options;\n        let visual;\n\n        super.createVisual();\n\n        if (options.visual) {\n            visual = options.visual({\n                category: this.category,\n                dataItem: this.dataItem,\n                value: this.value,\n                series: this.series,\n                percentage: this.percentage,\n                points: this.points,\n                options: options,\n                sender: this.getSender(),\n                createVisual: () => this.createPath()\n            });\n        } else {\n            visual = this.createPath();\n        }\n\n        if (visual) {\n            this.visual.append(visual);\n        }\n    }\n\n    createPath() {\n        const options = this.options;\n        const border = options.border;\n        const path = main[\"a\" /* drawing */].Path.fromPoints(this.points, {\n            fill: {\n                color: options.color,\n                opacity: options.opacity\n            },\n            stroke: {\n                color: border.color,\n                opacity: border.opacity,\n                width: border.width\n            }\n        }).close();\n\n        return path;\n    }\n\n    createHighlight(style) {\n        return main[\"a\" /* drawing */].Path.fromPoints(this.points, style);\n    }\n\n    highlightVisual() {\n        return this.visual.children[0];\n    }\n\n    highlightVisualArgs() {\n        const path = main[\"a\" /* drawing */].Path.fromPoints(this.points).close();\n\n        return {\n            options: this.options,\n            path: path\n        };\n    }\n\n    tooltipAnchor() {\n        const box = this.box;\n        return {\n            point: new core_point(box.center().x, box.y1),\n            align: {\n                horizontal: \"center\",\n                vertical: \"top\"\n            }\n        };\n    }\n\n    formatValue(format) {\n        const point = this;\n        return point.owner.formatPointValue(point, format);\n    }\n}\n\nsetDefaultOptions(funnel_segment_FunnelSegment, {\n    color: WHITE,\n    border: {\n        width: 1\n    }\n});\n\ndeepExtend(funnel_segment_FunnelSegment.prototype, point_events_mixin);\n\n/* harmony default export */ var funnel_segment = (funnel_segment_FunnelSegment);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/funnel-chart/funnel-chart.js\n\n\n\n\n\n\n\n\n\n\n\nclass funnel_chart_FunnelChart extends chart_element {\n    constructor(plotArea, options) {\n        super(options);\n\n        this.plotArea = plotArea;\n        this.points = [];\n        this.labels = [];\n        this.legendItems = [];\n        this.render();\n    }\n\n    formatPointValue(point, format) {\n        return this.chartService.format.auto(format,point.value);\n    }\n\n    render() {\n        const { options, plotArea: { options: { seriesColors = [] } } } = this;\n        const series = options.series[0];\n        const data = series.data;\n\n        if (!data) {\n            return;\n        }\n\n        const { total, points } = bindSegments(series);\n\n        for (let i = 0; i < points.length; i++) {\n            const pointData = points[i];\n\n            if (!pointData) {\n                continue;\n            }\n\n            let fields = pointData.fields;\n\n            if (!isFunction(series.color)) {\n                series.color = fields.color || seriesColors[i % seriesColors.length];\n            }\n\n            fields = deepExtend({\n                index: i,\n                owner: this,\n                series: series,\n                dataItem: data[i],\n                percentage: pointData.value / total\n            }, fields, { visible: pointData.visible });\n\n            const value = pointData.valueFields.value;\n            const segment = this.createSegment(value, fields);\n            const label = this.createLabel(value, fields);\n\n            if (segment && label) {\n                segment.append(label);\n            }\n        }\n    }\n\n    evalSegmentOptions(options, value, fields) {\n        const series = fields.series;\n\n        evalOptions(options, {\n            value: value,\n            series: series,\n            dataItem: fields.dataItem,\n            index: fields.index\n        }, { defaults: series._defaults, excluded: [ \"data\", \"content\", \"template\", \"toggle\", \"visual\" ] });\n    }\n\n    createSegment(value, fields) {\n        const seriesOptions = deepExtend({}, fields.series);\n        this.evalSegmentOptions(seriesOptions, value, fields);\n\n        this.createLegendItem(value, seriesOptions, fields);\n\n        if (fields.visible !== false) {\n\n            const segment = new funnel_segment(value, seriesOptions, fields);\n            Object.assign(segment, fields);\n\n            this.append(segment);\n            this.points.push(segment);\n\n            return segment;\n        }\n    }\n\n    createLabel(value, fields) {\n        const { series, dataItem } = fields;\n        const labels = deepExtend({}, this.options.labels, series.labels);\n        let text = value;\n\n        if (labels.visible) {\n            const labelTemplate = getTemplate(labels);\n            const data = {\n                dataItem: dataItem,\n                value: value,\n                percentage: fields.percentage,\n                category: fields.category,\n                series: series\n            };\n            if (labelTemplate) {\n                text = labelTemplate(data);\n            } else if (labels.format) {\n                text = this.plotArea.chartService.format.auto(labels.format, text);\n            }\n\n            if (!labels.color) {\n                const brightnessValue = new color_color[\"a\" /* default */](series.color).percBrightness();\n                if (brightnessValue > 180) {\n                    labels.color = BLACK;\n                } else {\n                    labels.color = WHITE;\n                }\n                if (!labels.background) {\n                    labels.background = series.color;\n                }\n            }\n\n            this.evalSegmentOptions(labels, value, fields);\n            const textBox = new text_box(text, deepExtend({\n                vAlign: labels.position\n            }, labels), data);\n\n            this.labels.push(textBox);\n\n            return textBox;\n        }\n    }\n\n    labelPadding() {\n        const labels = this.labels;\n        const padding = { left: 0, right: 0 };\n\n        for (let i = 0; i < labels.length; i++) {\n            const label = labels[i];\n            const align = label.options.align;\n            if (align !== CENTER) {\n                const width = labels[i].box.width();\n\n                if (align === LEFT) {\n                    padding.left = Math.max(padding.left, width);\n                } else {\n                    padding.right = Math.max(padding.right, width);\n                }\n            }\n        }\n\n        return padding;\n    }\n\n    dynamicSlopeReflow(box, width, totalHeight) {\n        const { options, points: segments } = this;\n        const count = segments.length;\n        const firstSegment = segments[0];\n        let maxSegment = firstSegment;\n\n        for (let idx = 0; idx < segments.length; idx++) {\n            if (segments[idx].percentage > maxSegment.percentage) {\n                maxSegment = segments[idx];\n            }\n        }\n\n        let lastUpperSide = (firstSegment.percentage / maxSegment.percentage) * width;\n        let previousOffset = (width - lastUpperSide) / 2;\n        let previousHeight = 0;\n\n        for (let idx = 0; idx < count; idx++) {\n            const percentage = segments[idx].percentage;\n            const nextSegment = segments[idx + 1];\n            const nextPercentage = (nextSegment ? nextSegment.percentage : percentage);\n            const points = segments[idx].points = [];\n            const height = (options.dynamicHeight) ? (totalHeight * percentage) : (totalHeight / count);\n            let offset;\n\n            if (!percentage) {\n                offset = nextPercentage ? 0 : width / 2;\n            } else {\n                offset = (width - lastUpperSide * (nextPercentage / percentage)) / 2;\n            }\n\n            offset = limitValue(offset, 0, width);\n\n            points.push(new main[\"b\" /* geometry */].Point(box.x1 + previousOffset, box.y1 + previousHeight));\n            points.push(new main[\"b\" /* geometry */].Point(box.x1 + width - previousOffset, box.y1 + previousHeight));\n            points.push(new main[\"b\" /* geometry */].Point(box.x1 + width - offset, box.y1 + height + previousHeight));\n            points.push(new main[\"b\" /* geometry */].Point(box.x1 + offset, box.y1 + height + previousHeight));\n\n            previousOffset = offset;\n            previousHeight += height + options.segmentSpacing;\n            lastUpperSide = limitValue(width - 2 * offset, 0, width);\n        }\n    }\n\n    constantSlopeReflow(box, width, totalHeight) {\n        const { options, points: segments } = this;\n        const count = segments.length;\n        const decreasingWidth = options.neckRatio <= 1;\n        const neckRatio = decreasingWidth ? options.neckRatio * width : width;\n        let previousOffset = decreasingWidth ? 0 : (width - width / options.neckRatio) / 2;\n        const topMostWidth = decreasingWidth ? width : width - previousOffset * 2;\n        const finalNarrow = (topMostWidth - neckRatio) / 2;\n        let previousHeight = 0;\n\n        for (let idx = 0; idx < count; idx++) {\n            const points = segments[idx].points = [];\n            const percentage = segments[idx].percentage;\n            const offset = (options.dynamicHeight) ? (finalNarrow * percentage) : (finalNarrow / count);\n            const height = (options.dynamicHeight) ? (totalHeight * percentage) : (totalHeight / count);\n\n            points.push(new main[\"b\" /* geometry */].Point(box.x1 + previousOffset, box.y1 + previousHeight));\n            points.push(new main[\"b\" /* geometry */].Point(box.x1 + width - previousOffset, box.y1 + previousHeight));\n            points.push(new main[\"b\" /* geometry */].Point(box.x1 + width - previousOffset - offset, box.y1 + height + previousHeight));\n            points.push(new main[\"b\" /* geometry */].Point(box.x1 + previousOffset + offset,box.y1 + height + previousHeight));\n            previousOffset += offset;\n            previousHeight += height + options.segmentSpacing;\n        }\n    }\n\n    reflow(chartBox) {\n        const points = this.points;\n        const count = points.length;\n\n        if (!count) {\n            return;\n        }\n\n        const options = this.options;\n        const box = chartBox.clone().unpad(this.labelPadding());\n        const totalHeight = box.height() - options.segmentSpacing * (count - 1);\n        const width = box.width();\n\n        if (options.dynamicSlope) {\n            this.dynamicSlopeReflow(box, width, totalHeight);\n        } else {\n            this.constantSlopeReflow(box, width, totalHeight);\n        }\n\n        for (let idx = 0; idx < count; idx++) {\n            points[idx].reflow(chartBox);\n        }\n    }\n}\n\nsetDefaultOptions(funnel_chart_FunnelChart, {\n    neckRatio: 0.3,\n    width: 300,\n    dynamicSlope: false,\n    dynamicHeight: true,\n    segmentSpacing: 0,\n    labels: {\n        visible: false,\n        align: CENTER,\n        position: CENTER,\n        zIndex: 1\n    }\n});\n\ndeepExtend(funnel_chart_FunnelChart.prototype, pie_chart_mixin);\n\n/* harmony default export */ var funnel_chart = (funnel_chart_FunnelChart);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/plotarea/funnel-plotarea.js\n\n\n\n\n\nclass funnel_plotarea_FunnelPlotArea extends plotarea_base {\n    render() {\n        this.createFunnelChart(this.series);\n    }\n\n    createFunnelChart(series) {\n        const firstSeries = series[0];\n        const funnelChart = new funnel_chart(this, {\n            series: series,\n            legend: this.options.legend,\n            neckRatio: firstSeries.neckRatio,\n            dynamicHeight: firstSeries.dynamicHeight,\n            dynamicSlope: firstSeries.dynamicSlope,\n            segmentSpacing: firstSeries.segmentSpacing,\n            highlight: firstSeries.highlight\n        });\n\n        this.appendChart(funnelChart);\n    }\n\n    appendChart(chart, pane) {\n        super.appendChart(chart, pane);\n        append(this.options.legend.items, chart.legendItems);\n    }\n}\n\n/* harmony default export */ var funnel_plotarea = (funnel_plotarea_FunnelPlotArea);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/register-charts.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst COLOR = \"color\";\nconst FIRST = \"first\";\nconst FROM = \"from\";\nconst MAX = \"max\";\nconst MIN = \"min\";\nconst NOTE_TEXT = \"noteText\";\nconst SUMMARY_FIELD = \"summary\";\nconst TO = \"to\";\n\nplotarea_factory.current.register(categorical_plotarea, [\n    BAR, COLUMN, LINE, VERTICAL_LINE, AREA, VERTICAL_AREA,\n    CANDLESTICK, OHLC, BULLET, VERTICAL_BULLET, BOX_PLOT, VERTICAL_BOX_PLOT,\n    RANGE_COLUMN, RANGE_BAR, WATERFALL, HORIZONTAL_WATERFALL, RANGE_AREA, VERTICAL_RANGE_AREA\n]);\n\nplotarea_factory.current.register(xy_plotarea, [\n    SCATTER, SCATTER_LINE, BUBBLE\n]);\n\nplotarea_factory.current.register(pie_plotarea, [ PIE ]);\nplotarea_factory.current.register(donut_plotarea, [ DONUT ]);\nplotarea_factory.current.register(funnel_plotarea, [ FUNNEL ]);\n\nplotarea_factory.current.register(polar_plotarea, [ POLAR_AREA, POLAR_LINE, POLAR_SCATTER ]);\nplotarea_factory.current.register(radar_plotarea, [ RADAR_AREA, RADAR_COLUMN, RADAR_LINE ]);\n\nseries_binder.current.register(\n    [ BAR, COLUMN, LINE, VERTICAL_LINE, AREA, VERTICAL_AREA ],\n    [ VALUE ], [ CATEGORY, COLOR, NOTE_TEXT, ERROR_LOW_FIELD, ERROR_HIGH_FIELD ]\n);\n\nseries_binder.current.register(\n    [ RANGE_COLUMN, RANGE_BAR, RANGE_AREA, VERTICAL_RANGE_AREA ],\n    [ FROM, TO ], [ CATEGORY, COLOR, NOTE_TEXT ]\n);\n\nseries_binder.current.register(\n    [ WATERFALL, HORIZONTAL_WATERFALL ],\n    [ VALUE ], [ CATEGORY, COLOR, NOTE_TEXT, SUMMARY_FIELD ]\n);\n\nseries_binder.current.register([ POLAR_AREA, POLAR_LINE, POLAR_SCATTER ], [ X, Y ], [ COLOR ]);\nseries_binder.current.register([ RADAR_AREA, RADAR_COLUMN, RADAR_LINE ], [ VALUE ], [ COLOR ]);\n\nseries_binder.current.register(\n    [ FUNNEL ],\n    [ VALUE ], [ CATEGORY, COLOR, \"visibleInLegend\", \"visible\" ]\n);\n\ndefault_aggregates.current.register(\n    [ BAR, COLUMN, LINE, VERTICAL_LINE, AREA, VERTICAL_AREA, WATERFALL, HORIZONTAL_WATERFALL ],\n    { value: MAX, color: FIRST, noteText: FIRST, errorLow: MIN, errorHigh: MAX }\n);\n\ndefault_aggregates.current.register(\n    [ RANGE_COLUMN, RANGE_BAR, RANGE_AREA, VERTICAL_RANGE_AREA ],\n    { from: MIN, to: MAX, color: FIRST, noteText: FIRST }\n);\n\ndefault_aggregates.current.register(\n    [ RADAR_AREA, RADAR_COLUMN, RADAR_LINE ],\n    { value: MAX, color: FIRST }\n);\n\nseries_binder.current.register(\n    [ SCATTER, SCATTER_LINE, BUBBLE ],\n    [ X, Y ], [ COLOR, NOTE_TEXT, X_ERROR_LOW_FIELD, X_ERROR_HIGH_FIELD, Y_ERROR_LOW_FIELD, Y_ERROR_HIGH_FIELD ]\n);\n\nseries_binder.current.register(\n    [ BUBBLE ], [ X, Y, \"size\" ], [ COLOR, CATEGORY, NOTE_TEXT ]\n);\n\nseries_binder.current.register(\n    [ CANDLESTICK, OHLC ],\n    [ \"open\", \"high\", \"low\", \"close\" ], [ CATEGORY, COLOR, \"downColor\", NOTE_TEXT ]\n);\n\ndefault_aggregates.current.register(\n    [ CANDLESTICK, OHLC ],\n    { open: MAX, high: MAX, low: MIN, close: MAX,\n      color: FIRST, downColor: FIRST, noteText: FIRST }\n);\n\nseries_binder.current.register(\n    [ BOX_PLOT, VERTICAL_BOX_PLOT ],\n    [ \"lower\", \"q1\", \"median\", \"q3\", \"upper\", \"mean\", \"outliers\" ], [ CATEGORY, COLOR, NOTE_TEXT ]\n);\n\ndefault_aggregates.current.register(\n    [ BOX_PLOT, VERTICAL_BOX_PLOT ],\n    { lower: MAX, q1: MAX, median: MAX, q3: MAX, upper: MAX, mean: MAX, outliers: FIRST,\n      color: FIRST, noteText: FIRST }\n);\n\nseries_binder.current.register(\n    [ BULLET, VERTICAL_BULLET ],\n    [ \"current\", \"target\" ], [ CATEGORY, COLOR, \"visibleInLegend\", NOTE_TEXT ]\n);\n\ndefault_aggregates.current.register(\n    [ BULLET, VERTICAL_BULLET ],\n    { current: MAX, target: MAX, color: FIRST, noteText: FIRST }\n);\n\nseries_binder.current.register(\n    [ PIE, DONUT ],\n    [ VALUE ], [ CATEGORY, COLOR, \"explode\", \"visibleInLegend\", \"visible\" ]\n);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/chart.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst AXIS_NAMES = [ CATEGORY, VALUE, X, Y ];\n\nconst MOUSEMOVE = \"mousemove\";\nconst CONTEXTMENU = \"contextmenu\";\nconst MOUSELEAVE = \"mouseleave\";\nconst MOUSEMOVE_DELAY = 20;\n\nclass chart_Chart extends common_class[\"a\" /* default */] {\n    constructor(element, userOptions, themeOptions, context = {}) {\n        super();\n\n        this.observers = [];\n        this.addObserver(context.observer);\n        this.chartService = new chart_service(this, context);\n        this.chartService.theme = themeOptions;\n\n        this._initElement(element);\n\n        const options = deepExtend({}, this.options, userOptions);\n        this._originalOptions = deepExtend({}, options);\n        this._theme = themeOptions;\n        this._initTheme(options, themeOptions);\n\n        this._initHandlers();\n        this._initSurface();\n\n        this.bindCategories();\n        font_loader.preloadFonts(userOptions, () => {\n            this.fontLoaded = true;\n            if (!this._destroyed) {\n                this.trigger('init');\n                this._redraw();\n                this._attachEvents();\n            }\n        });\n    }\n\n    _initElement(element) {\n        this._setElementClass(element);\n        element.style.position = \"relative\";\n        while (element.firstChild) {\n            element.removeChild(element.firstChild);\n        }\n        this.element = element;\n    }\n\n    _setElementClass(element) {\n        addClass(element, \"k-chart\");\n    }\n\n    _initTheme(options, themeOptions) {\n        const seriesCopies = [];\n        const series = options.series || [];\n\n        for (let i = 0; i < series.length; i++) {\n            seriesCopies.push(Object.assign({}, series[i]));\n        }\n        options.series = seriesCopies;\n\n        resolveAxisAliases(options);\n        this.applyDefaults(options, themeOptions);\n\n        // Clean up default if not overriden by data attributes\n        if (options.seriesColors === null) {\n            delete options.seriesColors;\n        }\n\n        this.options = deepExtend({}, themeOptions, options);\n        this.applySeriesColors();\n    }\n\n    getSize() {\n        const chartArea = this.options.chartArea || {};\n        const width = chartArea.width ? parseInt(chartArea.width, 10) : Math.floor(this.element.offsetWidth);\n        const height = chartArea.height ? parseInt(chartArea.height, 10) : Math.floor(this.element.offsetHeight);\n\n        return {\n            width: width,\n            height: height\n        };\n    }\n\n    resize(force) {\n        const size = this.getSize();\n        const currentSize = this._size;\n        const hasSize = size.width > 0 || size.height > 0;\n\n        if (force || hasSize && (!currentSize || size.width !== currentSize.width || size.height !== currentSize.height)) {\n            this._size = size;\n            this._resize(size, force);\n            this.trigger(\"resize\", size);\n        } else if (hasSize && this._selections && find(this._selections, s => !s.visible)) {\n            this._destroySelections();\n            this._setupSelection();\n        }\n    }\n\n    _resize() {\n        this._noTransitionsRedraw();\n    }\n\n    redraw(paneName) {\n        this.applyDefaults(this.options);\n        this.applySeriesColors();\n\n        if (paneName) {\n            const plotArea = this._model._plotArea;\n            const pane = plotArea.findPane(paneName);\n            plotArea.redraw(pane);\n        } else {\n            this._redraw();\n        }\n    }\n\n    getAxis(name) {\n        return findAxisByName(name, this._plotArea.axes);\n    }\n\n    findAxisByName(name) {\n        return this.getAxis(name);\n    }\n\n    findPaneByName(name) {\n        const panes = this._plotArea.panes;\n\n        for (let idx = 0; idx < panes.length; idx++) {\n            if (panes[idx].options.name === name) {\n                return new chart_pane(panes[idx]);\n            }\n        }\n    }\n\n    findPaneByIndex(idx) {\n        const panes = this._plotArea.panes;\n        if (panes[idx]) {\n            return new chart_pane(panes[idx]);\n        }\n    }\n\n    plotArea() {\n        return new chart_plotarea(this._plotArea);\n    }\n\n    toggleHighlight(show, filter) {\n        const plotArea = this._plotArea;\n        const firstSeries = (plotArea.srcSeries || plotArea.series || [])[0];\n        let points;\n\n        if (isFunction(filter)) {\n            points = plotArea.filterPoints(filter);\n        } else {\n            let seriesName, categoryName;\n            if (isObject(filter)) {\n                seriesName = filter.series;\n                categoryName = filter.category;\n            } else {\n                seriesName = categoryName = filter;\n            }\n\n            if (firstSeries.type === DONUT) {\n                points = pointByCategoryName(plotArea.pointsBySeriesName(seriesName), categoryName);\n            } else if (firstSeries.type === PIE || firstSeries.type === FUNNEL) {\n                points = pointByCategoryName((plotArea.charts[0] || {}).points, categoryName);\n            } else {\n                points = plotArea.pointsBySeriesName(seriesName);\n            }\n        }\n\n        if (points) {\n            this.togglePointsHighlight(show, points);\n        }\n    }\n\n    togglePointsHighlight(show, points) {\n        const highlight = this._highlight;\n        for (let idx = 0; idx < points.length; idx++) {\n            highlight.togglePointHighlight(points[idx], show);\n        }\n    }\n\n    showTooltip(filter) {\n        const shared = this._sharedTooltip();\n        const { _tooltip: tooltip, _plotArea: plotArea } = this;\n        let point, categoryIndex;\n\n        if (isFunction(filter)) {\n            point = plotArea.findPoint(filter);\n            if (point && shared) {\n                categoryIndex = point.categoryIx;\n            }\n        } else if (shared && defined(filter)) {\n            categoryIndex = plotArea.categoryAxis.categoryIndex(filter);\n        }\n\n        if (shared) {\n            if (categoryIndex >= 0) {\n                const points = this._plotArea.pointsByCategoryIndex(categoryIndex);\n                tooltip.showAt(points);\n            }\n        } else if (point) {\n            tooltip.show(point);\n        }\n    }\n\n    hideTooltip() {\n        this._tooltip.hide();\n    }\n\n    _initSurface() {\n        const surface = this.surface;\n        const wrap = this._surfaceWrap();\n\n        const chartArea = this.options.chartArea || {};\n        if (chartArea.width) {\n            drawing_utils_elementSize(wrap, { width: chartArea.width });\n        }\n        if (chartArea.height) {\n            drawing_utils_elementSize(wrap, { height: chartArea.height });\n        }\n\n        if (!surface || surface.options.type !== this.options.renderAs) {\n            this._destroySurface();\n\n            this.surface = main[\"a\" /* drawing */].Surface.create(wrap, {\n                type: this.options.renderAs\n            });\n\n            this.surface.bind(\"mouseenter\", this._surfaceMouseenterHandler);\n            this.surface.bind(\"mouseleave\", this._surfaceMouseleaveHandler);\n\n        } else {\n            this.surface.clear();\n            this.surface.resize();\n        }\n    }\n\n    _surfaceWrap() {\n        return this.element;\n    }\n\n    _redraw() {\n        const model = this._getModel();\n        this._size = {\n            width: model.options.width,\n            height: model.options.height\n        };\n\n        this._destroyView();\n\n        this._model = model;\n        this._plotArea = model._plotArea;\n\n        model.renderVisual();\n\n        if (this.options.transitions !== false) {\n            model.traverse(function(element) {\n                if (element.animation) {\n                    element.animation.setup();\n                }\n            });\n        }\n\n        this._initSurface();\n        this.surface.draw(model.visual);\n\n        if (this.options.transitions !== false) {\n            model.traverse(function(element) {\n                if (element.animation) {\n                    element.animation.play();\n                }\n            });\n        }\n\n        this._tooltip = this._createTooltip();\n        this._highlight = new chart_highlight();\n        this._setupSelection();\n        this._createPannable();\n        this._createZoomSelection();\n        this._createMousewheelZoom();\n\n        this.trigger(RENDER);\n        triggerPaneRender(this._plotArea.panes);\n\n        if (!this._navState) {\n            this._cancelDomEvents();\n        }\n    }\n\n    exportVisual(exportOptions) {\n        let visual;\n        if (exportOptions && (exportOptions.width || exportOptions.height || exportOptions.options)) {\n            const currentOptions = this.options;\n            const options = deepExtend({}, exportOptions.options, {\n                chartArea: {\n                    width: exportOptions.width,\n                    height: exportOptions.height\n                }\n            });\n\n            clearMissingValues(this._originalOptions, options);\n            this.options = deepExtend({}, this._originalOptions, options);\n            this._initTheme(this.options, this._theme);\n            this.bindCategories();\n\n            const model = this._getModel();\n\n            model.renderVisual();\n            triggerPaneRender(model._plotArea.panes);\n\n            visual = model.visual;\n\n            this.options = currentOptions;\n        } else {\n            visual = this.surface.exportVisual();\n        }\n\n        return visual;\n    }\n\n    _sharedTooltip() {\n        return this._plotArea instanceof categorical_plotarea && this.options.tooltip && this.options.tooltip.shared;\n    }\n\n    _createPannable() {\n        const options = this.options;\n        if (options.pannable !== false) {\n            this._pannable = new pan_and_zoom_pannable(this._plotArea, options.pannable);\n        }\n    }\n\n    _createZoomSelection() {\n        const zoomable = this.options.zoomable;\n        const selection = (zoomable || {}).selection;\n        if (zoomable !== false && selection !== false) {\n            this._zoomSelection = new zoom_selection(this, selection);\n        }\n    }\n\n    _createMousewheelZoom() {\n        const zoomable = this.options.zoomable;\n        const mousewheel = (zoomable || {}).mousewheel;\n        if (zoomable !== false && mousewheel !== false) {\n            this._mousewheelZoom = new mousewheel_zoom(this, mousewheel);\n        }\n    }\n\n    _toggleDragZoomEvents() {\n        const pannable = this.options.pannable;\n        const zoomable = this.options.zoomable;\n        const selection = (zoomable || {}).selection;\n        const mousewheel = (zoomable || {}).mousewheel;\n        const allowDrag = !pannable && (zoomable === false || selection === false) && !this.requiresHandlers([ DRAG_START, DRAG, DRAG_END ]);\n        const allowZoom = (zoomable === false || mousewheel === false) && !this.requiresHandlers([ ZOOM_START, ZOOM, ZOOM_END ]);\n        const element = this.element;\n\n        if (this._dragZoomEnabled && allowDrag && allowZoom) {\n            element.style.touchAction = this._touchAction || '';\n            this._dragZoomEnabled = false;\n        } else if (!this._dragZoomEnabled && !(allowDrag && allowZoom)) {\n            element.style.touchAction = \"none\";\n\n            this._dragZoomEnabled = true;\n        }\n\n        this._toggleDomEvents(!allowDrag, !allowZoom);\n    }\n\n    _toggleDomEvents(drag, zoom) {\n        const domEvents = this.domEvents;\n        if (!domEvents) {\n            return;\n        }\n\n        if (domEvents.toggleDrag) {\n            domEvents.toggleDrag(drag);\n        }\n\n        if (domEvents.toggleZoom) {\n            domEvents.toggleZoom(zoom);\n        }\n    }\n\n    _createTooltip() {\n        const { options: { tooltip: tooltipOptions } } = this;\n        let tooltip;\n\n        if (this._sharedTooltip()) {\n            tooltip = this._createSharedTooltip(tooltipOptions);\n        } else {\n            tooltip = new tooltip_tooltip(this.chartService, tooltipOptions);\n        }\n\n        return tooltip;\n    }\n\n    _createSharedTooltip(options) {\n        return new shared_tooltip(this._plotArea, options);\n    }\n\n    applyDefaults(options, themeOptions) {\n        applyAxisDefaults(options, themeOptions);\n        applySeriesDefaults(options, themeOptions);\n    }\n\n    applySeriesColors() {\n        const options = this.options;\n        const series = options.series;\n        const colors = options.seriesColors || [];\n\n        for (let i = 0; i < series.length; i++) {\n            const currentSeries = series[i];\n            const seriesColor = colors[i % colors.length];\n            const defaults = currentSeries._defaults;\n\n            currentSeries.color = currentSeries.color || seriesColor;\n            if (defaults) {\n                defaults.color = defaults.color || seriesColor;\n            }\n        }\n    }\n\n    _getModel() {\n        const options = this.options;\n        const plotArea = this._createPlotArea();\n        const model = new root_element(this._modelOptions());\n        model.chart = this;\n        model._plotArea = plotArea;\n\n        core_title.buildTitle(options.title, model);\n\n        if (options.legend && options.legend.visible) {\n            model.append(new legend_legend(plotArea.options.legend, this.chartService));\n        }\n        model.append(plotArea);\n        model.reflow();\n\n        return model;\n    }\n\n    _modelOptions() {\n        const options = this.options;\n        const size = this.getSize();\n\n        return deepExtend({\n            transitions: options.transitions,\n            width: size.width || DEFAULT_WIDTH,\n            height: size.height || DEFAULT_HEIGHT\n        }, options.chartArea);\n    }\n\n    _createPlotArea(skipSeries) {\n        const options = this.options;\n\n        const plotArea = plotarea_factory.current.create(skipSeries ? [] : options.series, options, this.chartService);\n\n        return plotArea;\n    }\n\n    _setupSelection() {\n        const { _plotArea: { axes } } = this;\n        const selections = this._selections = [];\n\n        for (let i = 0; i < axes.length; i++) {\n            const axis = axes[i];\n            const options = axis.options;\n            if (axis instanceof category_axis && options.select && !options.vertical) {\n                const range = axis.range();\n\n                const selection = new chart_selection(this, axis,\n                    deepExtend({ min: range.min, max: range.max }, options.select)\n                );\n\n                selections.push(selection);\n            }\n        }\n    }\n\n    _selectStart(e) {\n        return this.trigger(SELECT_START, e);\n    }\n\n    _select(e) {\n        return this.trigger(SELECT, e);\n    }\n\n    _selectEnd(e) {\n        return this.trigger(SELECT_END, e);\n    }\n\n    _initHandlers() {\n        this._clickHandler = this._click.bind(this);\n        this._mousewheelHandler = this._mousewheel.bind(this);\n        this._mouseleaveHandler = this._mouseleave.bind(this);\n        this._surfaceMouseenterHandler = this._mouseover.bind(this);\n        this._surfaceMouseleaveHandler = this._mouseout.bind(this);\n\n        this._mousemove = Object(throttle[\"a\" /* default */])(\n            this._mousemove.bind(this),\n            MOUSEMOVE_DELAY\n        );\n    }\n\n    addObserver(observer) {\n        if (observer) {\n            this.observers.push(observer);\n        }\n    }\n\n    removeObserver(observer) {\n        const index = this.observers.indexOf(observer);\n        if (index >= 0) {\n            this.observers.splice(index, 1);\n        }\n    }\n\n    requiresHandlers(eventNames) {\n        const observers = this.observers;\n        for (let idx = 0; idx < observers.length; idx++) {\n            if (observers[idx].requiresHandlers(eventNames)) {\n                return true;\n            }\n        }\n    }\n\n    trigger(name, args = {}) {\n        if (name === SHOW_TOOLTIP) {\n            args.anchor.point = this._toDocumentCoordinates(args.anchor.point);\n        }\n        args.sender = this;\n\n        const observers = this.observers;\n        let isDefaultPrevented = false;\n        for (let idx = 0; idx < observers.length; idx++) {\n            if (observers[idx].trigger(name, args)) {\n                isDefaultPrevented = true;\n            }\n        }\n\n        return isDefaultPrevented;\n    }\n\n    _attachEvents() {\n        const element = this.element;\n\n        this._touchAction = element.style.touchAction;\n\n        bindEvents(element, {\n            [ CONTEXTMENU ]: this._clickHandler,\n            [ MOUSEWHEEL ]: this._mousewheelHandler,\n            [ MOUSELEAVE ]: this._mouseleaveHandler\n        });\n\n        if (this._shouldAttachMouseMove()) {\n            bindEvents(element, { [ MOUSEMOVE ]: this._mousemove });\n        }\n\n        this.domEvents = dom_events_builder.create(this.element, {\n            start: this._start.bind(this),\n            move: this._move.bind(this),\n            end: this._end.bind(this),\n            tap: this._tap.bind(this),\n            gesturestart: this._gesturestart.bind(this),\n            gesturechange: this._gesturechange.bind(this),\n            gestureend: this._gestureend.bind(this)\n        });\n\n        this._toggleDragZoomEvents();\n    }\n\n    _mouseleave(e) {\n        if (this._hoveredPoint) {\n            this._hoveredPoint.out(this, e);\n            this._hoveredPoint = null;\n        }\n\n        if (this._plotArea.hovered) {\n            this.trigger(PLOT_AREA_LEAVE);\n            this._plotArea.hovered = false;\n        }\n    }\n\n    _cancelDomEvents() {\n        if (this.domEvents && this.domEvents.cancel) {\n            this.domEvents.cancel();\n        }\n    }\n\n    _gesturestart(e) {\n        if (this._mousewheelZoom && !this._stopChartHandlers(e)) {\n            this._gestureDistance = e.distance;\n            this._unsetActivePoint();\n            this.surface.suspendTracking();\n        }\n    }\n\n    _gestureend(e) {\n        if (this._zooming && !this._stopChartHandlers(e)) {\n            if (this.surface) {\n                this.surface.resumeTracking();\n            }\n            this._zooming = false;\n            this.trigger(ZOOM_END, {});\n        }\n    }\n\n    _gesturechange(e) {\n        const mousewheelZoom = this._mousewheelZoom;\n\n        if (mousewheelZoom && !this._stopChartHandlers(e)) {\n            e.preventDefault();\n            const previousGestureDistance = this._gestureDistance;\n            let scaleDelta = -e.distance / previousGestureDistance + 1;\n\n            if (Math.abs(scaleDelta) >= 0.1) {\n                scaleDelta = Math.round(scaleDelta * 10);\n\n                this._gestureDistance = e.distance;\n                const args = { delta: scaleDelta, axisRanges: chart_axisRanges(this._plotArea.axes), originalEvent: e };\n                if (this._zooming || !this.trigger(ZOOM_START, args)) {\n\n                    if (!this._zooming) {\n                        this._zooming = true;\n                    }\n\n                    const ranges = args.axisRanges = mousewheelZoom.updateRanges(scaleDelta);\n                    if (ranges && !this.trigger(ZOOM, args)) {\n                        mousewheelZoom.zoom();\n                    }\n                }\n            }\n        }\n    }\n\n    _mouseout(e) {\n        if (e.element) {\n            const element = this._drawingChartElement(e.element, e);\n\n            if (element && element.leave) {\n                element.leave(this, e.originalEvent);\n            }\n        }\n    }\n\n    _start(e) {\n        const coords = this._eventCoordinates(e);\n\n        if (this._stopChartHandlers(e) || !this._plotArea.backgroundContainsPoint(coords)) {\n            return;\n        }\n\n\n        if (this.requiresHandlers([ DRAG_START, DRAG, DRAG_END ])) {\n            this._startNavigation(e, coords, DRAG_START);\n        }\n\n        if (this._pannable && this._pannable.start(e)) {\n            this.surface.suspendTracking();\n            this._unsetActivePoint();\n            this._suppressHover = true;\n            this.chartService.panning = true;\n        }\n\n        if (this._zoomSelection) {\n            if (this._zoomSelection.start(e)) {\n                this.trigger(ZOOM_START, { axisRanges: chart_axisRanges(this._plotArea.axes), originalEvent: e });\n            }\n        }\n    }\n\n    _move(e) {\n        let { _navState: state, _pannable: pannable } = this;\n\n        if (this._stopChartHandlers(e)) {\n            return;\n        }\n\n        if (pannable) {\n            const ranges = pannable.move(e);\n\n            if (ranges && !this.trigger(DRAG, { axisRanges: ranges, originalEvent: e })) {\n                pannable.pan();\n            }\n        } else if (state) {\n            const ranges = {};\n            const axes = state.axes;\n\n            for (let i = 0; i < axes.length; i++) {\n                const currentAxis = axes[i];\n                const axisName = currentAxis.options.name;\n                if (axisName) {\n                    const axis = currentAxis.options.vertical ? e.y : e.x;\n                    const delta = axis.startLocation - axis.location;\n\n                    if (delta !== 0) {\n                        ranges[currentAxis.options.name] = currentAxis.translateRange(delta);\n                    }\n                }\n            }\n\n            state.axisRanges = ranges;\n            this.trigger(DRAG, {\n                axisRanges: ranges,\n                originalEvent: e\n            });\n        }\n\n        if (this._zoomSelection) {\n            this._zoomSelection.move(e);\n        }\n    }\n\n    _end(e) {\n        if (this._stopChartHandlers(e)) {\n            return;\n        }\n\n        const pannable = this._pannable;\n        if (pannable && pannable.end(e)) {\n            this.surface.resumeTracking();\n            this.trigger(DRAG_END, {\n                axisRanges: chart_axisRanges(this._plotArea.axes),\n                originalEvent: e\n            });\n            this._suppressHover = false;\n            this.chartService.panning = false;\n        } else {\n            this._endNavigation(e, DRAG_END);\n        }\n\n        if (this._zoomSelection) {\n            const ranges = this._zoomSelection.end(e);\n            if (ranges && !this.trigger(ZOOM, { axisRanges: ranges, originalEvent: e })) {\n                this._zoomSelection.zoom();\n                this.trigger(ZOOM_END, { axisRanges: ranges, originalEvent: e });\n            }\n        }\n    }\n\n    _stopChartHandlers(e) {\n        const selections = this._selections || [];\n        if (!selections.length) {\n            return false;\n        }\n\n        const coords = this._eventCoordinates(e);\n        const pane = this._plotArea.paneByPoint(coords);\n        if (pane) {\n            for (let idx = 0; idx < selections.length; idx++) {\n                if (selections[idx].onPane(pane)) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    _mousewheel(e) {\n        const delta = mousewheelDelta(e);\n        const mousewheelZoom = this._mousewheelZoom;\n        const coords = this._eventCoordinates(e);\n\n        if (this._stopChartHandlers(e) || !this._plotArea.backgroundContainsPoint(coords)) {\n            return;\n        }\n\n        if (mousewheelZoom) {\n            const args = { delta: delta, axisRanges: chart_axisRanges(this._plotArea.axes), originalEvent: e };\n            if (this._zooming || !this.trigger(ZOOM_START, args)) {\n                e.preventDefault();\n\n                if (!this._zooming) {\n                    this._unsetActivePoint();\n                    this.surface.suspendTracking();\n                    this._zooming = true;\n                }\n\n                if (this._mwTimeout) {\n                    clearTimeout(this._mwTimeout);\n                }\n\n                args.axisRanges = mousewheelZoom.updateRanges(delta);\n                if (args.axisRanges && !this.trigger(ZOOM, args)) {\n                    mousewheelZoom.zoom();\n                }\n\n                this._mwTimeout = setTimeout(() => {\n                    this.trigger(ZOOM_END, args);\n                    this._zooming = false;\n                    if (this.surface) {\n                        this.surface.resumeTracking();\n                    }\n                }, MOUSEWHEEL_DELAY);\n            }\n        } else {\n            let state = this._navState;\n            if (!state) {\n                const prevented = this._startNavigation(e, coords, ZOOM_START);\n                if (!prevented) {\n                    state = this._navState;\n                }\n            }\n\n            if (state) {\n                const totalDelta = state.totalDelta || delta;\n                state.totalDelta = totalDelta + delta;\n\n                const axes = this._navState.axes;\n                const ranges = {};\n\n                for (let i = 0; i < axes.length; i++) {\n                    const currentAxis = axes[i];\n                    const axisName = currentAxis.options.name;\n                    if (axisName) {\n                        ranges[axisName] = currentAxis.scaleRange(-totalDelta);\n                    }\n                }\n\n                this.trigger(ZOOM, {\n                    delta: delta,\n                    axisRanges: ranges,\n                    originalEvent: e\n                });\n\n                if (this._mwTimeout) {\n                    clearTimeout(this._mwTimeout);\n                }\n\n                this._mwTimeout = setTimeout(() => {\n                    this._endNavigation(e, ZOOM_END);\n                }, MOUSEWHEEL_DELAY);\n            }\n        }\n    }\n\n    _startNavigation(e, coords, chartEvent) {\n        const plotArea = this._model._plotArea;\n        const pane = plotArea.findPointPane(coords);\n        const axes = plotArea.axes.slice(0);\n\n        if (!pane) {\n            return;\n        }\n\n        const ranges = chart_axisRanges(axes);\n\n        const prevented = this.trigger(chartEvent, {\n            axisRanges: ranges,\n            originalEvent: e\n        });\n\n        if (prevented) {\n            this._cancelDomEvents();\n        } else {\n            this._suppressHover = true;\n            this._unsetActivePoint();\n            this._navState = {\n                axisRanges: ranges,\n                pane: pane,\n                axes: axes\n            };\n        }\n    }\n\n    _endNavigation(e, chartEvent) {\n        if (this._navState) {\n            this.trigger(chartEvent, {\n                axisRanges: this._navState.axisRanges,\n                originalEvent: e\n            });\n            this._suppressHover = false;\n            this._navState = null;\n        }\n    }\n\n    _getChartElement(e, match) {\n        const element = this.surface.eventTarget(e);\n        if (element) {\n            return this._drawingChartElement(element, e, match);\n        }\n    }\n\n    _drawingChartElement(element, e, match) {\n        let current = element;\n        let chartElement;\n        while (current && !chartElement) {\n            chartElement = current.chartElement;\n            current = current.parent;\n        }\n\n        if (chartElement) {\n            if (chartElement.aliasFor) {\n                chartElement = chartElement.aliasFor(e, this._eventCoordinates(e));\n            }\n\n            if (match) {\n                chartElement = chartElement.closest(match);\n                if (chartElement && chartElement.aliasFor) {\n                    chartElement = chartElement.aliasFor();\n                }\n            }\n\n            return chartElement;\n        }\n    }\n\n    _eventCoordinates(e) {\n        const coordinates = eventCoordinates(e);\n        return this._toModelCoordinates(coordinates.x, coordinates.y);\n    }\n\n    _elementPadding() {\n        if (!this._padding) {\n            const { paddingLeft, paddingTop } = element_styles_elementStyles(this.element, [ \"paddingLeft\", \"paddingTop\" ]);\n            this._padding = {\n                top: paddingTop,\n                left: paddingLeft\n            };\n        }\n\n        return this._padding;\n    }\n\n    _toDocumentCoordinates(point) {\n        const padding = this._elementPadding();\n        const offset = drawing_utils_elementOffset(this.element);\n\n        return {\n            left: round(point.x + padding.left + offset.left),\n            top: round(point.y + padding.top + offset.top)\n        };\n    }\n\n    // TODO: Breaking change due to peer version change\n    // Reuse by exposing _surfacePoint on Surface\n    _toModelCoordinates(clientX, clientY) {\n        const element = this.element;\n        const offset = drawing_utils_elementOffset(element);\n        const padding = this._elementPadding();\n        const inverseTransform = elementScale(element).invert();\n        const point = new main[\"b\" /* geometry */].Point(\n            clientX - offset.left - padding.left,\n            clientY - offset.top - padding.top\n        ).transform(inverseTransform);\n\n        return new core_point(point.x, point.y);\n    }\n\n    _tap(e) {\n        const drawingElement = this.surface.eventTarget(e);\n        const element = this._drawingChartElement(drawingElement, e);\n        const sharedTooltip = this._sharedTooltip();\n\n        if (!this._startHover(drawingElement, e) && !sharedTooltip) {\n            this._unsetActivePoint();\n        }\n\n        if (sharedTooltip) {\n            this._trackSharedTooltip(this._eventCoordinates(e), e, true);\n        }\n\n        this._propagateClick(element, e);\n\n        //part of fix for hover issue on windows touch\n        this.handlingTap = true;\n        setTimeout(() => {\n            this.handlingTap = false;\n        }, 0);\n    }\n\n    _click(e) {\n        const element = this._getChartElement(e);\n        this._propagateClick(element, e);\n    }\n\n    _propagateClick(element, e) {\n        let current = element;\n        while (current) {\n            if (current.click) {\n                current.click(this, e);\n            }\n\n            current = current.parent;\n        }\n    }\n\n    _startHover(element, e) {\n        if (this._suppressHover) {\n            return false;\n        }\n\n        let point = this._drawingChartElement(element, e, function(element) {\n            return (element.hover || element.over) && !(element instanceof plotarea_base);\n        });\n\n        const activePoint = this._activePoint;\n        const multipleSeries = this._plotArea.series.length > 1;\n        const hasInactiveOpacity = this._hasInactiveOpacity();\n\n        this._updateHoveredPoint(point, e);\n\n        if (point && activePoint !== point && point.hover) {\n            this._activePoint = point;\n\n            if (!this._sharedTooltip() && !point.hover(this, e)) {\n                this._displayTooltip(point);\n\n                if (hasInactiveOpacity) {\n                    this._displayInactiveOpacity(point, multipleSeries);\n                } else {\n                    this._highlight.show(point);\n                }\n            }\n        } else if (!point && hasInactiveOpacity) {\n            if (multipleSeries && this._activeChartInstance) {\n                this._updateSeriesOpacity(point, true);\n                this._applySeriesOpacity(this._activeChartInstance.children, null, true);\n                this._activeChartInstance = null;\n            }\n            this._highlight && this._highlight.hide();\n            this._activePoint = null;\n        }\n\n        return point;\n    }\n\n    _displayTooltip(point) {\n        const tooltipOptions = deepExtend({}, this.options.tooltip, point.options.tooltip);\n        if (tooltipOptions.visible) {\n            this._tooltip.show(point);\n        }\n    }\n\n    _displayInactiveOpacity(activePoint, multipleSeries, highlightPoints) {\n        const chartInstance = this._activeChartInstance = this._chartInstanceFromPoint(activePoint);\n\n        if (multipleSeries) {\n            this._updateSeriesOpacity(activePoint);\n            this._applySeriesOpacity(chartInstance.children, null, true);\n            this._applySeriesOpacity(chartInstance.children, activePoint.series);\n            this._highlight.show(highlightPoints || activePoint);\n        } else {\n            let inactivePoints;\n\n            if (!chartInstance.supportsPointInactiveOpacity()) {\n                this._highlight.show(activePoint);\n                return;\n            }\n\n            inactivePoints = this._getInactivePoints(activePoint, chartInstance);\n\n            if (inactivePoints && inactivePoints.length) {\n                this._highlight.show(inactivePoints, 1 - this._getInactiveOpacityForSeries(activePoint.series));\n            }\n        }\n    }\n\n    _getInactivePoints(activePoint, chartInstance) {\n        let allPoints = this._getAllPointsOfType(chartInstance, activePoint.constructor);\n\n        return allPoints.filter(point => point !== activePoint);\n    }\n\n    _getAllPointsOfType(container, type) {\n        let points = [];\n\n        for (let i = 0; i < container.children.length; i++) {\n            const element = container.children[i];\n\n            if (element.constructor === type) {\n                points.push(element);\n            } else if (element.children && element.children.length) {\n                points = points.concat(this._getAllPointsOfType(element, type));\n            }\n        }\n\n        return points;\n    }\n\n    _updateHoveredPoint(point, e) {\n        const hoveredPoint = this._hoveredPoint;\n\n        if (hoveredPoint && hoveredPoint !== point) {\n            hoveredPoint.out(this, e);\n            this._hoveredPoint = null;\n        }\n\n        if (point && hoveredPoint !== point && point.over) {\n            this._hoveredPoint = point;\n            point.over(this, e);\n        }\n    }\n\n    _updateSeriesOpacity(point, resetOpacity) {\n        const plotArea = this._plotArea;\n        const length = plotArea.series.length;\n\n        for (let i = 0; i < length; i++) {\n            const currSeries = plotArea.series[i];\n            const defaultOpacity = this._getDefaultOpacityForSeries(currSeries);\n            const inactiveOpacity = this._getInactiveOpacityForSeries(currSeries);\n\n            if (!resetOpacity && currSeries !== point.series) {\n                currSeries.defaultOpacity = defaultOpacity;\n                currSeries.opacity = inactiveOpacity;\n\n                if (currSeries.line) {\n                    currSeries.line.opacity = inactiveOpacity;\n                }\n            } else {\n                currSeries.opacity = defaultOpacity;\n\n                if (currSeries.line) {\n                    currSeries.line.opacity = defaultOpacity;\n                }\n            }\n        }\n    }\n\n    _applySeriesOpacity(elements, activeSeries, reset, series) {\n        for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            const currSeries = element.series || series;\n\n            if (currSeries && element.visual) {\n                const opacity = series ? series.opacity : element.series.opacity;\n                if (currSeries !== activeSeries || reset) {\n                    element.visual.opacity(reset ? 1 : opacity);\n                }\n            }\n\n            if (element.children && element.children.length) {\n                this._applySeriesOpacity(element.children, activeSeries, reset, element.series);\n            }\n        }\n    }\n\n    _chartInstanceFromPoint(point) {\n        let chartInstance = point.parent;\n\n        while (chartInstance && !chartInstance.plotArea) {\n            chartInstance = chartInstance.parent;\n        }\n\n        return chartInstance;\n    }\n\n    _hasInactiveOpacity() {\n        let hasDefaultInactiveOpacity = this.options.seriesDefaults.highlight.inactiveOpacity !== undefined;\n        let hasInactiveOpacity = this.options.series.filter(s => s.highlight.inactiveOpacity !== undefined ).length > 0;\n        return hasDefaultInactiveOpacity || hasInactiveOpacity;\n    }\n\n    _getInactiveOpacityForSeries(series) {\n        let defaultInactiveOpacity = this.options.seriesDefaults.highlight.inactiveOpacity;\n        let seriesInactiveOpacity = series.highlight.inactiveOpacity;\n        return seriesInactiveOpacity || defaultInactiveOpacity || series.opacity || DEFAULT_SERIES_OPACITY;\n    }\n\n    _getDefaultOpacityForSeries(series) {\n        return series.defaultOpacity || series.opacity || DEFAULT_SERIES_OPACITY;\n    }\n\n    _mouseover(e) {\n        const point = this._startHover(e.element, e.originalEvent);\n\n        if (point && point.tooltipTracking && !this._mouseMoveTrackHandler && !this._sharedTooltip()) {\n            this._mouseMoveTrackHandler = this._mouseMoveTracking.bind(this);\n            bindEvents(document, {\n                [ MOUSEMOVE ]: this._mouseMoveTrackHandler\n            });\n        }\n    }\n\n    _mouseMoveTracking(e) {\n        const { options, _tooltip: tooltip, _highlight: highlight, _activePoint: point } = this;\n        const coords = this._eventCoordinates(e);\n\n        if (this._plotArea.box.containsPoint(coords)) {\n            if (point && point.tooltipTracking && point.series && point.parent.getNearestPoint) {\n                const seriesPoint = point.parent.getNearestPoint(coords.x, coords.y, point.seriesIx);\n                if (seriesPoint && seriesPoint !== point) {\n                    this._activePoint = seriesPoint;\n\n                    if (!seriesPoint.hover(this, e)) {\n                        const tooltipOptions = deepExtend({}, options.tooltip, seriesPoint.options.tooltip);\n                        if (tooltipOptions.visible) {\n                            tooltip.show(seriesPoint);\n                        }\n\n                        highlight.show(seriesPoint);\n                    }\n                }\n            }\n        } else {\n            unbindEvents(document, {\n                [ MOUSEMOVE ]: this._mouseMoveTrackHandler\n            });\n            this._unsetActivePoint();\n            this._mouseMoveTrackHandler = null;\n        }\n    }\n\n    _mousemove(e) {\n        const coords = this._eventCoordinates(e);\n        const plotArea = this._plotArea;\n\n        this._trackCrosshairs(coords);\n\n        if (plotArea.hover) {\n            const overPlotArea = plotArea.backgroundContainsPoint(coords);\n            if (overPlotArea) {\n                plotArea.hovered = true;\n                this._plotArea.hover(this, e);\n            } else if (plotArea.hovered && !overPlotArea) {\n                this.trigger(PLOT_AREA_LEAVE);\n                plotArea.hovered = false;\n            }\n        }\n\n        if (this._sharedTooltip()) {\n            this._trackSharedTooltip(coords, e);\n        }\n    }\n\n    _trackCrosshairs(coords) {\n        const crosshairs = this._plotArea.crosshairs;\n\n        for (let i = 0; i < crosshairs.length; i++) {\n            const current = crosshairs[i];\n\n            if (current.box.containsPoint(coords)) {\n                current.showAt(coords);\n            } else {\n                current.hide();\n            }\n        }\n    }\n\n    _trackSharedTooltip(coords, e, toggle) {\n        if (this._suppressHover) {\n            return;\n        }\n\n        const { options: { tooltip: tooltipOptions }, _plotArea: plotArea, _plotArea: { categoryAxis }, _tooltip: tooltip, _highlight: highlight } = this;\n\n        if (plotArea.backgroundContainsPoint(coords)) {\n            const index = categoryAxis.pointCategoryIndex(coords);\n            if (index !== this._tooltipCategoryIx || (!this._sharedHighlight && toggle)) {\n                const points = plotArea.pointsByCategoryIndex(index);\n                const pointArgs = points.map(function(point) {\n                    return point.eventArgs(e);\n                });\n                const hoverArgs = pointArgs[0] || {};\n                hoverArgs.categoryPoints = pointArgs;\n\n                if (points.length > 0 && !this.trigger(SERIES_HOVER, hoverArgs)) {\n                    if (tooltipOptions.visible) {\n                        tooltip.showAt(points, coords);\n                    }\n\n                    highlight.show(points);\n\n                    this._sharedHighlight = true;\n                } else {\n                    tooltip.hide();\n                }\n\n                this._tooltipCategoryIx = index;\n            } else if (toggle && this._sharedHighlight) {\n                highlight.hide();\n                tooltip.hide();\n                this._sharedHighlight = false;\n            }\n        } else if (this._sharedHighlight) {\n            highlight.hide();\n            tooltip.hide();\n            this._tooltipCategoryIx = null;\n            this._sharedHighlight = false;\n        }\n    }\n\n    hideElements(options) {\n        const plotArea = this._plotArea;\n        this._mousemove.cancel();\n\n        plotArea.hideCrosshairs();\n\n        this._unsetActivePoint(options);\n    }\n\n    _unsetActivePoint(options) {\n        const { _tooltip: tooltip, _highlight: highlight } = this;\n\n        this._activePoint = null;\n        this._hoveredPoint = null;\n\n        if (tooltip && !(options && options.keepTooltipOpen)) {\n            tooltip.hide();\n        }\n\n        this._tooltipCategoryIx = null;\n        this._sharedHighlight = false;\n\n        if (highlight) {\n            highlight.hide();\n        }\n    }\n\n    _deferRedraw() {\n        this._redraw();\n    }\n\n    _clearRedrawTimeout() {\n        if (this._redrawTimeout) {\n            clearInterval(this._redrawTimeout);\n            this._redrawTimeout = null;\n        }\n    }\n\n    bindCategories() {\n        const options = this.options;\n        const definitions = [].concat(options.categoryAxis);\n\n        for (let axisIx = 0; axisIx < definitions.length; axisIx++) {\n            const axis = definitions[axisIx];\n            if (axis.autoBind !== false) {\n                this.bindCategoryAxisFromSeries(axis, axisIx);\n            }\n        }\n    }\n\n    bindCategoryAxisFromSeries(axis, axisIx) {\n        const series = this.options.series;\n        const seriesLength = series.length;\n        const uniqueCategories = new HashMap();//perf improvement in case type category with dates\n        let items = [];\n        let bindable = false;\n        let dateAxis;\n\n        for (let seriesIx = 0; seriesIx < seriesLength; seriesIx++) {\n            const s = series[seriesIx];\n            const onAxis = s.categoryAxis === axis.name || (!s.categoryAxis && axisIx === 0);\n            const data = s.data;\n            const dataLength = data.length;\n            const bind = s.categoryField && onAxis;\n            bindable = bind || bindable;\n\n            if (bind && dataLength > 0) {\n                dateAxis = isDateAxis(axis, getField(s.categoryField, data[0]));\n\n                const getFn = dateAxis ? getDateField : getField;\n\n                for (let dataIx = 0; dataIx < dataLength; dataIx++) {\n                    const dataRow = data[dataIx];\n                    const category = getFn(s.categoryField, dataRow, this.chartService.intl);\n\n                    if (dateAxis || !uniqueCategories.get(category)) {\n                        items.push([ category, dataRow ]);\n\n                        if (!dateAxis) {\n                            uniqueCategories.set(category, true);\n                        }\n                    }\n                }\n            }\n        }\n\n        if (items.length > 0) {\n            if (dateAxis) {\n                items = uniqueDates(items, function(a, b) {\n                    return dateComparer(a[0], b[0]);\n                });\n            }\n\n            const result = transpose(items);\n            axis.categories = result[0];\n        } else if (bindable) {\n            axis.categories = [];\n        }\n    }\n\n    _isBindable(series) {\n        const valueFields = series_binder.current.valueFields(series);\n        let result = true;\n\n        for (let i = 0; i < valueFields.length; i++) {\n            let field = valueFields[i];\n            if (field === VALUE) {\n                field = \"field\";\n            } else {\n                field = field + \"Field\";\n            }\n\n            if (!defined(series[field])) {\n                result = false;\n                break;\n            }\n        }\n\n        return result;\n    }\n\n    _noTransitionsRedraw() {\n        const options = this.options;\n        let transitionsState;\n\n        if (options.transitions !== false) {\n            options.transitions = false;\n            transitionsState = true;\n        }\n\n        this._redraw();\n\n        if (transitionsState) {\n            options.transitions = true;\n        }\n    }\n\n    _legendItemHover(seriesIndex, pointIndex) {\n        const { _plotArea: plotArea, _highlight: highlight } = this;\n        const currentSeries = (plotArea.srcSeries || plotArea.series)[seriesIndex];\n        let items;\n\n        if (inArray(currentSeries.type, [ PIE, DONUT, FUNNEL ])) {\n            items = plotArea.findPoint(function(point) {\n                return point.series.index === seriesIndex && point.index === pointIndex;\n            });\n        } else {\n            items = plotArea.pointsBySeriesIndex(seriesIndex);\n        }\n\n        if (this._hasInactiveOpacity() && currentSeries.visible && items) {\n            const multipleSeries = plotArea.series.length > 1;\n            const point = items.length ? items[0] : items;\n\n            this._displayInactiveOpacity(point, multipleSeries, items);\n        } else {\n            highlight.show(items);\n        }\n    }\n\n    _shouldAttachMouseMove() {\n        return this._plotArea.crosshairs.length || (this._tooltip && this._sharedTooltip()) || this.requiresHandlers([ PLOT_AREA_HOVER, PLOT_AREA_LEAVE ]);\n    }\n\n    updateMouseMoveHandler() {\n        unbindEvents(this.element, {\n            [ MOUSEMOVE ]: this._mousemove\n        });\n\n        if (this._shouldAttachMouseMove()) {\n            bindEvents(this.element, {\n                [ MOUSEMOVE ]: this._mousemove\n            });\n        }\n    }\n\n    applyOptions(options, theme) {\n        clearMissingValues(this._originalOptions, options);\n        this._originalOptions = deepExtend(this._originalOptions, options);\n        this.options = deepExtend({}, this._originalOptions);\n\n        if (theme) {\n            this._theme = theme;\n            this.chartService.theme = theme;\n        }\n        this._initTheme(this.options, this._theme);\n\n        this._toggleDragZoomEvents();\n    }\n\n    setOptions(options, theme) {\n        this.applyOptions(options, theme);\n        this.bindCategories();\n        this.redraw();\n        this.updateMouseMoveHandler();\n    }\n\n    setDirection(rtl) {\n        this.chartService.rtl = Boolean(rtl);\n        if (this.surface && this.surface.type === 'svg') {\n            this._destroySurface();\n        }\n    }\n\n    setIntlService(intl) {\n        this.chartService.intl = intl;\n    }\n\n    noTransitionsRedraw() {\n        this._noTransitionsRedraw();\n    }\n\n    destroy() {\n        this._destroyed = true;\n\n        unbindEvents(this.element, {\n            [ CONTEXTMENU ]: this._clickHandler,\n            [ MOUSEWHEEL ]: this._mousewheelHandler,\n            [ MOUSEMOVE ]: this._mousemove,\n            [ MOUSELEAVE ]: this._mouseleaveHandler\n        });\n\n        if (this.domEvents) {\n            this.domEvents.destroy();\n            delete this.domEvents;\n        }\n\n        if (this._mouseMoveTrackHandler) {\n            unbindEvents(document, {\n                [ MOUSEMOVE ]: this._mouseMoveTrackHandler\n            });\n        }\n\n        this._destroyView();\n\n        this._destroySurface();\n\n        this._clearRedrawTimeout();\n    }\n\n    _destroySurface() {\n        const surface = this.surface;\n        if (surface) {\n            surface.unbind(\"mouseenter\", this._surfaceMouseenterHandler);\n            surface.unbind(\"mouseleave\", this._surfaceMouseleaveHandler);\n            surface.destroy();\n\n            this.surface = null;\n        }\n    }\n\n    _destroySelections() {\n        const selections = this._selections;\n\n        if (selections) {\n            while (selections.length > 0) {\n                selections.shift().destroy();\n            }\n        }\n    }\n\n    _destroyView() {\n        const model = this._model;\n\n        if (model) {\n            model.destroy();\n            this._model = null;\n        }\n\n        this._unsetActivePoint();\n\n        this._destroySelections();\n\n        if (this._tooltip) {\n            this._tooltip.destroy();\n        }\n\n        if (this._highlight) {\n            this._highlight.destroy();\n        }\n\n        if (this._zoomSelection) {\n            this._zoomSelection.destroy();\n            delete this._zoomSelection;\n        }\n\n        if (this._pannable) {\n            this._pannable.destroy();\n            delete this._pannable;\n        }\n\n        if (this._mousewheelZoom) {\n            this._mousewheelZoom.destroy();\n            delete this._mousewheelZoom;\n        }\n    }\n}\n\nfunction resolveAxisAliases(options) {\n    const aliases = AXIS_NAMES;\n\n    for (let idx = 0; idx < aliases.length; idx++) {\n        const alias = aliases[idx] + \"Axes\";\n        if (options[alias]) {\n            options[aliases[idx] + \"Axis\"] = options[alias];\n            delete options[alias];\n        }\n    }\n}\n\nfunction pointByCategoryName(points, name) {\n    if (points) {\n        for (let idx = 0; idx < points.length; idx++) {\n            if (points[idx].category === name) {\n                return [ points[idx] ];\n            }\n        }\n    }\n}\n\nfunction applyAxisDefaults(options, themeOptions) {\n    const themeAxisDefaults = ((themeOptions || {}).axisDefaults) || {};\n    let axisName, axisDefaults, axes;\n\n    function mapAxisOptions(axisOptions) {\n        const axisColor = (axisOptions || {}).color || axisDefaults.color;\n        const result = deepExtend({},\n            themeAxisDefaults,\n            themeAxisDefaults[axisName],\n            axisDefaults,\n            axisDefaults[axisName], {\n                line: { color: axisColor },\n                labels: { color: axisColor },\n                title: { color: axisColor }\n            },\n            axisOptions\n        );\n\n        delete result[axisName];\n\n        return result;\n    }\n\n    for (let idx = 0; idx < AXIS_NAMES.length; idx++) {\n        axisName = AXIS_NAMES[idx] + \"Axis\";\n        axisDefaults = options.axisDefaults || {};\n        axes = [].concat(options[axisName]);\n\n        axes = axes.map(mapAxisOptions);\n\n        options[axisName] = axes.length > 1 ? axes : axes[0];\n    }\n}\n\nfunction applySeriesDefaults(options, themeOptions) {\n    const series = options.series;\n    const seriesLength = series.length;\n    const seriesDefaults = options.seriesDefaults;\n    const commonDefaults = deepExtend({}, options.seriesDefaults);\n    const themeSeriesDefaults = themeOptions ? deepExtend({}, themeOptions.seriesDefaults) : {};\n    const commonThemeDefaults = deepExtend({}, themeSeriesDefaults);\n\n    cleanupNestedSeriesDefaults(commonDefaults);\n    cleanupNestedSeriesDefaults(commonThemeDefaults);\n\n    for (let i = 0; i < seriesLength; i++) {\n        const seriesType = series[i].type || options.seriesDefaults.type;\n\n        const baseOptions = deepExtend(\n            { data: [] },\n            commonThemeDefaults,\n            themeSeriesDefaults[seriesType],\n            { tooltip: options.tooltip },\n            commonDefaults,\n            seriesDefaults[seriesType]\n        );\n\n        series[i]._defaults = baseOptions;\n        series[i] = deepExtend({}, baseOptions, series[i]);\n        series[i].data = series[i].data || [];\n    }\n}\n\nfunction cleanupNestedSeriesDefaults(seriesDefaults) {\n    delete seriesDefaults.bar;\n    delete seriesDefaults.column;\n    delete seriesDefaults.rangeColumn;\n    delete seriesDefaults.line;\n    delete seriesDefaults.verticalLine;\n    delete seriesDefaults.pie;\n    delete seriesDefaults.donut;\n    delete seriesDefaults.area;\n    delete seriesDefaults.verticalArea;\n    delete seriesDefaults.scatter;\n    delete seriesDefaults.scatterLine;\n    delete seriesDefaults.bubble;\n    delete seriesDefaults.candlestick;\n    delete seriesDefaults.ohlc;\n    delete seriesDefaults.boxPlot;\n    delete seriesDefaults.bullet;\n    delete seriesDefaults.verticalBullet;\n    delete seriesDefaults.polarArea;\n    delete seriesDefaults.polarLine;\n    delete seriesDefaults.radarArea;\n    delete seriesDefaults.radarLine;\n    delete seriesDefaults.waterfall;\n}\n\n\nfunction chart_axisRanges(axes) {\n    const ranges = {};\n\n    for (let i = 0; i < axes.length; i++) {\n        const axis = axes[i];\n        const axisName = axis.options.name;\n        if (axisName) {\n            ranges[axisName] = axis.range();\n        }\n    }\n\n    return ranges;\n}\n\nfunction sortDates(dates, comparer = dateComparer) {\n    for (let i = 1, length = dates.length; i < length; i++) {\n        if (comparer(dates[i], dates[i - 1]) < 0) {\n            dates.sort(comparer);\n            break;\n        }\n    }\n\n    return dates;\n}\n\nfunction uniqueDates(srcDates, comparer = dateComparer) {\n    const dates = sortDates(srcDates, comparer);\n    const length = dates.length;\n    const result = length > 0 ? [ dates[0] ] : [];\n\n    for (let i = 1; i < length; i++) {\n        if (comparer(dates[i], last(result)) !== 0) {\n            result.push(dates[i]);\n        }\n    }\n\n    return result;\n}\n\nfunction transpose(rows) {\n    const rowCount = rows.length;\n    const result = [];\n\n    for (let rowIx = 0; rowIx < rowCount; rowIx++) {\n        const row = rows[rowIx];\n        const colCount = row.length;\n\n        for (let colIx = 0; colIx < colCount; colIx++) {\n            result[colIx] = result[colIx] || [];\n            result[colIx].push(row[colIx]);\n        }\n    }\n\n    return result;\n}\n\nconst DATA_FIELDS = [ 'data', 'categories' ];\n\nfunction clearMissingValues(originalOptions, options) {\n    for (let field in options) {\n        if (!inArray(field, DATA_FIELDS) && options.hasOwnProperty(field)) {\n            const fieldValue = options[field];\n            const originalValue = originalOptions[field];\n            if (defined(originalValue)) {\n                const nullValue = fieldValue === null;\n                if ((nullValue || !defined(fieldValue))) {\n                    delete originalOptions[field];\n                    if (nullValue) {\n                        delete options[field];\n                    }\n                } else if (originalValue && isObject(fieldValue)) {\n                    if (isObject(originalValue)) {\n                        clearMissingValues(originalValue, fieldValue);\n                    }\n                }\n            }\n        }\n    }\n}\n\nfunction triggerPaneRender(panes) {\n    for (let idx = 0; idx < panes.length; idx++) {\n        panes[idx].notifyRender();\n    }\n}\n\nsetDefaultOptions(chart_Chart, {\n    renderAs: \"\",\n    chartArea: {},\n    legend: {\n        visible: true,\n        labels: {}\n    },\n    categoryAxis: {},\n    seriesDefaults: {\n        type: COLUMN,\n        data: [],\n        highlight: {\n            visible: true\n        },\n        labels: {},\n        negativeValues: {\n            visible: false\n        }\n    },\n    series: [],\n    seriesColors: null,\n    tooltip: {\n        visible: false\n    },\n    transitions: true,\n    valueAxis: {},\n    plotArea: {},\n    title: {},\n    xAxis: {},\n    yAxis: {},\n    panes: [ {} ],\n    pannable: false,\n    zoomable: false\n});\n\n/* harmony default export */ var chart_chart = (chart_Chart);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/sparkline/shared-tooltip.js\n\n\nconst TOP_OFFSET = -2;\n\nclass sparkline_shared_tooltip_SharedTooltip extends shared_tooltip {\n    _slotAnchor(coords, slot) {\n        const axis = this.plotArea.categoryAxis;\n        const vertical = axis.options.vertical;\n        const align = vertical ? {\n            horizontal: \"left\",\n            vertical: \"center\"\n        } : {\n            horizontal: \"center\",\n            vertical: \"bottom\"\n        };\n\n        let point;\n\n        if (vertical) {\n            point = new core_point(this.plotArea.box.x2, slot.center().y);\n        } else {\n            point = new core_point(slot.center().x, TOP_OFFSET);\n        }\n\n        return {\n            point: point,\n            align: align\n        };\n    }\n\n    _defaultAnchor(point, slot) {\n        return this._slotAnchor({}, slot);\n    }\n}\n\n/* harmony default export */ var sparkline_shared_tooltip = (sparkline_shared_tooltip_SharedTooltip);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/sparkline/sparkline.js\n\n\n\n\n\nconst DEAULT_BAR_WIDTH = 150;\nconst DEAULT_BULLET_WIDTH = 150;\nconst NO_CROSSHAIR = [ BAR, BULLET ];\n\nfunction hide(children) {\n    const state = [];\n    for (let idx = 0; idx < children.length; idx++) {\n        const child = children[idx];\n        state[idx] = child.style.display;\n        child.style.display = \"none\";\n    }\n\n    return state;\n}\n\nfunction sparkline_show(children, state) {\n    for (let idx = 0; idx < children.length; idx++) {\n        children[idx].style.display = state[idx];\n    }\n}\n\nfunction wrapNumber(value) {\n    return isNumber(value) ? [ value ] : value;\n}\n\nclass sparkline_Sparkline extends chart_chart {\n    _setElementClass(element) {\n        addClass(element, 'k-sparkline');\n    }\n\n    _initElement(element) {\n        super._initElement(element);\n\n        this._initialWidth = Math.floor(drawing_utils_elementSize(element).width);\n    }\n\n    _resize() {\n        const element = this.element;\n        const state = hide(element.childNodes);\n\n        this._initialWidth = Math.floor(drawing_utils_elementSize(element).width);\n\n        sparkline_show(element.childNodes, state);\n\n        super._resize();\n    }\n\n    _modelOptions() {\n        const chartOptions = this.options;\n        const stage = this._surfaceWrap();\n        const displayState = hide(stage.childNodes);\n\n        const space = document.createElement('span');\n        space.innerHTML = '&nbsp;';\n\n        stage.appendChild(space);\n\n        const options = deepExtend({\n            width: this._autoWidth,\n            height: drawing_utils_elementSize(stage).height,\n            transitions: chartOptions.transitions\n        }, chartOptions.chartArea, {\n            inline: true,\n            align: false\n        });\n\n        drawing_utils_elementSize(stage, {\n            width: options.width,\n            height: options.height\n        });\n\n        stage.removeChild(space);\n\n        sparkline_show(stage.childNodes, displayState);\n\n        if (this.surface) {\n            this.surface.resize();\n        }\n\n        return options;\n    }\n\n    _surfaceWrap() {\n        if (!this.stage) {\n            const stage = this.stage = document.createElement('span');\n            this.element.appendChild(stage);\n        }\n        return this.stage;\n    }\n\n    _createPlotArea(skipSeries) {\n        const plotArea = super._createPlotArea(skipSeries);\n        this._autoWidth = this._initialWidth || this._calculateWidth(plotArea);\n\n        return plotArea;\n    }\n\n    _calculateWidth(plotArea) {\n        const options = this.options;\n        const margin = getSpacing(options.chartArea.margin);\n        const charts = plotArea.charts;\n        const stage = this._surfaceWrap();\n        let total = 0;\n\n\n        for (let i = 0; i < charts.length; i++) {\n            const currentChart = charts[i];\n            const firstSeries = (currentChart.options.series || [])[0];\n            if (!firstSeries) {\n                continue;\n            }\n\n            if (firstSeries.type === BAR) {\n                return DEAULT_BAR_WIDTH;\n            }\n\n            if (firstSeries.type === BULLET) {\n                return DEAULT_BULLET_WIDTH;\n            }\n\n            if (firstSeries.type === PIE) {\n                return drawing_utils_elementSize(stage).height;\n            }\n\n            const categoryAxis = currentChart.categoryAxis;\n            if (categoryAxis) {\n                const pointsCount = categoryAxis.categoriesCount() *\n                    (!currentChart.options.isStacked && inArray(firstSeries.type, [ COLUMN, VERTICAL_BULLET ]) ? currentChart.seriesOptions.length : 1);\n\n                total = Math.max(total, pointsCount);\n            }\n        }\n\n        let size = total * options.pointWidth;\n        if (size > 0) {\n            size += margin.left + margin.right;\n        }\n\n        return size;\n    }\n\n    _createSharedTooltip(options) {\n        return new sparkline_shared_tooltip(this._plotArea, options);\n    }\n\n    static normalizeOptions(userOptions) {\n        let options = wrapNumber(userOptions);\n\n        if (isArray(options)) {\n            options = { seriesDefaults: { data: options } };\n        } else {\n            options = deepExtend({}, options);\n        }\n\n        if (!options.series) {\n            options.series = [ { data: wrapNumber(options.data) } ];\n        }\n\n        deepExtend(options, {\n            seriesDefaults: {\n                type: options.type\n            }\n        });\n\n        if (inArray(options.series[0].type, NO_CROSSHAIR) ||\n            inArray(options.seriesDefaults.type, NO_CROSSHAIR)) {\n            options = deepExtend({}, {\n                categoryAxis: {\n                    crosshair: {\n                        visible: false\n                    }\n                }\n            }, options);\n        }\n\n        return options;\n    }\n}\n\nsetDefaultOptions(sparkline_Sparkline, {\n    chartArea: {\n        margin: 2\n    },\n    axisDefaults: {\n        visible: false,\n        majorGridLines: {\n            visible: false\n        },\n        valueAxis: {\n            narrowRange: true\n        }\n    },\n    seriesDefaults: {\n        type: \"line\",\n        area: {\n            line: {\n                width: 0.5\n            }\n        },\n        bar: {\n            stack: true\n        },\n        padding: 2,\n        width: 0.5,\n        overlay: {\n            gradient: null\n        },\n        highlight: {\n            visible: false\n        },\n        border: {\n            width: 0\n        },\n        markers: {\n            size: 2,\n            visible: false\n        }\n    },\n    tooltip: {\n        visible: true,\n        shared: true\n    },\n    categoryAxis: {\n        crosshair: {\n            visible: true,\n            tooltip: {\n                visible: false\n            }\n        }\n    },\n    legend: {\n        visible: false\n    },\n    transitions: false,\n\n    pointWidth: 5,\n\n    panes: [ { clip: false } ]\n});\n\n/* harmony default export */ var sparkline = (sparkline_Sparkline);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/sparkline.js\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/stock/fade-out-animation.js\n\n\n\n\nclass fade_out_animation_FadeOutAnimation extends main[\"a\" /* drawing */].Animation {\n\n    setup() {\n        this._initialOpacity = parseFloat(element_styles_elementStyles(this.element, 'opacity').opacity);\n    }\n\n    step(pos) {\n        element_styles_elementStyles(this.element, {\n            opacity: String(interpolateValue(this._initialOpacity, 0, pos))\n        });\n    }\n\n    abort() {\n        super.abort();\n        element_styles_elementStyles(this.element, {\n            display: 'none',\n            opacity: String(this._initialOpacity)\n        });\n    }\n\n    cancel() {\n        super.abort();\n        element_styles_elementStyles(this.element, {\n            opacity: String(this._initialOpacity)\n        });\n    }\n}\n\n/* harmony default export */ var fade_out_animation = (fade_out_animation_FadeOutAnimation);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/stock/navigator-hint.js\n\n\n\n\nfunction navigator_hint_createDiv(className, style) {\n    const div = document.createElement(\"div\");\n    div.className = className;\n    if (style) {\n        div.style.cssText = style;\n    }\n\n    return div;\n}\n\nclass navigator_hint_NavigatorHint extends common_class[\"a\" /* default */] {\n    constructor(container, chartService, options) {\n        super();\n\n        this.options = deepExtend({}, this.options, options);\n        this.container = container;\n        this.chartService = chartService;\n\n        const padding = element_styles_elementStyles(container, [ \"paddingLeft\", \"paddingTop\" ]);\n        this.chartPadding = {\n            top: padding.paddingTop,\n            left: padding.paddingLeft\n        };\n\n        this.createElements();\n        container.appendChild(this.element);\n    }\n\n    createElements() {\n        const element = this.element = navigator_hint_createDiv('k-navigator-hint', 'display: none; position: absolute; top: 1px; left: 1px;');\n        const tooltip = this.tooltip = navigator_hint_createDiv('k-tooltip k-chart-tooltip');\n        const scroll = this.scroll = navigator_hint_createDiv('k-scroll');\n\n        tooltip.innerHTML = '&nbsp;';\n\n        element.appendChild(tooltip);\n        element.appendChild(scroll);\n    }\n\n    show(from, to, bbox) {\n        const { element, options, scroll, tooltip } = this;\n        const middle = toDate(toTime(from) + toTime(to - from) / 2);\n        const scrollWidth = bbox.width() * 0.4;\n        const minPos = bbox.center().x - scrollWidth;\n        const maxPos = bbox.center().x;\n        const posRange = maxPos - minPos;\n        const range = options.max - options.min;\n        const scale = posRange / range;\n        const offset = middle - options.min;\n        let text = this.chartService.intl.format(options.format, from, to);\n        const template = getTemplate(options);\n\n        this.clearHideTimeout();\n\n        if (!this._visible) {\n            element_styles_elementStyles(element, {\n                visibility: 'hidden',\n                display: 'block'\n            });\n            this._visible = true;\n        }\n\n        if (template) {\n            text = template({\n                from: from,\n                to: to\n            });\n        }\n\n        tooltip.innerHTML = text;\n        element_styles_elementStyles(tooltip, {\n            left: bbox.center().x - tooltip.offsetWidth / 2,\n            top: bbox.y1\n        });\n\n        const tooltipStyle = element_styles_elementStyles(tooltip, [ 'marginTop', 'borderTopWidth', 'height' ]);\n\n        element_styles_elementStyles(scroll, {\n            width: scrollWidth,\n            left: minPos + offset * scale,\n            top: bbox.y1 + tooltipStyle.marginTop + tooltipStyle.borderTopWidth + tooltipStyle.height / 2\n        });\n\n        element_styles_elementStyles(element, {\n            visibility: 'visible'\n        });\n    }\n\n    clearHideTimeout() {\n        if (this._hideTimeout) {\n            clearTimeout(this._hideTimeout);\n        }\n\n        if (this._hideAnimation) {\n            this._hideAnimation.cancel();\n        }\n    }\n\n    hide() {\n        this.clearHideTimeout();\n\n        this._hideTimeout = setTimeout(() => {\n            this._visible = false;\n            this._hideAnimation = new fade_out_animation(this.element);\n            this._hideAnimation.setup();\n            this._hideAnimation.play();\n        }, this.options.hideDelay);\n    }\n\n    destroy() {\n        this.clearHideTimeout();\n        if (this.container) {\n            this.container.removeChild(this.element);\n        }\n        delete this.container;\n        delete this.chartService;\n        delete this.element;\n        delete this.tooltip;\n        delete this.scroll;\n    }\n}\n\nsetDefaultOptions(navigator_hint_NavigatorHint, {\n    format: \"{0:d} - {1:d}\",\n    hideDelay: 500\n});\n\n/* harmony default export */ var navigator_hint = (navigator_hint_NavigatorHint);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/stock/constants.js\nconst NAVIGATOR_PANE = \"_navigator\";\nconst NAVIGATOR_AXIS = NAVIGATOR_PANE;\n\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/stock/navigator.js\n\n\n\n\n\n\n\n\nconst navigator_ZOOM_ACCELERATION = 3;\n\nclass navigator_Navigator extends common_class[\"a\" /* default */] {\n    constructor(chart) {\n        super();\n\n        this.chart = chart;\n        const options = this.options = deepExtend({}, this.options, chart.options.navigator);\n        const select = options.select;\n        if (select) {\n            select.from = this.parseDate(select.from);\n            select.to = this.parseDate(select.to);\n        }\n\n        if (!defined(options.hint.visible)) {\n            options.hint.visible = options.visible;\n        }\n\n        this.chartObserver = new instance_observer(this, {\n            [DRAG]: '_drag',\n            [DRAG_END]: '_dragEnd',\n            [ZOOM]: '_zoom',\n            [ZOOM_END]: '_zoomEnd'\n        });\n        chart.addObserver(this.chartObserver);\n    }\n\n    parseDate(value) {\n        return parse_date_parseDate(this.chart.chartService.intl, value);\n    }\n\n    clean() {\n        if (this.selection) {\n            this.selection.destroy();\n            this.selection = null;\n        }\n\n        if (this.hint) {\n            this.hint.destroy();\n            this.hint = null;\n        }\n    }\n\n    destroy() {\n        if (this.chart) {\n            this.chart.removeObserver(this.chartObserver);\n            delete this.chart;\n        }\n\n        this.clean();\n    }\n\n    redraw() {\n        this._redrawSelf();\n        this.initSelection();\n    }\n\n    initSelection() {\n        const { chart, options } = this;\n        const axis = this.mainAxis();\n        const { min, max } = axis.roundedRange();\n        const { from, to, mousewheel } = options.select;\n        const axisClone = clone(axis);\n\n        if (axis.categoriesCount() === 0) {\n            return;\n        }\n\n        this.clean();\n\n        // \"Freeze\" the selection axis position until the next redraw\n        axisClone.box = axis.box;\n\n        this.selection = new chart_selection(chart, axisClone, {\n            min: min,\n            max: max,\n            from: from || min,\n            to: to || max,\n            mousewheel: valueOrDefault(mousewheel, { zoom: \"left\" }),\n            visible: options.visible\n        }, new instance_observer(this, {\n            selectStart: '_selectStart',\n            select: '_select',\n            selectEnd: '_selectEnd'\n        }));\n\n        if (options.hint.visible) {\n            this.hint = new navigator_hint(chart.element, chart.chartService, {\n                min: min,\n                max: max,\n                template: getTemplate(options.hint),\n                format: options.hint.format\n            });\n        }\n    }\n\n    setRange() {\n        const plotArea = this.chart._createPlotArea(true);\n        const axis = plotArea.namedCategoryAxes[NAVIGATOR_AXIS];\n\n        const { min, max } = axis.roundedRange();\n\n        const select = this.options.select || {};\n        let from = select.from || min;\n        if (from < min) {\n            from = min;\n        }\n\n        let to = select.to || max;\n        if (to > max) {\n            to = max;\n        }\n\n        this.options.select = deepExtend({}, select, {\n            from: from,\n            to: to\n        });\n\n        this.filterAxes();\n    }\n\n    _redrawSelf(silent) {\n        const plotArea = this.chart._plotArea;\n\n        if (plotArea) {\n            plotArea.redraw(last(plotArea.panes), silent);\n        }\n    }\n\n    redrawSlaves() {\n        const chart = this.chart;\n        const plotArea = chart._plotArea;\n        const slavePanes = plotArea.panes.slice(0, -1);\n\n        // Update the original series and categoryAxis before partial refresh.\n        plotArea.srcSeries = chart.options.series;\n        plotArea.options.categoryAxis = chart.options.categoryAxis;\n        plotArea.clearSeriesPointsCache();\n\n        plotArea.redraw(slavePanes);\n    }\n\n    _drag(e) {\n        const { chart, selection } = this;\n        const coords = chart._eventCoordinates(e.originalEvent);\n        const navigatorAxis = this.mainAxis();\n        const naviRange = navigatorAxis.roundedRange();\n        const inNavigator = navigatorAxis.pane.box.containsPoint(coords);\n        const axis = chart._plotArea.categoryAxis;\n        const range = e.axisRanges[axis.options.name];\n        const select = this.options.select;\n        let duration;\n\n        if (!range || inNavigator || !selection) {\n            return;\n        }\n\n        if (select.from && select.to) {\n            duration = toTime(select.to) - toTime(select.from);\n        } else {\n            duration = toTime(selection.options.to) - toTime(selection.options.from);\n        }\n\n        const from = toDate(limitValue(\n            toTime(range.min),\n            naviRange.min, toTime(naviRange.max) - duration\n        ));\n\n        const to = toDate(limitValue(\n            toTime(from) + duration,\n            toTime(naviRange.min) + duration, naviRange.max\n        ));\n\n        this.options.select = { from: from, to: to };\n\n        if (this.options.liveDrag) {\n            this.filterAxes();\n            this.redrawSlaves();\n        }\n\n        selection.set(from, to);\n\n        this.showHint(from, to);\n    }\n\n    _dragEnd() {\n        this.filterAxes();\n        this.filter();\n        this.redrawSlaves();\n\n        if (this.hint) {\n            this.hint.hide();\n        }\n    }\n\n    readSelection() {\n        const { selection: { options: { from, to } }, options: { select } } = this;\n\n        select.from = from;\n        select.to = to;\n    }\n\n    filterAxes() {\n        const { options: { select = { } }, chart } = this;\n        const allAxes = chart.options.categoryAxis;\n        const { from, to } = select;\n\n        for (let idx = 0; idx < allAxes.length; idx++) {\n            const axis = allAxes[idx];\n            if (axis.pane !== NAVIGATOR_PANE) {\n                axis.min = from;\n                axis.max = to;\n            }\n        }\n    }\n\n    filter() {\n        const { chart, options: { select } } = this;\n\n        if (!chart.requiresHandlers([ \"navigatorFilter\" ])) {\n            return;\n        }\n\n        const mainAxis = this.mainAxis();\n        const args = {\n            from: select.from,\n            to: select.to\n        };\n\n        if (mainAxis.options.type !== 'category') {\n            const axisOptions = new date_category_axis(deepExtend({\n                baseUnit: \"fit\"\n            }, chart.options.categoryAxis[0], {\n                categories: [ select.from, select.to ]\n            }), chart.chartService).options;\n\n            args.from = addDuration(axisOptions.min, -axisOptions.baseUnitStep, axisOptions.baseUnit);\n            args.to = addDuration(axisOptions.max, axisOptions.baseUnitStep, axisOptions.baseUnit);\n        }\n\n        this.chart.trigger(\"navigatorFilter\", args);\n    }\n\n    _zoom(e) {\n        const { chart: { _plotArea: { categoryAxis: axis } }, selection, options: { select, liveDrag } } = this;\n        const mainAxis = this.mainAxis();\n        let delta = e.delta;\n\n        if (!selection) {\n            return;\n        }\n\n        const fromIx = mainAxis.categoryIndex(selection.options.from);\n        const toIx = mainAxis.categoryIndex(selection.options.to);\n\n        e.originalEvent.preventDefault();\n\n        if (Math.abs(delta) > 1) {\n            delta *= navigator_ZOOM_ACCELERATION;\n        }\n\n        if (toIx - fromIx > 1) {\n            selection.expand(delta);\n            this.readSelection();\n        } else {\n            axis.options.min = select.from;\n            select.from = axis.scaleRange(-e.delta).min;\n        }\n\n        if (liveDrag) {\n            this.filterAxes();\n            this.redrawSlaves();\n        }\n\n        selection.set(select.from, select.to);\n\n        this.showHint(this.options.select.from, this.options.select.to);\n    }\n\n    _zoomEnd(e) {\n        this._dragEnd(e);\n    }\n\n    showHint(from, to) {\n        const plotArea = this.chart._plotArea;\n\n        if (this.hint) {\n            this.hint.show(from, to, plotArea.backgroundBox());\n        }\n    }\n\n    _selectStart(e) {\n        return this.chart._selectStart(e);\n    }\n\n    _select(e) {\n        this.showHint(e.from, e.to);\n\n        return this.chart._select(e);\n    }\n\n    _selectEnd(e) {\n        if (this.hint) {\n            this.hint.hide();\n        }\n\n        this.readSelection();\n        this.filterAxes();\n        this.filter();\n        this.redrawSlaves();\n\n        return this.chart._selectEnd(e);\n    }\n\n    mainAxis() {\n        const plotArea = this.chart._plotArea;\n\n        if (plotArea) {\n            return plotArea.namedCategoryAxes[NAVIGATOR_AXIS];\n        }\n    }\n\n    select(from, to) {\n        const select = this.options.select;\n\n        if (from && to) {\n            select.from = this.parseDate(from);\n            select.to = this.parseDate(to);\n\n            this.filterAxes();\n            this.filter();\n            this.redrawSlaves();\n\n            this.selection.set(from, to);\n        }\n\n        return {\n            from: select.from,\n            to: select.to\n        };\n    }\n\n    static setup(options = {}, themeOptions = {}) {\n        if (options.__navi) {\n            return;\n        }\n        options.__navi = true;\n\n        const naviOptions = deepExtend({}, themeOptions.navigator, options.navigator);\n        const panes = options.panes = [].concat(options.panes);\n        const paneOptions = deepExtend({}, naviOptions.pane, { name: NAVIGATOR_PANE });\n\n        if (!naviOptions.visible) {\n            paneOptions.visible = false;\n            paneOptions.height = 0.1;\n        }\n\n        panes.push(paneOptions);\n\n        navigator_Navigator.attachAxes(options, naviOptions);\n        navigator_Navigator.attachSeries(options, naviOptions, themeOptions);\n    }\n\n    static attachAxes(options, naviOptions) {\n        const series = naviOptions.series || [];\n        const categoryAxes = options.categoryAxis = [].concat(options.categoryAxis);\n        const valueAxes = options.valueAxis = [].concat(options.valueAxis);\n\n        const equallySpacedSeries = filterSeriesByType(series, EQUALLY_SPACED_SERIES);\n        const justifyAxis = equallySpacedSeries.length === 0;\n\n        const base = deepExtend({\n            type: \"date\",\n            pane: NAVIGATOR_PANE,\n            roundToBaseUnit: !justifyAxis,\n            justified: justifyAxis,\n            _collapse: false,\n            majorTicks: { visible: true },\n            tooltip: { visible: false },\n            labels: { step: 1 },\n            autoBind: naviOptions.autoBindElements,\n            autoBaseUnitSteps: {\n                minutes: [ 1 ],\n                hours: [ 1, 2 ],\n                days: [ 1, 2 ],\n                weeks: [],\n                months: [ 1 ],\n                years: [ 1 ]\n            }\n        });\n        const user = naviOptions.categoryAxis;\n\n        categoryAxes.push(\n            deepExtend({}, base, {\n                maxDateGroups: 200\n            }, user, {\n                name: NAVIGATOR_AXIS,\n                title: null,\n                baseUnit: \"fit\",\n                baseUnitStep: \"auto\",\n                labels: { visible: false },\n                majorTicks: { visible: false }\n            }), deepExtend({}, base, user, {\n                name: NAVIGATOR_AXIS + \"_labels\",\n                maxDateGroups: 20,\n                baseUnitStep: \"auto\",\n                labels: { position: \"\" },\n                plotBands: [],\n                autoBaseUnitSteps: {\n                    minutes: []\n                },\n                _overlap: true\n            }), deepExtend({}, base, user, {\n                name: NAVIGATOR_AXIS + \"_ticks\",\n                maxDateGroups: 200,\n                majorTicks: {\n                    width: 0.5\n                },\n                plotBands: [],\n                title: null,\n                labels: { visible: false, mirror: true },\n                _overlap: true\n            })\n        );\n\n        valueAxes.push(deepExtend({\n            name: NAVIGATOR_AXIS,\n            pane: NAVIGATOR_PANE,\n            majorGridLines: {\n                visible: false\n            },\n            visible: false\n        }, naviOptions.valueAxis));\n    }\n\n    static attachSeries(options, naviOptions, themeOptions) {\n        const series = options.series = options.series || [];\n        const navigatorSeries = [].concat(naviOptions.series || []);\n        const seriesColors = themeOptions.seriesColors;\n        const defaults = naviOptions.seriesDefaults;\n\n        for (let idx = 0; idx < navigatorSeries.length; idx++) {\n            series.push(\n                deepExtend({\n                    color: seriesColors[idx % seriesColors.length],\n                    categoryField: naviOptions.dateField,\n                    visibleInLegend: false,\n                    tooltip: {\n                        visible: false\n                    }\n                }, defaults, navigatorSeries[idx], {\n                    axis: NAVIGATOR_AXIS,\n                    categoryAxis: NAVIGATOR_AXIS,\n                    autoBind: naviOptions.autoBindElements\n                })\n            );\n        }\n    }\n}\n\nfunction ClonedObject() { }\nfunction clone(obj) {\n    ClonedObject.prototype = obj;\n    return new ClonedObject();\n}\n\n/* harmony default export */ var stock_navigator = (navigator_Navigator);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/stock/stock-chart.js\n\n\n\n\n\n\n\nconst AUTO_CATEGORY_WIDTH = 28;\n\nclass stock_chart_StockChart extends chart_chart {\n\n    applyDefaults(options, themeOptions) {\n        const width = drawing_utils_elementSize(this.element).width || DEFAULT_WIDTH;\n        let theme = themeOptions;\n\n        const stockDefaults = {\n            seriesDefaults: {\n                categoryField: options.dateField\n            },\n            axisDefaults: {\n                categoryAxis: {\n                    name: \"default\",\n                    majorGridLines: {\n                        visible: false\n                    },\n                    labels: {\n                        step: 2\n                    },\n                    majorTicks: {\n                        visible: false\n                    },\n                    maxDateGroups: Math.floor(width / AUTO_CATEGORY_WIDTH)\n                }\n            }\n        };\n\n        if (theme) {\n            theme = deepExtend({}, theme, stockDefaults);\n        }\n\n        stock_navigator.setup(options, theme);\n\n        super.applyDefaults(options, theme);\n    }\n\n    _setElementClass(element) {\n        addClass(element, 'k-chart k-stockchart');\n    }\n\n    setOptions(options) {\n        this.destroyNavigator();\n        super.setOptions(options);\n    }\n\n    noTransitionsRedraw() {\n        const transitions = this.options.transitions;\n\n        this.options.transitions = false;\n        this._fullRedraw();\n        this.options.transitions = transitions;\n    }\n\n    _resize() {\n        this.noTransitionsRedraw();\n    }\n\n    _redraw() {\n        const navigator = this.navigator;\n\n        if (!this._dirty() && navigator && navigator.options.partialRedraw) {\n            navigator.redrawSlaves();\n        } else {\n            this._fullRedraw();\n        }\n    }\n\n    _dirty() {\n        const options = this.options;\n        const series = [].concat(options.series, options.navigator.series);\n        const seriesCount = grep(series, function(s) { return s && s.visible; }).length;\n        const dirty = this._seriesCount !== seriesCount;\n        this._seriesCount = seriesCount;\n\n        return dirty;\n    }\n\n    _fullRedraw() {\n        let navigator = this.navigator;\n\n        if (!navigator) {\n            navigator = this.navigator = new stock_navigator(this);\n            this.trigger(\"navigatorCreated\", { navigator: navigator });\n        }\n\n        navigator.clean();\n        navigator.setRange();\n\n        super._redraw();\n\n        navigator.initSelection();\n    }\n\n    _trackSharedTooltip(coords) {\n        const plotArea = this._plotArea;\n        const pane = plotArea.paneByPoint(coords);\n\n        if (pane && pane.options.name === NAVIGATOR_PANE) {\n            this._unsetActivePoint();\n        } else {\n            super._trackSharedTooltip(coords);\n        }\n    }\n\n    bindCategories() {\n        super.bindCategories();\n        this.copyNavigatorCategories();\n    }\n\n    copyNavigatorCategories() {\n        const definitions = [].concat(this.options.categoryAxis);\n        let categories;\n\n        for (let axisIx = 0; axisIx < definitions.length; axisIx++) {\n            const axis = definitions[axisIx];\n            if (axis.name === NAVIGATOR_AXIS) {\n                categories = axis.categories;\n            } else if (categories && axis.pane === NAVIGATOR_PANE) {\n                axis.categories = categories;\n            }\n        }\n    }\n\n    destroyNavigator() {\n        if (this.navigator) {\n            this.navigator.destroy();\n            this.navigator = null;\n        }\n    }\n\n    destroy() {\n        this.destroyNavigator();\n        super.destroy();\n    }\n\n    _stopChartHandlers(e) {\n        const coords = this._eventCoordinates(e);\n        const pane = this._plotArea.paneByPoint(coords);\n\n        return super._stopChartHandlers(e) || (pane && pane.options.name === NAVIGATOR_PANE);\n    }\n\n    _toggleDragZoomEvents() {\n        if (!this._dragZoomEnabled) {\n            this.element.style.touchAction = \"none\";\n\n            this._dragZoomEnabled = true;\n        }\n    }\n}\n\nsetDefaultOptions(stock_chart_StockChart, {\n    dateField: \"date\",\n    axisDefaults: {\n        categoryAxis: {\n            type: \"date\",\n            baseUnit: \"fit\",\n            justified: true\n        },\n        valueAxis: {\n            narrowRange: true,\n            labels: {\n                format: \"C\"\n            }\n        }\n    },\n    navigator: {\n        select: {},\n        seriesDefaults: {\n            markers: {\n                visible: false\n            },\n            tooltip: {\n                visible: true\n            },\n            line: {\n                width: 2\n            }\n        },\n        hint: {},\n        visible: true\n    },\n    tooltip: {\n        visible: true\n    },\n    legend: {\n        visible: false\n    }\n});\n\n/* harmony default export */ var stock_chart = (stock_chart_StockChart);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/stock.js\n\n\n\n\n\n\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/gauges/constants.js\nconst ANGULAR_SPEED = 150;\nconst LINEAR_SPEED = 250;\nconst ARROW = \"arrow\";\nconst ARROW_POINTER = \"arrowPointer\";\nconst BAR_POINTER = \"barPointer\";\nconst constants_DEFAULT_HEIGHT = 200;\nconst DEFAULT_LINE_WIDTH = 0.5;\nconst constants_DEFAULT_WIDTH = 200;\nconst DEGREE = Math.PI / 180;\nconst constants_INSIDE = \"inside\";\nconst constants_LINEAR = \"linear\";\nconst constants_OUTSIDE = \"outside\";\nconst RADIAL_POINTER = \"radialPointer\";\nconst RADIAL_RANGE_POINTER = \"radialRangePointer\";\n\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/gauges/utils/pad.js\n\n\nfunction pad(bbox, value) {\n    const origin = bbox.getOrigin();\n    const size = bbox.getSize();\n    const spacing = getSpacing(value);\n\n    bbox.setOrigin([ origin.x - spacing.left, origin.y - spacing.top ]);\n    bbox.setSize([ size.width + (spacing.left + spacing.right), size.height + (spacing.top + spacing.bottom) ]);\n\n    return bbox;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/gauges/utils/build-label-element.js\n\n\n\nconst { Group, Path, Text: build_label_element_Text } = main[\"a\" /* drawing */];\n\nfunction buildLabelElement(label, options) {\n    const labelBox = label.box;\n    const textBox = label.children[0].box;\n    const border = options.border || {};\n    const background = options.background || \"\";\n\n    const wrapper = Path.fromRect(new main[\"b\" /* geometry */].Rect([ labelBox.x1, labelBox.y1 ], [ labelBox.width(), labelBox.height() ]), {\n        stroke: {}\n    });\n\n    const text = new build_label_element_Text(label.text, new main[\"b\" /* geometry */].Point(textBox.x1, textBox.y1), {\n        font: options.font,\n        fill: { color: options.color }\n    });\n\n    const styleGeometry = pad(text.bbox().clone(), options.padding);\n\n    const styleBox = Path.fromRect(styleGeometry, {\n        stroke: {\n            color: border.width ? border.color : \"\",\n            width: border.width,\n            opacity: border.opacity,\n            dashType: border.dashType,\n            lineJoin: \"round\",\n            lineCap: \"round\"\n        },\n        fill: {\n            color: background\n        }\n    });\n\n    const elements = new Group();\n    elements.append(wrapper);\n    elements.append(styleBox);\n    elements.append(text);\n\n    return elements;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/gauges/utils/get-range.js\n\n\n\nfunction getRange(range, min, max) {\n    const from = defined(range.from) ? range.from : MIN_VALUE;\n    const to = defined(range.to) ? range.to : MAX_VALUE;\n\n    range.from = Math.max(Math.min(to, from), min);\n    range.to = Math.min(Math.max(to, from), max);\n\n    return range;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/gauges/utils/unpad.js\n\n\n\nfunction unpad(bbox, value) {\n    const spacing = getSpacing(value);\n\n    spacing.left = -spacing.left; spacing.top = -spacing.top;\n    spacing.right = -spacing.right; spacing.bottom = -spacing.bottom;\n\n    return pad(bbox, spacing);\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/gauges/utils.js\n\n\n\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/gauges/gauge.js\n\n\n\n\n\n\nconst DEFAULT_MARGIN = 5;\nconst { Path: gauge_Path, Surface } = main[\"a\" /* drawing */];\n\nclass gauge_Gauge extends common_class[\"a\" /* default */] {\n\n    constructor(element, userOptions, theme, context = {}) {\n        super();\n\n        this.element = element;\n        this.theme = theme;\n        this.contextService = new chart_service(this, context);\n        this._originalOptions = deepExtend({}, this.options, userOptions);\n        this.options = deepExtend({}, this._originalOptions);\n        this._initTheme(theme);\n\n        this.redraw();\n    }\n\n    destroy() {\n        if (this.surface) {\n            this.surface.destroy();\n            this.surface = null;\n        }\n\n        delete this.element;\n        delete this.surfaceElement;\n    }\n\n    value(pointerValue) {\n        const pointer = this.pointers[0];\n\n        if (arguments.length === 0) {\n            return pointer.value();\n        }\n\n        pointer.value(pointerValue);\n        this._setValueOptions(pointerValue);\n    }\n\n    _draw() {\n        const surface = this.surface;\n\n        surface.clear();\n        surface.draw(this._visuals);\n    }\n\n    exportVisual() {\n        return this._visuals;\n    }\n\n    allValues(values) {\n        const pointers = this.pointers;\n        const allValues = [];\n\n        if (arguments.length === 0) {\n            for (let i = 0; i < pointers.length; i++) {\n                allValues.push(pointers[i].value());\n            }\n\n            return allValues;\n        }\n\n        if (isArray(values)) {\n            for (let i = 0; i < values.length; i++) {\n                if (isNumber(values[i])) {\n                    pointers[i].value(values[i]);\n                }\n            }\n        }\n\n        this._setValueOptions(values);\n    }\n\n    _setValueOptions(values) {\n        const pointers = [].concat(this.options.pointer);\n        const arrayValues = [].concat(values);\n\n        for (let i = 0; i < arrayValues.length; i++) {\n            pointers[i].value = arrayValues[i];\n        }\n    }\n\n    resize() {\n        this.noTransitionsRedraw();\n    }\n\n    noTransitionsRedraw() {\n        const transitions = this.options.transitions;\n\n        this._toggleTransitions(false);\n\n        this.redraw();\n\n        this._toggleTransitions(transitions);\n    }\n\n    redraw() {\n        const size = this._surfaceSize();\n        const wrapper = new main[\"b\" /* geometry */].Rect([ 0, 0 ], [ size.width, size.height ]);\n\n        this._initSurface();\n\n        this.gaugeArea = this._createGaugeArea();\n\n        this._createModel();\n\n        const bbox = unpad(wrapper.bbox(), this._gaugeAreaMargin);\n        this.reflow(bbox);\n    }\n\n    setOptions(options, theme) {\n        this._originalOptions = deepExtend(this._originalOptions, options);\n        this.options = deepExtend({}, this._originalOptions);\n\n        this._initTheme(theme);\n\n        this.redraw();\n    }\n\n    setDirection(rtl) {\n        this.contextService.rtl = Boolean(rtl);\n        if (this.surface && this.surface.type === 'svg') {\n            this.surface.destroy();\n            this.surface = null;\n        }\n    }\n\n    setIntlService(intl) {\n        this.contextService.intl = intl;\n    }\n\n    _initTheme(theme) {\n        let currentTheme = theme || this.theme || {};\n        this.theme = currentTheme;\n\n        this.options = deepExtend({}, currentTheme, this.options);\n        const options = this.options;\n        const pointer = options.pointer;\n\n        if (isArray(pointer)) {\n            const pointers = [];\n            for (let i = 0; i < pointer.length; i++) {\n                pointers.push(deepExtend({}, currentTheme.pointer, pointer[i]));\n            }\n            options.pointer = pointers;\n        }\n    }\n\n    _createGaugeArea() {\n        const options = this.options.gaugeArea;\n        const size = this.surface.size();\n        const border = options.border || {};\n        let areaGeometry = new main[\"b\" /* geometry */].Rect([ 0, 0 ], [ size.width, size.height ]);\n\n        this._gaugeAreaMargin = options.margin || DEFAULT_MARGIN;\n\n        if (border.width > 0) {\n            areaGeometry = unpad(areaGeometry, border.width);\n        }\n\n        const gaugeArea = gauge_Path.fromRect(areaGeometry, {\n            stroke: {\n                color: border.width ? border.color : \"\",\n                width: border.width,\n                dashType: border.dashType,\n                lineJoin: \"round\",\n                lineCap: \"round\"\n            },\n            fill: {\n                color: options.background\n            }\n        });\n\n        return gaugeArea;\n    }\n\n    _initSurface() {\n        const { options, surface } = this;\n        const element = this._surfaceElement();\n        const size = this._surfaceSize();\n\n        drawing_utils_elementSize(element, size);\n\n        if (!surface || surface.options.type !== options.renderAs) {\n            if (surface) {\n                surface.destroy();\n            }\n\n            this.surface = Surface.create(element, {\n                type: options.renderAs\n            });\n        } else {\n            this.surface.clear();\n            this.surface.resize();\n        }\n    }\n\n    _surfaceSize() {\n        const options = this.options;\n        const size = this._getSize();\n\n        if (options.gaugeArea) {\n            deepExtend(size, options.gaugeArea);\n        }\n\n        return size;\n    }\n\n    _surfaceElement() {\n        if (!this.surfaceElement) {\n            this.surfaceElement = document.createElement('div');\n            this.element.appendChild(this.surfaceElement);\n        }\n\n        return this.surfaceElement;\n    }\n\n    getSize() {\n        return this._getSize();\n    }\n\n    _getSize() {\n        const element = this.element;\n        const defaultSize = this._defaultSize();\n        let width = element.offsetWidth;\n        let height = element.offsetHeight;\n\n        if (!width) {\n            width = defaultSize.width;\n        }\n\n        if (!height) {\n            height = defaultSize.height;\n        }\n\n        return { width: width, height: height };\n    }\n\n    _defaultSize() {\n        return {\n            width: constants_DEFAULT_WIDTH,\n            height: constants_DEFAULT_HEIGHT\n        };\n    }\n\n    _toggleTransitions(value) {\n        this.options.transitions = value;\n        for (let i = 0; i < this.pointers.length; i++) {\n            this.pointers[i].options.animation.transitions = value;\n        }\n    }\n}\n\nsetDefaultOptions(gauge_Gauge, {\n    plotArea: {},\n    theme: \"default\",\n    renderAs: \"\",\n    pointer: {},\n    scale: {},\n    gaugeArea: {}\n});\n\n/* harmony default export */ var gauge = (gauge_Gauge);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/gauges/linear/linear-scale.js\n\n\n\n\n\n\n\n\nconst { Path: linear_scale_Path, Group: linear_scale_Group } = main[\"a\" /* drawing */];\nconst linear_scale_Point = main[\"b\" /* geometry */].Point;\n\nfunction renderAxisTick(tickRenderOptions, tickOptions) {\n    const { position, tickX, tickY } = tickRenderOptions;\n    let start, end;\n\n    if (tickRenderOptions.vertical) {\n        start = new linear_scale_Point(tickX, position);\n        end = new linear_scale_Point(tickX + tickOptions.size, position);\n    } else {\n        start = new linear_scale_Point(position, tickY);\n        end = new linear_scale_Point(position, tickY + tickOptions.size);\n    }\n\n    const tickPath = new linear_scale_Path({\n        stroke: {\n            color: tickOptions.color,\n            width: tickOptions.width\n        }\n    }).moveTo(start).lineTo(end);\n\n    return tickPath;\n}\n\nfunction renderTicks(tickGroup, tickPositions, tickRenderOptions, tickOptions) {\n    const count = tickPositions.length;\n\n    if (tickOptions.visible) {\n        const { mirror, lineBox } = tickRenderOptions;\n        for (let i = tickOptions.skip; i < count; i += tickOptions.step) {\n            if (i % tickOptions.skipUnit === 0) {\n                continue;\n            }\n\n            tickRenderOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n            tickRenderOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n            tickRenderOptions.position = tickPositions[i];\n\n            tickGroup.append(renderAxisTick(tickRenderOptions, tickOptions));\n        }\n    }\n}\n\nclass linear_scale_LinearScale extends numeric_axis {\n    constructor(options, service) {\n        let scaleOptions = options || {};\n        if (!defined(scaleOptions.reverse) && scaleOptions.vertical === false && (service || {}).rtl) {\n            scaleOptions = Object.assign({}, scaleOptions, {\n                reverse: true\n            });\n        }\n\n        super(0, 1, scaleOptions, service);\n\n        this.options.minorUnit = this.options.minorUnit || this.options.majorUnit / 10;\n    }\n\n    initUserOptions(options) {\n        let scaleOptions = deepExtend({}, this.options, options);\n        scaleOptions = deepExtend({}, scaleOptions , { labels: { mirror: scaleOptions.mirror } });\n        scaleOptions.majorUnit = scaleOptions.majorUnit || autoMajorUnit(scaleOptions.min, scaleOptions.max);\n\n        return scaleOptions;\n    }\n\n    initFields() {\n    }\n\n    render() {\n        const elements = this.elements = new linear_scale_Group();\n        const labels = this.renderLabels();\n        const scaleLine = this.renderLine();\n        const scaleTicks = this.renderTicks();\n        const ranges = this.renderRanges();\n\n        elements.append(scaleLine, labels, scaleTicks, ranges);\n\n        return elements;\n    }\n\n    renderRanges() {\n        const options = this.options;\n        const { min, max, vertical, labels: { mirror } } = options;\n        const ranges = options.ranges || [];\n        const elements = new linear_scale_Group();\n        const count = ranges.length;\n        const rangeSize = options.rangeSize || options.minorTicks.size / 2;\n\n        for (let i = 0; i < count; i++) {\n            const range = getRange(ranges[i], min, max);\n            const slot = this.getSlot(range.from, range.to);\n            const slotX = vertical ? this.lineBox() : slot;\n            const slotY = vertical ? slot : this.lineBox();\n            if (vertical) {\n                slotX.x1 -= rangeSize * (mirror ? -1 : 1);\n            } else {\n                slotY.y2 += rangeSize * (mirror ? -1 : 1);\n            }\n\n            elements.append(linear_scale_Path.fromRect(new main[\"b\" /* geometry */].Rect([ slotX.x1, slotY.y1 ], [ slotX.x2 - slotX.x1, slotY.y2 - slotY.y1 ]), {\n                fill: { color: range.color, opacity: range.opacity },\n                stroke: { }\n            }));\n        }\n\n        return elements;\n    }\n\n    renderLabels() {\n        const { labels, options } = this;\n        const elements = new linear_scale_Group();\n\n        for (let i = 0; i < labels.length; i++) {\n            elements.append(buildLabelElement(labels[i], options.labels));\n        }\n\n        return elements;\n    }\n\n    renderLine() {\n        const line = this.options.line;\n        const lineBox = this.lineBox();\n        const elements = new linear_scale_Group();\n\n        if (line.width > 0 && line.visible) {\n            const linePath = new linear_scale_Path({\n                stroke: {\n                    color: line.color,\n                    dashType: line.dashType,\n                    width: line.width\n                }\n            });\n\n            linePath.moveTo(lineBox.x1, lineBox.y1).lineTo(lineBox.x2, lineBox.y2);\n            elements.append(linePath);\n        }\n\n        return elements;\n    }\n\n    renderTicks() {\n        const ticks = new linear_scale_Group();\n        const options = this.options;\n        const majorUnit = options.majorTicks.visible ? options.majorUnit : 0;\n        const tickRenderOptions = {\n            vertical: options.vertical,\n            mirror: options.labels.mirror,\n            lineBox: this.lineBox()\n        };\n\n        renderTicks(ticks, this.getMajorTickPositions(), tickRenderOptions, options.majorTicks);\n        renderTicks(ticks, this.getMinorTickPositions(), tickRenderOptions, deepExtend({}, {\n            skipUnit: majorUnit / options.minorUnit\n        }, options.minorTicks));\n\n        return ticks;\n    }\n}\n\nsetDefaultOptions(linear_scale_LinearScale, {\n    min: 0,\n    max: 50,\n\n    majorTicks: {\n        size: 15,\n        align: constants_INSIDE,\n        color: BLACK,\n        width: DEFAULT_LINE_WIDTH,\n        visible: true\n    },\n\n    minorTicks: {\n        size: 10,\n        align: constants_INSIDE,\n        color: BLACK,\n        width: DEFAULT_LINE_WIDTH,\n        visible: true\n    },\n\n    line: {\n        width: DEFAULT_LINE_WIDTH\n    },\n\n    labels: {\n        position: constants_INSIDE,\n        padding: 2\n    },\n    mirror: false,\n    _alignLines: false\n});\n\n/* harmony default export */ var linear_scale = (linear_scale_LinearScale);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/gauges/pointer.js\n\n\n\nclass pointer_Pointer extends common_class[\"a\" /* default */] {\n    constructor(scale, userOptions) {\n        super();\n\n        const { min, max } = scale.options;\n        const options = this.options = deepExtend({}, this.options, userOptions);\n\n        options.fill = options.color;\n\n        this.scale = scale;\n\n        if (defined(options.value)) {\n            options.value = limitValue(options.value, min, max);\n        } else {\n            options.value = min;\n        }\n    }\n\n    value(newValue) {\n        const options = this.options;\n        const value = options.value;\n\n        if (arguments.length === 0) {\n            return value;\n        }\n\n        const { min, max } = this.scale.options;\n\n        options._oldValue = defined(options._oldValue) ? options.value : min;\n        options.value = limitValue(newValue, min, max);\n\n        if (this.elements) {\n            this.repaint();\n        }\n    }\n}\n\nsetDefaultOptions(pointer_Pointer, {\n    color: BLACK\n});\n\n/* harmony default export */ var gauges_pointer = (pointer_Pointer);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/gauges/linear/linear-pointer.js\n\n\n\n\n\n\nclass linear_pointer_LinearPointer extends gauges_pointer {\n    constructor(scale, options) {\n        super(scale, options);\n\n        this.options = deepExtend({\n            track: {\n                visible: defined(options.track)\n            }\n        }, this.options);\n    }\n\n    reflow() {\n        const { options, scale } = this;\n        const { mirror, vertical } = scale.options;\n        const scaleLine = scale.lineBox();\n        const trackSize = options.track.size || options.size;\n        const pointerHalfSize = options.size / 2;\n        const margin = getSpacing(options.margin);\n        let space = vertical ?\n                 margin[mirror ? \"left\" : \"right\"] :\n                 margin[mirror ? \"bottom\" : \"top\"];\n        let pointerBox, pointerRangeBox, trackBox;\n\n        space = mirror ? -space : space;\n\n        if (vertical) {\n            trackBox = new core_box(\n                scaleLine.x1 + space, scaleLine.y1,\n                scaleLine.x1 + space, scaleLine.y2);\n\n            if (mirror) {\n                trackBox.x1 -= trackSize;\n            } else {\n                trackBox.x2 += trackSize;\n            }\n\n            if (options.shape !== BAR_POINTER) {\n                pointerRangeBox = new core_box(\n                    scaleLine.x2 + space, scaleLine.y1 - pointerHalfSize,\n                    scaleLine.x2 + space, scaleLine.y2 + pointerHalfSize\n                );\n                pointerBox = pointerRangeBox;\n            }\n        } else {\n            trackBox = new core_box(\n                scaleLine.x1, scaleLine.y1 - space,\n                scaleLine.x2, scaleLine.y1 - space);\n\n            if (mirror) {\n                trackBox.y2 += trackSize;\n            } else {\n                trackBox.y1 -= trackSize;\n            }\n\n            if (options.shape !== BAR_POINTER) {\n                pointerRangeBox = new core_box(\n                    scaleLine.x1 - pointerHalfSize, scaleLine.y1 - space,\n                    scaleLine.x2 + pointerHalfSize, scaleLine.y1 - space\n                );\n                pointerBox = pointerRangeBox;\n            }\n        }\n\n        this.trackBox = trackBox;\n        this.pointerRangeBox = pointerRangeBox;\n        this.box = pointerBox || trackBox.clone().pad(options.border.width);\n    }\n\n    getElementOptions() {\n        const options = this.options;\n\n        return {\n            fill: {\n                color: options.color,\n                opacity: options.opacity\n            },\n            stroke: defined(options.border) ? {\n                color: options.border.width ? options.border.color || options.color : \"\",\n                width: options.border.width,\n                dashType: options.border.dashType,\n                opacity: options.opacity\n            } : null\n        };\n    }\n\n    _margin() {\n        const { scale, options } = this;\n        const { mirror, vertical } = scale.options;\n        const margin = getSpacing(options.margin);\n\n        const space = vertical ?\n            margin[mirror ? \"left\" : \"right\"] :\n            margin[mirror ? \"bottom\" : \"top\"];\n\n        return space;\n    }\n}\n\nsetDefaultOptions(linear_pointer_LinearPointer, {\n    shape: BAR_POINTER,\n\n    track: {\n        border: {\n            width: 1\n        }\n    },\n\n    color: BLACK,\n    border: {\n        width: 1\n    },\n    opacity: 1,\n\n    margin: getSpacing(3),\n    animation: {\n        type: BAR_POINTER\n    },\n    visible: true\n});\n\n/* harmony default export */ var linear_pointer = (linear_pointer_LinearPointer);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/gauges/linear/arrow-linear-pointer-animation.js\n\n\n\n\nclass arrow_linear_pointer_animation_ArrowLinearPointerAnimation extends main[\"a\" /* drawing */].Animation {\n\n    setup() {\n        const options = this.options;\n        const { margin, from, to, vertical } = options;\n        const axis = vertical ? \"x1\" : \"y1\";\n\n        if (options.mirror === vertical) {\n            from[axis] -= margin; to[axis] -= margin;\n        } else {\n            from[axis] += margin; to[axis] += margin;\n        }\n\n        const fromScale = this.fromScale = new main[\"b\" /* geometry */].Point(from.x1, from.y1);\n        const toScale = this.toScale = new main[\"b\" /* geometry */].Point(to.x1, to.y1);\n\n        if (options.duration !== 0) {\n            options.duration = Math.max((fromScale.distanceTo(toScale) / options.duration) * 1000, 1);\n        }\n    }\n\n    step(pos) {\n        const translateX = interpolateValue(this.fromScale.x, this.toScale.x, pos);\n        const translateY = interpolateValue(this.fromScale.y, this.toScale.y, pos);\n\n        this.element.transform(main[\"b\" /* geometry */].transform().translate(translateX, translateY));\n    }\n}\n\nsetDefaultOptions(arrow_linear_pointer_animation_ArrowLinearPointerAnimation, {\n    easing: constants_LINEAR,\n    duration: LINEAR_SPEED\n});\n\nmain[\"a\" /* drawing */].AnimationFactory.current.register(ARROW_POINTER, arrow_linear_pointer_animation_ArrowLinearPointerAnimation);\n\n/* harmony default export */ var arrow_linear_pointer_animation = (arrow_linear_pointer_animation_ArrowLinearPointerAnimation);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/gauges/linear/arrow-linear-pointer.js\n\n\n\n\n\n\nconst arrow_linear_pointer_Point = main[\"b\" /* geometry */].Point;\nconst arrow_linear_pointer_Path = main[\"a\" /* drawing */].Path;\n\nclass arrow_linear_pointer_ArrowLinearPointer extends linear_pointer {\n    constructor(scale, options) {\n        super(scale, options);\n\n        if (!defined(this.options.size)) {\n            this.options.size = this.scale.options.majorTicks.size * 0.6;\n        }\n    }\n\n    pointerShape() {\n        const { scale, options: { size } } = this;\n        const halfSize = size / 2;\n        const sign = (scale.options.mirror ? -1 : 1);\n        let shape;\n\n        if (scale.options.vertical) {\n            shape = [\n                new arrow_linear_pointer_Point(0, 0 - halfSize), new arrow_linear_pointer_Point(0 - sign * size, 0), new arrow_linear_pointer_Point(0, 0 + halfSize)\n            ];\n        } else {\n            shape = [\n                new arrow_linear_pointer_Point(0 - halfSize, 0), new arrow_linear_pointer_Point(0, 0 + sign * size), new arrow_linear_pointer_Point(0 + halfSize, 0)\n            ];\n        }\n\n        return shape;\n    }\n\n    repaint() {\n        const { scale, options } = this;\n        const animation = new arrow_linear_pointer_animation(this.elements, deepExtend(options.animation, {\n            vertical: scale.options.vertical,\n            mirror: scale.options.mirror,\n            margin: this._margin(options.margin),\n            from: scale.getSlot(options._oldValue),\n            to: scale.getSlot(options.value)\n        }));\n\n        if (options.animation.transitions === false) {\n            animation.options.duration = 0;\n        }\n\n        animation.setup();\n        animation.play();\n    }\n\n    render() {\n        const { scale, options } = this;\n        const elementOptions = this.getElementOptions();\n        const shape = this.pointerShape(options.value);\n\n        options.animation.type = ARROW_POINTER;\n\n        const elements = new arrow_linear_pointer_Path({\n            stroke: elementOptions.stroke,\n            fill: elementOptions.fill\n        }).moveTo(shape[0]).lineTo(shape[1]).lineTo(shape[2]).close();\n\n        const slot = scale.getSlot(options.value);\n        elements.transform(main[\"b\" /* geometry */].transform().translate(slot.x1, slot.y1));\n\n        this.elements = elements;\n\n        return elements;\n    }\n}\n\n/* harmony default export */ var arrow_linear_pointer = (arrow_linear_pointer_ArrowLinearPointer);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/gauges/linear/bar-linear-pointer-animation.js\n\n\n\n\n\nclass bar_linear_pointer_animation_BarLinearPointerAnimation extends main[\"a\" /* drawing */].Animation {\n\n    setup() {\n        const options = this.options;\n        const axis = this.axis = options.vertical ? Y : X;\n        const to = this.to = options.newPoints[0][axis];\n        const from = this.from = options.oldPoints[0][axis];\n\n        if (options.duration !== 0) {\n            options.duration = Math.max((Math.abs(to - from) / options.speed) * 1000, 1);\n        }\n\n        this._set(from);\n    }\n\n    step(pos) {\n        const value = interpolateValue(this.from, this.to, pos);\n        this._set(value);\n    }\n\n    _set(value) {\n        const setter = \"set\" + this.axis.toUpperCase();\n        const points = this.options.newPoints;\n\n        points[0][setter](value);\n        points[1][setter](value);\n    }\n}\n\nsetDefaultOptions(bar_linear_pointer_animation_BarLinearPointerAnimation, {\n    easing: constants_LINEAR,\n    speed: LINEAR_SPEED\n});\n\nmain[\"a\" /* drawing */].AnimationFactory.current.register(BAR_POINTER, bar_linear_pointer_animation_BarLinearPointerAnimation);\n\n/* harmony default export */ var bar_linear_pointer_animation = (bar_linear_pointer_animation_BarLinearPointerAnimation);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/gauges/linear/bar-linear-pointer.js\n\n\n\n\n\n\nconst { Group: bar_linear_pointer_Group, Path: bar_linear_pointer_Path } = main[\"a\" /* drawing */];\n\nclass bar_linear_pointer_BarLinearPointer extends linear_pointer {\n    constructor(scale, options) {\n        super(scale, options);\n\n        if (!defined(this.options.size)) {\n            this.options.size = this.scale.options.majorTicks.size * 0.3;\n        }\n    }\n\n    pointerShape(value) {\n        const { scale, options } = this;\n        const { mirror, vertical } = scale.options;\n        const dir = mirror === vertical ? -1 : 1;\n        const size = options.size * dir;\n        const minSlot = scale.getSlot(scale.options.min);\n        const slot = scale.getSlot(value);\n        const axis = vertical ? Y : X;\n        const sizeAxis = vertical ? X : Y;\n        const margin = this._margin() * dir;\n\n        const p1 = new main[\"b\" /* geometry */].Point();\n        p1[axis] = minSlot[axis + \"1\"];\n        p1[sizeAxis] = minSlot[sizeAxis + \"1\"];\n\n        const p2 = new main[\"b\" /* geometry */].Point();\n        p2[axis] = slot[axis + \"1\"];\n        p2[sizeAxis] = slot[sizeAxis + \"1\"];\n\n        if (vertical) {\n            p1.translate(margin, 0);\n            p2.translate(margin, 0);\n        } else {\n            p1.translate(0, margin);\n            p2.translate(0, margin);\n        }\n\n        const p3 = p2.clone();\n        const p4 = p1.clone();\n\n        if (vertical) {\n            p3.translate(size, 0);\n            p4.translate(size, 0);\n        } else {\n            p3.translate(0, size);\n            p4.translate(0, size);\n        }\n\n        return [ p1, p2, p3, p4 ];\n    }\n\n    repaint() {\n        const { scale, options } = this;\n        const shape = this.pointerShape(options.value);\n        const pointerPath = this.pointerPath;\n        const oldShape = this.pointerShape(options._oldValue);\n\n        pointerPath.moveTo(shape[0]).lineTo(shape[1]).lineTo(shape[2]).lineTo(shape[3]).close();\n\n        const animation = new bar_linear_pointer_animation(pointerPath, deepExtend(options.animation, {\n            reverse: scale.options.reverse,\n            vertical: scale.options.vertical,\n            oldPoints: [ oldShape[1], oldShape[2] ],\n            newPoints: [ shape[1], shape[2] ]\n        }));\n\n        if (options.animation.transitions === false) {\n            animation.options.duration = 0;\n        }\n\n        animation.setup();\n        animation.play();\n    }\n\n    render() {\n        const group = new bar_linear_pointer_Group();\n        const elementOptions = this.getElementOptions();\n\n        if (this.options.track.visible) {\n            group.append(this.renderTrack());\n        }\n\n        const pointer = this.pointerPath = new bar_linear_pointer_Path({\n            stroke: elementOptions.stroke,\n            fill: elementOptions.fill\n        });\n\n        group.append(pointer);\n\n        this.elements = group;\n\n        return group;\n    }\n\n    renderTrack() {\n        const trackOptions = this.options.track;\n        const border = trackOptions.border || {};\n        const trackBox = this.trackBox.clone().pad(border.width || 0);\n\n        return new bar_linear_pointer_Path.fromRect(trackBox.toRect(), {\n            fill: {\n                color: trackOptions.color,\n                opacity: trackOptions.opacity\n            },\n            stroke: {\n                color: border.width ? border.color || trackOptions.color : \"\",\n                width: border.width,\n                dashType: border.dashType\n            }\n        });\n    }\n}\n\n/* harmony default export */ var bar_linear_pointer = (bar_linear_pointer_BarLinearPointer);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/gauges/linear/linear-gauge.js\n\n\n\n\n\n\n\n\n\nconst DEFAULT_MIN_WIDTH = 60;\nconst DEFAULT_MIN_HEIGHT = 60;\n\nconst linear_gauge_Group = main[\"a\" /* drawing */].Group;\n\nclass linear_gauge_LinearGauge extends gauge {\n\n    reflow(bbox) {\n        const pointers = this.pointers;\n        const bboxX = bbox.origin.x;\n        const bboxY = bbox.origin.y;\n\n        const box = new core_box(bboxX, bboxY, bboxX + bbox.width(), bboxY + bbox.height());\n\n        this.scale.reflow(box);\n        this._shrinkScaleWidth(box);\n\n        for (let i = 0; i < pointers.length; i++) {\n            pointers[i].reflow();\n        }\n\n        this.bbox = this._getBox(box);\n        this._alignElements();\n        this._shrinkElements();\n        this._buildVisual();\n        this._draw();\n    }\n\n    _buildVisual() {\n        const visuals = new linear_gauge_Group();\n        const scaleElements = this.scale.render();\n        const pointers = this.pointers;\n\n        visuals.append(this.gaugeArea);\n        visuals.append(scaleElements);\n\n        for (let i = 0; i < pointers.length; i++) {\n            const current = pointers[i];\n            visuals.append(current.render());\n            current.value(current.options.value);\n        }\n\n        this._visuals = visuals;\n    }\n\n    _createModel() {\n        const options = this.options;\n        const scale = this.scale = new linear_scale(options.scale, this.contextService);\n\n        this.pointers = [];\n\n        let pointers = options.pointer;\n        pointers = isArray(pointers) ? pointers : [ pointers ];\n\n        for (let i = 0; i < pointers.length; i++) {\n            const currentOptions = deepExtend({}, pointers[i], {\n                animation: {\n                    transitions: options.transitions\n                }\n            });\n            const pointerType = currentOptions.shape === ARROW ? arrow_linear_pointer : bar_linear_pointer;\n\n            this.pointers.push(new pointerType(scale, currentOptions));\n        }\n    }\n\n    _defaultSize() {\n        const vertical = this.options.scale.vertical;\n\n        return {\n            width: vertical ? DEFAULT_MIN_WIDTH : constants_DEFAULT_WIDTH,\n            height: vertical ? constants_DEFAULT_HEIGHT : DEFAULT_MIN_HEIGHT\n        };\n    }\n\n    _getBox(box) {\n        const { scale, pointers } = this;\n        const boxCenter = box.center();\n        let plotAreaBox = pointers[0].box.clone().wrap(scale.box);\n\n        for (let i = 0; i < pointers.length; i++) {\n            plotAreaBox.wrap(pointers[i].box.clone());\n        }\n\n        let size;\n        if (scale.options.vertical) {\n            size = plotAreaBox.width() / 2;\n            plotAreaBox = new core_box(\n                boxCenter.x - size, box.y1,\n                boxCenter.x + size, box.y2\n            );\n        } else {\n            size = plotAreaBox.height() / 2;\n            plotAreaBox = new core_box(\n                box.x1, boxCenter.y - size,\n                box.x2, boxCenter.y + size\n            );\n        }\n\n        return plotAreaBox;\n    }\n\n    _alignElements() {\n        const { scale, pointers } = this;\n        const scaleBox = scale.box;\n        const box = pointers[0].box.clone().wrap(scale.box);\n        const plotAreaBox = this.bbox;\n\n        for (let i = 0; i < pointers.length; i++) {\n            box.wrap(pointers[i].box.clone());\n        }\n\n        let diff;\n        if (scale.options.vertical) {\n            diff = plotAreaBox.center().x - box.center().x;\n            scale.reflow(new core_box(\n                scaleBox.x1 + diff, plotAreaBox.y1,\n                scaleBox.x2 + diff, plotAreaBox.y2\n            ));\n        } else {\n            diff = plotAreaBox.center().y - box.center().y;\n            scale.reflow(new core_box(\n                scaleBox.x1, scaleBox.y1 + diff,\n                scaleBox.x2, scaleBox.y2 + diff\n            ));\n        }\n\n        for (let i = 0; i < pointers.length; i++) {\n            pointers[i].reflow(this.bbox);\n        }\n    }\n\n    _shrinkScaleWidth(bbox) {\n        const { scale } = this;\n        if (!scale.options.vertical) {\n            const overflow = scale.contentBox().width() - bbox.width();\n            if (overflow > 0) {\n                scale.box.shrink(overflow, 0);\n                scale.box.alignTo(bbox, 'center');\n                scale.reflow(scale.box);\n            }\n        }\n    }\n\n    _shrinkElements() {\n        const { scale, pointers } = this;\n        const scaleBox = scale.box.clone();\n        const pos = scale.options.vertical ? \"y\" : \"x\";\n        const pointerBox = pointers[0].box;\n\n        for (let i = 0; i < pointers.length; i++) {\n            pointerBox.wrap(pointers[i].box.clone());\n        }\n\n        scaleBox[pos + 1] += Math.max(scaleBox[pos + 1] - pointerBox[pos + 1], 0);\n        scaleBox[pos + 2] -= Math.max(pointerBox[pos + 2] - scaleBox[pos + 2], 0);\n\n        scale.reflow(scaleBox);\n\n        for (let i = 0; i < pointers.length; i++) {\n            pointers[i].reflow(this.bbox);\n        }\n    }\n}\n\nsetDefaultOptions(linear_gauge_LinearGauge, {\n    transitions: true,\n    gaugeArea: {\n        background: \"\"\n    },\n    scale: {\n        vertical: true\n    }\n});\n\n/* harmony default export */ var linear_gauge = (linear_gauge_LinearGauge);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/gauges/radial/radial-scale.js\n\n\n\n\n\n\n\n\nconst GEO_ARC_ADJUST_ANGLE = 180;\n\nconst { Arc, Path: radial_scale_Path, Group: radial_scale_Group } = main[\"a\" /* drawing */];\n\nfunction drawTicks(arc, tickAngles, unit, tickOptions) {\n    const ticks = new radial_scale_Group();\n    const center = arc.center;\n    const radius = arc.getRadiusX();\n\n    if (tickOptions.visible) {\n        for (let i = 0; i < tickAngles.length; i++) {\n            const tickStart = arc.pointAt(tickAngles[i]);\n            const tickEnd = new main[\"b\" /* geometry */].Point(center.x + radius - tickOptions.size, center.y).rotate(tickAngles[i], center);\n\n            ticks.append(new radial_scale_Path({\n                stroke: {\n                    color: tickOptions.color,\n                    width: tickOptions.width\n                }\n            }).moveTo(tickStart).lineTo(tickEnd));\n        }\n    }\n\n    return ticks;\n}\n\nfunction rangeSegment(from, to, color, opacity) {\n    return { from: from, to: to, color: color, opacity: opacity };\n}\n\nclass radial_scale_RadialScale extends numeric_axis {\n    constructor(options, service) {\n        super(0, 1, options, service);\n    }\n\n    initUserOptions(options) {\n        const scaleOptions = deepExtend({}, this.options, options);\n        scaleOptions.majorUnit = scaleOptions.majorUnit || autoMajorUnit(scaleOptions.min, scaleOptions.max);\n        scaleOptions.minorUnit = scaleOptions.minorUnit || scaleOptions.majorUnit / 10;\n\n        return scaleOptions;\n    }\n\n    initFields() {\n    }\n\n    render(center, radius) {\n        const arc = this.renderArc(center, radius);\n\n        this.bbox = arc.bbox();\n        this.labelElements = this.renderLabels();\n        this.ticks = this.renderTicks();\n        this.ranges = this.renderRanges();\n    }\n\n    reflow(bbox) {\n        const center = bbox.center();\n        const radius = Math.min(bbox.height(), bbox.width()) / 2;\n\n        if (defined(this.bbox)) {\n            this.bbox = this.arc.bbox();\n            this.radius(this.arc.getRadiusX());\n            this.repositionRanges();\n            this.renderLabels();\n        } else {\n            return this.render(center, radius);\n        }\n    }\n\n    slotAngle(value) {\n        const { min, max, reverse, startAngle, endAngle } = this.options;\n        const angle = endAngle - startAngle;\n        let result;\n\n        if (reverse) {\n            result = endAngle - (value - min) / (max - min) * angle;\n        } else {\n            result = ((value - min) / (max - min) * angle) + startAngle;\n        }\n\n        return result + GEO_ARC_ADJUST_ANGLE;\n    }\n\n    hasRanges() {\n        const ranges = this.options.ranges;\n\n        return ranges && ranges.length;\n    }\n\n    ticksSize() {\n        const { majorTicks, minorTicks } = this.options;\n        let size = 0;\n        if (majorTicks.visible) {\n            size = majorTicks.size;\n        }\n\n        if (minorTicks.visible) {\n            size = Math.max(minorTicks.size, size);\n        }\n\n        return size;\n    }\n\n    labelsCount() {\n        let count = super.labelsCount();\n        const options = this.options;\n        const angle = options.endAngle - options.startAngle;\n\n        if (angle >= 360 && (options.max % options.majorUnit === 0)) {\n            count -= 1;\n        }\n\n        return count;\n    }\n\n    renderLabels() {\n        const options = this.options;\n        const arc = this.arc.clone();\n        let radius = arc.getRadiusX();\n        const tickAngles = this.tickAngles(arc, options.majorUnit);\n        const rangeSize = options.rangeSize = options.rangeSize || radius * 0.1;\n        const labelsGroup = new radial_scale_Group();\n\n        let rangeDistance = radius * 0.05;\n        if (defined(options.rangeDistance)) {\n            rangeDistance = options.rangeDistance;\n        } else {\n            options.rangeDistance = rangeDistance;\n        }\n\n        const labelsOptions = options.labels;\n        const isInside = labelsOptions.position === constants_INSIDE;\n        const hasLabelElements = defined(this.labelElements);\n\n        if (isInside) {\n            radius -= this.ticksSize();\n\n            if (this.hasRanges() && !hasLabelElements) {\n                radius -= rangeSize + rangeDistance;\n            }\n            arc.setRadiusX(radius).setRadiusY(radius);\n        }\n\n        const labels = this.labels;\n        const count = labels.length;\n        const padding = getSpacing(labelsOptions.padding);\n        const paddingWidth = (padding.left + padding.right) / 2;\n        const paddingHeight = (padding.top + padding.bottom) / 2;\n\n        for (let i = 0; i < count; i++) {\n            const label = labels[i];\n            const halfWidth = label.box.width() / 2;\n            const halfHeight = label.box.height() / 2;\n            const angle = tickAngles[i];\n            const labelAngle = (angle - GEO_ARC_ADJUST_ANGLE) * DEGREE;\n\n            const lp = arc.pointAt(angle);\n            const cx = lp.x + (Math.cos(labelAngle) * (halfWidth + paddingWidth) * (isInside ? 1 : -1));\n            const cy = lp.y + (Math.sin(labelAngle) * (halfHeight + paddingHeight) * (isInside ? 1 : -1));\n\n            label.reflow(new core_box(cx - halfWidth, cy - halfHeight, cx + halfWidth, cy + halfHeight));\n            const labelPos = new main[\"b\" /* geometry */].Point(label.box.x1, label.box.y1);\n\n            let labelElement;\n            if (!hasLabelElements) {\n                labelElement = buildLabelElement(label, options.labels);\n                labelsGroup.append(labelElement);\n            } else {\n                labelElement = this.labelElements.children[i];\n                const prevLabelPos = labelElement.bbox().origin;\n\n                const labelTransform = labelElement.transform() || main[\"b\" /* geometry */].transform();\n                labelTransform.translate(labelPos.x - prevLabelPos.x, labelPos.y - prevLabelPos.y);\n                labelElement.transform(labelTransform);\n            }\n\n            this.bbox = main[\"b\" /* geometry */].Rect.union(this.bbox, labelElement.bbox());\n        }\n\n        return labelsGroup;\n    }\n\n    repositionRanges() {\n        const ranges = this.ranges.children;\n\n        if (ranges.length > 0) {\n            const { rangeDistance, rangeSize } = this.options;\n            let rangeRadius = this.getRangeRadius();\n\n            if (this.options.labels.position === constants_INSIDE) {\n                rangeRadius += rangeSize + rangeDistance;\n            }\n\n            const newRadius = rangeRadius + (rangeSize / 2);\n\n            for (let i = 0; i < ranges.length; i++) {\n                ranges[i]._geometry.setRadiusX(newRadius).setRadiusY(newRadius);\n            }\n\n            this.bbox = main[\"b\" /* geometry */].Rect.union(this.bbox, this.ranges.bbox());\n        }\n    }\n\n    renderRanges() {\n        const segments = this.rangeSegments();\n        const segmentsCount = segments.length;\n        const result = new radial_scale_Group();\n\n        if (segmentsCount) {\n            const { rangeSize, reverse, rangeDistance } = this.options;\n            const rangeRadius = this.getRangeRadius();\n\n            // move the ticks with a range distance and a range size\n            this.radius(this.radius() - rangeSize - rangeDistance);\n\n            for (let i = 0; i < segmentsCount; i++) {\n                const segment = segments[i];\n                const from = this.slotAngle(segment[reverse ? \"to\" : \"from\"]);\n                const to = this.slotAngle(segment[!reverse ? \"to\" : \"from\"]);\n\n                if (to - from !== 0) {\n                    result.append(this.createRange(from, to, rangeRadius, segment));\n                }\n            }\n        }\n\n        return result;\n    }\n\n    createRange(startAngle, endAngle, rangeRadius, options) {\n        const rangeSize = this.options.rangeSize;\n        const rangeGeom = new main[\"b\" /* geometry */].Arc(this.arc.center, {\n            radiusX: rangeRadius + (rangeSize / 2),\n            radiusY: rangeRadius + (rangeSize / 2),\n            startAngle: startAngle,\n            endAngle: endAngle\n        });\n\n        return new Arc(rangeGeom, {\n            stroke: {\n                width: rangeSize,\n                color: options.color,\n                opacity: options.opacity,\n                lineCap: options.lineCap\n            }\n        });\n    }\n\n    rangeSegments() {\n        const options = this.options;\n        const ranges = options.ranges || [];\n        const count = ranges.length;\n        const segments = [];\n\n        if (count) {\n            const { min, max, rangePlaceholderColor: defaultColor } = options;\n            segments.push(rangeSegment(min, max, defaultColor));\n\n            for (let i = 0; i < count; i++) {\n                const range = getRange(ranges[i], min, max);\n                const segmentsCount = segments.length;\n\n                for (let j = 0; j < segmentsCount; j++) {\n                    const segment = segments[j];\n\n                    if (segment.from <= range.from && range.from <= segment.to) {\n                        segments.push(rangeSegment(range.from, range.to, range.color, range.opacity));\n\n                        if (segment.from <= range.to && range.to <= segment.to) {\n                            segments.push(rangeSegment(range.to, segment.to, defaultColor, range.opacity));\n                        }\n\n                        segment.to = range.from;\n\n                        break;\n                    }\n                }\n            }\n        }\n\n        return segments;\n    }\n\n    getRangeRadius() {\n        const { arc, options } = this;\n        const { rangeSize, rangeDistance, majorTicks: { size: majorTickSize } } = options;\n        let radius;\n\n        if (options.labels.position === constants_OUTSIDE) {\n            radius = arc.getRadiusX() - majorTickSize - rangeDistance - rangeSize;\n        } else {\n            radius = arc.getRadiusX() - rangeSize;\n        }\n\n        return radius;\n    }\n\n    renderArc(center, radius) {\n        const options = this.options;\n\n        const arc = this.arc = new main[\"b\" /* geometry */].Arc(center, {\n            radiusX: radius,\n            radiusY: radius,\n            startAngle: options.startAngle + GEO_ARC_ADJUST_ANGLE,\n            endAngle: options.endAngle + GEO_ARC_ADJUST_ANGLE\n        });\n\n        return arc;\n    }\n\n    renderTicks() {\n        const { arc, options } = this;\n        const tickArc = arc.clone();\n\n        this.majorTickAngles = this.tickAngles(arc, options.majorUnit);\n        this.majorTicks = drawTicks(tickArc, this.majorTickAngles, options.majorUnit, options.majorTicks);\n\n        const allTicks = new radial_scale_Group();\n        allTicks.append(this.majorTicks);\n\n        const majorTickSize = options.majorTicks.size;\n        const minorTickSize = options.minorTicks.size;\n\n        this._tickDifference = majorTickSize - minorTickSize;\n\n        if (options.labels.position === constants_OUTSIDE) {\n            const radius = tickArc.getRadiusX();\n            tickArc.setRadiusX(radius - majorTickSize + minorTickSize)\n                   .setRadiusY(radius - majorTickSize + minorTickSize);\n        }\n\n        this.minorTickAngles = this.normalizeTickAngles(this.tickAngles(arc, options.minorUnit));\n        this.minorTicks = drawTicks(tickArc, this.minorTickAngles, options.minorUnit, options.minorTicks);\n        allTicks.append(this.minorTicks);\n\n        return allTicks;\n    }\n\n    normalizeTickAngles(angles) {\n        const options = this.options;\n        const skip = options.majorUnit / options.minorUnit;\n\n        for (let i = angles.length - 1; i >= 0; i--) {\n            if (i % skip === 0) {\n                angles.splice(i, 1);\n            }\n        }\n\n        return angles;\n    }\n\n    tickAngles(ring, stepValue) {\n        const options = this.options;\n        const reverse = options.reverse;\n        const range = options.max - options.min;\n        const angle = ring.endAngle - ring.startAngle;\n        let tickCount = range / stepValue;\n        let pos = ring.startAngle;\n        let step = angle / tickCount;\n\n        if (reverse) {\n            pos += angle;\n            step = -step;\n        }\n\n        if (angle >= 360 && (options.max % stepValue === 0)) {\n            tickCount -= 1;\n        }\n\n        const positions = [];\n        for (let i = 0; i < tickCount; i++) {\n            positions.push(round(pos, COORD_PRECISION));\n            pos += step;\n        }\n\n        if (round(pos) <= ring.endAngle) {\n            positions.push(pos);\n        }\n\n        return positions;\n    }\n\n    radius(value) {\n        if (value) {\n            this.arc.setRadiusX(value).setRadiusY(value);\n            this.repositionTicks(this.majorTicks.children, this.majorTickAngles);\n            this.repositionTicks(this.minorTicks.children, this.minorTickAngles, true);\n        } else {\n            return this.arc.getRadiusX();\n        }\n    }\n\n    repositionTicks(ticks, tickAngles, minor) {\n        const diff = minor ? (this._tickDifference || 0) : 0;\n        let tickArc = this.arc;\n        const radius = tickArc.getRadiusX();\n\n        if (minor && this.options.labels.position === constants_OUTSIDE && diff !== 0) {\n            tickArc = this.arc.clone();\n            tickArc.setRadiusX(radius - diff).setRadiusY(radius - diff);\n        }\n\n        for (let i = 0; i < ticks.length; i++) {\n            const newPoint = tickArc.pointAt(tickAngles[i]);\n            const segments = ticks[i].segments;\n            const xDiff = newPoint.x - segments[0].anchor().x;\n            const yDiff = newPoint.y - segments[0].anchor().y;\n\n            ticks[i].transform(new main[\"b\" /* geometry */].transform().translate(xDiff, yDiff));\n        }\n    }\n}\n\nsetDefaultOptions(radial_scale_RadialScale, {\n    min: 0,\n    max: 100,\n\n    majorTicks: {\n        size: 15,\n        align: constants_INSIDE,\n        color: BLACK,\n        width: DEFAULT_LINE_WIDTH,\n        visible: true\n    },\n\n    minorTicks: {\n        size: 10,\n        align: constants_INSIDE,\n        color: BLACK,\n        width: DEFAULT_LINE_WIDTH,\n        visible: true\n    },\n\n    startAngle: -30,\n    endAngle: 210,\n\n    labels: {\n        position: constants_INSIDE,\n        padding: 2\n    }\n});\n\n/* harmony default export */ var radial_scale = (radial_scale_RadialScale);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/gauges/radial/radial-pointer-animation.js\n\n\n\n\nclass radial_pointer_animation_RadialPointerAnimation extends main[\"a\" /* drawing */].Animation {\n    constructor(element, options) {\n        super(element, options);\n\n        const animationOptions = this.options;\n\n        animationOptions.duration = Math.max((Math.abs(animationOptions.newAngle - animationOptions.oldAngle) / animationOptions.duration) * 1000, 1);\n    }\n\n    step(pos) {\n        const options = this.options;\n        const angle = interpolateValue(options.oldAngle, options.newAngle, pos);\n\n        this.element.transform(main[\"b\" /* geometry */].transform().rotate(angle, options.center));\n    }\n}\n\nsetDefaultOptions(radial_pointer_animation_RadialPointerAnimation, {\n    easing: constants_LINEAR,\n    duration: ANGULAR_SPEED\n});\n\nmain[\"a\" /* drawing */].AnimationFactory.current.register(RADIAL_POINTER, radial_pointer_animation_RadialPointerAnimation);\n\n/* harmony default export */ var radial_pointer_animation = (radial_pointer_animation_RadialPointerAnimation);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/gauges/radial/radial-pointer.js\n\n\n\n\n\n\n\nconst CAP_SIZE = 0.05;\nconst { Circle, Group: radial_pointer_Group, Path: radial_pointer_Path } = main[\"a\" /* drawing */];\n\nclass radial_pointer_RadialPointer extends gauges_pointer {\n\n    setAngle(angle) {\n        this.elements.transform(main[\"b\" /* geometry */].transform().rotate(angle, this.center));\n    }\n\n    repaint() {\n        const { scale, options } = this;\n        const oldAngle = scale.slotAngle(options._oldValue);\n        const newAngle = scale.slotAngle(options.value);\n\n        if (options.animation.transitions === false) {\n            this.setAngle(newAngle);\n        } else {\n            new radial_pointer_animation(this.elements, deepExtend(options.animation, {\n                oldAngle: oldAngle,\n                newAngle: newAngle\n            })).play();\n        }\n    }\n\n    render() {\n        const { scale, options } = this;\n        const elements = new radial_pointer_Group();\n\n        if (options.animation !== false) {\n            deepExtend(options.animation, {\n                startAngle: 0,\n                center: scale.arc.center,\n                reverse: scale.options.reverse\n            });\n        }\n\n        elements.append(this._renderNeedle(), this._renderCap());\n\n        this.elements = elements;\n        this.setAngle(DEGREE);\n\n        return elements;\n    }\n\n    reflow(arc) {\n        const center = this.center = arc.center;\n        const length = limitValue(this.options.length || 1, 0.1, 1.5);\n        const radius = this.radius = arc.getRadiusX() * length;\n        const capSize = this.capSize = Math.round(radius * this.options.cap.size);\n\n        this.bbox = main[\"b\" /* geometry */].Rect.fromPoints(new main[\"b\" /* geometry */].Point(center.x - capSize, center.y - capSize),\n                                    new main[\"b\" /* geometry */].Point(center.x + capSize, center.y + capSize));\n    }\n\n    _renderNeedle() {\n        const minorTickSize = this.scale.options.minorTicks.size;\n        const center = this.center;\n        const needleColor = this.options.color;\n\n        const needlePath = new radial_pointer_Path({\n            fill: { color: needleColor },\n            stroke: { color: needleColor, width: DEFAULT_LINE_WIDTH }\n        });\n\n        needlePath.moveTo(center.x + this.radius - minorTickSize, center.y)\n                  .lineTo(center.x, center.y - (this.capSize / 2))\n                  .lineTo(center.x, center.y + (this.capSize / 2))\n                  .close();\n\n        return needlePath;\n    }\n\n    _renderCap() {\n        const options = this.options;\n        const capColor = options.cap.color || options.color;\n        const circle = new main[\"b\" /* geometry */].Circle(this.center, this.capSize);\n\n        const cap = new Circle(circle, {\n            fill: { color: capColor },\n            stroke: { color: capColor }\n        });\n\n        return cap;\n    }\n}\n\nsetDefaultOptions(radial_pointer_RadialPointer, {\n    cap: {\n        size: CAP_SIZE\n    },\n    arrow: {\n        width: 16,\n        height: 14\n    },\n    animation: {\n        type: RADIAL_POINTER,\n        duration: ANGULAR_SPEED\n    }\n});\n\n/* harmony default export */ var radial_pointer = (radial_pointer_RadialPointer);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/gauges/radial/radial-gauge.js\n\n\n\n\n\n\n\nconst radial_gauge_Group = main[\"a\" /* drawing */].Group;\n\nclass radial_gauge_RadialGauge extends gauge {\n\n    reflow(bbox) {\n        const pointers = this.pointers;\n        this.scale.reflow(bbox);\n        this._initialPlotArea = this.scale.bbox;\n\n        for (let i = 0; i < pointers.length; i++) {\n            pointers[i].reflow(this.scale.arc);\n            this._initialPlotArea = main[\"b\" /* geometry */].Rect.union(this._initialPlotArea, pointers[i].bbox);\n        }\n\n        this.fitScale(bbox);\n        this.alignScale(bbox);\n        this._buildVisual(this.gaugeArea, pointers, this.scale);\n        this._draw();\n    }\n\n    _buildVisual(gaugeArea, pointers, scale) {\n        const visuals = this._visuals = new radial_gauge_Group();\n\n        visuals.append(gaugeArea);\n        visuals.append(scale.ticks);\n        visuals.append(scale.ranges);\n        this._buildPointers(pointers);\n        visuals.append(scale.labelElements);\n    }\n\n    _buildPointers(pointers) {\n        for (let i = 0; i < pointers.length; i++) {\n            const current = pointers[i];\n            current.render();\n            this._visuals.append(current.elements);\n\n            current.value(current.options.value);\n        }\n    }\n\n    fitScale(bbox) {\n        const arc = this.scale.arc;\n        const plotAreaBox = this._initialPlotArea;\n        const step = Math.abs(this.getDiff(plotAreaBox, bbox));\n        let min = round(step, COORD_PRECISION);\n        let max = round(-step, COORD_PRECISION);\n        let minDiff, midDiff, maxDiff, mid, oldDiff;\n        let staleFlag = 0;\n        let i = 0;\n\n        while (i++ < 100) {\n            staleFlag = (oldDiff === maxDiff) ? (staleFlag + 1) : 0;\n\n            if (staleFlag > 5) {\n                break;\n            }\n\n            if (min !== mid) {\n                minDiff = this.getPlotBox(min, bbox, arc);\n                if (0 <= minDiff && minDiff <= 2) {\n                    break;\n                }\n            }\n\n            if (max !== mid) {\n                maxDiff = this.getPlotBox(max, bbox, arc);\n                if (0 <= maxDiff && maxDiff <= 2) {\n                    break;\n                }\n            }\n\n            if (minDiff > 0 && maxDiff > 0) {\n                mid = min * 2;\n            } else if (minDiff < 0 && maxDiff < 0) {\n                mid = max * 2;\n            } else {\n                mid = round(((min + max) / 2) || 1, COORD_PRECISION);\n            }\n\n            midDiff = this.getPlotBox(mid, bbox, arc);\n            if (0 <= midDiff && midDiff <= 2) {\n                break;\n            }\n\n            oldDiff = maxDiff;\n\n            if (midDiff > 0) {\n                max = mid;\n                maxDiff = midDiff;\n            } else {\n                min = mid;\n                minDiff = midDiff;\n            }\n        }\n    }\n\n    getPlotBox(step, bbox, arc) {\n        const scale = this.scale;\n        const pointers = this.pointers;\n        const radius = arc.getRadiusX();\n        const scaleArc = arc.clone();\n\n        scaleArc.setRadiusX(radius + step).setRadiusY(radius + step);\n\n        scale.arc = scaleArc;\n        scale.reflow(bbox);\n        this.plotBbox = scale.bbox;\n\n        for (let i = 0; i < pointers.length; i++) {\n            pointers[i].reflow(scaleArc);\n            this.plotBbox = main[\"b\" /* geometry */].Rect.union(this.plotBbox, pointers[i].bbox);\n        }\n\n        return this.getDiff(this.plotBbox, bbox);\n    }\n\n    getDiff(plotBox, box) {\n        return Math.min(box.width() - plotBox.width(), box.height() - plotBox.height());\n    }\n\n    alignScale(bbox) {\n        const plotBoxCenter = this.plotBbox.center();\n        const boxCenter = bbox.center();\n        const paddingX = plotBoxCenter.x - boxCenter.x;\n        const paddingY = plotBoxCenter.y - boxCenter.y;\n        const { scale, pointers } = this;\n\n        scale.arc.center.x -= paddingX;\n        scale.arc.center.y -= paddingY;\n\n        scale.reflow(bbox);\n\n        for (let i = 0; i < pointers.length; i++) {\n            pointers[i].reflow(scale.arc);\n            this.plotBbox = main[\"b\" /* geometry */].Rect.union(scale.bbox, pointers[i].bbox);\n        }\n    }\n\n    _createModel() {\n        const options = this.options;\n        const pointers = options.pointer;\n        const scale = this.scale = new radial_scale(options.scale, this.contextService);\n\n        this.pointers = [];\n\n        const pointersArr = isArray(pointers) ? pointers : [ pointers ];\n        for (let i = 0; i < pointersArr.length; i++) {\n            const current = new radial_pointer(scale, deepExtend({}, pointersArr[i], {\n                animation: {\n                    transitions: options.transitions\n                }\n            }));\n\n            this.pointers.push(current);\n        }\n    }\n}\n\nsetDefaultOptions(radial_gauge_RadialGauge, {\n    transitions: true,\n    gaugeArea: {\n        background: \"\"\n    }\n});\n\n/* harmony default export */ var radial_gauge = (radial_gauge_RadialGauge);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/gauges/arc/arc-scale.js\n\n\n\nclass arc_scale_ArcScale extends radial_scale {\n\n    rangeSegments() {\n        const { min, max, rangePlaceholderColor, rangeLineCap } = this.options;\n\n        return [ { from: min, to: max, color: rangePlaceholderColor, lineCap: rangeLineCap } ];\n    }\n\n    hasRanges() {\n        return true;\n    }\n\n    placeholderRangeAngle(angle) {\n        const geometry = this.ranges.children[0].geometry();\n\n        if (this.options.reverse) {\n            geometry.setEndAngle(angle);\n        } else {\n            geometry.setStartAngle(angle);\n        }\n    }\n\n    addRange(from, to, options) {\n        const reverse = this.options.reverse;\n\n        const startAngle = this.slotAngle(reverse ? to : from);\n        const endAngle = this.slotAngle(reverse ? from : to);\n\n        const range = this.createRange(startAngle, endAngle, this.getRangeRadius(), options);\n\n        this.ranges.append(range);\n\n        return range;\n    }\n}\n\nsetDefaultOptions(arc_scale_ArcScale, {\n    min: 0,\n    max: 100,\n\n    majorTicks: {\n        visible: false\n    },\n\n    minorTicks: {\n        visible: false\n    },\n\n    labels: {\n        visible: false\n    },\n\n    startAngle: 0,\n    endAngle: 180,\n    rangeLineCap: 'round'\n});\n\n/* harmony default export */ var arc_scale = (arc_scale_ArcScale);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/gauges/arc/range-pointer-animation.js\n\n\n\n\nconst MAX_DURATION = 800;\n\nclass range_pointer_animation_RangePointerAnimation extends main[\"a\" /* drawing */].Animation {\n    constructor(element, options) {\n        super(element, options);\n\n        const animationOptions = this.options;\n        const duration = (Math.abs(animationOptions.newAngle - animationOptions.oldAngle) / animationOptions.duration) * 1000;\n        animationOptions.duration = limitValue(duration, ANGULAR_SPEED, MAX_DURATION);\n\n        const startColor = element.elements.options.get(\"stroke.color\");\n        const color = element.currentColor();\n        if (startColor !== color) {\n            this.startColor = new color_color[\"a\" /* default */](startColor);\n            this.color = new color_color[\"a\" /* default */](color);\n        }\n    }\n\n    step(pos) {\n        const { options, startColor, color } = this;\n        const angle = interpolateValue(options.oldAngle, options.newAngle, pos);\n        this.element.angle(angle);\n\n        if (color) {\n            const r = round(interpolateValue(startColor.r, color.r, pos));\n            const g = round(interpolateValue(startColor.g, color.g, pos));\n            const b = round(interpolateValue(startColor.b, color.b, pos));\n\n            this.element.stroke(new color_color[\"a\" /* default */](r, g, b).toHex());\n        }\n    }\n}\n\nsetDefaultOptions(range_pointer_animation_RangePointerAnimation, {\n    easing: constants_LINEAR,\n    duration: ANGULAR_SPEED\n});\n\nmain[\"a\" /* drawing */].AnimationFactory.current.register(RADIAL_RANGE_POINTER, range_pointer_animation_RangePointerAnimation);\n\n/* harmony default export */ var range_pointer_animation = (range_pointer_animation_RangePointerAnimation);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/gauges/arc/range-pointer.js\n\n\n\n\n\nclass range_pointer_RangePointer extends gauges_pointer {\n\n    repaint() {\n        const { scale, options } = this;\n        const oldAngle = scale.slotAngle(options._oldValue);\n        const newAngle = scale.slotAngle(options.value);\n\n        if (this.animation) {\n            this.animation.abort();\n        }\n\n        if (options.animation.transitions === false) {\n            this.angle(newAngle);\n            this.stroke(this.currentColor());\n        } else {\n            this.animation = new range_pointer_animation(this, deepExtend(options.animation, {\n                oldAngle: oldAngle,\n                newAngle: newAngle\n            }));\n\n            this.animation.play();\n        }\n    }\n\n    angle(value) {\n        const geometry = this.elements.geometry();\n        if (this.scale.options.reverse) {\n            geometry.setStartAngle(value);\n        } else {\n            geometry.setEndAngle(value);\n        }\n        this.scale.placeholderRangeAngle(value);\n    }\n\n    stroke(value) {\n        this.elements.stroke(value);\n    }\n\n    render() {\n        if (this.elements) {\n            return;\n        }\n\n        const { scale, options } = this;\n\n        if (options.animation !== false) {\n            deepExtend(options.animation, {\n                startAngle: 0,\n                center: scale.arc.center,\n                reverse: scale.options.reverse\n            });\n        }\n\n        this.elements = scale.addRange(scale.options.min, this.options.value, {\n            color: this.currentColor(),\n            opacity: options.opacity,\n            lineCap: scale.options.rangeLineCap\n        });\n    }\n\n    currentColor() {\n        const { min, max } = this.scale.options;\n        const { colors, color, value } = this.options;\n        const currentValue = isNumber(value) ? value : min;\n\n        if (colors) {\n            for (let idx = 0; idx < colors.length; idx++) {\n                const { color: rangeColor, from = min, to = max } = colors[idx];\n\n                if (from <= currentValue && currentValue <= to) {\n                    return rangeColor;\n                }\n            }\n        }\n\n        return color;\n    }\n\n    reflow() {\n        this.render();\n\n        this.bbox = this.elements.bbox();\n    }\n}\n\nsetDefaultOptions(range_pointer_RangePointer, {\n    animation: {\n        type: RADIAL_RANGE_POINTER,\n        duration: ANGULAR_SPEED\n    }\n});\n\n/* harmony default export */ var range_pointer = (range_pointer_RangePointer);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/gauges/arc/arc-gauge.js\n\n\n\n\n\n\n\nclass arc_gauge_ArcGauge extends radial_gauge {\n\n    _initTheme(theme) {\n        super._initTheme(theme);\n\n        this.options.color = this.options.color || (this.theme.pointer || {}).color;\n    }\n\n    _createModel() {\n        const options = this.options;\n        const scale = this.scale = new arc_scale(options.scale, this.contextService);\n\n        const pointer = new range_pointer(scale, deepExtend({}, {\n            colors: options.colors,\n            color: options.color,\n            value: options.value,\n            opacity: options.opacity,\n            animation: {\n                transitions: options.transitions\n            }\n        }));\n\n        this.pointers = [ pointer ];\n    }\n\n    _buildPointers(pointers) {\n        for (let i = 0; i < pointers.length; i++) {\n            const current = pointers[i];\n            current.render();\n\n            current.value(current.options.value);\n        }\n    }\n\n    _setValueOptions(value) {\n        this.options.value = value;\n    }\n\n    currentColor() {\n        const pointer = this.pointers[0];\n        if (pointer) {\n            return pointer.currentColor();\n        }\n    }\n\n    centerLabelPosition(width, height) {\n        const size = this.getSize();\n        const center = this.scale.arc.center;\n\n        let left = center.x - width / 2;\n        let top = center.y - height / 2;\n\n        if (width < size.width) {\n            const right = left + width;\n\n            left = Math.max(left, 0);\n\n            if (right > size.width) {\n                left -= right - size.width;\n            }\n        }\n\n        if (height < size.height) {\n            const bbox = this.scale.bbox;\n            const yLimit = bbox.bottomRight().y;\n            const bottom = top + height;\n\n            top = Math.max(top, bbox.origin.y);\n\n            if (bottom > yLimit) {\n                top -= bottom - yLimit;\n            }\n        }\n\n        return {\n            left: left,\n            top: top\n        };\n    }\n}\n\n/* harmony default export */ var arc_gauge = (arc_gauge_ArcGauge);\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/gauges/circular/circular-gauge.js\n\n\nconst defaultStartAngle = 90;\n\nclass circular_gauge_CircularGauge extends arc_gauge {\n    _createModel() {\n        const scaleOptions = this.options.scale;\n        if (typeof scaleOptions.startAngle !== 'number') {\n            scaleOptions.startAngle = defaultStartAngle;\n        }\n\n        scaleOptions.endAngle = scaleOptions.startAngle + 360;\n\n        super._createModel();\n    }\n}\n\n/* harmony default export */ var circular_gauge = (circular_gauge_CircularGauge);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/gauges.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/chart/base-theme.js\nconst BAR_GAP = 1.5;\nconst BAR_SPACING = 0.4;\nconst base_theme_BLACK = '#000';\nconst SANS = 'Arial, Helvetica, sans-serif';\nconst SANS11 = \"11px \" + SANS;\nconst SANS12 = '12px ' + SANS;\nconst SANS16 = '16px ' + SANS;\nconst TRANSPARENT = 'transparent';\nconst base_theme_WHITE = '#fff';\n\nconst base_theme_notes = () => ({\n    icon: {\n        border: {\n            width: 1\n        }\n    },\n    label: {\n        font: SANS12,\n        padding: 3\n    },\n    line: {\n        length: 10,\n        width: 2\n    },\n    visible: true\n});\n\nconst base_theme_axisDefaults = () => ({\n    labels: {\n        font: SANS12\n    },\n    notes: base_theme_notes(),\n    title: {\n        font: SANS16,\n        margin: 5\n    }\n});\n\nconst areaSeries = () => ({\n    highlight: {\n        markers: {\n            border: {}\n        }\n    },\n    line: {\n        opacity: 1,\n        width: 0\n    },\n    markers: {\n        size: 6,\n        visible: false\n    },\n    opacity: 0.4\n});\n\nconst rangeAreaSeries = () => ({\n    highlight: {\n        markers: {\n            border: {}\n        }\n    },\n    line: {\n        opacity: 1,\n        width: 0\n    },\n    markers: {\n        size: 6,\n        visible: false\n    },\n    opacity: 0.4\n});\n\nconst barSeries = () => ({\n    gap: BAR_GAP,\n    spacing: BAR_SPACING\n});\n\nconst boxPlotSeries = () => ({\n    outliersField: \"\",\n    meanField: \"\",\n    border: {\n        _brightness: 0.8,\n        width: 1\n    },\n    downColor: base_theme_WHITE,\n    gap: 1,\n    highlight: {\n        border: {\n            opacity: 1,\n            width: 2\n        },\n        whiskers: {\n            width: 3\n        },\n        mean: {\n            width: 2\n        },\n        median: {\n            width: 2\n        }\n    },\n    mean: {\n        width: 2\n    },\n    median: {\n        width: 2\n    },\n    spacing: 0.3,\n    whiskers: {\n        width: 2\n    }\n});\n\nconst bubbleSeries = () => ({\n    border: {\n        width: 0\n    },\n    labels: {\n        background: TRANSPARENT\n    },\n    opacity: 0.6\n});\n\nconst bulletSeries = () => ({\n    gap: BAR_GAP,\n    spacing: BAR_SPACING,\n    target: {\n        color: \"#ff0000\"\n    }\n});\n\nconst candlestickSeries = () => ({\n    border: {\n        _brightness: 0.8,\n        width: 1\n    },\n    downColor: base_theme_WHITE,\n    gap: 1,\n    highlight: {\n        border: {\n            opacity: 1,\n            width: 2\n        },\n        line: {\n            width: 2\n        }\n    },\n    line: {\n        color: base_theme_BLACK,\n        width: 1\n    },\n    spacing: 0.3\n});\n\nconst columnSeries = () => ({\n    gap: BAR_GAP,\n    spacing: BAR_SPACING\n});\n\nconst donutSeries = () => ({\n    margin: 1\n});\n\nconst lineSeries = () => ({\n    width: 2\n});\n\nconst ohlcSeries = () => ({\n    gap: 1,\n    highlight: {\n        line: {\n            opacity: 1,\n            width: 3\n        }\n    },\n    line: {\n        width: 1\n    },\n    spacing: 0.3\n});\n\nconst radarAreaSeries = () => ({\n    line: {\n        opacity: 1,\n        width: 0\n    },\n    markers: {\n        size: 6,\n        visible: false\n    },\n    opacity: 0.5\n});\n\nconst radarLineSeries = () => ({\n    markers: {\n        visible: false\n    },\n    width: 2\n});\n\nconst rangeBarSeries = () => ({\n    gap: BAR_GAP,\n    spacing: BAR_SPACING\n});\n\nconst rangeColumnSeries = () => ({\n    gap: BAR_GAP,\n    spacing: BAR_SPACING\n});\n\nconst scatterLineSeries = () => ({\n    width: 1\n});\n\nconst waterfallSeries = () => ({\n    gap: 0.5,\n    line: {\n        color: base_theme_BLACK,\n        width: 1\n    },\n    spacing: BAR_SPACING\n});\n\nconst pieSeries = () => ({\n    labels: {\n        background: '',\n        color: '',\n        padding: {\n            top: 5,\n            bottom: 5,\n            left: 7,\n            right: 7\n        }\n    }\n});\n\nconst funnelSeries = () => ({\n    labels: {\n        background: '',\n        color: '',\n        padding: {\n            top: 5,\n            bottom: 5,\n            left: 7,\n            right: 7\n        }\n    }\n});\n\nconst base_theme_seriesDefaults = (options) => ({\n    visible: true,\n    labels: {\n        font: SANS11\n    },\n    overlay: options.gradients ? {} : {\n        gradient: \"none\"\n    },\n    area: areaSeries(),\n    rangeArea: rangeAreaSeries(),\n    verticalRangeArea: rangeAreaSeries(),\n    bar: barSeries(),\n    boxPlot: boxPlotSeries(),\n    bubble: bubbleSeries(),\n    bullet: bulletSeries(),\n    candlestick: candlestickSeries(),\n    column: columnSeries(),\n    pie: pieSeries(),\n    donut: donutSeries(),\n    funnel: funnelSeries(),\n    horizontalWaterfall: waterfallSeries(),\n    line: lineSeries(),\n    notes: base_theme_notes(),\n    ohlc: ohlcSeries(),\n    radarArea: radarAreaSeries(),\n    radarLine: radarLineSeries(),\n    polarArea: radarAreaSeries(),\n    polarLine: radarLineSeries(),\n    rangeBar: rangeBarSeries(),\n    rangeColumn: rangeColumnSeries(),\n    scatterLine: scatterLineSeries(),\n    verticalArea: areaSeries(),\n    verticalBoxPlot: boxPlotSeries(),\n    verticalBullet: bulletSeries(),\n    verticalLine: lineSeries(),\n    waterfall: waterfallSeries()\n});\n\nconst base_theme_title = () => ({\n    font: SANS16\n});\n\nconst base_theme_legend = () => ({\n    labels: {\n        font: SANS12\n    }\n});\n\nconst baseTheme = (options = {}) => ({\n    axisDefaults: base_theme_axisDefaults(),\n    categoryAxis: {\n        majorGridLines: {\n            visible: true\n        }\n    },\n    navigator: {\n        pane: {\n            height: 90,\n            margin: {\n                top: 10\n            }\n        }\n    },\n    seriesDefaults: base_theme_seriesDefaults(options),\n    title: base_theme_title(),\n    legend: base_theme_legend()\n});\n\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-charts/dist/es2015/main.js\n\n\n\n\n\n\n\n\n\n\n\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-draggable/dist/es2015/main.js\nconst proxy = (a, b) => (e) => b(a(e));\nconst main_bind = (el, event, callback) => el.addEventListener && el.addEventListener(event, callback);\nconst unbind = (el, event, callback) => el && el.removeEventListener && el.removeEventListener(event, callback);\nconst noop = () => { };\nconst main_preventDefault = e => e.preventDefault();\nconst touchRegExp = /touch/;\n// 300ms is the usual mouse interval;\n// // However, an underpowered mobile device under a heavy load may queue mouse events for a longer period.\nconst IGNORE_MOUSE_TIMEOUT = 2000;\nfunction normalizeEvent(e) {\n    if (e.type.match(touchRegExp)) {\n        return {\n            pageX: e.changedTouches[0].pageX,\n            pageY: e.changedTouches[0].pageY,\n            clientX: e.changedTouches[0].clientX,\n            clientY: e.changedTouches[0].clientY,\n            type: e.type,\n            originalEvent: e,\n            isTouch: true\n        };\n    }\n    return {\n        pageX: e.pageX,\n        pageY: e.pageY,\n        clientX: e.clientX,\n        clientY: e.clientY,\n        offsetX: e.offsetX,\n        offsetY: e.offsetY,\n        type: e.type,\n        ctrlKey: e.ctrlKey,\n        shiftKey: e.shiftKey,\n        altKey: e.altKey,\n        originalEvent: e\n    };\n}\nlet Draggable = /*@__PURE__*/ (() => {\n    class Draggable {\n        static supportPointerEvent() {\n            return (typeof window !== 'undefined') && window.PointerEvent;\n        }\n        get document() {\n            return this._element\n                ? this._element.ownerDocument\n                : document;\n        }\n        constructor({ press = noop, drag = noop, release = noop, mouseOnly = false }) {\n            this._pressHandler = proxy(normalizeEvent, press);\n            this._dragHandler = proxy(normalizeEvent, drag);\n            this._releaseHandler = proxy(normalizeEvent, release);\n            this._ignoreMouse = false;\n            this._mouseOnly = mouseOnly;\n            this._touchstart = (e) => {\n                if (e.touches.length === 1) {\n                    this._pressHandler(e);\n                }\n            };\n            this._touchmove = (e) => {\n                if (e.touches.length === 1) {\n                    this._dragHandler(e);\n                }\n            };\n            this._touchend = (e) => {\n                // the last finger has been lifted, and the user is not doing gesture.\n                // there might be a better way to handle this.\n                if (e.touches.length === 0 && e.changedTouches.length === 1) {\n                    this._releaseHandler(e);\n                    this._ignoreMouse = true;\n                    setTimeout(this._restoreMouse, IGNORE_MOUSE_TIMEOUT);\n                }\n            };\n            this._restoreMouse = () => {\n                this._ignoreMouse = false;\n            };\n            this._mousedown = (e) => {\n                const { which } = e;\n                if ((which && which > 1) || this._ignoreMouse) {\n                    return;\n                }\n                main_bind(this.document, \"mousemove\", this._mousemove);\n                main_bind(this.document, \"mouseup\", this._mouseup);\n                this._pressHandler(e);\n            };\n            this._mousemove = (e) => {\n                this._dragHandler(e);\n            };\n            this._mouseup = (e) => {\n                unbind(this.document, \"mousemove\", this._mousemove);\n                unbind(this.document, \"mouseup\", this._mouseup);\n                this._releaseHandler(e);\n            };\n            this._pointerdown = (e) => {\n                if (e.isPrimary && e.button === 0) {\n                    main_bind(this.document, \"pointermove\", this._pointermove);\n                    main_bind(this.document, \"pointerup\", this._pointerup);\n                    main_bind(this.document, \"pointercancel\", this._pointerup);\n                    main_bind(this.document, \"contextmenu\", main_preventDefault);\n                    this._pressHandler(e);\n                }\n            };\n            this._pointermove = (e) => {\n                if (e.isPrimary) {\n                    this._dragHandler(e);\n                }\n            };\n            this._pointerup = (e) => {\n                if (e.isPrimary) {\n                    unbind(this.document, \"pointermove\", this._pointermove);\n                    unbind(this.document, \"pointerup\", this._pointerup);\n                    unbind(this.document, \"pointercancel\", this._pointerup);\n                    unbind(this.document, \"contextmenu\", main_preventDefault);\n                    this._releaseHandler(e);\n                }\n            };\n        }\n        bindTo(element) {\n            if (element === this._element) {\n                return;\n            }\n            if (this._element) {\n                this._unbindFromCurrent();\n            }\n            this._element = element;\n            this._bindToCurrent();\n        }\n        _bindToCurrent() {\n            const element = this._element;\n            if (this._usePointers()) {\n                main_bind(element, \"pointerdown\", this._pointerdown);\n                return;\n            }\n            main_bind(element, \"mousedown\", this._mousedown);\n            if (!this._mouseOnly) {\n                main_bind(element, \"touchstart\", this._touchstart);\n                main_bind(element, \"touchmove\", this._touchmove);\n                main_bind(element, \"touchend\", this._touchend);\n            }\n        }\n        _unbindFromCurrent() {\n            const element = this._element;\n            if (this._usePointers()) {\n                unbind(element, \"pointerdown\", this._pointerdown);\n                unbind(this.document, \"pointermove\", this._pointermove);\n                unbind(this.document, \"pointerup\", this._pointerup);\n                unbind(this.document, \"contextmenu\", main_preventDefault);\n                unbind(this.document, \"pointercancel\", this._pointerup);\n                return;\n            }\n            unbind(element, \"mousedown\", this._mousedown);\n            if (!this._mouseOnly) {\n                unbind(element, \"touchstart\", this._touchstart);\n                unbind(element, \"touchmove\", this._touchmove);\n                unbind(element, \"touchend\", this._touchend);\n            }\n        }\n        _usePointers() {\n            return !this._mouseOnly && Draggable.supportPointerEvent();\n        }\n        update({ press = noop, drag = noop, release = noop, mouseOnly = false }) {\n            this._pressHandler = proxy(normalizeEvent, press);\n            this._dragHandler = proxy(normalizeEvent, drag);\n            this._releaseHandler = proxy(normalizeEvent, release);\n            this._mouseOnly = mouseOnly;\n        }\n        destroy() {\n            this._unbindFromCurrent();\n            this._element = null;\n        }\n    }\n    // Re-export as \"default\" field to address a bug\n    // where the ES Module is imported by CommonJS code.\n    //\n    // See https://github.com/telerik/kendo-angular/issues/1314\n    Draggable.default = Draggable;\n    return Draggable;\n})();\n// Rollup won't output exports['default'] otherwise\n/* harmony default export */ var es2015_main = (Draggable);\n\n// EXTERNAL MODULE: ./node_modules/@angular/common/__ivy_ngcc__/fesm2015/common.js\nvar common = __webpack_require__(\"ofXK\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/merge.js\nvar merge = __webpack_require__(\"VRyK\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/fromEvent.js\nvar fromEvent = __webpack_require__(\"xgIS\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/from.js + 6 modules\nvar observable_from = __webpack_require__(\"Cfvw\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-angular-common/__ivy_ngcc__/dist/fesm2015/index.js\n/**-----------------------------------------------------------------------------------------\n* Copyright © 2020 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\nconst isDocumentAvailable = () => typeof document !== 'undefined';\nconst isChanged = (propertyName, changes, skipFirstChange = true) => (typeof changes[propertyName] !== 'undefined' &&\n    (!changes[propertyName].isFirstChange() || !skipFirstChange) &&\n    changes[propertyName].previousValue !== changes[propertyName].currentValue);\nconst anyChanged = (propertyNames, changes, skipFirstChange = true) => propertyNames.some(name => isChanged(name, changes, skipFirstChange));\nconst hasObservers = (emitter) => emitter && emitter.observers.length > 0;\nconst guid = () => {\n    let id = \"\";\n    for (let i = 0; i < 32; i++) {\n        const random = Math.random() * 16 | 0; // tslint:disable-line:no-bitwise\n        if (i === 8 || i === 12 || i === 16 || i === 20) {\n            id += \"-\";\n        }\n        // tslint:disable-next-line:no-bitwise\n        id += (i === 12 ? 4 : (i === 16 ? (random & 3 | 8) : random)).toString(16);\n    }\n    return id;\n};\nlet fesm2015_DraggableDirective = /*@__PURE__*/ (() => {\n    let DraggableDirective = class DraggableDirective {\n        constructor(element, ngZone) {\n            this.element = element;\n            this.ngZone = ngZone;\n            this.enableDrag = true;\n            this.kendoPress = new core[\"o\" /* EventEmitter */]();\n            this.kendoDrag = new core[\"o\" /* EventEmitter */]();\n            this.kendoRelease = new core[\"o\" /* EventEmitter */]();\n        }\n        ngOnInit() {\n            this.toggleDraggable();\n        }\n        ngOnChanges(changes) {\n            if (isChanged('enableDrag', changes)) {\n                this.toggleDraggable();\n            }\n        }\n        ngOnDestroy() {\n            this.destroyDraggable();\n        }\n        toggleDraggable() {\n            if (isDocumentAvailable()) {\n                this.destroyDraggable();\n                if (this.enableDrag) {\n                    this.draggable = new es2015_main({\n                        drag: (e) => this.kendoDrag.next(e),\n                        press: (e) => this.kendoPress.next(e),\n                        release: (e) => this.kendoRelease.next(e)\n                    });\n                    this.ngZone.runOutsideAngular(() => this.draggable.bindTo(this.element.nativeElement));\n                }\n            }\n        }\n        destroyDraggable() {\n            if (this.draggable) {\n                this.draggable.destroy();\n                this.draggable = null;\n            }\n        }\n    };\n    DraggableDirective.ɵfac = function DraggableDirective_Factory(t) { return new (t || DraggableDirective)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */])); };\n    DraggableDirective.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: DraggableDirective, selectors: [[\"\", \"kendoDraggable\", \"\"]], inputs: { enableDrag: \"enableDrag\" }, outputs: { kendoPress: \"kendoPress\", kendoDrag: \"kendoDrag\", kendoRelease: \"kendoRelease\" }, features: [core[\"Ab\" /* ɵɵNgOnChangesFeature */]] });\n    DraggableDirective = __decorate([__metadata(\"design:paramtypes\", [core[\"l\" /* ElementRef */], core[\"B\" /* NgZone */]])\n    ], DraggableDirective);\n    return DraggableDirective;\n})();\nlet fesm2015_DraggableModule = /*@__PURE__*/ (() => {\n    /**\n     * @hidden\n     */\n    let DraggableModule = class DraggableModule {\n    };\n    DraggableModule.ɵmod = core[\"Nb\" /* ɵɵdefineNgModule */]({ type: DraggableModule });\n    DraggableModule.ɵinj = core[\"Mb\" /* ɵɵdefineInjector */]({ factory: function DraggableModule_Factory(t) { return new (t || DraggableModule)(); }, imports: [[common[\"c\" /* CommonModule */]]] });\n    return DraggableModule;\n})();\nconst closestInScope = (node, predicate, scope) => {\n    while (node && node !== scope && !predicate(node)) {\n        node = node.parentNode;\n    }\n    if (node !== scope) {\n        return node;\n    }\n};\nconst closest = (node, predicate) => {\n    while (node && !predicate(node)) {\n        node = node.parentNode;\n    }\n    return node;\n};\nconst contains = (parent, node, matchSelf = false) => {\n    const outside = !closest(node, (child) => child === parent);\n    if (outside) {\n        return false;\n    }\n    const el = closest(node, (child) => child === node);\n    return el && (matchSelf || el !== parent);\n};\nconst findElement = (node, predicate, matchSelf = true) => {\n    if (!node) {\n        return;\n    }\n    if (matchSelf && predicate(node)) {\n        return node;\n    }\n    node = node.firstChild;\n    while (node) {\n        if (node.nodeType === 1) {\n            const element = findElement(node, predicate);\n            if (element) {\n                return element;\n            }\n        }\n        node = node.nextSibling;\n    }\n};\nconst focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;\nconst isFocusable = (element) => {\n    if (!element.tagName) {\n        return false;\n    }\n    const tagName = element.tagName.toLowerCase();\n    const hasTabIndex = Boolean(element.getAttribute('tabIndex'));\n    const focusable = !element.disabled && focusableRegex.test(tagName);\n    return focusable || hasTabIndex;\n};\nconst isVisible = (element) => {\n    const rect = element.getBoundingClientRect();\n    const hasSize = rect.width > 0 && rect.height > 0;\n    const hasPosition = rect.x !== 0 && rect.y !== 0;\n    // Elements can have zero size due to styling, but they will still count as visible.\n    // For example, the selection checkbox has no size, but is made visible through styling.\n    return (hasSize || hasPosition) && window.getComputedStyle(element).visibility !== 'hidden';\n};\nconst isFocusableWithTabKey = (element, checkVisibility = true) => {\n    if (!isFocusable(element)) {\n        return false;\n    }\n    const tabIndex = element.getAttribute('tabIndex');\n    const visible = !checkVisibility || isVisible(element);\n    return visible && tabIndex !== '-1';\n};\nconst findFocusableChild = (element, checkVisibility = true) => {\n    return findElement(element, (node) => isFocusableWithTabKey(node, checkVisibility), false);\n};\nconst findFocusable = (element, checkVisibility = true) => {\n    return findElement(element, (node) => isFocusableWithTabKey(node, checkVisibility));\n};\nconst toClassList = (classNames) => String(classNames).trim().split(' ');\nconst fesm2015_hasClasses = (element, classNames) => {\n    const namesList = toClassList(classNames);\n    return Boolean(toClassList(element.className).find((className) => namesList.indexOf(className) >= 0));\n};\nconst matchesClasses = (classNames) => (element) => fesm2015_hasClasses(element, classNames);\nconst NODE_NAME_PREDICATES = {};\nconst matchesNodeName = (nodeName) => {\n    if (!NODE_NAME_PREDICATES[nodeName]) {\n        NODE_NAME_PREDICATES[nodeName] = (element) => String(element.nodeName).toLowerCase() === nodeName.toLowerCase();\n    }\n    return NODE_NAME_PREDICATES[nodeName];\n};\n/**\n * Normalizes a scroll position value in RTL mode.\n */\nfunction rtlScrollPosition(position, element, initial) {\n    let result = position;\n    if (initial < 0) {\n        result = -position;\n    }\n    else if (initial > 0) {\n        result = element.scrollWidth - element.offsetWidth - position;\n    }\n    return result;\n}\nlet fesm2015_EventsOutsideAngularDirective = /*@__PURE__*/ (() => {\n    /* tslint:disable:no-input-rename */\n    /**\n     * @hidden\n     */\n    let EventsOutsideAngularDirective = class EventsOutsideAngularDirective {\n        constructor(element, ngZone, renderer) {\n            this.element = element;\n            this.ngZone = ngZone;\n            this.renderer = renderer;\n            this.events = {};\n        }\n        ngOnInit() {\n            if (!this.element || !this.element.nativeElement) {\n                return;\n            }\n            const events = this.events;\n            this.subscriptions = [];\n            this.ngZone.runOutsideAngular(() => {\n                for (let name in events) {\n                    if (events.hasOwnProperty(name)) {\n                        this.subscriptions.push(this.renderer.listen(this.element.nativeElement, name, this.scope ? events[name].bind(this.scope) : events[name]));\n                    }\n                }\n            });\n        }\n        ngOnDestroy() {\n            if (this.subscriptions) {\n                for (let idx = 0; idx < this.subscriptions.length; idx++) {\n                    this.subscriptions[idx]();\n                }\n                this.subscriptions = null;\n            }\n        }\n    };\n    EventsOutsideAngularDirective.ɵfac = function EventsOutsideAngularDirective_Factory(t) { return new (t || EventsOutsideAngularDirective)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"G\" /* Renderer2 */])); };\n    EventsOutsideAngularDirective.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: EventsOutsideAngularDirective, selectors: [[\"\", \"kendoEventsOutsideAngular\", \"\"]], inputs: { events: [\"kendoEventsOutsideAngular\", \"events\"], scope: \"scope\" } });\n    EventsOutsideAngularDirective = __decorate([__metadata(\"design:paramtypes\", [core[\"l\" /* ElementRef */],\n            core[\"B\" /* NgZone */],\n            core[\"G\" /* Renderer2 */]])\n    ], EventsOutsideAngularDirective);\n    return EventsOutsideAngularDirective;\n})();\nlet fesm2015_EventsModule = /*@__PURE__*/ (() => {\n    /**\n     * @hidden\n     */\n    let EventsModule = class EventsModule {\n    };\n    EventsModule.ɵmod = core[\"Nb\" /* ɵɵdefineNgModule */]({ type: EventsModule });\n    EventsModule.ɵinj = core[\"Mb\" /* ɵɵdefineInjector */]({ factory: function EventsModule_Factory(t) { return new (t || EventsModule)(); } });\n    return EventsModule;\n})();\nclass fesm2015_ResizeService {\n    constructor(resizeBatchService) {\n        this.resizeBatchService = resizeBatchService;\n        this.resize = new core[\"o\" /* EventEmitter */]();\n        this.acceptedSize = false;\n        this.state = 0 /* Initial */;\n    }\n    acceptSize(size = this.measure()) {\n        this.lastWidth = size.width;\n        this.lastHeight = size.height;\n        this.acceptedSize = true;\n    }\n    checkChanges() {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        if (this.state === 0 /* Initial */) {\n            this.state = 1 /* Initializing */;\n            // batch initial measure\n            this.resizeBatchService.schedule(this, this.init);\n        }\n    }\n    destroy() {\n        this.resizeBatchService.cancel(this);\n    }\n    checkSize() {\n        if (!this.parentElement) {\n            return;\n        }\n        const { width, height } = this.measure();\n        const sameSize = width === this.lastWidth && height === this.lastHeight;\n        if (sameSize) {\n            return;\n        }\n        this.lastWidth = width;\n        this.lastHeight = height;\n        this.acceptedSize = false;\n        this.resize.emit();\n        return true;\n    }\n    initSize() {\n        const size = this.measure();\n        this.lastWidth = size.width;\n        this.lastHeight = size.height;\n    }\n    measure() {\n        let width = 0;\n        let height = 0;\n        if (this.parentElement) {\n            height = this.parentElement.offsetHeight;\n            width = this.parentElement.offsetWidth;\n        }\n        return { height, width };\n    }\n}\n// tslint:disable:deprecation\nconst div = style => {\n    const el = document.createElement('div');\n    el.style.cssText = style;\n    return el;\n};\nconst computedProp = (elem, prop) => getComputedStyle(elem, null).getPropertyValue(prop);\nconst WRAP_STYLE = 'position: absolute; display: block; left: 0; top: 0; right: 0; bottom: 0; z-index: -1;' +\n    'overflow: hidden; visibility: hidden;';\nconst EXPAND_CHILD_STYLE = 'position: absolute; left: 0; top: 0; transition: 0s;';\nconst SHRINK_CHILD_STYLE = EXPAND_CHILD_STYLE + 'width: 200%; height: 200%;';\nclass fesm2015_ResizeCompatService extends fesm2015_ResizeService {\n    constructor(resizeBatchService, element, ngZone) {\n        super(resizeBatchService);\n        this.element = element;\n        this.ngZone = ngZone;\n    }\n    checkChanges() {\n        if (this.state === 2 /* Initialized */) {\n            if (!this.resizeBatchService.isScheduled(this)) {\n                this.resizeBatchService.schedule(this, this.checkSize);\n            }\n            return;\n        }\n        super.checkChanges();\n    }\n    destroy() {\n        super.destroy();\n        if (this.subscription) {\n            this.subscription.unsubscribe();\n        }\n        if (this.expand) {\n            const element = this.element.nativeElement;\n            element.removeChild(this.expand);\n            element.removeChild(this.shrink);\n            this.expand.removeChild(this.expandChild);\n            this.expand = this.expandChild = this.shrink = this.element = null;\n        }\n    }\n    checkSize() {\n        if (super.checkSize()) {\n            this.reset();\n            return true;\n        }\n    }\n    init() {\n        const parentElement = this.parentElement = this.element.nativeElement.parentElement;\n        if (computedProp(parentElement, 'position') === 'static') {\n            parentElement.style.position = 'relative';\n        }\n        this.state = 2 /* Initialized */;\n        this.render();\n        this.reset();\n        this.initSize();\n        this.subscribe();\n    }\n    render() {\n        const element = this.element.nativeElement;\n        element.style.cssText = WRAP_STYLE;\n        element.setAttribute('dir', 'ltr');\n        this.expand = div(WRAP_STYLE);\n        this.expandChild = div(EXPAND_CHILD_STYLE);\n        this.expand.appendChild(this.expandChild);\n        element.appendChild(this.expand);\n        this.shrink = div(WRAP_STYLE);\n        const shrinkChild = div(SHRINK_CHILD_STYLE);\n        this.shrink.appendChild(shrinkChild);\n        element.appendChild(this.shrink);\n    }\n    reset() {\n        const expandChild = this.expandChild;\n        expandChild.style.width = 100000 + 'px';\n        expandChild.style.height = 100000 + 'px';\n        const expand = this.expand;\n        expand.scrollLeft = 100000;\n        expand.scrollTop = 100000;\n        const shrink = this.shrink;\n        shrink.scrollLeft = 100000;\n        shrink.scrollTop = 100000;\n    }\n    subscribe() {\n        this.ngZone.runOutsideAngular(() => {\n            this.subscription = Object(merge[\"a\" /* merge */])(Object(fromEvent[\"a\" /* fromEvent */])(this.shrink, 'scroll'), Object(fromEvent[\"a\" /* fromEvent */])(this.expand, 'scroll'))\n                .subscribe(() => {\n                this.checkSize();\n            });\n        });\n    }\n}\nconst HAS_OBSERVER = typeof ResizeObserver !== 'undefined';\n/**\n * @hidden\n */\nclass ResizeObserverService extends fesm2015_ResizeService {\n    constructor(resizeBatchService, element, ngZone) {\n        super(resizeBatchService);\n        this.element = element;\n        this.ngZone = ngZone;\n    }\n    static supported() {\n        return HAS_OBSERVER;\n    }\n    destroy() {\n        super.destroy();\n        if (this.resizeObserver) {\n            this.resizeObserver.disconnect();\n            this.resizeObserver = null;\n        }\n        this.parentElement = null;\n    }\n    init() {\n        this.parentElement = this.element.nativeElement.parentElement;\n        this.initSize();\n        this.state = 2 /* Initialized */;\n        this.ngZone.runOutsideAngular(() => {\n            this.resizeObserver = new ResizeObserver(() => {\n                this.checkSize();\n            });\n            this.resizeObserver.observe(this.parentElement);\n        });\n    }\n}\nlet fesm2015_ResizeBatchService = /*@__PURE__*/ (() => {\n    /* tslint:disable:align */\n    /**\n     * @hidden\n     */\n    let ResizeBatchService = class ResizeBatchService {\n        constructor(ngZone) {\n            this.ngZone = ngZone;\n            this.scheduled = [];\n            this.resolvedPromise = Promise.resolve(null);\n            this.flush = this.flush.bind(this);\n        }\n        schedule(instance, method) {\n            this.scheduled.push({ instance, method });\n            if (!this.subscription) {\n                this.ngZone.runOutsideAngular(() => {\n                    this.subscription = Object(observable_from[\"a\" /* from */])(this.resolvedPromise)\n                        .subscribe(this.flush);\n                });\n            }\n        }\n        isScheduled(instance) {\n            return Boolean(this.scheduled.find(item => item.instance === instance));\n        }\n        cancel(instance) {\n            const scheduled = this.scheduled;\n            const count = scheduled.length;\n            for (let idx = 0; idx < count; idx++) {\n                if (scheduled[idx].instance === instance) {\n                    scheduled.splice(idx, 1);\n                    if (!scheduled.length) {\n                        this.unsubscribe();\n                    }\n                    return;\n                }\n            }\n        }\n        ngOnDestroy() {\n            this.unsubscribe();\n        }\n        unsubscribe() {\n            if (this.subscription) {\n                this.subscription.unsubscribe();\n                this.subscription = null;\n            }\n        }\n        flush() {\n            this.scheduled.forEach(item => {\n                item.method.call(item.instance);\n            });\n            this.scheduled = [];\n            this.unsubscribe();\n        }\n    };\n    ResizeBatchService.ɵfac = function ResizeBatchService_Factory(t) { return new (t || ResizeBatchService)(core[\"cc\" /* ɵɵinject */](core[\"B\" /* NgZone */])); };\n    ResizeBatchService.ɵprov = core[\"Lb\" /* ɵɵdefineInjectable */]({ token: ResizeBatchService, factory: function (t) { return ResizeBatchService.ɵfac(t); } });\n    ResizeBatchService = __decorate([__metadata(\"design:paramtypes\", [core[\"B\" /* NgZone */]])\n    ], ResizeBatchService);\n    return ResizeBatchService;\n})();\n/**\n * Emit up to 10 resize events per second by default.\n * Chosen as a compromise between responsiveness and performance.\n */\nconst DEFAULT_RATE_LIMIT = 10;\nlet fesm2015_ResizeSensorComponent = /*@__PURE__*/ (() => {\n    /**\n     * Resize Sensor Component\n     *\n     * Triggers a \"resize\" event whenever the parent DOM element size changes.\n     */\n    let ResizeSensorComponent = class ResizeSensorComponent {\n        constructor(resizeBatchService, element, ngZone) {\n            /**\n             * The maximum number of resize events to emit per second.\n             *\n             * Defaults to 10.\n             */\n            this.rateLimit = DEFAULT_RATE_LIMIT;\n            /**\n             * Fires when the parent DOM element has been resized.\n             */\n            this.resize = new core[\"o\" /* EventEmitter */]();\n            const serviceType = ResizeObserverService.supported() ? ResizeObserverService : fesm2015_ResizeCompatService;\n            this.resizeService = new serviceType(resizeBatchService, element, ngZone);\n            const throttleTime = 1000 / (this.rateLimit || DEFAULT_RATE_LIMIT);\n            this.subscription = this.resizeService.resize\n                .pipe(Object(auditTime[\"a\" /* auditTime */])(throttleTime))\n                .subscribe(() => {\n                if (!this.resizeService.acceptedSize) {\n                    this.resize.emit();\n                }\n            });\n        }\n        ngAfterViewChecked() {\n            this.resizeService.checkChanges();\n        }\n        ngOnDestroy() {\n            this.subscription.unsubscribe();\n            this.resizeService.destroy();\n        }\n        acceptSize(size) {\n            this.resizeService.acceptSize(size);\n        }\n    };\n    ResizeSensorComponent.ɵfac = function ResizeSensorComponent_Factory(t) { return new (t || ResizeSensorComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ResizeBatchService), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */])); };\n    ResizeSensorComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: ResizeSensorComponent, selectors: [[\"kendo-resize-sensor\"]], inputs: { rateLimit: \"rateLimit\" }, outputs: { resize: \"resize\" }, decls: 0, vars: 0, template: function ResizeSensorComponent_Template(rf, ctx) { }, encapsulation: 2 });\n    ResizeSensorComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ResizeBatchService, core[\"l\" /* ElementRef */], core[\"B\" /* NgZone */]])\n    ], ResizeSensorComponent);\n    return ResizeSensorComponent;\n})();\nconst COMPONENT_DIRECTIVES = [fesm2015_ResizeSensorComponent];\nlet fesm2015_ResizeSensorModule = /*@__PURE__*/ (() => {\n    /**\n     * Resize Sensor module\n     */\n    let ResizeSensorModule = class ResizeSensorModule {\n    };\n    ResizeSensorModule.ɵmod = core[\"Nb\" /* ɵɵdefineNgModule */]({ type: ResizeSensorModule });\n    ResizeSensorModule.ɵinj = core[\"Mb\" /* ɵɵdefineInjector */]({ factory: function ResizeSensorModule_Factory(t) { return new (t || ResizeSensorModule)(); }, providers: [fesm2015_ResizeBatchService] });\n    return ResizeSensorModule;\n})();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ec\" /* ɵɵsetNgModuleScope */](fesm2015_DraggableModule, { declarations: function () { return [fesm2015_DraggableDirective]; }, imports: function () { return [common[\"c\" /* CommonModule */]]; }, exports: function () { return [fesm2015_DraggableDirective]; } }); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ec\" /* ɵɵsetNgModuleScope */](fesm2015_EventsModule, { declarations: [fesm2015_EventsOutsideAngularDirective], exports: [fesm2015_EventsOutsideAngularDirective] }); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ec\" /* ɵɵsetNgModuleScope */](fesm2015_ResizeSensorModule, { declarations: [fesm2015_ResizeSensorComponent], exports: [fesm2015_ResizeSensorComponent] }); })();\nclass KendoInput {\n}\n/**\n * Enum with key codes.\n */\nvar Keys = /*@__PURE__*/ (function (Keys) {\n    Keys[Keys[\"Alt\"] = 18] = \"Alt\";\n    Keys[Keys[\"ArrowDown\"] = 40] = \"ArrowDown\";\n    Keys[Keys[\"ArrowLeft\"] = 37] = \"ArrowLeft\";\n    Keys[Keys[\"ArrowRight\"] = 39] = \"ArrowRight\";\n    Keys[Keys[\"ArrowUp\"] = 38] = \"ArrowUp\";\n    Keys[Keys[\"Backspace\"] = 8] = \"Backspace\";\n    Keys[Keys[\"Control\"] = 17] = \"Control\";\n    Keys[Keys[\"Delete\"] = 46] = \"Delete\";\n    Keys[Keys[\"Digit0\"] = 48] = \"Digit0\";\n    Keys[Keys[\"Digit1\"] = 49] = \"Digit1\";\n    Keys[Keys[\"Digit2\"] = 50] = \"Digit2\";\n    Keys[Keys[\"Digit3\"] = 51] = \"Digit3\";\n    Keys[Keys[\"Digit4\"] = 52] = \"Digit4\";\n    Keys[Keys[\"Digit5\"] = 53] = \"Digit5\";\n    Keys[Keys[\"Digit6\"] = 54] = \"Digit6\";\n    Keys[Keys[\"Digit7\"] = 55] = \"Digit7\";\n    Keys[Keys[\"Digit8\"] = 56] = \"Digit8\";\n    Keys[Keys[\"Digit9\"] = 57] = \"Digit9\";\n    Keys[Keys[\"End\"] = 35] = \"End\";\n    Keys[Keys[\"Enter\"] = 13] = \"Enter\";\n    Keys[Keys[\"Escape\"] = 27] = \"Escape\";\n    Keys[Keys[\"F1\"] = 112] = \"F1\";\n    Keys[Keys[\"F2\"] = 113] = \"F2\";\n    Keys[Keys[\"F10\"] = 121] = \"F10\";\n    Keys[Keys[\"Home\"] = 36] = \"Home\";\n    Keys[Keys[\"Insert\"] = 45] = \"Insert\";\n    Keys[Keys[\"KeyA\"] = 65] = \"KeyA\";\n    Keys[Keys[\"KeyB\"] = 66] = \"KeyB\";\n    Keys[Keys[\"KeyC\"] = 67] = \"KeyC\";\n    Keys[Keys[\"KeyD\"] = 68] = \"KeyD\";\n    Keys[Keys[\"KeyE\"] = 69] = \"KeyE\";\n    Keys[Keys[\"KeyF\"] = 70] = \"KeyF\";\n    Keys[Keys[\"KeyG\"] = 71] = \"KeyG\";\n    Keys[Keys[\"KeyH\"] = 72] = \"KeyH\";\n    Keys[Keys[\"KeyI\"] = 73] = \"KeyI\";\n    Keys[Keys[\"KeyJ\"] = 74] = \"KeyJ\";\n    Keys[Keys[\"KeyK\"] = 75] = \"KeyK\";\n    Keys[Keys[\"KeyL\"] = 76] = \"KeyL\";\n    Keys[Keys[\"KeyM\"] = 77] = \"KeyM\";\n    Keys[Keys[\"KeyN\"] = 78] = \"KeyN\";\n    Keys[Keys[\"KeyO\"] = 79] = \"KeyO\";\n    Keys[Keys[\"KeyP\"] = 80] = \"KeyP\";\n    Keys[Keys[\"KeyQ\"] = 81] = \"KeyQ\";\n    Keys[Keys[\"KeyR\"] = 82] = \"KeyR\";\n    Keys[Keys[\"KeyS\"] = 83] = \"KeyS\";\n    Keys[Keys[\"KeyT\"] = 84] = \"KeyT\";\n    Keys[Keys[\"KeyU\"] = 85] = \"KeyU\";\n    Keys[Keys[\"KeyV\"] = 86] = \"KeyV\";\n    Keys[Keys[\"KeyW\"] = 87] = \"KeyW\";\n    Keys[Keys[\"KeyX\"] = 88] = \"KeyX\";\n    Keys[Keys[\"KeyY\"] = 89] = \"KeyY\";\n    Keys[Keys[\"KeyZ\"] = 90] = \"KeyZ\";\n    Keys[Keys[\"NumpadDecimal\"] = 110] = \"NumpadDecimal\";\n    Keys[Keys[\"PageDown\"] = 34] = \"PageDown\";\n    Keys[Keys[\"PageUp\"] = 33] = \"PageUp\";\n    Keys[Keys[\"Shift\"] = 16] = \"Shift\";\n    Keys[Keys[\"Space\"] = 32] = \"Space\";\n    Keys[Keys[\"Tab\"] = 9] = \"Tab\";\n    return Keys;\n})({});\nclass PreventableEvent {\n    constructor() {\n        this.prevented = false;\n    }\n    /**\n     * Prevents the default action for a specified event.\n     * In this way, the source component suppresses\n     * the built-in behavior that follows the event.\n     */\n    preventDefault() {\n        this.prevented = true;\n    }\n    /**\n     * Returns `true` if the event was prevented\n     * by any of its subscribers.\n     *\n     * @returns `true` if the default action was prevented.\n     * Otherwise, returns `false`.\n     */\n    isDefaultPrevented() {\n        return this.prevented;\n    }\n}\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztzU0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7cUtBT29CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3dPQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztpSUFNaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztrSkFBRTtBQUNGLGlDQUVHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3FTQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUtHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFPdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIENvcHlyaWdodCDCqSAyMDIwIFByb2dyZXNzIFNvZnR3YXJlIENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciBjb21tZXJjaWFsIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IF9fZGVjb3JhdGUsIF9fbWV0YWRhdGEgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQsIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgTmdab25lLCBOZ01vZHVsZSwgUmVuZGVyZXIyLCBJbmplY3RhYmxlLCBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCBEcmFnZ2FibGUgZnJvbSAnQHRlbGVyaWsva2VuZG8tZHJhZ2dhYmxlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBhdWRpdFRpbWUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBtZXJnZSwgZnJvbUV2ZW50LCBmcm9tIH0gZnJvbSAncnhqcyc7XG5cbmNvbnN0IGlzRG9jdW1lbnRBdmFpbGFibGUgPSAoKSA9PiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG5jb25zdCBpc0NoYW5nZWQgPSAocHJvcGVydHlOYW1lLCBjaGFuZ2VzLCBza2lwRmlyc3RDaGFuZ2UgPSB0cnVlKSA9PiAodHlwZW9mIGNoYW5nZXNbcHJvcGVydHlOYW1lXSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAoIWNoYW5nZXNbcHJvcGVydHlOYW1lXS5pc0ZpcnN0Q2hhbmdlKCkgfHwgIXNraXBGaXJzdENoYW5nZSkgJiZcbiAgICBjaGFuZ2VzW3Byb3BlcnR5TmFtZV0ucHJldmlvdXNWYWx1ZSAhPT0gY2hhbmdlc1twcm9wZXJ0eU5hbWVdLmN1cnJlbnRWYWx1ZSk7XG5cbmNvbnN0IGFueUNoYW5nZWQgPSAocHJvcGVydHlOYW1lcywgY2hhbmdlcywgc2tpcEZpcnN0Q2hhbmdlID0gdHJ1ZSkgPT4gcHJvcGVydHlOYW1lcy5zb21lKG5hbWUgPT4gaXNDaGFuZ2VkKG5hbWUsIGNoYW5nZXMsIHNraXBGaXJzdENoYW5nZSkpO1xuXG5jb25zdCBoYXNPYnNlcnZlcnMgPSAoZW1pdHRlcikgPT4gZW1pdHRlciAmJiBlbWl0dGVyLm9ic2VydmVycy5sZW5ndGggPiAwO1xuXG5jb25zdCBndWlkID0gKCkgPT4ge1xuICAgIGxldCBpZCA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHJhbmRvbSA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDA7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6bm8tYml0d2lzZVxuICAgICAgICBpZiAoaSA9PT0gOCB8fCBpID09PSAxMiB8fCBpID09PSAxNiB8fCBpID09PSAyMCkge1xuICAgICAgICAgICAgaWQgKz0gXCItXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWJpdHdpc2VcbiAgICAgICAgaWQgKz0gKGkgPT09IDEyID8gNCA6IChpID09PSAxNiA/IChyYW5kb20gJiAzIHwgOCkgOiByYW5kb20pKS50b1N0cmluZygxNik7XG4gICAgfVxuICAgIHJldHVybiBpZDtcbn07XG5cbmxldCBEcmFnZ2FibGVEaXJlY3RpdmUgPSBjbGFzcyBEcmFnZ2FibGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG5nWm9uZSkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5lbmFibGVEcmFnID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5rZW5kb1ByZXNzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmtlbmRvRHJhZyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5rZW5kb1JlbGVhc2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnRvZ2dsZURyYWdnYWJsZSgpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChpc0NoYW5nZWQoJ2VuYWJsZURyYWcnLCBjaGFuZ2VzKSkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVEcmFnZ2FibGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95RHJhZ2dhYmxlKCk7XG4gICAgfVxuICAgIHRvZ2dsZURyYWdnYWJsZSgpIHtcbiAgICAgICAgaWYgKGlzRG9jdW1lbnRBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95RHJhZ2dhYmxlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5lbmFibGVEcmFnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2FibGUgPSBuZXcgRHJhZ2dhYmxlKHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZzogKGUpID0+IHRoaXMua2VuZG9EcmFnLm5leHQoZSksXG4gICAgICAgICAgICAgICAgICAgIHByZXNzOiAoZSkgPT4gdGhpcy5rZW5kb1ByZXNzLm5leHQoZSksXG4gICAgICAgICAgICAgICAgICAgIHJlbGVhc2U6IChlKSA9PiB0aGlzLmtlbmRvUmVsZWFzZS5uZXh0KGUpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4gdGhpcy5kcmFnZ2FibGUuYmluZFRvKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveURyYWdnYWJsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdnYWJsZS5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmRyYWdnYWJsZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIERyYWdnYWJsZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZW5hYmxlRHJhZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIERyYWdnYWJsZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwia2VuZG9QcmVzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIERyYWdnYWJsZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwia2VuZG9EcmFnXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgRHJhZ2dhYmxlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJrZW5kb1JlbGVhc2VcIiwgdm9pZCAwKTtcbkRyYWdnYWJsZURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvRHJhZ2dhYmxlXSdcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE5nWm9uZV0pXG5dLCBEcmFnZ2FibGVEaXJlY3RpdmUpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IERyYWdnYWJsZU1vZHVsZSA9IGNsYXNzIERyYWdnYWJsZU1vZHVsZSB7XG59O1xuRHJhZ2dhYmxlTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBkZWNsYXJhdGlvbnM6IFtEcmFnZ2FibGVEaXJlY3RpdmVdLFxuICAgICAgICBleHBvcnRzOiBbRHJhZ2dhYmxlRGlyZWN0aXZlXSxcbiAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV1cbiAgICB9KVxuXSwgRHJhZ2dhYmxlTW9kdWxlKTtcblxuY29uc3QgY2xvc2VzdEluU2NvcGUgPSAobm9kZSwgcHJlZGljYXRlLCBzY29wZSkgPT4ge1xuICAgIHdoaWxlIChub2RlICYmIG5vZGUgIT09IHNjb3BlICYmICFwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgaWYgKG5vZGUgIT09IHNjb3BlKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbn07XG5cbmNvbnN0IGNsb3Nlc3QgPSAobm9kZSwgcHJlZGljYXRlKSA9PiB7XG4gICAgd2hpbGUgKG5vZGUgJiYgIXByZWRpY2F0ZShub2RlKSkge1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbmNvbnN0IGNvbnRhaW5zID0gKHBhcmVudCwgbm9kZSwgbWF0Y2hTZWxmID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCBvdXRzaWRlID0gIWNsb3Nlc3Qobm9kZSwgKGNoaWxkKSA9PiBjaGlsZCA9PT0gcGFyZW50KTtcbiAgICBpZiAob3V0c2lkZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGVsID0gY2xvc2VzdChub2RlLCAoY2hpbGQpID0+IGNoaWxkID09PSBub2RlKTtcbiAgICByZXR1cm4gZWwgJiYgKG1hdGNoU2VsZiB8fCBlbCAhPT0gcGFyZW50KTtcbn07XG5cbmNvbnN0IGZpbmRFbGVtZW50ID0gKG5vZGUsIHByZWRpY2F0ZSwgbWF0Y2hTZWxmID0gdHJ1ZSkgPT4ge1xuICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChtYXRjaFNlbGYgJiYgcHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZmluZEVsZW1lbnQobm9kZSwgcHJlZGljYXRlKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxufTtcblxuY29uc3QgZm9jdXNhYmxlUmVnZXggPSAvXig/OmF8aW5wdXR8c2VsZWN0fG9wdGlvbnx0ZXh0YXJlYXxidXR0b258b2JqZWN0KSQvaTtcbmNvbnN0IGlzRm9jdXNhYmxlID0gKGVsZW1lbnQpID0+IHtcbiAgICBpZiAoIWVsZW1lbnQudGFnTmFtZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHRhZ05hbWUgPSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBoYXNUYWJJbmRleCA9IEJvb2xlYW4oZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RhYkluZGV4JykpO1xuICAgIGNvbnN0IGZvY3VzYWJsZSA9ICFlbGVtZW50LmRpc2FibGVkICYmIGZvY3VzYWJsZVJlZ2V4LnRlc3QodGFnTmFtZSk7XG4gICAgcmV0dXJuIGZvY3VzYWJsZSB8fCBoYXNUYWJJbmRleDtcbn07XG5cbmNvbnN0IGlzVmlzaWJsZSA9IChlbGVtZW50KSA9PiB7XG4gICAgY29uc3QgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgaGFzU2l6ZSA9IHJlY3Qud2lkdGggPiAwICYmIHJlY3QuaGVpZ2h0ID4gMDtcbiAgICBjb25zdCBoYXNQb3NpdGlvbiA9IHJlY3QueCAhPT0gMCAmJiByZWN0LnkgIT09IDA7XG4gICAgLy8gRWxlbWVudHMgY2FuIGhhdmUgemVybyBzaXplIGR1ZSB0byBzdHlsaW5nLCBidXQgdGhleSB3aWxsIHN0aWxsIGNvdW50IGFzIHZpc2libGUuXG4gICAgLy8gRm9yIGV4YW1wbGUsIHRoZSBzZWxlY3Rpb24gY2hlY2tib3ggaGFzIG5vIHNpemUsIGJ1dCBpcyBtYWRlIHZpc2libGUgdGhyb3VnaCBzdHlsaW5nLlxuICAgIHJldHVybiAoaGFzU2l6ZSB8fCBoYXNQb3NpdGlvbikgJiYgd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkudmlzaWJpbGl0eSAhPT0gJ2hpZGRlbic7XG59O1xuXG5jb25zdCBpc0ZvY3VzYWJsZVdpdGhUYWJLZXkgPSAoZWxlbWVudCwgY2hlY2tWaXNpYmlsaXR5ID0gdHJ1ZSkgPT4ge1xuICAgIGlmICghaXNGb2N1c2FibGUoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB0YWJJbmRleCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0YWJJbmRleCcpO1xuICAgIGNvbnN0IHZpc2libGUgPSAhY2hlY2tWaXNpYmlsaXR5IHx8IGlzVmlzaWJsZShlbGVtZW50KTtcbiAgICByZXR1cm4gdmlzaWJsZSAmJiB0YWJJbmRleCAhPT0gJy0xJztcbn07XG5cbmNvbnN0IGZpbmRGb2N1c2FibGVDaGlsZCA9IChlbGVtZW50LCBjaGVja1Zpc2liaWxpdHkgPSB0cnVlKSA9PiB7XG4gICAgcmV0dXJuIGZpbmRFbGVtZW50KGVsZW1lbnQsIChub2RlKSA9PiBpc0ZvY3VzYWJsZVdpdGhUYWJLZXkobm9kZSwgY2hlY2tWaXNpYmlsaXR5KSwgZmFsc2UpO1xufTtcblxuY29uc3QgZmluZEZvY3VzYWJsZSA9IChlbGVtZW50LCBjaGVja1Zpc2liaWxpdHkgPSB0cnVlKSA9PiB7XG4gICAgcmV0dXJuIGZpbmRFbGVtZW50KGVsZW1lbnQsIChub2RlKSA9PiBpc0ZvY3VzYWJsZVdpdGhUYWJLZXkobm9kZSwgY2hlY2tWaXNpYmlsaXR5KSk7XG59O1xuXG5jb25zdCB0b0NsYXNzTGlzdCA9IChjbGFzc05hbWVzKSA9PiBTdHJpbmcoY2xhc3NOYW1lcykudHJpbSgpLnNwbGl0KCcgJyk7XG5jb25zdCBoYXNDbGFzc2VzID0gKGVsZW1lbnQsIGNsYXNzTmFtZXMpID0+IHtcbiAgICBjb25zdCBuYW1lc0xpc3QgPSB0b0NsYXNzTGlzdChjbGFzc05hbWVzKTtcbiAgICByZXR1cm4gQm9vbGVhbih0b0NsYXNzTGlzdChlbGVtZW50LmNsYXNzTmFtZSkuZmluZCgoY2xhc3NOYW1lKSA9PiBuYW1lc0xpc3QuaW5kZXhPZihjbGFzc05hbWUpID49IDApKTtcbn07XG5cbmNvbnN0IG1hdGNoZXNDbGFzc2VzID0gKGNsYXNzTmFtZXMpID0+IChlbGVtZW50KSA9PiBoYXNDbGFzc2VzKGVsZW1lbnQsIGNsYXNzTmFtZXMpO1xuXG5jb25zdCBOT0RFX05BTUVfUFJFRElDQVRFUyA9IHt9O1xuY29uc3QgbWF0Y2hlc05vZGVOYW1lID0gKG5vZGVOYW1lKSA9PiB7XG4gICAgaWYgKCFOT0RFX05BTUVfUFJFRElDQVRFU1tub2RlTmFtZV0pIHtcbiAgICAgICAgTk9ERV9OQU1FX1BSRURJQ0FURVNbbm9kZU5hbWVdID0gKGVsZW1lbnQpID0+IFN0cmluZyhlbGVtZW50Lm5vZGVOYW1lKS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gTk9ERV9OQU1FX1BSRURJQ0FURVNbbm9kZU5hbWVdO1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemVzIGEgc2Nyb2xsIHBvc2l0aW9uIHZhbHVlIGluIFJUTCBtb2RlLlxuICovXG5mdW5jdGlvbiBydGxTY3JvbGxQb3NpdGlvbihwb3NpdGlvbiwgZWxlbWVudCwgaW5pdGlhbCkge1xuICAgIGxldCByZXN1bHQgPSBwb3NpdGlvbjtcbiAgICBpZiAoaW5pdGlhbCA8IDApIHtcbiAgICAgICAgcmVzdWx0ID0gLXBvc2l0aW9uO1xuICAgIH1cbiAgICBlbHNlIGlmIChpbml0aWFsID4gMCkge1xuICAgICAgICByZXN1bHQgPSBlbGVtZW50LnNjcm9sbFdpZHRoIC0gZWxlbWVudC5vZmZzZXRXaWR0aCAtIHBvc2l0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZTpuby1pbnB1dC1yZW5hbWUgKi9cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgRXZlbnRzT3V0c2lkZUFuZ3VsYXJEaXJlY3RpdmUgPSBjbGFzcyBFdmVudHNPdXRzaWRlQW5ndWxhckRpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgbmdab25lLCByZW5kZXJlcikge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IHt9O1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnQgfHwgIXRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXZlbnRzID0gdGhpcy5ldmVudHM7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIGluIGV2ZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChldmVudHMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2godGhpcy5yZW5kZXJlci5saXN0ZW4odGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIG5hbWUsIHRoaXMuc2NvcGUgPyBldmVudHNbbmFtZV0uYmluZCh0aGlzLnNjb3BlKSA6IGV2ZW50c1tuYW1lXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCB0aGlzLnN1YnNjcmlwdGlvbnMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uc1tpZHhdKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCdrZW5kb0V2ZW50c091dHNpZGVBbmd1bGFyJyksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEV2ZW50c091dHNpZGVBbmd1bGFyRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJldmVudHNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEV2ZW50c091dHNpZGVBbmd1bGFyRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJzY29wZVwiLCB2b2lkIDApO1xuRXZlbnRzT3V0c2lkZUFuZ3VsYXJEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0V2ZW50c091dHNpZGVBbmd1bGFyXSdcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsXG4gICAgICAgIE5nWm9uZSxcbiAgICAgICAgUmVuZGVyZXIyXSlcbl0sIEV2ZW50c091dHNpZGVBbmd1bGFyRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBFdmVudHNNb2R1bGUgPSBjbGFzcyBFdmVudHNNb2R1bGUge1xufTtcbkV2ZW50c01vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbRXZlbnRzT3V0c2lkZUFuZ3VsYXJEaXJlY3RpdmVdLFxuICAgICAgICBleHBvcnRzOiBbRXZlbnRzT3V0c2lkZUFuZ3VsYXJEaXJlY3RpdmVdXG4gICAgfSlcbl0sIEV2ZW50c01vZHVsZSk7XG5cbmNsYXNzIFJlc2l6ZVNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKHJlc2l6ZUJhdGNoU2VydmljZSkge1xuICAgICAgICB0aGlzLnJlc2l6ZUJhdGNoU2VydmljZSA9IHJlc2l6ZUJhdGNoU2VydmljZTtcbiAgICAgICAgdGhpcy5yZXNpemUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuYWNjZXB0ZWRTaXplID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAwIC8qIEluaXRpYWwgKi87XG4gICAgfVxuICAgIGFjY2VwdFNpemUoc2l6ZSA9IHRoaXMubWVhc3VyZSgpKSB7XG4gICAgICAgIHRoaXMubGFzdFdpZHRoID0gc2l6ZS53aWR0aDtcbiAgICAgICAgdGhpcy5sYXN0SGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG4gICAgICAgIHRoaXMuYWNjZXB0ZWRTaXplID0gdHJ1ZTtcbiAgICB9XG4gICAgY2hlY2tDaGFuZ2VzKCkge1xuICAgICAgICBpZiAoIWlzRG9jdW1lbnRBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAwIC8qIEluaXRpYWwgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxIC8qIEluaXRpYWxpemluZyAqLztcbiAgICAgICAgICAgIC8vIGJhdGNoIGluaXRpYWwgbWVhc3VyZVxuICAgICAgICAgICAgdGhpcy5yZXNpemVCYXRjaFNlcnZpY2Uuc2NoZWR1bGUodGhpcywgdGhpcy5pbml0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnJlc2l6ZUJhdGNoU2VydmljZS5jYW5jZWwodGhpcyk7XG4gICAgfVxuICAgIGNoZWNrU2l6ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMubWVhc3VyZSgpO1xuICAgICAgICBjb25zdCBzYW1lU2l6ZSA9IHdpZHRoID09PSB0aGlzLmxhc3RXaWR0aCAmJiBoZWlnaHQgPT09IHRoaXMubGFzdEhlaWdodDtcbiAgICAgICAgaWYgKHNhbWVTaXplKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0V2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5sYXN0SGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLmFjY2VwdGVkU2l6ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlc2l6ZS5lbWl0KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpbml0U2l6ZSgpIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMubWVhc3VyZSgpO1xuICAgICAgICB0aGlzLmxhc3RXaWR0aCA9IHNpemUud2lkdGg7XG4gICAgICAgIHRoaXMubGFzdEhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgIH1cbiAgICBtZWFzdXJlKCkge1xuICAgICAgICBsZXQgd2lkdGggPSAwO1xuICAgICAgICBsZXQgaGVpZ2h0ID0gMDtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5wYXJlbnRFbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgIHdpZHRoID0gdGhpcy5wYXJlbnRFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGhlaWdodCwgd2lkdGggfTtcbiAgICB9XG59XG5cbi8vIHRzbGludDpkaXNhYmxlOmRlcHJlY2F0aW9uXG5jb25zdCBkaXYgPSBzdHlsZSA9PiB7XG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbC5zdHlsZS5jc3NUZXh0ID0gc3R5bGU7XG4gICAgcmV0dXJuIGVsO1xufTtcbmNvbnN0IGNvbXB1dGVkUHJvcCA9IChlbGVtLCBwcm9wKSA9PiBnZXRDb21wdXRlZFN0eWxlKGVsZW0sIG51bGwpLmdldFByb3BlcnR5VmFsdWUocHJvcCk7XG5jb25zdCBXUkFQX1NUWUxFID0gJ3Bvc2l0aW9uOiBhYnNvbHV0ZTsgZGlzcGxheTogYmxvY2s7IGxlZnQ6IDA7IHRvcDogMDsgcmlnaHQ6IDA7IGJvdHRvbTogMDsgei1pbmRleDogLTE7JyArXG4gICAgJ292ZXJmbG93OiBoaWRkZW47IHZpc2liaWxpdHk6IGhpZGRlbjsnO1xuY29uc3QgRVhQQU5EX0NISUxEX1NUWUxFID0gJ3Bvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogMDsgdG9wOiAwOyB0cmFuc2l0aW9uOiAwczsnO1xuY29uc3QgU0hSSU5LX0NISUxEX1NUWUxFID0gRVhQQU5EX0NISUxEX1NUWUxFICsgJ3dpZHRoOiAyMDAlOyBoZWlnaHQ6IDIwMCU7JztcbmNsYXNzIFJlc2l6ZUNvbXBhdFNlcnZpY2UgZXh0ZW5kcyBSZXNpemVTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNpemVCYXRjaFNlcnZpY2UsIGVsZW1lbnQsIG5nWm9uZSkge1xuICAgICAgICBzdXBlcihyZXNpemVCYXRjaFNlcnZpY2UpO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICB9XG4gICAgY2hlY2tDaGFuZ2VzKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gMiAvKiBJbml0aWFsaXplZCAqLykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlc2l6ZUJhdGNoU2VydmljZS5pc1NjaGVkdWxlZCh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplQmF0Y2hTZXJ2aWNlLnNjaGVkdWxlKHRoaXMsIHRoaXMuY2hlY2tTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5jaGVja0NoYW5nZXMoKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXhwYW5kKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuZXhwYW5kKTtcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5zaHJpbmspO1xuICAgICAgICAgICAgdGhpcy5leHBhbmQucmVtb3ZlQ2hpbGQodGhpcy5leHBhbmRDaGlsZCk7XG4gICAgICAgICAgICB0aGlzLmV4cGFuZCA9IHRoaXMuZXhwYW5kQ2hpbGQgPSB0aGlzLnNocmluayA9IHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tTaXplKCkge1xuICAgICAgICBpZiAoc3VwZXIuY2hlY2tTaXplKCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaXQoKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudEVsZW1lbnQgPSB0aGlzLnBhcmVudEVsZW1lbnQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICBpZiAoY29tcHV0ZWRQcm9wKHBhcmVudEVsZW1lbnQsICdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuICAgICAgICAgICAgcGFyZW50RWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IDIgLyogSW5pdGlhbGl6ZWQgKi87XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgdGhpcy5pbml0U2l6ZSgpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gV1JBUF9TVFlMRTtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RpcicsICdsdHInKTtcbiAgICAgICAgdGhpcy5leHBhbmQgPSBkaXYoV1JBUF9TVFlMRSk7XG4gICAgICAgIHRoaXMuZXhwYW5kQ2hpbGQgPSBkaXYoRVhQQU5EX0NISUxEX1NUWUxFKTtcbiAgICAgICAgdGhpcy5leHBhbmQuYXBwZW5kQ2hpbGQodGhpcy5leHBhbmRDaGlsZCk7XG4gICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5leHBhbmQpO1xuICAgICAgICB0aGlzLnNocmluayA9IGRpdihXUkFQX1NUWUxFKTtcbiAgICAgICAgY29uc3Qgc2hyaW5rQ2hpbGQgPSBkaXYoU0hSSU5LX0NISUxEX1NUWUxFKTtcbiAgICAgICAgdGhpcy5zaHJpbmsuYXBwZW5kQ2hpbGQoc2hyaW5rQ2hpbGQpO1xuICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuc2hyaW5rKTtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIGNvbnN0IGV4cGFuZENoaWxkID0gdGhpcy5leHBhbmRDaGlsZDtcbiAgICAgICAgZXhwYW5kQ2hpbGQuc3R5bGUud2lkdGggPSAxMDAwMDAgKyAncHgnO1xuICAgICAgICBleHBhbmRDaGlsZC5zdHlsZS5oZWlnaHQgPSAxMDAwMDAgKyAncHgnO1xuICAgICAgICBjb25zdCBleHBhbmQgPSB0aGlzLmV4cGFuZDtcbiAgICAgICAgZXhwYW5kLnNjcm9sbExlZnQgPSAxMDAwMDA7XG4gICAgICAgIGV4cGFuZC5zY3JvbGxUb3AgPSAxMDAwMDA7XG4gICAgICAgIGNvbnN0IHNocmluayA9IHRoaXMuc2hyaW5rO1xuICAgICAgICBzaHJpbmsuc2Nyb2xsTGVmdCA9IDEwMDAwMDtcbiAgICAgICAgc2hyaW5rLnNjcm9sbFRvcCA9IDEwMDAwMDtcbiAgICB9XG4gICAgc3Vic2NyaWJlKCkge1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IG1lcmdlKGZyb21FdmVudCh0aGlzLnNocmluaywgJ3Njcm9sbCcpLCBmcm9tRXZlbnQodGhpcy5leHBhbmQsICdzY3JvbGwnKSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrU2l6ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY29uc3QgSEFTX09CU0VSVkVSID0gdHlwZW9mIFJlc2l6ZU9ic2VydmVyICE9PSAndW5kZWZpbmVkJztcbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBSZXNpemVPYnNlcnZlclNlcnZpY2UgZXh0ZW5kcyBSZXNpemVTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNpemVCYXRjaFNlcnZpY2UsIGVsZW1lbnQsIG5nWm9uZSkge1xuICAgICAgICBzdXBlcihyZXNpemVCYXRjaFNlcnZpY2UpO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICB9XG4gICAgc3RhdGljIHN1cHBvcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIEhBU19PQlNFUlZFUjtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5yZXNpemVPYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcmVudEVsZW1lbnQgPSBudWxsO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICB0aGlzLnBhcmVudEVsZW1lbnQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICB0aGlzLmluaXRTaXplKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAyIC8qIEluaXRpYWxpemVkICovO1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrU2l6ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy5wYXJlbnRFbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZTphbGlnbiAqL1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBSZXNpemVCYXRjaFNlcnZpY2UgPSBjbGFzcyBSZXNpemVCYXRjaFNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKG5nWm9uZSkge1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZWQgPSBbXTtcbiAgICAgICAgdGhpcy5yZXNvbHZlZFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIHRoaXMuZmx1c2ggPSB0aGlzLmZsdXNoLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIHNjaGVkdWxlKGluc3RhbmNlLCBtZXRob2QpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZWQucHVzaCh7IGluc3RhbmNlLCBtZXRob2QgfSk7XG4gICAgICAgIGlmICghdGhpcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IGZyb20odGhpcy5yZXNvbHZlZFByb21pc2UpXG4gICAgICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUodGhpcy5mbHVzaCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc1NjaGVkdWxlZChpbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLnNjaGVkdWxlZC5maW5kKGl0ZW0gPT4gaXRlbS5pbnN0YW5jZSA9PT0gaW5zdGFuY2UpKTtcbiAgICB9XG4gICAgY2FuY2VsKGluc3RhbmNlKSB7XG4gICAgICAgIGNvbnN0IHNjaGVkdWxlZCA9IHRoaXMuc2NoZWR1bGVkO1xuICAgICAgICBjb25zdCBjb3VudCA9IHNjaGVkdWxlZC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGNvdW50OyBpZHgrKykge1xuICAgICAgICAgICAgaWYgKHNjaGVkdWxlZFtpZHhdLmluc3RhbmNlID09PSBpbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlZC5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgICAgICBpZiAoIXNjaGVkdWxlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmbHVzaCgpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZWQuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGl0ZW0ubWV0aG9kLmNhbGwoaXRlbS5pbnN0YW5jZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNjaGVkdWxlZCA9IFtdO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxufTtcblJlc2l6ZUJhdGNoU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05nWm9uZV0pXG5dLCBSZXNpemVCYXRjaFNlcnZpY2UpO1xuXG4vKipcbiAqIEVtaXQgdXAgdG8gMTAgcmVzaXplIGV2ZW50cyBwZXIgc2Vjb25kIGJ5IGRlZmF1bHQuXG4gKiBDaG9zZW4gYXMgYSBjb21wcm9taXNlIGJldHdlZW4gcmVzcG9uc2l2ZW5lc3MgYW5kIHBlcmZvcm1hbmNlLlxuICovXG5jb25zdCBERUZBVUxUX1JBVEVfTElNSVQgPSAxMDtcbi8qKlxuICogUmVzaXplIFNlbnNvciBDb21wb25lbnRcbiAqXG4gKiBUcmlnZ2VycyBhIFwicmVzaXplXCIgZXZlbnQgd2hlbmV2ZXIgdGhlIHBhcmVudCBET00gZWxlbWVudCBzaXplIGNoYW5nZXMuXG4gKi9cbmxldCBSZXNpemVTZW5zb3JDb21wb25lbnQgPSBjbGFzcyBSZXNpemVTZW5zb3JDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHJlc2l6ZUJhdGNoU2VydmljZSwgZWxlbWVudCwgbmdab25lKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgcmVzaXplIGV2ZW50cyB0byBlbWl0IHBlciBzZWNvbmQuXG4gICAgICAgICAqXG4gICAgICAgICAqIERlZmF1bHRzIHRvIDEwLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYXRlTGltaXQgPSBERUZBVUxUX1JBVEVfTElNSVQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBwYXJlbnQgRE9NIGVsZW1lbnQgaGFzIGJlZW4gcmVzaXplZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzaXplID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBjb25zdCBzZXJ2aWNlVHlwZSA9IFJlc2l6ZU9ic2VydmVyU2VydmljZS5zdXBwb3J0ZWQoKSA/IFJlc2l6ZU9ic2VydmVyU2VydmljZSA6IFJlc2l6ZUNvbXBhdFNlcnZpY2U7XG4gICAgICAgIHRoaXMucmVzaXplU2VydmljZSA9IG5ldyBzZXJ2aWNlVHlwZShyZXNpemVCYXRjaFNlcnZpY2UsIGVsZW1lbnQsIG5nWm9uZSk7XG4gICAgICAgIGNvbnN0IHRocm90dGxlVGltZSA9IDEwMDAgLyAodGhpcy5yYXRlTGltaXQgfHwgREVGQVVMVF9SQVRFX0xJTUlUKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLnJlc2l6ZVNlcnZpY2UucmVzaXplXG4gICAgICAgICAgICAucGlwZShhdWRpdFRpbWUodGhyb3R0bGVUaW1lKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlc2l6ZVNlcnZpY2UuYWNjZXB0ZWRTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemUuZW1pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdDaGVja2VkKCkge1xuICAgICAgICB0aGlzLnJlc2l6ZVNlcnZpY2UuY2hlY2tDaGFuZ2VzKCk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLnJlc2l6ZVNlcnZpY2UuZGVzdHJveSgpO1xuICAgIH1cbiAgICBhY2NlcHRTaXplKHNpemUpIHtcbiAgICAgICAgdGhpcy5yZXNpemVTZXJ2aWNlLmFjY2VwdFNpemUoc2l6ZSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFJlc2l6ZVNlbnNvckNvbXBvbmVudC5wcm90b3R5cGUsIFwicmF0ZUxpbWl0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgUmVzaXplU2Vuc29yQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyZXNpemVcIiwgdm9pZCAwKTtcblJlc2l6ZVNlbnNvckNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tcmVzaXplLXNlbnNvcicsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbUmVzaXplQmF0Y2hTZXJ2aWNlLCBFbGVtZW50UmVmLCBOZ1pvbmVdKVxuXSwgUmVzaXplU2Vuc29yQ29tcG9uZW50KTtcblxuY29uc3QgQ09NUE9ORU5UX0RJUkVDVElWRVMgPSBbUmVzaXplU2Vuc29yQ29tcG9uZW50XTtcbi8qKlxuICogUmVzaXplIFNlbnNvciBtb2R1bGVcbiAqL1xubGV0IFJlc2l6ZVNlbnNvck1vZHVsZSA9IGNsYXNzIFJlc2l6ZVNlbnNvck1vZHVsZSB7XG59O1xuUmVzaXplU2Vuc29yTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBkZWNsYXJhdGlvbnM6IFtDT01QT05FTlRfRElSRUNUSVZFU10sXG4gICAgICAgIGV4cG9ydHM6IFtDT01QT05FTlRfRElSRUNUSVZFU10sXG4gICAgICAgIHByb3ZpZGVyczogW1Jlc2l6ZUJhdGNoU2VydmljZV1cbiAgICB9KVxuXSwgUmVzaXplU2Vuc29yTW9kdWxlKTtcblxuY2xhc3MgS2VuZG9JbnB1dCB7XG59XG5cbi8qKlxuICogRW51bSB3aXRoIGtleSBjb2Rlcy5cbiAqL1xudmFyIEtleXM7XG4oZnVuY3Rpb24gKEtleXMpIHtcbiAgICBLZXlzW0tleXNbXCJBbHRcIl0gPSAxOF0gPSBcIkFsdFwiO1xuICAgIEtleXNbS2V5c1tcIkFycm93RG93blwiXSA9IDQwXSA9IFwiQXJyb3dEb3duXCI7XG4gICAgS2V5c1tLZXlzW1wiQXJyb3dMZWZ0XCJdID0gMzddID0gXCJBcnJvd0xlZnRcIjtcbiAgICBLZXlzW0tleXNbXCJBcnJvd1JpZ2h0XCJdID0gMzldID0gXCJBcnJvd1JpZ2h0XCI7XG4gICAgS2V5c1tLZXlzW1wiQXJyb3dVcFwiXSA9IDM4XSA9IFwiQXJyb3dVcFwiO1xuICAgIEtleXNbS2V5c1tcIkJhY2tzcGFjZVwiXSA9IDhdID0gXCJCYWNrc3BhY2VcIjtcbiAgICBLZXlzW0tleXNbXCJDb250cm9sXCJdID0gMTddID0gXCJDb250cm9sXCI7XG4gICAgS2V5c1tLZXlzW1wiRGVsZXRlXCJdID0gNDZdID0gXCJEZWxldGVcIjtcbiAgICBLZXlzW0tleXNbXCJEaWdpdDBcIl0gPSA0OF0gPSBcIkRpZ2l0MFwiO1xuICAgIEtleXNbS2V5c1tcIkRpZ2l0MVwiXSA9IDQ5XSA9IFwiRGlnaXQxXCI7XG4gICAgS2V5c1tLZXlzW1wiRGlnaXQyXCJdID0gNTBdID0gXCJEaWdpdDJcIjtcbiAgICBLZXlzW0tleXNbXCJEaWdpdDNcIl0gPSA1MV0gPSBcIkRpZ2l0M1wiO1xuICAgIEtleXNbS2V5c1tcIkRpZ2l0NFwiXSA9IDUyXSA9IFwiRGlnaXQ0XCI7XG4gICAgS2V5c1tLZXlzW1wiRGlnaXQ1XCJdID0gNTNdID0gXCJEaWdpdDVcIjtcbiAgICBLZXlzW0tleXNbXCJEaWdpdDZcIl0gPSA1NF0gPSBcIkRpZ2l0NlwiO1xuICAgIEtleXNbS2V5c1tcIkRpZ2l0N1wiXSA9IDU1XSA9IFwiRGlnaXQ3XCI7XG4gICAgS2V5c1tLZXlzW1wiRGlnaXQ4XCJdID0gNTZdID0gXCJEaWdpdDhcIjtcbiAgICBLZXlzW0tleXNbXCJEaWdpdDlcIl0gPSA1N10gPSBcIkRpZ2l0OVwiO1xuICAgIEtleXNbS2V5c1tcIkVuZFwiXSA9IDM1XSA9IFwiRW5kXCI7XG4gICAgS2V5c1tLZXlzW1wiRW50ZXJcIl0gPSAxM10gPSBcIkVudGVyXCI7XG4gICAgS2V5c1tLZXlzW1wiRXNjYXBlXCJdID0gMjddID0gXCJFc2NhcGVcIjtcbiAgICBLZXlzW0tleXNbXCJGMVwiXSA9IDExMl0gPSBcIkYxXCI7XG4gICAgS2V5c1tLZXlzW1wiRjJcIl0gPSAxMTNdID0gXCJGMlwiO1xuICAgIEtleXNbS2V5c1tcIkYxMFwiXSA9IDEyMV0gPSBcIkYxMFwiO1xuICAgIEtleXNbS2V5c1tcIkhvbWVcIl0gPSAzNl0gPSBcIkhvbWVcIjtcbiAgICBLZXlzW0tleXNbXCJJbnNlcnRcIl0gPSA0NV0gPSBcIkluc2VydFwiO1xuICAgIEtleXNbS2V5c1tcIktleUFcIl0gPSA2NV0gPSBcIktleUFcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlCXCJdID0gNjZdID0gXCJLZXlCXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5Q1wiXSA9IDY3XSA9IFwiS2V5Q1wiO1xuICAgIEtleXNbS2V5c1tcIktleURcIl0gPSA2OF0gPSBcIktleURcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlFXCJdID0gNjldID0gXCJLZXlFXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5RlwiXSA9IDcwXSA9IFwiS2V5RlwiO1xuICAgIEtleXNbS2V5c1tcIktleUdcIl0gPSA3MV0gPSBcIktleUdcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlIXCJdID0gNzJdID0gXCJLZXlIXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5SVwiXSA9IDczXSA9IFwiS2V5SVwiO1xuICAgIEtleXNbS2V5c1tcIktleUpcIl0gPSA3NF0gPSBcIktleUpcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlLXCJdID0gNzVdID0gXCJLZXlLXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5TFwiXSA9IDc2XSA9IFwiS2V5TFwiO1xuICAgIEtleXNbS2V5c1tcIktleU1cIl0gPSA3N10gPSBcIktleU1cIjtcbiAgICBLZXlzW0tleXNbXCJLZXlOXCJdID0gNzhdID0gXCJLZXlOXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5T1wiXSA9IDc5XSA9IFwiS2V5T1wiO1xuICAgIEtleXNbS2V5c1tcIktleVBcIl0gPSA4MF0gPSBcIktleVBcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlRXCJdID0gODFdID0gXCJLZXlRXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5UlwiXSA9IDgyXSA9IFwiS2V5UlwiO1xuICAgIEtleXNbS2V5c1tcIktleVNcIl0gPSA4M10gPSBcIktleVNcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlUXCJdID0gODRdID0gXCJLZXlUXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5VVwiXSA9IDg1XSA9IFwiS2V5VVwiO1xuICAgIEtleXNbS2V5c1tcIktleVZcIl0gPSA4Nl0gPSBcIktleVZcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlXXCJdID0gODddID0gXCJLZXlXXCI7XG4gICAgS2V5c1tLZXlzW1wiS2V5WFwiXSA9IDg4XSA9IFwiS2V5WFwiO1xuICAgIEtleXNbS2V5c1tcIktleVlcIl0gPSA4OV0gPSBcIktleVlcIjtcbiAgICBLZXlzW0tleXNbXCJLZXlaXCJdID0gOTBdID0gXCJLZXlaXCI7XG4gICAgS2V5c1tLZXlzW1wiTnVtcGFkRGVjaW1hbFwiXSA9IDExMF0gPSBcIk51bXBhZERlY2ltYWxcIjtcbiAgICBLZXlzW0tleXNbXCJQYWdlRG93blwiXSA9IDM0XSA9IFwiUGFnZURvd25cIjtcbiAgICBLZXlzW0tleXNbXCJQYWdlVXBcIl0gPSAzM10gPSBcIlBhZ2VVcFwiO1xuICAgIEtleXNbS2V5c1tcIlNoaWZ0XCJdID0gMTZdID0gXCJTaGlmdFwiO1xuICAgIEtleXNbS2V5c1tcIlNwYWNlXCJdID0gMzJdID0gXCJTcGFjZVwiO1xuICAgIEtleXNbS2V5c1tcIlRhYlwiXSA9IDldID0gXCJUYWJcIjtcbn0pKEtleXMgfHwgKEtleXMgPSB7fSkpO1xuXG5jbGFzcyBQcmV2ZW50YWJsZUV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJldmVudHMgdGhlIGRlZmF1bHQgYWN0aW9uIGZvciBhIHNwZWNpZmllZCBldmVudC5cbiAgICAgKiBJbiB0aGlzIHdheSwgdGhlIHNvdXJjZSBjb21wb25lbnQgc3VwcHJlc3Nlc1xuICAgICAqIHRoZSBidWlsdC1pbiBiZWhhdmlvciB0aGF0IGZvbGxvd3MgdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICB0aGlzLnByZXZlbnRlZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBldmVudCB3YXMgcHJldmVudGVkXG4gICAgICogYnkgYW55IG9mIGl0cyBzdWJzY3JpYmVycy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgZGVmYXVsdCBhY3Rpb24gd2FzIHByZXZlbnRlZC5cbiAgICAgKiBPdGhlcndpc2UsIHJldHVybnMgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBpc0RlZmF1bHRQcmV2ZW50ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZlbnRlZDtcbiAgICB9XG59XG5cbi8qKlxuICogR2VuZXJhdGVkIGJ1bmRsZSBpbmRleC4gRG8gbm90IGVkaXQuXG4gKi9cblxuZXhwb3J0IHsgUmVzaXplU2VydmljZSwgUHJldmVudGFibGVFdmVudCwgRHJhZ2dhYmxlRGlyZWN0aXZlLCBEcmFnZ2FibGVNb2R1bGUsIGNsb3Nlc3RJblNjb3BlLCBjbG9zZXN0LCBjb250YWlucywgZmluZEVsZW1lbnQsIGZpbmRGb2N1c2FibGVDaGlsZCwgZmluZEZvY3VzYWJsZSwgaGFzQ2xhc3NlcywgaXNGb2N1c2FibGVXaXRoVGFiS2V5LCBpc0ZvY3VzYWJsZSwgaXNWaXNpYmxlLCBtYXRjaGVzQ2xhc3NlcywgbWF0Y2hlc05vZGVOYW1lLCBydGxTY3JvbGxQb3NpdGlvbiwgRXZlbnRzT3V0c2lkZUFuZ3VsYXJEaXJlY3RpdmUsIEV2ZW50c01vZHVsZSwgUmVzaXplU2Vuc29yQ29tcG9uZW50LCBSZXNpemVCYXRjaFNlcnZpY2UsIFJlc2l6ZUNvbXBhdFNlcnZpY2UsIFJlc2l6ZU9ic2VydmVyU2VydmljZSwgUmVzaXplU2Vuc29yTW9kdWxlLCBLZW5kb0lucHV0LCBpc0RvY3VtZW50QXZhaWxhYmxlLCBpc0NoYW5nZWQsIGFueUNoYW5nZWQsIGhhc09ic2VydmVycywgZ3VpZCwgS2V5cyB9O1xuIl19\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-popup-common/dist/es2015/align-point.js\n/* harmony default export */ var align_point = ({\n    \"bottom\": \"bottom\",\n    \"center\": \"center\",\n    \"middle\": \"middle\",\n    \"left\": \"left\",\n    \"right\": \"right\",\n    \"top\": \"top\"\n});\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-popup-common/dist/es2015/align.js\n\n\nconst align_align = (options) => {\n    const { anchorRect, anchorAlign, elementRect, elementAlign, margin = {} } = options;\n    const anchorHorizontal = anchorAlign.horizontal;\n    const anchorVertical = anchorAlign.vertical;\n    const elementHorizontal = elementAlign.horizontal;\n    const elementVertical = elementAlign.vertical;\n\n    let horizontalMargin = margin.horizontal || 0;\n    let verticalMargin = margin.vertical || 0;\n\n    let top = anchorRect.top;\n    let left = anchorRect.left;\n\n    if (anchorVertical === align_point.bottom) {\n        top += anchorRect.height;\n    }\n\n    if (anchorVertical === align_point.center || anchorVertical === align_point.middle) {\n        top += Math.round(anchorRect.height / 2);\n    }\n\n    if (elementVertical === align_point.bottom) {\n        top -= elementRect.height;\n        verticalMargin *= -1;\n    }\n\n    if (elementVertical === align_point.center || elementVertical === align_point.middle) {\n        top -= Math.round(elementRect.height / 2);\n        verticalMargin *= -1;\n    }\n\n    if (anchorHorizontal === align_point.right) {\n        left += anchorRect.width;\n    }\n\n    if (anchorHorizontal === align_point.center || anchorHorizontal === align_point.middle) {\n        left += Math.round(anchorRect.width / 2);\n    }\n\n    if (elementHorizontal === align_point.right) {\n        left -= elementRect.width;\n        horizontalMargin *= -1;\n    }\n\n    if (elementHorizontal === align_point.center || elementHorizontal === align_point.middle) {\n        left -= Math.round(elementRect.width / 2);\n        horizontalMargin *= -1;\n    }\n\n    return {\n        top: top + verticalMargin,\n        left: left + horizontalMargin\n    };\n};\n\n/* harmony default export */ var es2015_align = (align_align);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-popup-common/dist/es2015/add-scroll.js\nfunction addScroll(rect, scroll) {\n    return {\n        top: rect.top + scroll.y,\n        left: rect.left + scroll.x,\n        height: rect.height,\n        width: rect.width\n    };\n}\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-popup-common/dist/es2015/apply-location-offset.js\nfunction applyLocationOffset(rect, location, isOffsetBody) {\n    let { top, left } = rect;\n\n    if (isOffsetBody) {\n        left = 0;\n        top = 0;\n    }\n\n    return {\n        top: top + location.top,\n        left: left + location.left,\n        height: rect.height,\n        width: rect.width\n    };\n}\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-popup-common/dist/es2015/owner-document.js\nfunction owner_document_ownerDocument(element) {\n    return element.ownerDocument || element.document || element;\n}\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-popup-common/dist/es2015/window.js\n\n\nconst getWindow = (element) => owner_document_ownerDocument(element).defaultView;\n\n/* harmony default export */ var es2015_window = (getWindow);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-popup-common/dist/es2015/document.js\n\n\nconst getDocument = (element) => owner_document_ownerDocument(element).documentElement;\n\n/* harmony default export */ var es2015_document = (getDocument);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-popup-common/dist/es2015/scrollbar-width.js\nlet cachedWidth = 0;\n\nfunction scrollbarWidth() {\n    if (!cachedWidth && typeof document !== 'undefined') {\n        const div = document.createElement(\"div\");\n\n        div.style.cssText = \"overflow:scroll;overflow-x:hidden;zoom:1;clear:both;display:block\";\n        div.innerHTML = \"&nbsp;\";\n        document.body.appendChild(div);\n\n        cachedWidth = div.offsetWidth - div.scrollWidth;\n\n        document.body.removeChild(div);\n    }\n\n    return cachedWidth;\n}\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-popup-common/dist/es2015/window-viewport.js\n\n\n\n\nfunction windowViewport(element) {\n    const win = es2015_window(element);\n    const document = es2015_document(element);\n    const result = {\n        height: win.innerHeight,\n        width: win.innerWidth\n    };\n\n    if (document.scrollHeight - document.clientHeight > 0) {\n        result.width -= scrollbarWidth();\n    }\n\n    return result;\n}\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-popup-common/dist/es2015/bounding-offset.js\n\n\nconst boundingOffset = (element) => {\n    if (!element.getBoundingClientRect) {\n        const viewport = windowViewport(element);\n        return {\n            bottom: viewport.height,\n            left: 0,\n            right: viewport.width,\n            top: 0\n        };\n    }\n\n    const { bottom, left, right, top } = element.getBoundingClientRect();\n\n    return {\n        bottom,\n        left,\n        right,\n        top\n    };\n};\n\n/* harmony default export */ var bounding_offset = (boundingOffset);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-popup-common/dist/es2015/offset-parent.js\n\n\nconst offset_parent_offsetParent = (element) => {\n    let offsetParent = element.offsetParent;\n\n    while (offsetParent && offsetParent.style.position === \"static\") {\n        offsetParent = offsetParent.offsetParent;\n    }\n\n    return offsetParent || es2015_document(element);\n};\n\n/* harmony default export */ var offset_parent = (offset_parent_offsetParent);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-popup-common/dist/es2015/is-body-offset.js\n\n\nconst isBodyOffset = (element) => (offset_parent(element) === element.ownerDocument.body);\n\n/* harmony default export */ var is_body_offset = (isBodyOffset);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-popup-common/dist/es2015/offset.js\nconst rectOfHiddenElement = (element) => {\n    const { display, left, position } = element.style;\n\n    element.style.display = '';\n    element.style.left = '-10000px';\n    element.style.position = 'absolute';\n\n    const rect = element.getBoundingClientRect();\n\n    element.style.display = display;\n    element.style.left = left;\n    element.style.position = position;\n\n    return rect;\n};\n\nconst offset_offset = (element) => {\n    let rect = element.getBoundingClientRect();\n    let { left, top } = rect;\n\n    if (!rect.height && !rect.width) {\n        rect = rectOfHiddenElement(element);\n    }\n\n    return {\n        top: top,\n        left: left,\n        height: rect.height,\n        width: rect.width\n    };\n};\n\n/* harmony default export */ var es2015_offset = (offset_offset);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-popup-common/dist/es2015/parents.js\n/* harmony default export */ var parents = ((element, until) => {\n    const result = [];\n    let next = element.parentNode;\n\n    while (next) {\n        result.push(next);\n\n        if (next === until) { break; }\n\n        next = next.parentNode;\n    }\n\n    return result;\n});\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-popup-common/dist/es2015/scroll-position.js\n\n\n\nfunction scrollPosition(element) {\n    const documentElement = es2015_document(element);\n    const win = es2015_window(element);\n\n    return {\n        x: win.pageXOffset || documentElement.scrollLeft || 0,\n        y: win.pageYOffset || documentElement.scrollTop || 0\n    };\n}\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-popup-common/dist/es2015/element-scroll-position.js\n\n\n/* harmony default export */ var element_scroll_position = ((element) => {\n    if (element === (element.ownerDocument || {}).body) {\n        return scrollPosition(element);\n    }\n\n    return {\n        x: element.scrollLeft,\n        y: element.scrollTop\n    };\n});\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-popup-common/dist/es2015/parent-scroll-position.js\n\n\n\nfunction parentScrollPosition(element) {\n    const parent = offset_parent(element);\n\n    return parent ? element_scroll_position(parent) : { x: 0, y: 0 };\n}\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-popup-common/dist/es2015/position.js\n\n\n\n\nconst position_position = (element, parent) => {\n    const win = es2015_window(element);\n    const elementStyles = win.getComputedStyle(element);\n    const offset = es2015_offset(element);\n    const parentElement = parent || offset_parent(element);\n\n    const ownerDocument = element.ownerDocument;\n    const useRelative = parentElement !== ownerDocument.body && parentElement !== ownerDocument.documentElement;\n\n    let parentOffset = { top: 0, left: 0 };\n\n    if (elementStyles.position !== \"fixed\" && useRelative) {\n        const parentStyles = win.getComputedStyle(parentElement);\n\n        parentOffset = es2015_offset(parentElement);\n        parentOffset.top += parseInt(parentStyles.borderTopWidth, 10);\n        parentOffset.left += parseInt(parentStyles.borderLeftWidth, 10);\n    }\n\n    return {\n        top: offset.top - parentOffset.top,\n        left: offset.left - parentOffset.left,\n        height: offset.height,\n        width: offset.width\n    };\n};\n\n/* harmony default export */ var es2015_position = (position_position);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-popup-common/dist/es2015/offset-parent-scroll-position.js\n\n\n\n/* harmony default export */ var offset_parent_scroll_position = ((offsetParentElement, element) => ( // eslint-disable-line no-arrow-condition\n    offsetParentElement ? element_scroll_position(offsetParentElement) : parentScrollPosition(element)\n));\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-popup-common/dist/es2015/position-with-scroll.js\n\n\n\n\n/* harmony default export */ var position_with_scroll = ((element, parent, scale = 1) => {\n    const offsetParentElement = parent ? offset_parent(parent) : null;\n    const { top, left, height, width } = es2015_position(element, offsetParentElement);\n    const { x, y } = offset_parent_scroll_position(offsetParentElement, element);\n    const ownerDocument = element.ownerDocument;\n    const positionScale = offsetParentElement === ownerDocument.body || offsetParentElement === ownerDocument.documentElement ? 1 : scale;\n\n    return {\n        top: top + y * positionScale,\n        left: left + x * positionScale,\n        height: height,\n        width: width\n    };\n});\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-popup-common/dist/es2015/remove-scroll.js\nfunction removeScroll(rect, scroll) {\n    return {\n        top: rect.top - scroll.y,\n        left: rect.left - scroll.x,\n        height: rect.height,\n        width: rect.width\n    };\n}\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-popup-common/dist/es2015/collision.js\n/* harmony default export */ var collision = ({\n    \"fit\": \"fit\",\n    \"flip\": \"flip\"\n});\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-popup-common/dist/es2015/restrict-to-view.js\n\n\n\nconst restrict_to_view_fit = function(position, size, viewPortSize) {\n    let output = 0;\n\n    if (position + size > viewPortSize) {\n        output = viewPortSize - (position + size);\n    }\n\n    if (position < 0) {\n        output = -position;\n    }\n\n    return output;\n};\n\nconst restrict_to_view_flip = function({ offset, size, anchorSize, viewPortSize, anchorAlignPoint, elementAlignPoint, margin }) {\n    let output = 0;\n\n    const isPositionCentered = elementAlignPoint === align_point.center || elementAlignPoint === align_point.middle;\n    const isOriginCentered = anchorAlignPoint === align_point.center || anchorAlignPoint === align_point.middle;\n    const marginToAdd = 2 * margin; //2x to keep margin after flip\n\n    if (elementAlignPoint !== anchorAlignPoint && !isPositionCentered && !isOriginCentered) {\n        const isBeforeAnchor = anchorAlignPoint === align_point.top || anchorAlignPoint === align_point.left;\n        if (offset < 0 && isBeforeAnchor) {\n            output = size + anchorSize + marginToAdd;\n            if (offset + output + size > viewPortSize) {\n                output = 0; //skip flip\n            }\n        } else if (offset >= 0 && !isBeforeAnchor) {\n            if (offset + size > viewPortSize) {\n                output += -(anchorSize + size + marginToAdd);\n            }\n\n            if (offset + output < 0) {\n                output = 0; //skip flip\n            }\n        }\n    }\n\n    return output;\n};\n\nconst restrictToView = (options) => {\n    const { anchorRect, anchorAlign, elementRect, elementAlign, collisions, viewPort, margin = {} } = options;\n    const { top: elementTop, left: elementLeft, height: elementHeight, width: elementWidth } = elementRect;\n    const { height: viewPortHeight, width: viewPortWidth } = viewPort;\n    const horizontalMargin = margin.horizontal || 0;\n    const verticalMargin = margin.vertical || 0;\n\n    let left = 0;\n    let top = 0;\n\n    const isHorizontalFlip = collisions.horizontal === collision.flip;\n    const isVerticalFlip = collisions.vertical === collision.flip;\n\n    if (collisions.vertical === collision.fit) {\n        top += restrict_to_view_fit(elementTop, elementHeight, viewPortHeight);\n    }\n\n    if (collisions.horizontal === collision.fit) {\n        left += restrict_to_view_fit(elementLeft, elementWidth, viewPortWidth);\n    }\n\n    if (isVerticalFlip) {\n        top += restrict_to_view_flip({\n            margin: verticalMargin,\n            offset: elementTop,\n            size: elementHeight,\n            anchorSize: anchorRect.height,\n            viewPortSize: viewPortHeight,\n            anchorAlignPoint: anchorAlign.vertical,\n            elementAlignPoint: elementAlign.vertical\n        });\n    }\n\n    if (isHorizontalFlip) {\n        left += restrict_to_view_flip({\n            margin: horizontalMargin,\n            offset: elementLeft,\n            size: elementWidth,\n            anchorSize: anchorRect.width,\n            viewPortSize: viewPortWidth,\n            anchorAlignPoint: anchorAlign.horizontal,\n            elementAlignPoint: elementAlign.horizontal\n        });\n    }\n    const flippedHorizontal = isHorizontalFlip && left !== 0;\n    const flippedVertical = isVerticalFlip && top !== 0;\n\n    return {\n        flipped: flippedHorizontal || flippedVertical,\n        flip: {\n            horizontal: flippedHorizontal,\n            vertical: flippedVertical\n        },\n        offset: {\n            left: left,\n            top: top\n        }\n    };\n};\n\n/* harmony default export */ var restrict_to_view = (restrictToView);\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-popup-common/dist/es2015/siblings.js\n/* harmony default export */ var siblings = ((element) => {\n    const result = [];\n\n    let sibling = element.parentNode.firstElementChild;\n\n    while (sibling) {\n        if (sibling !== element) {\n            result.push(sibling);\n        }\n\n        sibling = sibling.nextElementSibling;\n    }\n    return result;\n});\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-popup-common/dist/es2015/sibling-container.js\n/* eslint-disable no-loop-func */\n\n\n\n\n/* harmony default export */ var sibling_container = ((anchor, container) => {\n    const parentElements = parents(anchor);\n    let containerElement = container;\n    let siblingElements;\n    let result;\n\n    while (containerElement) {\n        siblingElements = siblings(containerElement);\n\n        result = parentElements.reduce(\n            (list, p) => list.concat(siblingElements.filter(s => s === p)),\n            []\n        )[0];\n\n        if (result) { break; }\n\n        containerElement = containerElement.parentElement;\n    }\n\n    return result;\n});\n\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-popup-common/dist/es2015/z-index.js\n\n\n\nfunction z_index_zIndex(anchor, container) {\n    if (!anchor || !container) { return null; }\n\n    const sibling = sibling_container(anchor, container);\n\n    if (!sibling) { return null; }\n\n    const result = [ anchor ].concat(parents(anchor, sibling)).reduce(\n        (index, p) => {\n            const zIndexStyle = p.style.zIndex || window.getComputedStyle(p).zIndex;\n            const current = parseInt(zIndexStyle, 10);\n            return current > index ? current : index;\n        },\n        0\n    );\n\n    return result ? (result + 1) : null;\n}\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-popup-common/dist/es2015/main.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// EXTERNAL MODULE: ./node_modules/@angular/animations/__ivy_ngcc__/fesm2015/animations.js\nvar animations = __webpack_require__(\"R0Ic\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-angular-popup/__ivy_ngcc__/dist/fesm2015/index.js\n/**-----------------------------------------------------------------------------------------\n* Copyright © 2020 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n\n\n/**\n * @hidden\n */\n\n\n\n\nconst _c0 = [\"container\"];\nfunction PopupComponent_ng_template_3_Template(rf, ctx) { }\nconst _c1 = [\"*\"];\nconst eitherRect = (rect, offset$$1) => {\n    if (!rect) {\n        return { height: 0, left: offset$$1.left, top: offset$$1.top, width: 0 };\n    }\n    return rect;\n};\n/**\n * @hidden\n */\nconst removeStackingOffset = (rect, stackingOffset) => {\n    if (!stackingOffset) {\n        return rect;\n    }\n    const result = {\n        height: rect.height,\n        left: rect.left - stackingOffset.left,\n        top: rect.top - stackingOffset.top,\n        width: rect.width\n    };\n    return result;\n};\n/**\n * @hidden\n */\nconst isDifferentOffset = (oldOffset, newOffset) => {\n    const { left: oldLeft, top: oldTop } = oldOffset;\n    const { left: newLeft, top: newTop } = newOffset;\n    return Math.abs(oldLeft - newLeft) >= 1 || Math.abs(oldTop - newTop) >= 1;\n};\n/**\n * @hidden\n */\nconst isWindowAvailable = () => {\n    return typeof window !== 'undefined';\n};\n/**\n * @hidden\n */\nconst OVERFLOW_REGEXP = /auto|scroll/;\nconst overflowElementStyle = (element) => {\n    return `${element.style.overflow}${element.style.overflowX}${element.style.overflowY}`;\n};\nconst overflowComputedStyle = (element) => {\n    const styles = window.getComputedStyle(element);\n    return `${styles.overflow}${styles.overflowX}${styles.overflowY}`;\n};\nconst overflowStyle = (element) => {\n    return overflowElementStyle(element) || overflowComputedStyle(element);\n};\n/**\n * @hidden\n */\nconst scrollableParents = (element) => {\n    const parentElements = [];\n    if (!isDocumentAvailable() || !isWindowAvailable()) {\n        return parentElements;\n    }\n    let parent = element.parentElement;\n    while (parent) {\n        if (OVERFLOW_REGEXP.test(overflowStyle(parent)) || parent.hasAttribute('data-scrollable')) {\n            parentElements.push(parent);\n        }\n        parent = parent.parentElement;\n    }\n    parentElements.push(window);\n    return parentElements;\n};\n/**\n * @hidden\n */\nconst FRAME_DURATION = 1000 / 60; //1000ms divided by 60fps\nfunction memoize(fun) {\n    let result;\n    let called = false;\n    return (...args) => {\n        if (called) {\n            return result;\n        }\n        result = fun(...args);\n        called = true;\n        return result;\n    };\n}\nconst ɵ3 = () => {\n    if (!isDocumentAvailable() && document.body !== null) {\n        return false;\n    }\n    const top = 10;\n    const parent = document.createElement(\"div\");\n    parent.style.transform = \"matrix(10, 0, 0, 10, 0, 0)\";\n    parent.innerHTML = `<div style=\"position: fixed; top: ${top}px;\">child</div>`;\n    document.body.appendChild(parent);\n    const isDifferent = parent.children[0].getBoundingClientRect().top !== top;\n    document.body.removeChild(parent);\n    return isDifferent;\n};\n/**\n * @hidden\n */\nconst hasRelativeStackingContext = memoize(ɵ3);\n/**\n * @hidden\n */\nconst fesm2015_zIndex = (anchor, container) => {\n    if (!anchor || !isDocumentAvailable() || !isWindowAvailable()) {\n        return null;\n    }\n    const sibling = sibling_container(anchor, container);\n    if (!sibling) {\n        return null;\n    }\n    const result = [anchor].concat(parents(anchor, sibling)).reduce((index, p) => {\n        const zIndexStyle = p.style.zIndex || window.getComputedStyle(p).zIndex;\n        const current = parseInt(zIndexStyle, 10);\n        return current > index ? current : index;\n    }, 0);\n    return result ? (result + 1) : null;\n};\n/**\n * @hidden\n */\nconst scaleRect = (rect, scale) => {\n    if (!rect || scale === 1) {\n        return rect;\n    }\n    return {\n        height: rect.height / scale,\n        left: rect.left / scale,\n        top: rect.top / scale,\n        width: rect.width / scale\n    };\n};\nconst STYLES = [\n    'font-size',\n    'font-family',\n    'font-stretch',\n    'font-style',\n    'font-weight',\n    'line-height'\n];\nlet fesm2015_DOMService = /*@__PURE__*/ (() => {\n    /**\n     * @hidden\n     */\n    let DOMService = class DOMService {\n        addOffset(current, addition) {\n            return {\n                left: current.left + addition.left,\n                top: current.top + addition.top\n            };\n        }\n        addScroll(rect, scroll) {\n            return addScroll(rect, scroll);\n        }\n        align(settings) {\n            return es2015_align(settings);\n        }\n        boundingOffset(el) {\n            return bounding_offset(this.nativeElement(el));\n        }\n        getFontStyles(el) {\n            const window = this.getWindow();\n            if (!window || !el) {\n                return [];\n            }\n            const computedStyles = window.getComputedStyle(this.nativeElement(el));\n            return STYLES.map(font => ({ key: font, value: computedStyles[font] }));\n        }\n        getWindow() {\n            return isWindowAvailable() ? window : null;\n        }\n        hasOffsetParent(el) {\n            if (!el) {\n                return false;\n            }\n            return !!this.nativeElement(el).offsetParent;\n        }\n        offset(el) {\n            if (!el) {\n                return null;\n            }\n            return es2015_offset(this.nativeElement(el));\n        }\n        offsetAtPoint(el, currentLocation) {\n            if (!el) {\n                return null;\n            }\n            const element = this.nativeElement(el);\n            const { left, top, transition } = element.style;\n            element.style.transition = 'none';\n            element.style.left = `${currentLocation.left}px`;\n            element.style.top = `${currentLocation.top}px`;\n            const currentOffset = es2015_offset(element);\n            element.style.left = left;\n            element.style.top = top;\n            // prevents elements with transition to be animated because of the change\n            // tslint:disable-next-line:no-unused-expression\n            element.offsetHeight;\n            element.style.transition = transition;\n            return currentOffset;\n        }\n        nativeElement(el) {\n            if (!el) {\n                return null;\n            }\n            return el.nativeElement || el;\n        }\n        position(element, popup, scale = 1) {\n            if (!element || !popup) {\n                return null;\n            }\n            return position_with_scroll(this.nativeElement(element), this.nativeElement(popup), scale);\n        }\n        removeScroll(rect, scroll) {\n            return removeScroll(rect, scroll);\n        }\n        restrictToView(settings) {\n            return restrict_to_view(settings);\n        }\n        scrollPosition(el) {\n            return scrollPosition(this.nativeElement(el));\n        }\n        scrollableParents(el) {\n            return scrollableParents(this.nativeElement(el));\n        }\n        stackingElementOffset(el) {\n            const relativeContextElement = this.getRelativeContextElement(el);\n            if (!relativeContextElement) {\n                return null;\n            }\n            return es2015_offset(relativeContextElement);\n        }\n        stackingElementScroll(el) {\n            const relativeContextElement = this.getRelativeContextElement(el);\n            if (!relativeContextElement) {\n                return { x: 0, y: 0 };\n            }\n            return {\n                x: relativeContextElement.scrollLeft,\n                y: relativeContextElement.scrollTop\n            };\n        }\n        getRelativeContextElement(el) {\n            if (!el || !hasRelativeStackingContext()) {\n                return null;\n            }\n            let parent = this.nativeElement(el).parentElement;\n            while (parent) {\n                if (window.getComputedStyle(parent).transform !== 'none') {\n                    return parent;\n                }\n                parent = parent.parentElement;\n            }\n            return null;\n        }\n        useRelativePosition(el) {\n            return !!this.getRelativeContextElement(el);\n        }\n        windowViewPort(el) {\n            return windowViewport(this.nativeElement(el));\n        }\n        zIndex(anchor, container) {\n            return fesm2015_zIndex(this.nativeElement(anchor), this.nativeElement(container));\n        }\n        zoomLevel() {\n            if (!isDocumentAvailable() || !isWindowAvailable()) {\n                return 1;\n            }\n            return parseFloat((document.documentElement.clientWidth / window.innerWidth).toFixed(2)) || 1;\n        }\n        isZoomed() {\n            return this.zoomLevel() > 1;\n        }\n    };\n    DOMService.ɵfac = function DOMService_Factory(t) { return new (t || DOMService)(); };\n    DOMService.ɵprov = core[\"Lb\" /* ɵɵdefineInjectable */]({ token: DOMService, factory: function (t) { return DOMService.ɵfac(t); } });\n    return DOMService;\n})();\n/**\n * Used to set the document scale when using a [scale transform](https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/scale).\n *\n * The document or container scale is required to compute the popup position correctly. Detecting the scale is not reliable and must be set by providing a value for SCALE. See [Support for Document Scale]({% slug documentscale_popup %}).\n *\n * > Using this token is not necessary for user-applied browser zoom.\n *\n * {% meta height:300 %}\n * {% embed_file scale/app.component.ts preview %}\n * {% embed_file scale/app.module.ts %}\n * {% embed_file shared/main.ts %}\n * {% endmeta %}\n *\n *\n */\nconst SCALE = new core[\"s\" /* InjectionToken */]('Popup Document Scale');\nlet fesm2015_AlignService = /*@__PURE__*/ (() => {\n    /**\n     * @hidden\n     */\n    let AlignService = class AlignService {\n        constructor(_dom, scale = 1) {\n            this._dom = _dom;\n            this.scale = scale;\n        }\n        alignElement(settings) {\n            const { anchor, element, anchorAlign, elementAlign, margin, offset: offset$$1, positionMode } = settings;\n            const scale = this.scale || 1;\n            const fixedMode = positionMode === 'fixed' || !this._dom.hasOffsetParent(element);\n            const anchorRect = fixedMode ? this.absoluteRect(anchor, element, offset$$1, scale) : this.relativeRect(anchor, element, offset$$1, scale);\n            const elementRect = scaleRect(this._dom.offset(element), scale);\n            const result = this._dom.align({\n                anchorAlign: anchorAlign,\n                anchorRect: anchorRect,\n                elementAlign: elementAlign,\n                elementRect: elementRect,\n                margin\n            });\n            return result;\n        }\n        absoluteRect(anchor, element, offset$$1, scale) {\n            const scrollPos = this.elementScrollPosition(anchor, element);\n            const rect = eitherRect(this._dom.offset(anchor), offset$$1);\n            const stackScale = 2 * scale;\n            const stackScroll = this._dom.stackingElementScroll(element);\n            if (scale !== 1 && stackScroll) {\n                stackScroll.x /= stackScale;\n                stackScroll.y /= stackScale;\n            }\n            const stackOffset = this._dom.stackingElementOffset(element);\n            if (scale !== 1 && stackOffset) {\n                stackOffset.left /= stackScale;\n                stackOffset.top /= stackScale;\n            }\n            return this._dom.removeScroll(this._dom.addScroll(removeStackingOffset(scaleRect(rect, scale), stackOffset), stackScroll), scrollPos);\n        }\n        elementScrollPosition(anchor, element) {\n            return anchor ? { x: 0, y: 0 } : this._dom.scrollPosition(element);\n        }\n        relativeRect(anchor, element, offset$$1, scale) {\n            const rect = eitherRect(this._dom.position(anchor, element, scale), offset$$1);\n            return scaleRect(rect, scale);\n        }\n    };\n    AlignService.ɵfac = function AlignService_Factory(t) { return new (t || AlignService)(core[\"cc\" /* ɵɵinject */](fesm2015_DOMService), core[\"cc\" /* ɵɵinject */](SCALE, 8)); };\n    AlignService.ɵprov = core[\"Lb\" /* ɵɵdefineInjectable */]({ token: AlignService, factory: function (t) { return AlignService.ɵfac(t); } });\n    AlignService = __decorate([__param(1, Object(core[\"q\" /* Inject */])(SCALE)), __param(1, Object(core[\"C\" /* Optional */])()),\n        __metadata(\"design:paramtypes\", [fesm2015_DOMService, Number])\n    ], AlignService);\n    return AlignService;\n})();\nlet fesm2015_PositionService = /*@__PURE__*/ (() => {\n    /**\n     * @hidden\n     */\n    let PositionService = class PositionService {\n        constructor(_dom, scale = 1) {\n            this._dom = _dom;\n            this.scale = scale;\n        }\n        positionElement(settings) {\n            const { anchor, currentLocation, element, anchorAlign, elementAlign, collisions, margin } = settings;\n            const dom = this._dom;\n            const scale = this.scale || 1;\n            const elementOffset = dom.offsetAtPoint(element, currentLocation);\n            const elementRect = scaleRect(elementOffset, scale);\n            const anchorOffset = scaleRect(dom.offset(anchor), scale);\n            const anchorRect = eitherRect(anchorOffset, currentLocation);\n            const viewPort = settings.viewPort || dom.windowViewPort(element);\n            viewPort.width = viewPort.width / scale;\n            viewPort.height = viewPort.height / scale;\n            const result = dom.restrictToView({\n                anchorAlign,\n                anchorRect,\n                collisions,\n                elementAlign,\n                elementRect,\n                margin,\n                viewPort\n            });\n            const offset$$1 = dom.addOffset(currentLocation, result.offset);\n            return {\n                flip: result.flip,\n                flipped: result.flipped,\n                offset: offset$$1\n            };\n        }\n    };\n    PositionService.ɵfac = function PositionService_Factory(t) { return new (t || PositionService)(core[\"cc\" /* ɵɵinject */](fesm2015_DOMService), core[\"cc\" /* ɵɵinject */](SCALE, 8)); };\n    PositionService.ɵprov = core[\"Lb\" /* ɵɵdefineInjectable */]({ token: PositionService, factory: function (t) { return PositionService.ɵfac(t); } });\n    PositionService = __decorate([__param(1, Object(core[\"q\" /* Inject */])(SCALE)), __param(1, Object(core[\"C\" /* Optional */])()),\n        __metadata(\"design:paramtypes\", [fesm2015_DOMService, Number])\n    ], PositionService);\n    return PositionService;\n})();\nlet dist_fesm2015_ResizeService = /*@__PURE__*/ (() => {\n    /**\n     * @hidden\n     */\n    let ResizeService = class ResizeService {\n        constructor(_dom, _zone) {\n            this._dom = _dom;\n            this._zone = _zone;\n        }\n        subscribe(callback) {\n            if (!isDocumentAvailable()) {\n                return;\n            }\n            this._zone.runOutsideAngular(() => {\n                this.subscription = Object(fromEvent[\"a\" /* fromEvent */])(this._dom.getWindow(), \"resize\")\n                    .pipe(Object(auditTime[\"a\" /* auditTime */])(FRAME_DURATION))\n                    .subscribe(() => callback());\n            });\n        }\n        unsubscribe() {\n            if (!this.subscription) {\n                return;\n            }\n            this.subscription.unsubscribe();\n        }\n        isUnsubscribed() {\n            return this.subscription && this.subscription.closed;\n        }\n    };\n    ResizeService.ɵfac = function ResizeService_Factory(t) { return new (t || ResizeService)(core[\"cc\" /* ɵɵinject */](fesm2015_DOMService), core[\"cc\" /* ɵɵinject */](core[\"B\" /* NgZone */])); };\n    ResizeService.ɵprov = core[\"Lb\" /* ɵɵdefineInjectable */]({ token: ResizeService, factory: function (t) { return ResizeService.ɵfac(t); } });\n    ResizeService = __decorate([__metadata(\"design:paramtypes\", [fesm2015_DOMService, core[\"B\" /* NgZone */]])\n    ], ResizeService);\n    return ResizeService;\n})();\n/**\n * @hidden\n */\nconst THRESHOLD_DIFF = 1;\nlet fesm2015_ScrollableService = /*@__PURE__*/ (() => {\n    /**\n     * @hidden\n     */\n    let ScrollableService = class ScrollableService {\n        constructor(_dom, _zone) {\n            this._dom = _dom;\n            this._zone = _zone;\n        }\n        forElement(element) {\n            this.unsubscribe();\n            this.element = element;\n            return this;\n        }\n        subscribe(callback) {\n            if (!callback || !isDocumentAvailable() || !this.element) {\n                return;\n            }\n            const nativeElement = this._dom.nativeElement(this.element);\n            const parents$$1 = this._dom.scrollableParents(this.element);\n            this._zone.runOutsideAngular(() => {\n                const observables = parents$$1.map(p => Object(fromEvent[\"a\" /* fromEvent */])(p, \"scroll\").pipe(Object(auditTime[\"a\" /* auditTime */])(FRAME_DURATION)));\n                const subscriber = (e) => {\n                    const target = e.target;\n                    const isParent = parents$$1.filter(p => p === target).length > 0;\n                    const isDocument = target === document;\n                    const isWindow = target === window;\n                    if (isParent || isDocument || isWindow) {\n                        callback(this.isVisible(nativeElement, target));\n                    }\n                };\n                this.subscription = Object(merge[\"a\" /* merge */])(...observables).subscribe(subscriber);\n            });\n        }\n        unsubscribe() {\n            if (!this.subscription) {\n                return;\n            }\n            this.subscription.unsubscribe();\n        }\n        isVisible(elem, container) {\n            const elemRect = this._dom.boundingOffset(elem);\n            const containerRect = this._dom.boundingOffset(container);\n            if (THRESHOLD_DIFF < (containerRect.top - elemRect.bottom)) {\n                return false;\n            }\n            if (THRESHOLD_DIFF < (elemRect.top - containerRect.bottom)) {\n                return false;\n            }\n            if (THRESHOLD_DIFF < (elemRect.left - containerRect.right)) {\n                return false;\n            }\n            if (THRESHOLD_DIFF < (containerRect.left - elemRect.right)) {\n                return false;\n            }\n            return true;\n        }\n    };\n    ScrollableService.ɵfac = function ScrollableService_Factory(t) { return new (t || ScrollableService)(core[\"cc\" /* ɵɵinject */](fesm2015_DOMService), core[\"cc\" /* ɵɵinject */](core[\"B\" /* NgZone */])); };\n    ScrollableService.ɵprov = core[\"Lb\" /* ɵɵdefineInjectable */]({ token: ScrollableService, factory: function (t) { return ScrollableService.ɵfac(t); } });\n    ScrollableService = __decorate([__metadata(\"design:paramtypes\", [fesm2015_DOMService, core[\"B\" /* NgZone */]])\n    ], ScrollableService);\n    return ScrollableService;\n})();\nconst fesm2015_LEFT = 'left';\nconst fesm2015_RIGHT = 'right';\nconst DOWN = 'down';\nconst UP = 'up';\nconst DEFAULT_TYPE = 'slide';\nconst DEFAULT_DURATION = 100;\nconst animationTypes = {};\n/* tslint:disable:object-literal-sort-keys */\nanimationTypes.expand = (direction) => {\n    const scale = direction === UP || direction === DOWN ? 'scaleY' : 'scaleX';\n    const startScale = 0;\n    const endScale = 1;\n    let origin;\n    if (direction === DOWN) {\n        origin = 'top';\n    }\n    else if (direction === fesm2015_LEFT) {\n        origin = fesm2015_RIGHT;\n    }\n    else if (direction === fesm2015_RIGHT) {\n        origin = fesm2015_LEFT;\n    }\n    else {\n        origin = 'bottom';\n    }\n    return {\n        start: { transform: `${scale}(${startScale})`, transformOrigin: origin },\n        end: { transform: `${scale}(${endScale})` }\n    };\n};\nanimationTypes.slide = (direction) => {\n    const translate = direction === fesm2015_LEFT || direction === fesm2015_RIGHT ? 'translateX' : 'translateY';\n    const start = direction === fesm2015_RIGHT || direction === DOWN ? -100 : 100;\n    const end = 0;\n    return {\n        start: { transform: `${translate}(${start}%)` },\n        end: { transform: `${translate}(${end}%)` }\n    };\n};\nanimationTypes.fade = () => {\n    return {\n        start: { opacity: 0 },\n        end: { opacity: 1 }\n    };\n};\nanimationTypes.zoom = () => {\n    const start = 0;\n    const end = 1;\n    return {\n        start: { transform: `scale(${start})` },\n        end: { transform: `scale(${end})` }\n    };\n};\nlet fesm2015_AnimationService = /*@__PURE__*/ (() => {\n    /**\n     * @hidden\n     */\n    let AnimationService = class AnimationService {\n        constructor(animationBuilder) {\n            this.animationBuilder = animationBuilder;\n            this.start = new core[\"o\" /* EventEmitter */]();\n            this.end = new core[\"o\" /* EventEmitter */]();\n        }\n        play(element, options, flip) {\n            if (!this.flip || this.flip.horizontal !== flip.horizontal ||\n                this.flip.vertical !== flip.vertical) {\n                this.flip = flip;\n                const type = options.type || DEFAULT_TYPE;\n                const statesFn = animationTypes[type];\n                if (statesFn) {\n                    const direction = this.getDirection(flip, options);\n                    const states = statesFn(direction);\n                    this.playStates(element, states, options);\n                }\n                else if (Object(core[\"Y\" /* isDevMode */])()) {\n                    throw new Error(`Unsupported animation type: \"${type}\". The supported types are slide, expand, fade and zoom.`);\n                }\n            }\n        }\n        ngOnDestroy() {\n            this.stopPlayer();\n        }\n        playStates(element, states, options) {\n            this.stopPlayer();\n            const duration = options.duration || DEFAULT_DURATION;\n            const factory = this.animationBuilder.build([\n                Object(animations[\"k\" /* style */])(states.start),\n                Object(animations[\"e\" /* animate */])(`${duration}ms ease-in`, Object(animations[\"k\" /* style */])(states.end))\n            ]);\n            const player = this.player = factory.create(element);\n            player.onDone(() => {\n                this.end.emit();\n                this.stopPlayer();\n            });\n            this.start.emit();\n            player.play();\n        }\n        getDirection(flip, options) {\n            let direction = options.direction || DOWN;\n            if (flip.horizontal) {\n                if (direction === fesm2015_LEFT) {\n                    direction = fesm2015_RIGHT;\n                }\n                else if (direction === fesm2015_RIGHT) {\n                    direction = fesm2015_LEFT;\n                }\n            }\n            if (flip.vertical) {\n                if (direction === DOWN) {\n                    direction = UP;\n                }\n                else if (direction === UP) {\n                    direction = DOWN;\n                }\n            }\n            return direction;\n        }\n        stopPlayer() {\n            if (this.player) {\n                this.player.destroy();\n                this.player = null;\n            }\n        }\n    };\n    AnimationService.ɵfac = function AnimationService_Factory(t) { return new (t || AnimationService)(core[\"cc\" /* ɵɵinject */](animations[\"b\" /* AnimationBuilder */])); };\n    AnimationService.ɵprov = core[\"Lb\" /* ɵɵdefineInjectable */]({ token: AnimationService, factory: function (t) { return AnimationService.ɵfac(t); } });\n    AnimationService = __decorate([__metadata(\"design:paramtypes\", [animations[\"b\" /* AnimationBuilder */]])\n    ], AnimationService);\n    return AnimationService;\n})();\n/**\n * @hidden\n */\nconst packageMetadata = {\n    name: '@progress/kendo-angular-popup',\n    productName: 'Kendo UI for Angular',\n    productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],\n    publishDate: 1620213546,\n    version: '',\n    licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'\n};\nconst DEFAULT_OFFSET = { left: -10000, top: 0 };\nconst ANIMATION_CONTAINER = 'k-animation-container';\nconst ANIMATION_CONTAINER_FIXED = 'k-animation-container-fixed';\nlet fesm2015_PopupComponent = /*@__PURE__*/ (() => {\n    /**\n     * Represents the [Kendo UI Popup component for Angular]({% slug overview_popup %}).\n     *\n     * @example\n     * ```ts\n     * _@Component({\n     * selector: 'my-app',\n     * template: `\n     *  <button #anchor (click)=\"show=!show\">Toggle</button>\n     *  <kendo-popup *ngIf=\"show\" [anchor]=\"anchor\">\n     *      <strong>Popup content!</strong>\n     *  </kendo-popup>\n     * `\n     * })\n     * class AppComponent {\n     *   public show: boolean = false;\n     * }\n     * ```\n     */\n    let PopupComponent = class PopupComponent {\n        constructor(container, _alignService, domService, _positionService, _resizeService, _scrollableService, animationService, _renderer, _zone) {\n            this.container = container;\n            this._alignService = _alignService;\n            this.domService = domService;\n            this._positionService = _positionService;\n            this._resizeService = _resizeService;\n            this._scrollableService = _scrollableService;\n            this.animationService = animationService;\n            this._renderer = _renderer;\n            this._zone = _zone;\n            /**\n             * Controls the Popup animation. By default, the opening and closing animations\n             * are enabled ([see example]({% slug animations_popup %})).\n             */\n            this.animate = true;\n            /**\n             * Specifies the anchor pivot point\n             * ([see example]({% slug alignmentpositioning_popup %}#toc-positioning)).\n             */\n            this.anchorAlign = { horizontal: 'left', vertical: 'bottom' };\n            /**\n             * Configures the collision behavior of the Popup\n             * ([see example]({% slug viewportboundarydetection_popup %})).\n             */\n            this.collision = { horizontal: 'fit', vertical: 'flip' };\n            /**\n             * Specifies the pivot point of the Popup\n             * ([see example]({% slug alignmentpositioning_popup %}#toc-positioning)).\n             */\n            this.popupAlign = { horizontal: 'left', vertical: 'top' };\n            /**\n             * Controls whether the component will copy the `anchor` font styles.\n             */\n            this.copyAnchorStyles = false;\n            /**\n             * Specifies the position mode of the component. By default, the Popup uses fixed positioning.\n             * To make the Popup acquire absolute positioning, set this option to `absolute`.\n             *\n             * > If you need to support mobile browsers with the zoom option,\n             * use the `absolute` positioning of the Popup.\n             *\n             * @example\n             * ```html\n             * <style>\n             *  .parent-content {\n             *     position: relative;\n             *     width: 200px;\n             *     height: 200px;\n             *     overflow: auto;\n             *     margin: 200px auto;\n             *     border: 1px solid red;\n             *  }\n             *  .content {\n             *     position: relative;\n             *     width: 100px;\n             *     height: 100px;\n             *     overflow: auto;\n             *     margin: 300px;\n             *     border: 1px solid blue;\n             *  }\n             *  .anchor {\n             *     position: absolute;\n             *     top: 200px;\n             *     left: 200px;\n             *  }\n             * </style>\n             * ```\n             * ```ts\n             * _@Component({\n             * selector: 'my-app',\n             * template: `\n             *   <div class=\"example-config\">\n             *      Position mode:\n             *      <label><input type=\"radio\" value=\"fixed\" [(ngModel)]=\"mode\" /> Fixed</label>\n             *      <label><input type=\"radio\" value=\"absolute\" [(ngModel)]=\"mode\" /> Absolute</label>\n             *   </div>\n             *   <div class=\"example-config\">\n             *       Append to\n             *       <label>\n             *           <input type=\"radio\" name=\"place\" [value]=\"1\" [(ngModel)]=\"checked\" />\n             *           Root component\n             *       </label>\n             *       <label>\n             *           <input type=\"radio\" name=\"place\" [value]=\"2\" [(ngModel)]=\"checked\" />\n             *           <span style=\"color: red\">Red Container</span>\n             *       </label>\n             *       <label>\n             *           <input type=\"radio\" name=\"place\" [value]=\"3\" [(ngModel)]=\"checked\" />\n             *           <span style=\"color: blue\">Blue Container</span>\n             *       </label>\n             *   </div>\n             *   <div class=\"example\">\n             *     <div class=\"parent-content\" [scrollLeft]=\"250\" [scrollTop]=\"230\">\n             *         <div class=\"content\" [scrollLeft]=\"170\" [scrollTop]=\"165\">\n             *           <button #anchor class=\"anchor\" (click)=\"show = !show\">Toggle</button>\n             *           <kendo-popup [positionMode]=\"mode\" [anchor]=\"anchor\" (anchorViewportLeave)=\"show=false\" *ngIf=\"show && checked === 3\">\n             *             <ul>\n             *                 <li>Item1</li>\n             *                 <li>Item2</li>\n             *                 <li>Item3</li>\n             *             </ul>\n             *           </kendo-popup>\n             *           <span style=\"position: absolute; top: 400px; left: 400px\">Bottom/Right</span>\n             *         </div>\n             *         <kendo-popup [positionMode]=\"mode\" [anchor]=\"anchor\" (anchorViewportLeave)=\"show=false\" *ngIf=\"show && checked === 2\">\n             *           <ul>\n             *               <li>Item1</li>\n             *               <li>Item2</li>\n             *               <li>Item3</li>\n             *           </ul>\n             *         </kendo-popup>\n             *         <span style=\"position: absolute; top: 600px; left: 600px\">Bottom/Right</span>\n             *     </div>\n             *     <kendo-popup [positionMode]=\"mode\" [anchor]=\"anchor\" (anchorViewportLeave)=\"show=false\" *ngIf=\"show && checked === 1\">\n             *       <ul>\n             *           <li>Item1</li>\n             *           <li>Item2</li>\n             *           <li>Item3</li>\n             *       </ul>\n             *     </kendo-popup>\n             *   </div>\n             * `\n             * })\n             * class AppComponent {\n             *   public checked: number = 3;\n             *   public mode: string = 'absolute';\n             *   public show: boolean = true;\n             * }\n             * ```\n             */\n            this.positionMode = 'fixed';\n            /**\n             * Specifies the absolute position of the element\n             * ([see example]({% slug alignmentpositioning_popup %}#toc-aligning-to-absolute-points)).\n             * The Popup opens next to that point. The Popup pivot point is defined by the `popupAlign` configuration option.\n             * The boundary detection is applied by using the window viewport.\n             */\n            this.offset = DEFAULT_OFFSET;\n            /**\n             * Fires when the anchor is scrolled outside the screen boundaries.\n             * ([see example]({% slug closing_popup %}#toc-after-leaving-the-viewport)).\n             */\n            this.anchorViewportLeave = new core[\"o\" /* EventEmitter */]();\n            /**\n             * Fires after the component is closed.\n             */\n            this.close = new core[\"o\" /* EventEmitter */]();\n            /**\n             * Fires after the component is opened and the opening animation ends.\n             */\n            this.open = new core[\"o\" /* EventEmitter */]();\n            /**\n             * Fires after the component is opened and the Popup is positioned.\n             */\n            this.positionChange = new core[\"o\" /* EventEmitter */]();\n            this.resolvedPromise = Promise.resolve(null);\n            this.initialCheck = true;\n            validatePackage(packageMetadata);\n            this._renderer.addClass(container.nativeElement, ANIMATION_CONTAINER);\n            this.updateFixedClass();\n        }\n        ngOnInit() {\n            this.reposition = this.reposition.bind(this);\n            this._resizeService.subscribe(this.reposition);\n            this.animationSubscriptions = this.animationService.start.subscribe(this.onAnimationStart.bind(this));\n            this.animationSubscriptions.add(this.animationService.end.subscribe(this.onAnimationEnd.bind(this)));\n            this._scrollableService.forElement(this.anchor || this.container).subscribe(this.onScroll.bind(this));\n            this.currentOffset = DEFAULT_OFFSET;\n            this.setZIndex();\n            this.copyFontStyles();\n            this.updateFixedClass();\n        }\n        ngOnChanges(changes) {\n            if (changes.copyAnchorStyles) {\n                this.copyFontStyles();\n            }\n            if (changes.positionMode) {\n                this.updateFixedClass();\n            }\n        }\n        ngAfterViewInit() {\n            this.reposition();\n            if (!this.animate) {\n                this.resolvedPromise.then(() => {\n                    this.onAnimationEnd();\n                });\n            }\n        }\n        ngAfterViewChecked() {\n            if (this.initialCheck) {\n                this.initialCheck = false;\n                return;\n            }\n            this._zone.runOutsideAngular(() => {\n                // workarounds https://github.com/angular/angular/issues/19094\n                // uses promise because it is executed synchronously after the content is updated\n                // does not use onStable in case the current zone is not the angular one.\n                this.unsubscribeReposition();\n                this.repositionSubscription = Object(observable_from[\"a\" /* from */])(this.resolvedPromise)\n                    .subscribe(this.reposition);\n            });\n        }\n        ngOnDestroy() {\n            this.anchorViewportLeave.complete();\n            this.positionChange.complete();\n            this.close.emit();\n            this.close.complete();\n            this._resizeService.unsubscribe();\n            this._scrollableService.unsubscribe();\n            this.animationSubscriptions.unsubscribe();\n            this.unsubscribeReposition();\n        }\n        /**\n         * @hidden\n         */\n        onResize() {\n            this.reposition();\n        }\n        onAnimationStart() {\n            this._renderer.removeClass(this.container.nativeElement, 'k-animation-container-shown');\n        }\n        onAnimationEnd() {\n            this._renderer.addClass(this.container.nativeElement, 'k-animation-container-shown');\n            this.open.emit();\n            this.open.complete();\n        }\n        get currentOffset() {\n            return this._currentOffset;\n        }\n        set currentOffset(offset$$1) {\n            this.setContainerStyle('left', `${offset$$1.left}px`);\n            this.setContainerStyle('top', `${offset$$1.top}px`);\n            this._currentOffset = offset$$1;\n        }\n        setZIndex() {\n            if (this.anchor) {\n                this.setContainerStyle('z-index', String(this.domService.zIndex(this.anchor, this.container)));\n            }\n        }\n        reposition() {\n            if (!isDocumentAvailable()) {\n                return;\n            }\n            const { flip, offset: offset$$1 } = this.position();\n            if (!this.currentOffset || isDifferentOffset(this.currentOffset, offset$$1)) {\n                this.currentOffset = offset$$1;\n                if (hasObservers(this.positionChange)) {\n                    this._zone.run(() => this.positionChange.emit({ offset: offset$$1, flip }));\n                }\n            }\n            if (this.animate) {\n                this.animationService.play(this.contentContainer.nativeElement, this.animate, flip);\n            }\n            this.resizeSensor.acceptSize();\n        }\n        position() {\n            const alignedOffset = this._alignService.alignElement({\n                anchor: this.anchor,\n                anchorAlign: this.anchorAlign,\n                element: this.container,\n                elementAlign: this.popupAlign,\n                margin: this.margin,\n                offset: this.offset,\n                positionMode: this.positionMode\n            });\n            return this._positionService.positionElement({\n                anchor: this.anchor,\n                anchorAlign: this.anchorAlign,\n                collisions: this.collision,\n                currentLocation: alignedOffset,\n                element: this.container,\n                elementAlign: this.popupAlign,\n                margin: this.margin\n            });\n        }\n        onScroll(isInViewPort) {\n            const hasLeaveObservers = hasObservers(this.anchorViewportLeave);\n            if (isInViewPort || !hasLeaveObservers) {\n                this.reposition();\n            }\n            else if (hasLeaveObservers) {\n                this._zone.run(() => {\n                    this.anchorViewportLeave.emit();\n                });\n            }\n        }\n        copyFontStyles() {\n            if (!this.anchor || !this.copyAnchorStyles) {\n                return;\n            }\n            this.domService.getFontStyles(this.anchor)\n                .forEach(s => this.setContainerStyle(s.key, s.value));\n        }\n        updateFixedClass() {\n            const action = this.positionMode === 'fixed' ? 'addClass' : 'removeClass';\n            this._renderer[action](this.container.nativeElement, ANIMATION_CONTAINER_FIXED);\n        }\n        setContainerStyle(name, value) {\n            this._renderer.setStyle(this.container.nativeElement, name, value);\n        }\n        unsubscribeReposition() {\n            if (this.repositionSubscription) {\n                this.repositionSubscription.unsubscribe();\n            }\n        }\n    };\n    PopupComponent.ɵfac = function PopupComponent_Factory(t) { return new (t || PopupComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_AlignService), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_DOMService), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_PositionService), core[\"Pb\" /* ɵɵdirectiveInject */](dist_fesm2015_ResizeService), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ScrollableService), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_AnimationService), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"G\" /* Renderer2 */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */])); };\n    PopupComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: PopupComponent, selectors: [[\"kendo-popup\"]], viewQuery: function PopupComponent_Query(rf, ctx) {\n            if (rf & 1) {\n                core[\"Gc\" /* ɵɵstaticViewQuery */](_c0, true);\n                core[\"Gc\" /* ɵɵstaticViewQuery */](fesm2015_ResizeSensorComponent, true);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx.contentContainer = _t.first);\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx.resizeSensor = _t.first);\n            }\n        }, inputs: { animate: \"animate\", anchorAlign: \"anchorAlign\", collision: \"collision\", popupAlign: \"popupAlign\", copyAnchorStyles: \"copyAnchorStyles\", positionMode: \"positionMode\", offset: \"offset\", anchor: \"anchor\", popupClass: \"popupClass\", margin: \"margin\" }, outputs: { anchorViewportLeave: \"anchorViewportLeave\", close: \"close\", open: \"open\", positionChange: \"positionChange\" }, exportAs: [\"kendo-popup\"], features: [core[\"Bb\" /* ɵɵProvidersFeature */]([fesm2015_AlignService, fesm2015_AnimationService, fesm2015_DOMService, fesm2015_PositionService, dist_fesm2015_ResizeService, fesm2015_ScrollableService]), core[\"Ab\" /* ɵɵNgOnChangesFeature */]], ngContentSelectors: _c1, decls: 5, vars: 4, consts: [[1, \"k-popup\", 3, \"ngClass\"], [\"container\", \"\"], [3, \"ngTemplateOutlet\", \"ngIf\"], [3, \"rateLimit\", \"resize\"]], template: function PopupComponent_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"oc\" /* ɵɵprojectionDef */]();\n                core[\"Vb\" /* ɵɵelementStart */](0, \"div\", 0, 1);\n                core[\"nc\" /* ɵɵprojection */](2);\n                core[\"Kc\" /* ɵɵtemplate */](3, PopupComponent_ng_template_3_Template, 0, 0, \"ng-template\", 2);\n                core[\"Vb\" /* ɵɵelementStart */](4, \"kendo-resize-sensor\", 3);\n                core[\"gc\" /* ɵɵlistener */](\"resize\", function PopupComponent_Template_kendo_resize_sensor_resize_4_listener() { return ctx.onResize(); });\n                core[\"Ub\" /* ɵɵelementEnd */]();\n                core[\"Ub\" /* ɵɵelementEnd */]();\n            }\n            if (rf & 2) {\n                core[\"pc\" /* ɵɵproperty */](\"ngClass\", ctx.popupClass);\n                core[\"Cb\" /* ɵɵadvance */](3);\n                core[\"pc\" /* ɵɵproperty */](\"ngTemplateOutlet\", ctx.content)(\"ngIf\", ctx.content);\n                core[\"Cb\" /* ɵɵadvance */](1);\n                core[\"pc\" /* ɵɵproperty */](\"rateLimit\", 100);\n            }\n        }, directives: [common[\"j\" /* NgClass */], common[\"q\" /* NgTemplateOutlet */], common[\"l\" /* NgIf */], fesm2015_ResizeSensorComponent], encapsulation: 2 });\n    PopupComponent = __decorate([__metadata(\"design:paramtypes\", [core[\"l\" /* ElementRef */],\n            fesm2015_AlignService,\n            fesm2015_DOMService,\n            fesm2015_PositionService,\n            dist_fesm2015_ResizeService,\n            fesm2015_ScrollableService,\n            fesm2015_AnimationService,\n            core[\"G\" /* Renderer2 */],\n            core[\"B\" /* NgZone */]])\n    ], PopupComponent);\n    return PopupComponent;\n})();\nconst removeElement = (element) => {\n    if (element && element.parentNode) {\n        element.parentNode.removeChild(element);\n    }\n};\n/**\n * Used to inject the Popup container. If not provided, the first root component of\n * the application is used.\n *\n * > The `POPUP_CONTAINER` can be used only with the [`PopupService`]({% slug service_popup %}) class.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Popup module\n * import { PopupModule, POPUP_CONTAINER } from '@progress/kendo-angular-popup';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { ElementRef, NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, PopupModule], // import Popup module\n *     bootstrap:    [AppComponent],\n *     providers: [{\n *       provide: POPUP_CONTAINER,\n *       useFactory: () => {\n *          //return the container ElementRef, where the popup will be injected\n *          return { nativeElement: document.body } as ElementRef;\n *       }\n *     }]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n * ```\n */\nconst POPUP_CONTAINER = new core[\"s\" /* InjectionToken */]('Popup Container');\nlet fesm2015_PopupService = /*@__PURE__*/ (() => {\n    /**\n     * A service for opening Popup components dynamically\n     * ([see example]({% slug service_popup %})).\n     *\n     * @export\n     * @class PopupService\n     */\n    let PopupService = class PopupService {\n        constructor(applicationRef, componentFactoryResolver, injector, container) {\n            this.applicationRef = applicationRef;\n            this.componentFactoryResolver = componentFactoryResolver;\n            this.injector = injector;\n            this.container = container;\n        }\n        /**\n         * Gets the root view container into which the component will be injected.\n         *\n         * @returns {ComponentRef<any>}\n         */\n        get rootViewContainer() {\n            // https://github.com/angular/angular/blob/4.0.x/packages/core/src/application_ref.ts#L571\n            const rootComponents = this.applicationRef.components || [];\n            if (rootComponents[0]) {\n                return rootComponents[0];\n            }\n            throw new Error(`\n            View Container not found! Inject the POPUP_CONTAINER or define a specific ViewContainerRef via the appendTo option.\n            See http://www.telerik.com/kendo-angular-ui/components/popup/api/POPUP_CONTAINER/ for more details.\n        `);\n        }\n        /**\n         * Sets or gets the HTML element of the root component container.\n         *\n         * @returns {HTMLElement}\n         */\n        get rootViewContainerNode() {\n            return this.container ? this.container.nativeElement : this.getComponentRootNode(this.rootViewContainer);\n        }\n        /**\n         * Opens a Popup component. Created Popups are mounted\n         * in the DOM directly in the root application component.\n         *\n         * @param {PopupSettings} options - The options which define the Popup.\n         * @returns {ComponentRef<PopupComponent>} - A reference to the Popup object.\n         *\n         * @example\n         *\n         * ```ts-no-run\n         * _@Component({\n         *   selector: 'my-app',\n         *   template: `\n         *     <ng-template #template>\n         *      Popup content\n         *     </ng-template>\n         *     <button #anchor kendoButton (click)=\"open(anchor, template)\">Open</button>\n         *   `\n         * })\n         * export class AppComponent {\n         *     public popupRef: PopupRef;\n         *\n         *     constructor( private popupService: PopupService ) {}\n         *\n         *     public open(anchor: ElementRef, template: TemplateRef<any>): void {\n         *         if (this.popupRef) {\n         *              this.popupRef.close();\n         *              this.popupRef = null;\n         *              return;\n         *         }\n         *\n         *         this.popupRef = this.popupService.open({\n         *           anchor: anchor,\n         *           content: template\n         *         });\n         *     }\n         * }\n         * ```\n         */\n        open(options = {}) {\n            const { component, nodes } = this.contentFrom(options.content);\n            const popupComponentRef = this.appendPopup(nodes, options.appendTo);\n            const popupInstance = popupComponentRef.instance;\n            this.projectComponentInputs(popupComponentRef, options);\n            popupComponentRef.changeDetectorRef.detectChanges();\n            if (component) {\n                component.changeDetectorRef.detectChanges();\n            }\n            const popupElement = this.getComponentRootNode(popupComponentRef);\n            return {\n                close: () => {\n                    if (component) {\n                        component.destroy();\n                    }\n                    popupComponentRef.destroy();\n                    // Angular will not remove the element unless the change detection is triggered\n                    removeElement(popupElement);\n                },\n                content: component,\n                popup: popupComponentRef,\n                popupAnchorViewportLeave: popupInstance.anchorViewportLeave,\n                popupClose: popupInstance.close,\n                popupElement: popupElement,\n                popupOpen: popupInstance.open,\n                popupPositionChange: popupInstance.positionChange\n            };\n        }\n        appendPopup(nodes, container) {\n            const popupComponentRef = this.createComponent(fesm2015_PopupComponent, nodes, container);\n            if (!container) {\n                this.rootViewContainerNode.appendChild(this.getComponentRootNode(popupComponentRef));\n            }\n            return popupComponentRef;\n        }\n        /**\n         * Gets the HTML element for a component reference.\n         *\n         * @param {ComponentRef<any>} componentRef\n         * @returns {HTMLElement}\n         */\n        getComponentRootNode(componentRef) {\n            return componentRef.location.nativeElement;\n        }\n        /**\n         * Gets the `ComponentFactory` instance by its type.\n         *\n         * @param {*} componentClass\n         * @param {*} nodes\n         * @returns {ComponentRef<any>}\n         */\n        getComponentFactory(componentClass) {\n            return this.componentFactoryResolver.resolveComponentFactory(componentClass);\n        }\n        /**\n         * Creates a component reference from a `Component` type class.\n         *\n         * @param {*} componentClass\n         * @param {*} nodes\n         * @returns {ComponentRef<any>}\n         */\n        createComponent(componentClass, nodes, container) {\n            const factory = this.getComponentFactory(componentClass);\n            if (container) {\n                return container.createComponent(factory, undefined, this.injector, nodes);\n            }\n            else {\n                const component = factory.create(this.injector, nodes);\n                this.applicationRef.attachView(component.hostView);\n                return component;\n            }\n        }\n        /**\n         * Projects the inputs on the component.\n         *\n         * @param {ComponentRef<any>} component\n         * @param {*} options\n         * @returns {ComponentRef<any>}\n         */\n        projectComponentInputs(component, options) {\n            Object.getOwnPropertyNames(options)\n                .filter(prop => prop !== 'content' || options.content instanceof core[\"O\" /* TemplateRef */])\n                .map((prop) => {\n                component.instance[prop] = options[prop];\n            });\n            return component;\n        }\n        /**\n         * Gets the component and the nodes to append from the `content` option.\n         *\n         * @param {*} content\n         * @returns {any}\n         */\n        contentFrom(content) {\n            if (!content || content instanceof core[\"O\" /* TemplateRef */]) {\n                return { component: null, nodes: [[]] };\n            }\n            const component = this.createComponent(content);\n            const nodes = component ? [component.location.nativeElement] : [];\n            return {\n                component: component,\n                nodes: [\n                    nodes // <ng-content>\n                ]\n            };\n        }\n    };\n    PopupService.ɵfac = function PopupService_Factory(t) { return new (t || PopupService)(core[\"cc\" /* ɵɵinject */](core[\"g\" /* ApplicationRef */]), core[\"cc\" /* ɵɵinject */](core[\"j\" /* ComponentFactoryResolver */]), core[\"cc\" /* ɵɵinject */](core[\"t\" /* Injector */]), core[\"cc\" /* ɵɵinject */](POPUP_CONTAINER, 8)); };\n    PopupService.ɵprov = core[\"Lb\" /* ɵɵdefineInjectable */]({ token: PopupService, factory: function (t) { return PopupService.ɵfac(t); } });\n    PopupService = __decorate([__param(3, Object(core[\"q\" /* Inject */])(POPUP_CONTAINER)), __param(3, Object(core[\"C\" /* Optional */])()),\n        __metadata(\"design:paramtypes\", [core[\"g\" /* ApplicationRef */],\n            core[\"j\" /* ComponentFactoryResolver */],\n            core[\"t\" /* Injector */],\n            core[\"l\" /* ElementRef */]])\n    ], PopupService);\n    return PopupService;\n})();\nconst POPUP_DIRECTIVES = [fesm2015_PopupComponent];\nlet fesm2015_PopupModule = /*@__PURE__*/ (() => {\n    /**\n     * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n     * definition for the Popup component.\n     *\n     * @example\n     *\n     * ```ts-no-run\n     * // Import the Popup module\n     * import { PopupModule } from '@progress/kendo-angular-popup';\n     *\n     * // The browser platform with a compiler\n     * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n     *\n     * import { NgModule } from '@angular/core';\n     *\n     * // Import the app component\n     * import { AppComponent } from './app.component';\n     *\n     * // Define the app module\n     * _@NgModule({\n     *     declarations: [AppComponent], // declare app component\n     *     imports:      [BrowserModule, PopupModule], // import Popup module\n     *     bootstrap:    [AppComponent]\n     * })\n     * export class AppModule {}\n     *\n     * // Compile and launch the module\n     * platformBrowserDynamic().bootstrapModule(AppModule);\n     *\n     * ```\n     */\n    let PopupModule = class PopupModule {\n    };\n    PopupModule.ɵmod = core[\"Nb\" /* ɵɵdefineNgModule */]({ type: PopupModule });\n    PopupModule.ɵinj = core[\"Mb\" /* ɵɵdefineInjector */]({ factory: function PopupModule_Factory(t) { return new (t || PopupModule)(); }, providers: [fesm2015_PopupService], imports: [[common[\"c\" /* CommonModule */], fesm2015_ResizeSensorModule]] });\n    return PopupModule;\n})();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ec\" /* ɵɵsetNgModuleScope */](fesm2015_PopupModule, { declarations: function () { return [fesm2015_PopupComponent]; }, imports: function () { return [common[\"c\" /* CommonModule */], fesm2015_ResizeSensorModule]; }, exports: function () { return [fesm2015_PopupComponent]; } }); })();\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzswSEFHZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2dJQUFFO0FBQ0YsMkJBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3lJQUFFO0FBQ0YsOEJBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7bUlBQUU7QUFDRiw0QkFFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7K0lBQUU7QUFDRixnQ0FFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzRJQUFFO0FBQ0YsK0JBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OytIQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFjRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2dJQUFFO0FBQ0YsMkJBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQVNnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiBDb3B5cmlnaHQgwqkgMjAyMCBQcm9ncmVzcyBTb2Z0d2FyZSBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiogTGljZW5zZWQgdW5kZXIgY29tbWVyY2lhbCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBpbiB0aGUgcHJvamVjdCByb290IGZvciBtb3JlIGluZm9ybWF0aW9uXG4qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBfX2RlY29yYXRlLCBfX3BhcmFtLCBfX21ldGFkYXRhIH0gZnJvbSAndHNsaWInO1xuaW1wb3J0IHsgSW5qZWN0YWJsZSwgSW5qZWN0aW9uVG9rZW4sIEluamVjdCwgT3B0aW9uYWwsIE5nWm9uZSwgRXZlbnRFbWl0dGVyLCBpc0Rldk1vZGUsIElucHV0LCBFbGVtZW50UmVmLCBPdXRwdXQsIFZpZXdDaGlsZCwgQ29tcG9uZW50LCBSZW5kZXJlcjIsIFRlbXBsYXRlUmVmLCBBcHBsaWNhdGlvblJlZiwgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBJbmplY3RvciwgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHNpYmxpbmdDb250YWluZXIsIHBhcmVudHMsIGFkZFNjcm9sbCwgYWxpZ24sIGJvdW5kaW5nT2Zmc2V0LCBvZmZzZXQsIHBvc2l0aW9uV2l0aFNjcm9sbCwgcmVtb3ZlU2Nyb2xsLCByZXN0cmljdFRvVmlldywgc2Nyb2xsUG9zaXRpb24sIGdldFdpbmRvd1ZpZXdQb3J0IH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLXBvcHVwLWNvbW1vbic7XG5pbXBvcnQgeyBpc0RvY3VtZW50QXZhaWxhYmxlLCBoYXNPYnNlcnZlcnMsIFJlc2l6ZVNlbnNvckNvbXBvbmVudCwgUmVzaXplU2Vuc29yTW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItY29tbW9uJztcbmltcG9ydCB7IGZyb21FdmVudCwgbWVyZ2UsIGZyb20gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGF1ZGl0VGltZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IHN0eWxlLCBhbmltYXRlLCBBbmltYXRpb25CdWlsZGVyIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQgeyB2YWxpZGF0ZVBhY2thZ2UgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tbGljZW5zaW5nJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBlaXRoZXJSZWN0ID0gKHJlY3QsIG9mZnNldCQkMSkgPT4ge1xuICAgIGlmICghcmVjdCkge1xuICAgICAgICByZXR1cm4geyBoZWlnaHQ6IDAsIGxlZnQ6IG9mZnNldCQkMS5sZWZ0LCB0b3A6IG9mZnNldCQkMS50b3AsIHdpZHRoOiAwIH07XG4gICAgfVxuICAgIHJldHVybiByZWN0O1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCByZW1vdmVTdGFja2luZ09mZnNldCA9IChyZWN0LCBzdGFja2luZ09mZnNldCkgPT4ge1xuICAgIGlmICghc3RhY2tpbmdPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCxcbiAgICAgICAgbGVmdDogcmVjdC5sZWZ0IC0gc3RhY2tpbmdPZmZzZXQubGVmdCxcbiAgICAgICAgdG9wOiByZWN0LnRvcCAtIHN0YWNraW5nT2Zmc2V0LnRvcCxcbiAgICAgICAgd2lkdGg6IHJlY3Qud2lkdGhcbiAgICB9O1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGlzRGlmZmVyZW50T2Zmc2V0ID0gKG9sZE9mZnNldCwgbmV3T2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgeyBsZWZ0OiBvbGRMZWZ0LCB0b3A6IG9sZFRvcCB9ID0gb2xkT2Zmc2V0O1xuICAgIGNvbnN0IHsgbGVmdDogbmV3TGVmdCwgdG9wOiBuZXdUb3AgfSA9IG5ld09mZnNldDtcbiAgICByZXR1cm4gTWF0aC5hYnMob2xkTGVmdCAtIG5ld0xlZnQpID49IDEgfHwgTWF0aC5hYnMob2xkVG9wIC0gbmV3VG9wKSA+PSAxO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBpc1dpbmRvd0F2YWlsYWJsZSA9ICgpID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IE9WRVJGTE9XX1JFR0VYUCA9IC9hdXRvfHNjcm9sbC87XG5jb25zdCBvdmVyZmxvd0VsZW1lbnRTdHlsZSA9IChlbGVtZW50KSA9PiB7XG4gICAgcmV0dXJuIGAke2VsZW1lbnQuc3R5bGUub3ZlcmZsb3d9JHtlbGVtZW50LnN0eWxlLm92ZXJmbG93WH0ke2VsZW1lbnQuc3R5bGUub3ZlcmZsb3dZfWA7XG59O1xuY29uc3Qgb3ZlcmZsb3dDb21wdXRlZFN0eWxlID0gKGVsZW1lbnQpID0+IHtcbiAgICBjb25zdCBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgICByZXR1cm4gYCR7c3R5bGVzLm92ZXJmbG93fSR7c3R5bGVzLm92ZXJmbG93WH0ke3N0eWxlcy5vdmVyZmxvd1l9YDtcbn07XG5jb25zdCBvdmVyZmxvd1N0eWxlID0gKGVsZW1lbnQpID0+IHtcbiAgICByZXR1cm4gb3ZlcmZsb3dFbGVtZW50U3R5bGUoZWxlbWVudCkgfHwgb3ZlcmZsb3dDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBzY3JvbGxhYmxlUGFyZW50cyA9IChlbGVtZW50KSA9PiB7XG4gICAgY29uc3QgcGFyZW50RWxlbWVudHMgPSBbXTtcbiAgICBpZiAoIWlzRG9jdW1lbnRBdmFpbGFibGUoKSB8fCAhaXNXaW5kb3dBdmFpbGFibGUoKSkge1xuICAgICAgICByZXR1cm4gcGFyZW50RWxlbWVudHM7XG4gICAgfVxuICAgIGxldCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICBpZiAoT1ZFUkZMT1dfUkVHRVhQLnRlc3Qob3ZlcmZsb3dTdHlsZShwYXJlbnQpKSB8fCBwYXJlbnQuaGFzQXR0cmlidXRlKCdkYXRhLXNjcm9sbGFibGUnKSkge1xuICAgICAgICAgICAgcGFyZW50RWxlbWVudHMucHVzaChwYXJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgICBwYXJlbnRFbGVtZW50cy5wdXNoKHdpbmRvdyk7XG4gICAgcmV0dXJuIHBhcmVudEVsZW1lbnRzO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBGUkFNRV9EVVJBVElPTiA9IDEwMDAgLyA2MDsgLy8xMDAwbXMgZGl2aWRlZCBieSA2MGZwc1xuZnVuY3Rpb24gbWVtb2l6ZShmdW4pIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKGNhbGxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBmdW4oLi4uYXJncyk7XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cbmNvbnN0IMm1MyA9ICgpID0+IHtcbiAgICBpZiAoIWlzRG9jdW1lbnRBdmFpbGFibGUoKSAmJiBkb2N1bWVudC5ib2R5ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdG9wID0gMTA7XG4gICAgY29uc3QgcGFyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBwYXJlbnQuc3R5bGUudHJhbnNmb3JtID0gXCJtYXRyaXgoMTAsIDAsIDAsIDEwLCAwLCAwKVwiO1xuICAgIHBhcmVudC5pbm5lckhUTUwgPSBgPGRpdiBzdHlsZT1cInBvc2l0aW9uOiBmaXhlZDsgdG9wOiAke3RvcH1weDtcIj5jaGlsZDwvZGl2PmA7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwYXJlbnQpO1xuICAgIGNvbnN0IGlzRGlmZmVyZW50ID0gcGFyZW50LmNoaWxkcmVuWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAhPT0gdG9wO1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQocGFyZW50KTtcbiAgICByZXR1cm4gaXNEaWZmZXJlbnQ7XG59O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGhhc1JlbGF0aXZlU3RhY2tpbmdDb250ZXh0ID0gbWVtb2l6ZSjJtTMpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHpJbmRleCA9IChhbmNob3IsIGNvbnRhaW5lcikgPT4ge1xuICAgIGlmICghYW5jaG9yIHx8ICFpc0RvY3VtZW50QXZhaWxhYmxlKCkgfHwgIWlzV2luZG93QXZhaWxhYmxlKCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNpYmxpbmcgPSBzaWJsaW5nQ29udGFpbmVyKGFuY2hvciwgY29udGFpbmVyKTtcbiAgICBpZiAoIXNpYmxpbmcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IFthbmNob3JdLmNvbmNhdChwYXJlbnRzKGFuY2hvciwgc2libGluZykpLnJlZHVjZSgoaW5kZXgsIHApID0+IHtcbiAgICAgICAgY29uc3QgekluZGV4U3R5bGUgPSBwLnN0eWxlLnpJbmRleCB8fCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwKS56SW5kZXg7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBwYXJzZUludCh6SW5kZXhTdHlsZSwgMTApO1xuICAgICAgICByZXR1cm4gY3VycmVudCA+IGluZGV4ID8gY3VycmVudCA6IGluZGV4O1xuICAgIH0sIDApO1xuICAgIHJldHVybiByZXN1bHQgPyAocmVzdWx0ICsgMSkgOiBudWxsO1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBzY2FsZVJlY3QgPSAocmVjdCwgc2NhbGUpID0+IHtcbiAgICBpZiAoIXJlY3QgfHwgc2NhbGUgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHQgLyBzY2FsZSxcbiAgICAgICAgbGVmdDogcmVjdC5sZWZ0IC8gc2NhbGUsXG4gICAgICAgIHRvcDogcmVjdC50b3AgLyBzY2FsZSxcbiAgICAgICAgd2lkdGg6IHJlY3Qud2lkdGggLyBzY2FsZVxuICAgIH07XG59O1xuXG5jb25zdCBTVFlMRVMgPSBbXG4gICAgJ2ZvbnQtc2l6ZScsXG4gICAgJ2ZvbnQtZmFtaWx5JyxcbiAgICAnZm9udC1zdHJldGNoJyxcbiAgICAnZm9udC1zdHlsZScsXG4gICAgJ2ZvbnQtd2VpZ2h0JyxcbiAgICAnbGluZS1oZWlnaHQnXG5dO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBET01TZXJ2aWNlID0gY2xhc3MgRE9NU2VydmljZSB7XG4gICAgYWRkT2Zmc2V0KGN1cnJlbnQsIGFkZGl0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiBjdXJyZW50LmxlZnQgKyBhZGRpdGlvbi5sZWZ0LFxuICAgICAgICAgICAgdG9wOiBjdXJyZW50LnRvcCArIGFkZGl0aW9uLnRvcFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhZGRTY3JvbGwocmVjdCwgc2Nyb2xsKSB7XG4gICAgICAgIHJldHVybiBhZGRTY3JvbGwocmVjdCwgc2Nyb2xsKTtcbiAgICB9XG4gICAgYWxpZ24oc2V0dGluZ3MpIHtcbiAgICAgICAgcmV0dXJuIGFsaWduKHNldHRpbmdzKTtcbiAgICB9XG4gICAgYm91bmRpbmdPZmZzZXQoZWwpIHtcbiAgICAgICAgcmV0dXJuIGJvdW5kaW5nT2Zmc2V0KHRoaXMubmF0aXZlRWxlbWVudChlbCkpO1xuICAgIH1cbiAgICBnZXRGb250U3R5bGVzKGVsKSB7XG4gICAgICAgIGNvbnN0IHdpbmRvdyA9IHRoaXMuZ2V0V2luZG93KCk7XG4gICAgICAgIGlmICghd2luZG93IHx8ICFlbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbXB1dGVkU3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5uYXRpdmVFbGVtZW50KGVsKSk7XG4gICAgICAgIHJldHVybiBTVFlMRVMubWFwKGZvbnQgPT4gKHsga2V5OiBmb250LCB2YWx1ZTogY29tcHV0ZWRTdHlsZXNbZm9udF0gfSkpO1xuICAgIH1cbiAgICBnZXRXaW5kb3coKSB7XG4gICAgICAgIHJldHVybiBpc1dpbmRvd0F2YWlsYWJsZSgpID8gd2luZG93IDogbnVsbDtcbiAgICB9XG4gICAgaGFzT2Zmc2V0UGFyZW50KGVsKSB7XG4gICAgICAgIGlmICghZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gISF0aGlzLm5hdGl2ZUVsZW1lbnQoZWwpLm9mZnNldFBhcmVudDtcbiAgICB9XG4gICAgb2Zmc2V0KGVsKSB7XG4gICAgICAgIGlmICghZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvZmZzZXQodGhpcy5uYXRpdmVFbGVtZW50KGVsKSk7XG4gICAgfVxuICAgIG9mZnNldEF0UG9pbnQoZWwsIGN1cnJlbnRMb2NhdGlvbikge1xuICAgICAgICBpZiAoIWVsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5uYXRpdmVFbGVtZW50KGVsKTtcbiAgICAgICAgY29uc3QgeyBsZWZ0LCB0b3AsIHRyYW5zaXRpb24gfSA9IGVsZW1lbnQuc3R5bGU7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbiA9ICdub25lJztcbiAgICAgICAgZWxlbWVudC5zdHlsZS5sZWZ0ID0gYCR7Y3VycmVudExvY2F0aW9uLmxlZnR9cHhgO1xuICAgICAgICBlbGVtZW50LnN0eWxlLnRvcCA9IGAke2N1cnJlbnRMb2NhdGlvbi50b3B9cHhgO1xuICAgICAgICBjb25zdCBjdXJyZW50T2Zmc2V0ID0gb2Zmc2V0KGVsZW1lbnQpO1xuICAgICAgICBlbGVtZW50LnN0eWxlLmxlZnQgPSBsZWZ0O1xuICAgICAgICBlbGVtZW50LnN0eWxlLnRvcCA9IHRvcDtcbiAgICAgICAgLy8gcHJldmVudHMgZWxlbWVudHMgd2l0aCB0cmFuc2l0aW9uIHRvIGJlIGFuaW1hdGVkIGJlY2F1c2Ugb2YgdGhlIGNoYW5nZVxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tdW51c2VkLWV4cHJlc3Npb25cbiAgICAgICAgZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XG4gICAgICAgIHJldHVybiBjdXJyZW50T2Zmc2V0O1xuICAgIH1cbiAgICBuYXRpdmVFbGVtZW50KGVsKSB7XG4gICAgICAgIGlmICghZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbC5uYXRpdmVFbGVtZW50IHx8IGVsO1xuICAgIH1cbiAgICBwb3NpdGlvbihlbGVtZW50LCBwb3B1cCwgc2NhbGUgPSAxKSB7XG4gICAgICAgIGlmICghZWxlbWVudCB8fCAhcG9wdXApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3NpdGlvbldpdGhTY3JvbGwodGhpcy5uYXRpdmVFbGVtZW50KGVsZW1lbnQpLCB0aGlzLm5hdGl2ZUVsZW1lbnQocG9wdXApLCBzY2FsZSk7XG4gICAgfVxuICAgIHJlbW92ZVNjcm9sbChyZWN0LCBzY3JvbGwpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZVNjcm9sbChyZWN0LCBzY3JvbGwpO1xuICAgIH1cbiAgICByZXN0cmljdFRvVmlldyhzZXR0aW5ncykge1xuICAgICAgICByZXR1cm4gcmVzdHJpY3RUb1ZpZXcoc2V0dGluZ3MpO1xuICAgIH1cbiAgICBzY3JvbGxQb3NpdGlvbihlbCkge1xuICAgICAgICByZXR1cm4gc2Nyb2xsUG9zaXRpb24odGhpcy5uYXRpdmVFbGVtZW50KGVsKSk7XG4gICAgfVxuICAgIHNjcm9sbGFibGVQYXJlbnRzKGVsKSB7XG4gICAgICAgIHJldHVybiBzY3JvbGxhYmxlUGFyZW50cyh0aGlzLm5hdGl2ZUVsZW1lbnQoZWwpKTtcbiAgICB9XG4gICAgc3RhY2tpbmdFbGVtZW50T2Zmc2V0KGVsKSB7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlQ29udGV4dEVsZW1lbnQgPSB0aGlzLmdldFJlbGF0aXZlQ29udGV4dEVsZW1lbnQoZWwpO1xuICAgICAgICBpZiAoIXJlbGF0aXZlQ29udGV4dEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvZmZzZXQocmVsYXRpdmVDb250ZXh0RWxlbWVudCk7XG4gICAgfVxuICAgIHN0YWNraW5nRWxlbWVudFNjcm9sbChlbCkge1xuICAgICAgICBjb25zdCByZWxhdGl2ZUNvbnRleHRFbGVtZW50ID0gdGhpcy5nZXRSZWxhdGl2ZUNvbnRleHRFbGVtZW50KGVsKTtcbiAgICAgICAgaWYgKCFyZWxhdGl2ZUNvbnRleHRFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHJlbGF0aXZlQ29udGV4dEVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgIHk6IHJlbGF0aXZlQ29udGV4dEVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldFJlbGF0aXZlQ29udGV4dEVsZW1lbnQoZWwpIHtcbiAgICAgICAgaWYgKCFlbCB8fCAhaGFzUmVsYXRpdmVTdGFja2luZ0NvbnRleHQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMubmF0aXZlRWxlbWVudChlbCkucGFyZW50RWxlbWVudDtcbiAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHBhcmVudCkudHJhbnNmb3JtICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHVzZVJlbGF0aXZlUG9zaXRpb24oZWwpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5nZXRSZWxhdGl2ZUNvbnRleHRFbGVtZW50KGVsKTtcbiAgICB9XG4gICAgd2luZG93Vmlld1BvcnQoZWwpIHtcbiAgICAgICAgcmV0dXJuIGdldFdpbmRvd1ZpZXdQb3J0KHRoaXMubmF0aXZlRWxlbWVudChlbCkpO1xuICAgIH1cbiAgICB6SW5kZXgoYW5jaG9yLCBjb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuIHpJbmRleCh0aGlzLm5hdGl2ZUVsZW1lbnQoYW5jaG9yKSwgdGhpcy5uYXRpdmVFbGVtZW50KGNvbnRhaW5lcikpO1xuICAgIH1cbiAgICB6b29tTGV2ZWwoKSB7XG4gICAgICAgIGlmICghaXNEb2N1bWVudEF2YWlsYWJsZSgpIHx8ICFpc1dpbmRvd0F2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIC8gd2luZG93LmlubmVyV2lkdGgpLnRvRml4ZWQoMikpIHx8IDE7XG4gICAgfVxuICAgIGlzWm9vbWVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy56b29tTGV2ZWwoKSA+IDE7XG4gICAgfVxufTtcbkRPTVNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKClcbl0sIERPTVNlcnZpY2UpO1xuXG4vKipcbiAqIFVzZWQgdG8gc2V0IHRoZSBkb2N1bWVudCBzY2FsZSB3aGVuIHVzaW5nIGEgW3NjYWxlIHRyYW5zZm9ybV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3RyYW5zZm9ybS1mdW5jdGlvbi9zY2FsZSkuXG4gKlxuICogVGhlIGRvY3VtZW50IG9yIGNvbnRhaW5lciBzY2FsZSBpcyByZXF1aXJlZCB0byBjb21wdXRlIHRoZSBwb3B1cCBwb3NpdGlvbiBjb3JyZWN0bHkuIERldGVjdGluZyB0aGUgc2NhbGUgaXMgbm90IHJlbGlhYmxlIGFuZCBtdXN0IGJlIHNldCBieSBwcm92aWRpbmcgYSB2YWx1ZSBmb3IgU0NBTEUuIFNlZSBbU3VwcG9ydCBmb3IgRG9jdW1lbnQgU2NhbGVdKHslIHNsdWcgZG9jdW1lbnRzY2FsZV9wb3B1cCAlfSkuXG4gKlxuICogPiBVc2luZyB0aGlzIHRva2VuIGlzIG5vdCBuZWNlc3NhcnkgZm9yIHVzZXItYXBwbGllZCBicm93c2VyIHpvb20uXG4gKlxuICogeyUgbWV0YSBoZWlnaHQ6MzAwICV9XG4gKiB7JSBlbWJlZF9maWxlIHNjYWxlL2FwcC5jb21wb25lbnQudHMgcHJldmlldyAlfVxuICogeyUgZW1iZWRfZmlsZSBzY2FsZS9hcHAubW9kdWxlLnRzICV9XG4gKiB7JSBlbWJlZF9maWxlIHNoYXJlZC9tYWluLnRzICV9XG4gKiB7JSBlbmRtZXRhICV9XG4gKlxuICpcbiAqL1xuY29uc3QgU0NBTEUgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ1BvcHVwIERvY3VtZW50IFNjYWxlJyk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgQWxpZ25TZXJ2aWNlID0gY2xhc3MgQWxpZ25TZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihfZG9tLCBzY2FsZSA9IDEpIHtcbiAgICAgICAgdGhpcy5fZG9tID0gX2RvbTtcbiAgICAgICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAgIH1cbiAgICBhbGlnbkVsZW1lbnQoc2V0dGluZ3MpIHtcbiAgICAgICAgY29uc3QgeyBhbmNob3IsIGVsZW1lbnQsIGFuY2hvckFsaWduLCBlbGVtZW50QWxpZ24sIG1hcmdpbiwgb2Zmc2V0OiBvZmZzZXQkJDEsIHBvc2l0aW9uTW9kZSB9ID0gc2V0dGluZ3M7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5zY2FsZSB8fCAxO1xuICAgICAgICBjb25zdCBmaXhlZE1vZGUgPSBwb3NpdGlvbk1vZGUgPT09ICdmaXhlZCcgfHwgIXRoaXMuX2RvbS5oYXNPZmZzZXRQYXJlbnQoZWxlbWVudCk7XG4gICAgICAgIGNvbnN0IGFuY2hvclJlY3QgPSBmaXhlZE1vZGUgPyB0aGlzLmFic29sdXRlUmVjdChhbmNob3IsIGVsZW1lbnQsIG9mZnNldCQkMSwgc2NhbGUpIDogdGhpcy5yZWxhdGl2ZVJlY3QoYW5jaG9yLCBlbGVtZW50LCBvZmZzZXQkJDEsIHNjYWxlKTtcbiAgICAgICAgY29uc3QgZWxlbWVudFJlY3QgPSBzY2FsZVJlY3QodGhpcy5fZG9tLm9mZnNldChlbGVtZW50KSwgc2NhbGUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kb20uYWxpZ24oe1xuICAgICAgICAgICAgYW5jaG9yQWxpZ246IGFuY2hvckFsaWduLFxuICAgICAgICAgICAgYW5jaG9yUmVjdDogYW5jaG9yUmVjdCxcbiAgICAgICAgICAgIGVsZW1lbnRBbGlnbjogZWxlbWVudEFsaWduLFxuICAgICAgICAgICAgZWxlbWVudFJlY3Q6IGVsZW1lbnRSZWN0LFxuICAgICAgICAgICAgbWFyZ2luXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhYnNvbHV0ZVJlY3QoYW5jaG9yLCBlbGVtZW50LCBvZmZzZXQkJDEsIHNjYWxlKSB7XG4gICAgICAgIGNvbnN0IHNjcm9sbFBvcyA9IHRoaXMuZWxlbWVudFNjcm9sbFBvc2l0aW9uKGFuY2hvciwgZWxlbWVudCk7XG4gICAgICAgIGNvbnN0IHJlY3QgPSBlaXRoZXJSZWN0KHRoaXMuX2RvbS5vZmZzZXQoYW5jaG9yKSwgb2Zmc2V0JCQxKTtcbiAgICAgICAgY29uc3Qgc3RhY2tTY2FsZSA9IDIgKiBzY2FsZTtcbiAgICAgICAgY29uc3Qgc3RhY2tTY3JvbGwgPSB0aGlzLl9kb20uc3RhY2tpbmdFbGVtZW50U2Nyb2xsKGVsZW1lbnQpO1xuICAgICAgICBpZiAoc2NhbGUgIT09IDEgJiYgc3RhY2tTY3JvbGwpIHtcbiAgICAgICAgICAgIHN0YWNrU2Nyb2xsLnggLz0gc3RhY2tTY2FsZTtcbiAgICAgICAgICAgIHN0YWNrU2Nyb2xsLnkgLz0gc3RhY2tTY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFja09mZnNldCA9IHRoaXMuX2RvbS5zdGFja2luZ0VsZW1lbnRPZmZzZXQoZWxlbWVudCk7XG4gICAgICAgIGlmIChzY2FsZSAhPT0gMSAmJiBzdGFja09mZnNldCkge1xuICAgICAgICAgICAgc3RhY2tPZmZzZXQubGVmdCAvPSBzdGFja1NjYWxlO1xuICAgICAgICAgICAgc3RhY2tPZmZzZXQudG9wIC89IHN0YWNrU2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvbS5yZW1vdmVTY3JvbGwodGhpcy5fZG9tLmFkZFNjcm9sbChyZW1vdmVTdGFja2luZ09mZnNldChzY2FsZVJlY3QocmVjdCwgc2NhbGUpLCBzdGFja09mZnNldCksIHN0YWNrU2Nyb2xsKSwgc2Nyb2xsUG9zKTtcbiAgICB9XG4gICAgZWxlbWVudFNjcm9sbFBvc2l0aW9uKGFuY2hvciwgZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gYW5jaG9yID8geyB4OiAwLCB5OiAwIH0gOiB0aGlzLl9kb20uc2Nyb2xsUG9zaXRpb24oZWxlbWVudCk7XG4gICAgfVxuICAgIHJlbGF0aXZlUmVjdChhbmNob3IsIGVsZW1lbnQsIG9mZnNldCQkMSwgc2NhbGUpIHtcbiAgICAgICAgY29uc3QgcmVjdCA9IGVpdGhlclJlY3QodGhpcy5fZG9tLnBvc2l0aW9uKGFuY2hvciwgZWxlbWVudCwgc2NhbGUpLCBvZmZzZXQkJDEpO1xuICAgICAgICByZXR1cm4gc2NhbGVSZWN0KHJlY3QsIHNjYWxlKTtcbiAgICB9XG59O1xuQWxpZ25TZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fcGFyYW0oMSwgSW5qZWN0KFNDQUxFKSksIF9fcGFyYW0oMSwgT3B0aW9uYWwoKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtET01TZXJ2aWNlLCBOdW1iZXJdKVxuXSwgQWxpZ25TZXJ2aWNlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBQb3NpdGlvblNlcnZpY2UgPSBjbGFzcyBQb3NpdGlvblNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKF9kb20sIHNjYWxlID0gMSkge1xuICAgICAgICB0aGlzLl9kb20gPSBfZG9tO1xuICAgICAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG4gICAgfVxuICAgIHBvc2l0aW9uRWxlbWVudChzZXR0aW5ncykge1xuICAgICAgICBjb25zdCB7IGFuY2hvciwgY3VycmVudExvY2F0aW9uLCBlbGVtZW50LCBhbmNob3JBbGlnbiwgZWxlbWVudEFsaWduLCBjb2xsaXNpb25zLCBtYXJnaW4gfSA9IHNldHRpbmdzO1xuICAgICAgICBjb25zdCBkb20gPSB0aGlzLl9kb207XG4gICAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5zY2FsZSB8fCAxO1xuICAgICAgICBjb25zdCBlbGVtZW50T2Zmc2V0ID0gZG9tLm9mZnNldEF0UG9pbnQoZWxlbWVudCwgY3VycmVudExvY2F0aW9uKTtcbiAgICAgICAgY29uc3QgZWxlbWVudFJlY3QgPSBzY2FsZVJlY3QoZWxlbWVudE9mZnNldCwgc2NhbGUpO1xuICAgICAgICBjb25zdCBhbmNob3JPZmZzZXQgPSBzY2FsZVJlY3QoZG9tLm9mZnNldChhbmNob3IpLCBzY2FsZSk7XG4gICAgICAgIGNvbnN0IGFuY2hvclJlY3QgPSBlaXRoZXJSZWN0KGFuY2hvck9mZnNldCwgY3VycmVudExvY2F0aW9uKTtcbiAgICAgICAgY29uc3Qgdmlld1BvcnQgPSBzZXR0aW5ncy52aWV3UG9ydCB8fCBkb20ud2luZG93Vmlld1BvcnQoZWxlbWVudCk7XG4gICAgICAgIHZpZXdQb3J0LndpZHRoID0gdmlld1BvcnQud2lkdGggLyBzY2FsZTtcbiAgICAgICAgdmlld1BvcnQuaGVpZ2h0ID0gdmlld1BvcnQuaGVpZ2h0IC8gc2NhbGU7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGRvbS5yZXN0cmljdFRvVmlldyh7XG4gICAgICAgICAgICBhbmNob3JBbGlnbixcbiAgICAgICAgICAgIGFuY2hvclJlY3QsXG4gICAgICAgICAgICBjb2xsaXNpb25zLFxuICAgICAgICAgICAgZWxlbWVudEFsaWduLFxuICAgICAgICAgICAgZWxlbWVudFJlY3QsXG4gICAgICAgICAgICBtYXJnaW4sXG4gICAgICAgICAgICB2aWV3UG9ydFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0JCQxID0gZG9tLmFkZE9mZnNldChjdXJyZW50TG9jYXRpb24sIHJlc3VsdC5vZmZzZXQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmxpcDogcmVzdWx0LmZsaXAsXG4gICAgICAgICAgICBmbGlwcGVkOiByZXN1bHQuZmxpcHBlZCxcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0JCQxXG4gICAgICAgIH07XG4gICAgfVxufTtcblBvc2l0aW9uU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX3BhcmFtKDEsIEluamVjdChTQ0FMRSkpLCBfX3BhcmFtKDEsIE9wdGlvbmFsKCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRE9NU2VydmljZSwgTnVtYmVyXSlcbl0sIFBvc2l0aW9uU2VydmljZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgUmVzaXplU2VydmljZSA9IGNsYXNzIFJlc2l6ZVNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKF9kb20sIF96b25lKSB7XG4gICAgICAgIHRoaXMuX2RvbSA9IF9kb207XG4gICAgICAgIHRoaXMuX3pvbmUgPSBfem9uZTtcbiAgICB9XG4gICAgc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghaXNEb2N1bWVudEF2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IGZyb21FdmVudCh0aGlzLl9kb20uZ2V0V2luZG93KCksIFwicmVzaXplXCIpXG4gICAgICAgICAgICAgICAgLnBpcGUoYXVkaXRUaW1lKEZSQU1FX0RVUkFUSU9OKSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IGNhbGxiYWNrKCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgIGlmICghdGhpcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBpc1Vuc3Vic2NyaWJlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3Vic2NyaXB0aW9uICYmIHRoaXMuc3Vic2NyaXB0aW9uLmNsb3NlZDtcbiAgICB9XG59O1xuUmVzaXplU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0RPTVNlcnZpY2UsIE5nWm9uZV0pXG5dLCBSZXNpemVTZXJ2aWNlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IFRIUkVTSE9MRF9ESUZGID0gMTtcbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgU2Nyb2xsYWJsZVNlcnZpY2UgPSBjbGFzcyBTY3JvbGxhYmxlU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoX2RvbSwgX3pvbmUpIHtcbiAgICAgICAgdGhpcy5fZG9tID0gX2RvbTtcbiAgICAgICAgdGhpcy5fem9uZSA9IF96b25lO1xuICAgIH1cbiAgICBmb3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3Vic2NyaWJlKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2sgfHwgIWlzRG9jdW1lbnRBdmFpbGFibGUoKSB8fCAhdGhpcy5lbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmF0aXZlRWxlbWVudCA9IHRoaXMuX2RvbS5uYXRpdmVFbGVtZW50KHRoaXMuZWxlbWVudCk7XG4gICAgICAgIGNvbnN0IHBhcmVudHMkJDEgPSB0aGlzLl9kb20uc2Nyb2xsYWJsZVBhcmVudHModGhpcy5lbGVtZW50KTtcbiAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvYnNlcnZhYmxlcyA9IHBhcmVudHMkJDEubWFwKHAgPT4gZnJvbUV2ZW50KHAsIFwic2Nyb2xsXCIpLnBpcGUoYXVkaXRUaW1lKEZSQU1FX0RVUkFUSU9OKSkpO1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlciA9IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNQYXJlbnQgPSBwYXJlbnRzJCQxLmZpbHRlcihwID0+IHAgPT09IHRhcmdldCkubGVuZ3RoID4gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0RvY3VtZW50ID0gdGFyZ2V0ID09PSBkb2N1bWVudDtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1dpbmRvdyA9IHRhcmdldCA9PT0gd2luZG93O1xuICAgICAgICAgICAgICAgIGlmIChpc1BhcmVudCB8fCBpc0RvY3VtZW50IHx8IGlzV2luZG93KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMuaXNWaXNpYmxlKG5hdGl2ZUVsZW1lbnQsIHRhcmdldCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IG1lcmdlKC4uLm9ic2VydmFibGVzKS5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIGlzVmlzaWJsZShlbGVtLCBjb250YWluZXIpIHtcbiAgICAgICAgY29uc3QgZWxlbVJlY3QgPSB0aGlzLl9kb20uYm91bmRpbmdPZmZzZXQoZWxlbSk7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclJlY3QgPSB0aGlzLl9kb20uYm91bmRpbmdPZmZzZXQoY29udGFpbmVyKTtcbiAgICAgICAgaWYgKFRIUkVTSE9MRF9ESUZGIDwgKGNvbnRhaW5lclJlY3QudG9wIC0gZWxlbVJlY3QuYm90dG9tKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChUSFJFU0hPTERfRElGRiA8IChlbGVtUmVjdC50b3AgLSBjb250YWluZXJSZWN0LmJvdHRvbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVEhSRVNIT0xEX0RJRkYgPCAoZWxlbVJlY3QubGVmdCAtIGNvbnRhaW5lclJlY3QucmlnaHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFRIUkVTSE9MRF9ESUZGIDwgKGNvbnRhaW5lclJlY3QubGVmdCAtIGVsZW1SZWN0LnJpZ2h0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn07XG5TY3JvbGxhYmxlU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0RPTVNlcnZpY2UsIE5nWm9uZV0pXG5dLCBTY3JvbGxhYmxlU2VydmljZSk7XG5cbmNvbnN0IExFRlQgPSAnbGVmdCc7XG5jb25zdCBSSUdIVCA9ICdyaWdodCc7XG5jb25zdCBET1dOID0gJ2Rvd24nO1xuY29uc3QgVVAgPSAndXAnO1xuY29uc3QgREVGQVVMVF9UWVBFID0gJ3NsaWRlJztcbmNvbnN0IERFRkFVTFRfRFVSQVRJT04gPSAxMDA7XG5jb25zdCBhbmltYXRpb25UeXBlcyA9IHt9O1xuLyogdHNsaW50OmRpc2FibGU6b2JqZWN0LWxpdGVyYWwtc29ydC1rZXlzICovXG5hbmltYXRpb25UeXBlcy5leHBhbmQgPSAoZGlyZWN0aW9uKSA9PiB7XG4gICAgY29uc3Qgc2NhbGUgPSBkaXJlY3Rpb24gPT09IFVQIHx8IGRpcmVjdGlvbiA9PT0gRE9XTiA/ICdzY2FsZVknIDogJ3NjYWxlWCc7XG4gICAgY29uc3Qgc3RhcnRTY2FsZSA9IDA7XG4gICAgY29uc3QgZW5kU2NhbGUgPSAxO1xuICAgIGxldCBvcmlnaW47XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gRE9XTikge1xuICAgICAgICBvcmlnaW4gPSAndG9wJztcbiAgICB9XG4gICAgZWxzZSBpZiAoZGlyZWN0aW9uID09PSBMRUZUKSB7XG4gICAgICAgIG9yaWdpbiA9IFJJR0hUO1xuICAgIH1cbiAgICBlbHNlIGlmIChkaXJlY3Rpb24gPT09IFJJR0hUKSB7XG4gICAgICAgIG9yaWdpbiA9IExFRlQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvcmlnaW4gPSAnYm90dG9tJztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHsgdHJhbnNmb3JtOiBgJHtzY2FsZX0oJHtzdGFydFNjYWxlfSlgLCB0cmFuc2Zvcm1PcmlnaW46IG9yaWdpbiB9LFxuICAgICAgICBlbmQ6IHsgdHJhbnNmb3JtOiBgJHtzY2FsZX0oJHtlbmRTY2FsZX0pYCB9XG4gICAgfTtcbn07XG5hbmltYXRpb25UeXBlcy5zbGlkZSA9IChkaXJlY3Rpb24pID0+IHtcbiAgICBjb25zdCB0cmFuc2xhdGUgPSBkaXJlY3Rpb24gPT09IExFRlQgfHwgZGlyZWN0aW9uID09PSBSSUdIVCA/ICd0cmFuc2xhdGVYJyA6ICd0cmFuc2xhdGVZJztcbiAgICBjb25zdCBzdGFydCA9IGRpcmVjdGlvbiA9PT0gUklHSFQgfHwgZGlyZWN0aW9uID09PSBET1dOID8gLTEwMCA6IDEwMDtcbiAgICBjb25zdCBlbmQgPSAwO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiB7IHRyYW5zZm9ybTogYCR7dHJhbnNsYXRlfSgke3N0YXJ0fSUpYCB9LFxuICAgICAgICBlbmQ6IHsgdHJhbnNmb3JtOiBgJHt0cmFuc2xhdGV9KCR7ZW5kfSUpYCB9XG4gICAgfTtcbn07XG5hbmltYXRpb25UeXBlcy5mYWRlID0gKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiB7IG9wYWNpdHk6IDAgfSxcbiAgICAgICAgZW5kOiB7IG9wYWNpdHk6IDEgfVxuICAgIH07XG59O1xuYW5pbWF0aW9uVHlwZXMuem9vbSA9ICgpID0+IHtcbiAgICBjb25zdCBzdGFydCA9IDA7XG4gICAgY29uc3QgZW5kID0gMTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogeyB0cmFuc2Zvcm06IGBzY2FsZSgke3N0YXJ0fSlgIH0sXG4gICAgICAgIGVuZDogeyB0cmFuc2Zvcm06IGBzY2FsZSgke2VuZH0pYCB9XG4gICAgfTtcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IEFuaW1hdGlvblNlcnZpY2UgPSBjbGFzcyBBbmltYXRpb25TZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihhbmltYXRpb25CdWlsZGVyKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uQnVpbGRlciA9IGFuaW1hdGlvbkJ1aWxkZXI7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZW5kID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBwbGF5KGVsZW1lbnQsIG9wdGlvbnMsIGZsaXApIHtcbiAgICAgICAgaWYgKCF0aGlzLmZsaXAgfHwgdGhpcy5mbGlwLmhvcml6b250YWwgIT09IGZsaXAuaG9yaXpvbnRhbCB8fFxuICAgICAgICAgICAgdGhpcy5mbGlwLnZlcnRpY2FsICE9PSBmbGlwLnZlcnRpY2FsKSB7XG4gICAgICAgICAgICB0aGlzLmZsaXAgPSBmbGlwO1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IG9wdGlvbnMudHlwZSB8fCBERUZBVUxUX1RZUEU7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZXNGbiA9IGFuaW1hdGlvblR5cGVzW3R5cGVdO1xuICAgICAgICAgICAgaWYgKHN0YXRlc0ZuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5nZXREaXJlY3Rpb24oZmxpcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdGVzID0gc3RhdGVzRm4oZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBsYXlTdGF0ZXMoZWxlbWVudCwgc3RhdGVzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRGV2TW9kZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBhbmltYXRpb24gdHlwZTogXCIke3R5cGV9XCIuIFRoZSBzdXBwb3J0ZWQgdHlwZXMgYXJlIHNsaWRlLCBleHBhbmQsIGZhZGUgYW5kIHpvb20uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc3RvcFBsYXllcigpO1xuICAgIH1cbiAgICBwbGF5U3RhdGVzKGVsZW1lbnQsIHN0YXRlcywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnN0b3BQbGF5ZXIoKTtcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uIHx8IERFRkFVTFRfRFVSQVRJT047XG4gICAgICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzLmFuaW1hdGlvbkJ1aWxkZXIuYnVpbGQoW1xuICAgICAgICAgICAgc3R5bGUoc3RhdGVzLnN0YXJ0KSxcbiAgICAgICAgICAgIGFuaW1hdGUoYCR7ZHVyYXRpb259bXMgZWFzZS1pbmAsIHN0eWxlKHN0YXRlcy5lbmQpKVxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgcGxheWVyID0gdGhpcy5wbGF5ZXIgPSBmYWN0b3J5LmNyZWF0ZShlbGVtZW50KTtcbiAgICAgICAgcGxheWVyLm9uRG9uZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVuZC5lbWl0KCk7XG4gICAgICAgICAgICB0aGlzLnN0b3BQbGF5ZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RhcnQuZW1pdCgpO1xuICAgICAgICBwbGF5ZXIucGxheSgpO1xuICAgIH1cbiAgICBnZXREaXJlY3Rpb24oZmxpcCwgb3B0aW9ucykge1xuICAgICAgICBsZXQgZGlyZWN0aW9uID0gb3B0aW9ucy5kaXJlY3Rpb24gfHwgRE9XTjtcbiAgICAgICAgaWYgKGZsaXAuaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gTEVGVCkge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9IFJJR0hUO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGlyZWN0aW9uID09PSBSSUdIVCkge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9IExFRlQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZsaXAudmVydGljYWwpIHtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09IERPV04pIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSBVUDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gVVApIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSBET1dOO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXJlY3Rpb247XG4gICAgfVxuICAgIHN0b3BQbGF5ZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnBsYXllcikge1xuICAgICAgICAgICAgdGhpcy5wbGF5ZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5wbGF5ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufTtcbkFuaW1hdGlvblNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtBbmltYXRpb25CdWlsZGVyXSlcbl0sIEFuaW1hdGlvblNlcnZpY2UpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgcGFja2FnZU1ldGFkYXRhID0ge1xuICAgIG5hbWU6ICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1wb3B1cCcsXG4gICAgcHJvZHVjdE5hbWU6ICdLZW5kbyBVSSBmb3IgQW5ndWxhcicsXG4gICAgcHJvZHVjdENvZGVzOiBbJ0tFTkRPVUlBTkdVTEFSJywgJ0tFTkRPVUlDT01QTEVURSddLFxuICAgIHB1Ymxpc2hEYXRlOiAxNjIwMjEzNTQ2LFxuICAgIHZlcnNpb246ICcnLFxuICAgIGxpY2Vuc2luZ0RvY3NVcmw6ICdodHRwczovL3d3dy50ZWxlcmlrLmNvbS9rZW5kby1hbmd1bGFyLXVpL215LWxpY2Vuc2UvP3V0bV9tZWRpdW09cHJvZHVjdCZ1dG1fc291cmNlPWtlbmRvYW5ndWxhciZ1dG1fY2FtcGFpZ249a2VuZG8tdWktYW5ndWxhci1wdXJjaGFzZS1saWNlbnNlLWtleXMtd2FybmluZydcbn07XG5cbmNvbnN0IERFRkFVTFRfT0ZGU0VUID0geyBsZWZ0OiAtMTAwMDAsIHRvcDogMCB9O1xuY29uc3QgQU5JTUFUSU9OX0NPTlRBSU5FUiA9ICdrLWFuaW1hdGlvbi1jb250YWluZXInO1xuY29uc3QgQU5JTUFUSU9OX0NPTlRBSU5FUl9GSVhFRCA9ICdrLWFuaW1hdGlvbi1jb250YWluZXItZml4ZWQnO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBbS2VuZG8gVUkgUG9wdXAgY29tcG9uZW50IGZvciBBbmd1bGFyXSh7JSBzbHVnIG92ZXJ2aWV3X3BvcHVwICV9KS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIF9AQ29tcG9uZW50KHtcbiAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqIHRlbXBsYXRlOiBgXG4gKiAgPGJ1dHRvbiAjYW5jaG9yIChjbGljayk9XCJzaG93PSFzaG93XCI+VG9nZ2xlPC9idXR0b24+XG4gKiAgPGtlbmRvLXBvcHVwICpuZ0lmPVwic2hvd1wiIFthbmNob3JdPVwiYW5jaG9yXCI+XG4gKiAgICAgIDxzdHJvbmc+UG9wdXAgY29udGVudCE8L3N0cm9uZz5cbiAqICA8L2tlbmRvLXBvcHVwPlxuICogYFxuICogfSlcbiAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiAgIHB1YmxpYyBzaG93OiBib29sZWFuID0gZmFsc2U7XG4gKiB9XG4gKiBgYGBcbiAqL1xubGV0IFBvcHVwQ29tcG9uZW50ID0gY2xhc3MgUG9wdXBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lciwgX2FsaWduU2VydmljZSwgZG9tU2VydmljZSwgX3Bvc2l0aW9uU2VydmljZSwgX3Jlc2l6ZVNlcnZpY2UsIF9zY3JvbGxhYmxlU2VydmljZSwgYW5pbWF0aW9uU2VydmljZSwgX3JlbmRlcmVyLCBfem9uZSkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5fYWxpZ25TZXJ2aWNlID0gX2FsaWduU2VydmljZTtcbiAgICAgICAgdGhpcy5kb21TZXJ2aWNlID0gZG9tU2VydmljZTtcbiAgICAgICAgdGhpcy5fcG9zaXRpb25TZXJ2aWNlID0gX3Bvc2l0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5fcmVzaXplU2VydmljZSA9IF9yZXNpemVTZXJ2aWNlO1xuICAgICAgICB0aGlzLl9zY3JvbGxhYmxlU2VydmljZSA9IF9zY3JvbGxhYmxlU2VydmljZTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TZXJ2aWNlID0gYW5pbWF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX3pvbmUgPSBfem9uZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnRyb2xzIHRoZSBQb3B1cCBhbmltYXRpb24uIEJ5IGRlZmF1bHQsIHRoZSBvcGVuaW5nIGFuZCBjbG9zaW5nIGFuaW1hdGlvbnNcbiAgICAgICAgICogYXJlIGVuYWJsZWQgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBhbmltYXRpb25zX3BvcHVwICV9KSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFuaW1hdGUgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIHRoZSBhbmNob3IgcGl2b3QgcG9pbnRcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBhbGlnbm1lbnRwb3NpdGlvbmluZ19wb3B1cCAlfSN0b2MtcG9zaXRpb25pbmcpKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYW5jaG9yQWxpZ24gPSB7IGhvcml6b250YWw6ICdsZWZ0JywgdmVydGljYWw6ICdib3R0b20nIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25maWd1cmVzIHRoZSBjb2xsaXNpb24gYmVoYXZpb3Igb2YgdGhlIFBvcHVwXG4gICAgICAgICAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgdmlld3BvcnRib3VuZGFyeWRldGVjdGlvbl9wb3B1cCAlfSkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2xsaXNpb24gPSB7IGhvcml6b250YWw6ICdmaXQnLCB2ZXJ0aWNhbDogJ2ZsaXAnIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIHBpdm90IHBvaW50IG9mIHRoZSBQb3B1cFxuICAgICAgICAgKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGFsaWdubWVudHBvc2l0aW9uaW5nX3BvcHVwICV9I3RvYy1wb3NpdGlvbmluZykpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb3B1cEFsaWduID0geyBob3Jpem9udGFsOiAnbGVmdCcsIHZlcnRpY2FsOiAndG9wJyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29udHJvbHMgd2hldGhlciB0aGUgY29tcG9uZW50IHdpbGwgY29weSB0aGUgYGFuY2hvcmAgZm9udCBzdHlsZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvcHlBbmNob3JTdHlsZXMgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgcG9zaXRpb24gbW9kZSBvZiB0aGUgY29tcG9uZW50LiBCeSBkZWZhdWx0LCB0aGUgUG9wdXAgdXNlcyBmaXhlZCBwb3NpdGlvbmluZy5cbiAgICAgICAgICogVG8gbWFrZSB0aGUgUG9wdXAgYWNxdWlyZSBhYnNvbHV0ZSBwb3NpdGlvbmluZywgc2V0IHRoaXMgb3B0aW9uIHRvIGBhYnNvbHV0ZWAuXG4gICAgICAgICAqXG4gICAgICAgICAqID4gSWYgeW91IG5lZWQgdG8gc3VwcG9ydCBtb2JpbGUgYnJvd3NlcnMgd2l0aCB0aGUgem9vbSBvcHRpb24sXG4gICAgICAgICAqIHVzZSB0aGUgYGFic29sdXRlYCBwb3NpdGlvbmluZyBvZiB0aGUgUG9wdXAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYGh0bWxcbiAgICAgICAgICogPHN0eWxlPlxuICAgICAgICAgKiAgLnBhcmVudC1jb250ZW50IHtcbiAgICAgICAgICogICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgICogICAgIHdpZHRoOiAyMDBweDtcbiAgICAgICAgICogICAgIGhlaWdodDogMjAwcHg7XG4gICAgICAgICAqICAgICBvdmVyZmxvdzogYXV0bztcbiAgICAgICAgICogICAgIG1hcmdpbjogMjAwcHggYXV0bztcbiAgICAgICAgICogICAgIGJvcmRlcjogMXB4IHNvbGlkIHJlZDtcbiAgICAgICAgICogIH1cbiAgICAgICAgICogIC5jb250ZW50IHtcbiAgICAgICAgICogICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgICogICAgIHdpZHRoOiAxMDBweDtcbiAgICAgICAgICogICAgIGhlaWdodDogMTAwcHg7XG4gICAgICAgICAqICAgICBvdmVyZmxvdzogYXV0bztcbiAgICAgICAgICogICAgIG1hcmdpbjogMzAwcHg7XG4gICAgICAgICAqICAgICBib3JkZXI6IDFweCBzb2xpZCBibHVlO1xuICAgICAgICAgKiAgfVxuICAgICAgICAgKiAgLmFuY2hvciB7XG4gICAgICAgICAqICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgICAqICAgICB0b3A6IDIwMHB4O1xuICAgICAgICAgKiAgICAgbGVmdDogMjAwcHg7XG4gICAgICAgICAqICB9XG4gICAgICAgICAqIDwvc3R5bGU+XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBfQENvbXBvbmVudCh7XG4gICAgICAgICAqIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgICAgICogdGVtcGxhdGU6IGBcbiAgICAgICAgICogICA8ZGl2IGNsYXNzPVwiZXhhbXBsZS1jb25maWdcIj5cbiAgICAgICAgICogICAgICBQb3NpdGlvbiBtb2RlOlxuICAgICAgICAgKiAgICAgIDxsYWJlbD48aW5wdXQgdHlwZT1cInJhZGlvXCIgdmFsdWU9XCJmaXhlZFwiIFsobmdNb2RlbCldPVwibW9kZVwiIC8+IEZpeGVkPC9sYWJlbD5cbiAgICAgICAgICogICAgICA8bGFiZWw+PGlucHV0IHR5cGU9XCJyYWRpb1wiIHZhbHVlPVwiYWJzb2x1dGVcIiBbKG5nTW9kZWwpXT1cIm1vZGVcIiAvPiBBYnNvbHV0ZTwvbGFiZWw+XG4gICAgICAgICAqICAgPC9kaXY+XG4gICAgICAgICAqICAgPGRpdiBjbGFzcz1cImV4YW1wbGUtY29uZmlnXCI+XG4gICAgICAgICAqICAgICAgIEFwcGVuZCB0b1xuICAgICAgICAgKiAgICAgICA8bGFiZWw+XG4gICAgICAgICAqICAgICAgICAgICA8aW5wdXQgdHlwZT1cInJhZGlvXCIgbmFtZT1cInBsYWNlXCIgW3ZhbHVlXT1cIjFcIiBbKG5nTW9kZWwpXT1cImNoZWNrZWRcIiAvPlxuICAgICAgICAgKiAgICAgICAgICAgUm9vdCBjb21wb25lbnRcbiAgICAgICAgICogICAgICAgPC9sYWJlbD5cbiAgICAgICAgICogICAgICAgPGxhYmVsPlxuICAgICAgICAgKiAgICAgICAgICAgPGlucHV0IHR5cGU9XCJyYWRpb1wiIG5hbWU9XCJwbGFjZVwiIFt2YWx1ZV09XCIyXCIgWyhuZ01vZGVsKV09XCJjaGVja2VkXCIgLz5cbiAgICAgICAgICogICAgICAgICAgIDxzcGFuIHN0eWxlPVwiY29sb3I6IHJlZFwiPlJlZCBDb250YWluZXI8L3NwYW4+XG4gICAgICAgICAqICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAqICAgICAgIDxsYWJlbD5cbiAgICAgICAgICogICAgICAgICAgIDxpbnB1dCB0eXBlPVwicmFkaW9cIiBuYW1lPVwicGxhY2VcIiBbdmFsdWVdPVwiM1wiIFsobmdNb2RlbCldPVwiY2hlY2tlZFwiIC8+XG4gICAgICAgICAqICAgICAgICAgICA8c3BhbiBzdHlsZT1cImNvbG9yOiBibHVlXCI+Qmx1ZSBDb250YWluZXI8L3NwYW4+XG4gICAgICAgICAqICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAqICAgPC9kaXY+XG4gICAgICAgICAqICAgPGRpdiBjbGFzcz1cImV4YW1wbGVcIj5cbiAgICAgICAgICogICAgIDxkaXYgY2xhc3M9XCJwYXJlbnQtY29udGVudFwiIFtzY3JvbGxMZWZ0XT1cIjI1MFwiIFtzY3JvbGxUb3BdPVwiMjMwXCI+XG4gICAgICAgICAqICAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRlbnRcIiBbc2Nyb2xsTGVmdF09XCIxNzBcIiBbc2Nyb2xsVG9wXT1cIjE2NVwiPlxuICAgICAgICAgKiAgICAgICAgICAgPGJ1dHRvbiAjYW5jaG9yIGNsYXNzPVwiYW5jaG9yXCIgKGNsaWNrKT1cInNob3cgPSAhc2hvd1wiPlRvZ2dsZTwvYnV0dG9uPlxuICAgICAgICAgKiAgICAgICAgICAgPGtlbmRvLXBvcHVwIFtwb3NpdGlvbk1vZGVdPVwibW9kZVwiIFthbmNob3JdPVwiYW5jaG9yXCIgKGFuY2hvclZpZXdwb3J0TGVhdmUpPVwic2hvdz1mYWxzZVwiICpuZ0lmPVwic2hvdyAmJiBjaGVja2VkID09PSAzXCI+XG4gICAgICAgICAqICAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICogICAgICAgICAgICAgICAgIDxsaT5JdGVtMTwvbGk+XG4gICAgICAgICAqICAgICAgICAgICAgICAgICA8bGk+SXRlbTI8L2xpPlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgPGxpPkl0ZW0zPC9saT5cbiAgICAgICAgICogICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICogICAgICAgICAgIDwva2VuZG8tcG9wdXA+XG4gICAgICAgICAqICAgICAgICAgICA8c3BhbiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiA0MDBweDsgbGVmdDogNDAwcHhcIj5Cb3R0b20vUmlnaHQ8L3NwYW4+XG4gICAgICAgICAqICAgICAgICAgPC9kaXY+XG4gICAgICAgICAqICAgICAgICAgPGtlbmRvLXBvcHVwIFtwb3NpdGlvbk1vZGVdPVwibW9kZVwiIFthbmNob3JdPVwiYW5jaG9yXCIgKGFuY2hvclZpZXdwb3J0TGVhdmUpPVwic2hvdz1mYWxzZVwiICpuZ0lmPVwic2hvdyAmJiBjaGVja2VkID09PSAyXCI+XG4gICAgICAgICAqICAgICAgICAgICA8dWw+XG4gICAgICAgICAqICAgICAgICAgICAgICAgPGxpPkl0ZW0xPC9saT5cbiAgICAgICAgICogICAgICAgICAgICAgICA8bGk+SXRlbTI8L2xpPlxuICAgICAgICAgKiAgICAgICAgICAgICAgIDxsaT5JdGVtMzwvbGk+XG4gICAgICAgICAqICAgICAgICAgICA8L3VsPlxuICAgICAgICAgKiAgICAgICAgIDwva2VuZG8tcG9wdXA+XG4gICAgICAgICAqICAgICAgICAgPHNwYW4gc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogNjAwcHg7IGxlZnQ6IDYwMHB4XCI+Qm90dG9tL1JpZ2h0PC9zcGFuPlxuICAgICAgICAgKiAgICAgPC9kaXY+XG4gICAgICAgICAqICAgICA8a2VuZG8tcG9wdXAgW3Bvc2l0aW9uTW9kZV09XCJtb2RlXCIgW2FuY2hvcl09XCJhbmNob3JcIiAoYW5jaG9yVmlld3BvcnRMZWF2ZSk9XCJzaG93PWZhbHNlXCIgKm5nSWY9XCJzaG93ICYmIGNoZWNrZWQgPT09IDFcIj5cbiAgICAgICAgICogICAgICAgPHVsPlxuICAgICAgICAgKiAgICAgICAgICAgPGxpPkl0ZW0xPC9saT5cbiAgICAgICAgICogICAgICAgICAgIDxsaT5JdGVtMjwvbGk+XG4gICAgICAgICAqICAgICAgICAgICA8bGk+SXRlbTM8L2xpPlxuICAgICAgICAgKiAgICAgICA8L3VsPlxuICAgICAgICAgKiAgICAgPC9rZW5kby1wb3B1cD5cbiAgICAgICAgICogICA8L2Rpdj5cbiAgICAgICAgICogYFxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICAgICAgICAgKiAgIHB1YmxpYyBjaGVja2VkOiBudW1iZXIgPSAzO1xuICAgICAgICAgKiAgIHB1YmxpYyBtb2RlOiBzdHJpbmcgPSAnYWJzb2x1dGUnO1xuICAgICAgICAgKiAgIHB1YmxpYyBzaG93OiBib29sZWFuID0gdHJ1ZTtcbiAgICAgICAgICogfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucG9zaXRpb25Nb2RlID0gJ2ZpeGVkJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnRcbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBhbGlnbm1lbnRwb3NpdGlvbmluZ19wb3B1cCAlfSN0b2MtYWxpZ25pbmctdG8tYWJzb2x1dGUtcG9pbnRzKSkuXG4gICAgICAgICAqIFRoZSBQb3B1cCBvcGVucyBuZXh0IHRvIHRoYXQgcG9pbnQuIFRoZSBQb3B1cCBwaXZvdCBwb2ludCBpcyBkZWZpbmVkIGJ5IHRoZSBgcG9wdXBBbGlnbmAgY29uZmlndXJhdGlvbiBvcHRpb24uXG4gICAgICAgICAqIFRoZSBib3VuZGFyeSBkZXRlY3Rpb24gaXMgYXBwbGllZCBieSB1c2luZyB0aGUgd2luZG93IHZpZXdwb3J0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vZmZzZXQgPSBERUZBVUxUX09GRlNFVDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGFuY2hvciBpcyBzY3JvbGxlZCBvdXRzaWRlIHRoZSBzY3JlZW4gYm91bmRhcmllcy5cbiAgICAgICAgICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBjbG9zaW5nX3BvcHVwICV9I3RvYy1hZnRlci1sZWF2aW5nLXRoZS12aWV3cG9ydCkpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbmNob3JWaWV3cG9ydExlYXZlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgYWZ0ZXIgdGhlIGNvbXBvbmVudCBpcyBjbG9zZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsb3NlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgYWZ0ZXIgdGhlIGNvbXBvbmVudCBpcyBvcGVuZWQgYW5kIHRoZSBvcGVuaW5nIGFuaW1hdGlvbiBlbmRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcGVuID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgYWZ0ZXIgdGhlIGNvbXBvbmVudCBpcyBvcGVuZWQgYW5kIHRoZSBQb3B1cCBpcyBwb3NpdGlvbmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb3NpdGlvbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5yZXNvbHZlZFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbENoZWNrID0gdHJ1ZTtcbiAgICAgICAgdmFsaWRhdGVQYWNrYWdlKHBhY2thZ2VNZXRhZGF0YSk7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLmFkZENsYXNzKGNvbnRhaW5lci5uYXRpdmVFbGVtZW50LCBBTklNQVRJT05fQ09OVEFJTkVSKTtcbiAgICAgICAgdGhpcy51cGRhdGVGaXhlZENsYXNzKCk7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnJlcG9zaXRpb24gPSB0aGlzLnJlcG9zaXRpb24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcmVzaXplU2VydmljZS5zdWJzY3JpYmUodGhpcy5yZXBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25TdWJzY3JpcHRpb25zID0gdGhpcy5hbmltYXRpb25TZXJ2aWNlLnN0YXJ0LnN1YnNjcmliZSh0aGlzLm9uQW5pbWF0aW9uU3RhcnQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3Vic2NyaXB0aW9ucy5hZGQodGhpcy5hbmltYXRpb25TZXJ2aWNlLmVuZC5zdWJzY3JpYmUodGhpcy5vbkFuaW1hdGlvbkVuZC5iaW5kKHRoaXMpKSk7XG4gICAgICAgIHRoaXMuX3Njcm9sbGFibGVTZXJ2aWNlLmZvckVsZW1lbnQodGhpcy5hbmNob3IgfHwgdGhpcy5jb250YWluZXIpLnN1YnNjcmliZSh0aGlzLm9uU2Nyb2xsLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmN1cnJlbnRPZmZzZXQgPSBERUZBVUxUX09GRlNFVDtcbiAgICAgICAgdGhpcy5zZXRaSW5kZXgoKTtcbiAgICAgICAgdGhpcy5jb3B5Rm9udFN0eWxlcygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUZpeGVkQ2xhc3MoKTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlcy5jb3B5QW5jaG9yU3R5bGVzKSB7XG4gICAgICAgICAgICB0aGlzLmNvcHlGb250U3R5bGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXMucG9zaXRpb25Nb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZpeGVkQ2xhc3MoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMucmVwb3NpdGlvbigpO1xuICAgICAgICBpZiAoIXRoaXMuYW5pbWF0ZSkge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlZFByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkFuaW1hdGlvbkVuZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdBZnRlclZpZXdDaGVja2VkKCkge1xuICAgICAgICBpZiAodGhpcy5pbml0aWFsQ2hlY2spIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbENoZWNrID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAvLyB3b3JrYXJvdW5kcyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8xOTA5NFxuICAgICAgICAgICAgLy8gdXNlcyBwcm9taXNlIGJlY2F1c2UgaXQgaXMgZXhlY3V0ZWQgc3luY2hyb25vdXNseSBhZnRlciB0aGUgY29udGVudCBpcyB1cGRhdGVkXG4gICAgICAgICAgICAvLyBkb2VzIG5vdCB1c2Ugb25TdGFibGUgaW4gY2FzZSB0aGUgY3VycmVudCB6b25lIGlzIG5vdCB0aGUgYW5ndWxhciBvbmUuXG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlUmVwb3NpdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5yZXBvc2l0aW9uU3Vic2NyaXB0aW9uID0gZnJvbSh0aGlzLnJlc29sdmVkUHJvbWlzZSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKHRoaXMucmVwb3NpdGlvbik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5hbmNob3JWaWV3cG9ydExlYXZlLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMucG9zaXRpb25DaGFuZ2UuY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy5jbG9zZS5lbWl0KCk7XG4gICAgICAgIHRoaXMuY2xvc2UuY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy5fcmVzaXplU2VydmljZS51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLl9zY3JvbGxhYmxlU2VydmljZS51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLmFuaW1hdGlvblN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZVJlcG9zaXRpb24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG9uUmVzaXplKCkge1xuICAgICAgICB0aGlzLnJlcG9zaXRpb24oKTtcbiAgICB9XG4gICAgb25BbmltYXRpb25TdGFydCgpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5jb250YWluZXIubmF0aXZlRWxlbWVudCwgJ2stYW5pbWF0aW9uLWNvbnRhaW5lci1zaG93bicpO1xuICAgIH1cbiAgICBvbkFuaW1hdGlvbkVuZCgpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5jb250YWluZXIubmF0aXZlRWxlbWVudCwgJ2stYW5pbWF0aW9uLWNvbnRhaW5lci1zaG93bicpO1xuICAgICAgICB0aGlzLm9wZW4uZW1pdCgpO1xuICAgICAgICB0aGlzLm9wZW4uY29tcGxldGUoKTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50T2Zmc2V0O1xuICAgIH1cbiAgICBzZXQgY3VycmVudE9mZnNldChvZmZzZXQkJDEpIHtcbiAgICAgICAgdGhpcy5zZXRDb250YWluZXJTdHlsZSgnbGVmdCcsIGAke29mZnNldCQkMS5sZWZ0fXB4YCk7XG4gICAgICAgIHRoaXMuc2V0Q29udGFpbmVyU3R5bGUoJ3RvcCcsIGAke29mZnNldCQkMS50b3B9cHhgKTtcbiAgICAgICAgdGhpcy5fY3VycmVudE9mZnNldCA9IG9mZnNldCQkMTtcbiAgICB9XG4gICAgc2V0WkluZGV4KCkge1xuICAgICAgICBpZiAodGhpcy5hbmNob3IpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29udGFpbmVyU3R5bGUoJ3otaW5kZXgnLCBTdHJpbmcodGhpcy5kb21TZXJ2aWNlLnpJbmRleCh0aGlzLmFuY2hvciwgdGhpcy5jb250YWluZXIpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwb3NpdGlvbigpIHtcbiAgICAgICAgaWYgKCFpc0RvY3VtZW50QXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGZsaXAsIG9mZnNldDogb2Zmc2V0JCQxIH0gPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICAgIGlmICghdGhpcy5jdXJyZW50T2Zmc2V0IHx8IGlzRGlmZmVyZW50T2Zmc2V0KHRoaXMuY3VycmVudE9mZnNldCwgb2Zmc2V0JCQxKSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50T2Zmc2V0ID0gb2Zmc2V0JCQxO1xuICAgICAgICAgICAgaWYgKGhhc09ic2VydmVycyh0aGlzLnBvc2l0aW9uQ2hhbmdlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3pvbmUucnVuKCgpID0+IHRoaXMucG9zaXRpb25DaGFuZ2UuZW1pdCh7IG9mZnNldDogb2Zmc2V0JCQxLCBmbGlwIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hbmltYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvblNlcnZpY2UucGxheSh0aGlzLmNvbnRlbnRDb250YWluZXIubmF0aXZlRWxlbWVudCwgdGhpcy5hbmltYXRlLCBmbGlwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc2l6ZVNlbnNvci5hY2NlcHRTaXplKCk7XG4gICAgfVxuICAgIHBvc2l0aW9uKCkge1xuICAgICAgICBjb25zdCBhbGlnbmVkT2Zmc2V0ID0gdGhpcy5fYWxpZ25TZXJ2aWNlLmFsaWduRWxlbWVudCh7XG4gICAgICAgICAgICBhbmNob3I6IHRoaXMuYW5jaG9yLFxuICAgICAgICAgICAgYW5jaG9yQWxpZ246IHRoaXMuYW5jaG9yQWxpZ24sXG4gICAgICAgICAgICBlbGVtZW50OiB0aGlzLmNvbnRhaW5lcixcbiAgICAgICAgICAgIGVsZW1lbnRBbGlnbjogdGhpcy5wb3B1cEFsaWduLFxuICAgICAgICAgICAgbWFyZ2luOiB0aGlzLm1hcmdpbixcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICBwb3NpdGlvbk1vZGU6IHRoaXMucG9zaXRpb25Nb2RlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9zaXRpb25TZXJ2aWNlLnBvc2l0aW9uRWxlbWVudCh7XG4gICAgICAgICAgICBhbmNob3I6IHRoaXMuYW5jaG9yLFxuICAgICAgICAgICAgYW5jaG9yQWxpZ246IHRoaXMuYW5jaG9yQWxpZ24sXG4gICAgICAgICAgICBjb2xsaXNpb25zOiB0aGlzLmNvbGxpc2lvbixcbiAgICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbjogYWxpZ25lZE9mZnNldCxcbiAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMuY29udGFpbmVyLFxuICAgICAgICAgICAgZWxlbWVudEFsaWduOiB0aGlzLnBvcHVwQWxpZ24sXG4gICAgICAgICAgICBtYXJnaW46IHRoaXMubWFyZ2luXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvblNjcm9sbChpc0luVmlld1BvcnQpIHtcbiAgICAgICAgY29uc3QgaGFzTGVhdmVPYnNlcnZlcnMgPSBoYXNPYnNlcnZlcnModGhpcy5hbmNob3JWaWV3cG9ydExlYXZlKTtcbiAgICAgICAgaWYgKGlzSW5WaWV3UG9ydCB8fCAhaGFzTGVhdmVPYnNlcnZlcnMpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3NpdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhc0xlYXZlT2JzZXJ2ZXJzKSB7XG4gICAgICAgICAgICB0aGlzLl96b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmNob3JWaWV3cG9ydExlYXZlLmVtaXQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvcHlGb250U3R5bGVzKCkge1xuICAgICAgICBpZiAoIXRoaXMuYW5jaG9yIHx8ICF0aGlzLmNvcHlBbmNob3JTdHlsZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvbVNlcnZpY2UuZ2V0Rm9udFN0eWxlcyh0aGlzLmFuY2hvcilcbiAgICAgICAgICAgIC5mb3JFYWNoKHMgPT4gdGhpcy5zZXRDb250YWluZXJTdHlsZShzLmtleSwgcy52YWx1ZSkpO1xuICAgIH1cbiAgICB1cGRhdGVGaXhlZENsYXNzKCkge1xuICAgICAgICBjb25zdCBhY3Rpb24gPSB0aGlzLnBvc2l0aW9uTW9kZSA9PT0gJ2ZpeGVkJyA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnO1xuICAgICAgICB0aGlzLl9yZW5kZXJlclthY3Rpb25dKHRoaXMuY29udGFpbmVyLm5hdGl2ZUVsZW1lbnQsIEFOSU1BVElPTl9DT05UQUlORVJfRklYRUQpO1xuICAgIH1cbiAgICBzZXRDb250YWluZXJTdHlsZShuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmNvbnRhaW5lci5uYXRpdmVFbGVtZW50LCBuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlUmVwb3NpdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMucmVwb3NpdGlvblN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5yZXBvc2l0aW9uU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgUG9wdXBDb21wb25lbnQucHJvdG90eXBlLCBcImFuaW1hdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEVsZW1lbnRSZWYpXG5dLCBQb3B1cENvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5jaG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBQb3B1cENvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5jaG9yQWxpZ25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFBvcHVwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xsaXNpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFBvcHVwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwb3B1cEFsaWduXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgUG9wdXBDb21wb25lbnQucHJvdG90eXBlLCBcImNvcHlBbmNob3JTdHlsZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFBvcHVwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwb3B1cENsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBQb3B1cENvbXBvbmVudC5wcm90b3R5cGUsIFwicG9zaXRpb25Nb2RlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBQb3B1cENvbXBvbmVudC5wcm90b3R5cGUsIFwib2Zmc2V0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBQb3B1cENvbXBvbmVudC5wcm90b3R5cGUsIFwibWFyZ2luXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgUG9wdXBDb21wb25lbnQucHJvdG90eXBlLCBcImFuY2hvclZpZXdwb3J0TGVhdmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBQb3B1cENvbXBvbmVudC5wcm90b3R5cGUsIFwiY2xvc2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBQb3B1cENvbXBvbmVudC5wcm90b3R5cGUsIFwib3BlblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFBvcHVwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwb3NpdGlvbkNoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKCdjb250YWluZXInLCB7IHN0YXRpYzogdHJ1ZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRWxlbWVudFJlZilcbl0sIFBvcHVwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb250ZW50Q29udGFpbmVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoUmVzaXplU2Vuc29yQ29tcG9uZW50LCB7IHN0YXRpYzogdHJ1ZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUmVzaXplU2Vuc29yQ29tcG9uZW50KVxuXSwgUG9wdXBDb21wb25lbnQucHJvdG90eXBlLCBcInJlc2l6ZVNlbnNvclwiLCB2b2lkIDApO1xuUG9wdXBDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBleHBvcnRBczogJ2tlbmRvLXBvcHVwJyxcbiAgICAgICAgcHJvdmlkZXJzOiBbQWxpZ25TZXJ2aWNlLCBBbmltYXRpb25TZXJ2aWNlLCBET01TZXJ2aWNlLCBQb3NpdGlvblNlcnZpY2UsIFJlc2l6ZVNlcnZpY2UsIFNjcm9sbGFibGVTZXJ2aWNlXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1wb3B1cCcsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJrLXBvcHVwXCIgW25nQ2xhc3NdPVwicG9wdXBDbGFzc1wiICNjb250YWluZXI+XG4gICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nVGVtcGxhdGVPdXRsZXRdPVwiY29udGVudFwiIFtuZ0lmXT1cImNvbnRlbnRcIj48L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgPGtlbmRvLXJlc2l6ZS1zZW5zb3IgW3JhdGVMaW1pdF09XCIxMDBcIiAocmVzaXplKT1cIm9uUmVzaXplKClcIj5cbiAgICAgICAgICAgIDwva2VuZG8tcmVzaXplLXNlbnNvcj5cbiAgICAgICAgPC9kaXY+XG4gICAgIGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsXG4gICAgICAgIEFsaWduU2VydmljZSxcbiAgICAgICAgRE9NU2VydmljZSxcbiAgICAgICAgUG9zaXRpb25TZXJ2aWNlLFxuICAgICAgICBSZXNpemVTZXJ2aWNlLFxuICAgICAgICBTY3JvbGxhYmxlU2VydmljZSxcbiAgICAgICAgQW5pbWF0aW9uU2VydmljZSxcbiAgICAgICAgUmVuZGVyZXIyLFxuICAgICAgICBOZ1pvbmVdKVxuXSwgUG9wdXBDb21wb25lbnQpO1xuXG5jb25zdCByZW1vdmVFbGVtZW50ID0gKGVsZW1lbnQpID0+IHtcbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICAgIH1cbn07XG4vKipcbiAqIFVzZWQgdG8gaW5qZWN0IHRoZSBQb3B1cCBjb250YWluZXIuIElmIG5vdCBwcm92aWRlZCwgdGhlIGZpcnN0IHJvb3QgY29tcG9uZW50IG9mXG4gKiB0aGUgYXBwbGljYXRpb24gaXMgdXNlZC5cbiAqXG4gKiA+IFRoZSBgUE9QVVBfQ09OVEFJTkVSYCBjYW4gYmUgdXNlZCBvbmx5IHdpdGggdGhlIFtgUG9wdXBTZXJ2aWNlYF0oeyUgc2x1ZyBzZXJ2aWNlX3BvcHVwICV9KSBjbGFzcy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzLW5vLXJ1blxuICogLy8gSW1wb3J0IHRoZSBQb3B1cCBtb2R1bGVcbiAqIGltcG9ydCB7IFBvcHVwTW9kdWxlLCBQT1BVUF9DT05UQUlORVIgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1wb3B1cCc7XG4gKlxuICogLy8gVGhlIGJyb3dzZXIgcGxhdGZvcm0gd2l0aCBhIGNvbXBpbGVyXG4gKiBpbXBvcnQgeyBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljJztcbiAqXG4gKiBpbXBvcnQgeyBFbGVtZW50UmVmLCBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICpcbiAqIC8vIEltcG9ydCB0aGUgYXBwIGNvbXBvbmVudFxuICogaW1wb3J0IHsgQXBwQ29tcG9uZW50IH0gZnJvbSAnLi9hcHAuY29tcG9uZW50JztcbiAqXG4gKiAvLyBEZWZpbmUgdGhlIGFwcCBtb2R1bGVcbiAqIF9ATmdNb2R1bGUoe1xuICogICAgIGRlY2xhcmF0aW9uczogW0FwcENvbXBvbmVudF0sIC8vIGRlY2xhcmUgYXBwIGNvbXBvbmVudFxuICogICAgIGltcG9ydHM6ICAgICAgW0Jyb3dzZXJNb2R1bGUsIFBvcHVwTW9kdWxlXSwgLy8gaW1wb3J0IFBvcHVwIG1vZHVsZVxuICogICAgIGJvb3RzdHJhcDogICAgW0FwcENvbXBvbmVudF0sXG4gKiAgICAgcHJvdmlkZXJzOiBbe1xuICogICAgICAgcHJvdmlkZTogUE9QVVBfQ09OVEFJTkVSLFxuICogICAgICAgdXNlRmFjdG9yeTogKCkgPT4ge1xuICogICAgICAgICAgLy9yZXR1cm4gdGhlIGNvbnRhaW5lciBFbGVtZW50UmVmLCB3aGVyZSB0aGUgcG9wdXAgd2lsbCBiZSBpbmplY3RlZFxuICogICAgICAgICAgcmV0dXJuIHsgbmF0aXZlRWxlbWVudDogZG9jdW1lbnQuYm9keSB9IGFzIEVsZW1lbnRSZWY7XG4gKiAgICAgICB9XG4gKiAgICAgfV1cbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwTW9kdWxlIHt9XG4gKlxuICogLy8gQ29tcGlsZSBhbmQgbGF1bmNoIHRoZSBtb2R1bGVcbiAqIHBsYXRmb3JtQnJvd3NlckR5bmFtaWMoKS5ib290c3RyYXBNb2R1bGUoQXBwTW9kdWxlKTtcbiAqIGBgYFxuICovXG5jb25zdCBQT1BVUF9DT05UQUlORVIgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ1BvcHVwIENvbnRhaW5lcicpO1xuLyoqXG4gKiBBIHNlcnZpY2UgZm9yIG9wZW5pbmcgUG9wdXAgY29tcG9uZW50cyBkeW5hbWljYWxseVxuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBzZXJ2aWNlX3BvcHVwICV9KSkuXG4gKlxuICogQGV4cG9ydFxuICogQGNsYXNzIFBvcHVwU2VydmljZVxuICovXG5sZXQgUG9wdXBTZXJ2aWNlID0gY2xhc3MgUG9wdXBTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHBsaWNhdGlvblJlZiwgY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBpbmplY3RvciwgY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuYXBwbGljYXRpb25SZWYgPSBhcHBsaWNhdGlvblJlZjtcbiAgICAgICAgdGhpcy5jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgPSBjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHJvb3QgdmlldyBjb250YWluZXIgaW50byB3aGljaCB0aGUgY29tcG9uZW50IHdpbGwgYmUgaW5qZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29tcG9uZW50UmVmPGFueT59XG4gICAgICovXG4gICAgZ2V0IHJvb3RWaWV3Q29udGFpbmVyKCkge1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2Jsb2IvNC4wLngvcGFja2FnZXMvY29yZS9zcmMvYXBwbGljYXRpb25fcmVmLnRzI0w1NzFcbiAgICAgICAgY29uc3Qgcm9vdENvbXBvbmVudHMgPSB0aGlzLmFwcGxpY2F0aW9uUmVmLmNvbXBvbmVudHMgfHwgW107XG4gICAgICAgIGlmIChyb290Q29tcG9uZW50c1swXSkge1xuICAgICAgICAgICAgcmV0dXJuIHJvb3RDb21wb25lbnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgXG4gICAgICAgICAgICBWaWV3IENvbnRhaW5lciBub3QgZm91bmQhIEluamVjdCB0aGUgUE9QVVBfQ09OVEFJTkVSIG9yIGRlZmluZSBhIHNwZWNpZmljIFZpZXdDb250YWluZXJSZWYgdmlhIHRoZSBhcHBlbmRUbyBvcHRpb24uXG4gICAgICAgICAgICBTZWUgaHR0cDovL3d3dy50ZWxlcmlrLmNvbS9rZW5kby1hbmd1bGFyLXVpL2NvbXBvbmVudHMvcG9wdXAvYXBpL1BPUFVQX0NPTlRBSU5FUi8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgb3IgZ2V0cyB0aGUgSFRNTCBlbGVtZW50IG9mIHRoZSByb290IGNvbXBvbmVudCBjb250YWluZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgZ2V0IHJvb3RWaWV3Q29udGFpbmVyTm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyID8gdGhpcy5jb250YWluZXIubmF0aXZlRWxlbWVudCA6IHRoaXMuZ2V0Q29tcG9uZW50Um9vdE5vZGUodGhpcy5yb290Vmlld0NvbnRhaW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW5zIGEgUG9wdXAgY29tcG9uZW50LiBDcmVhdGVkIFBvcHVwcyBhcmUgbW91bnRlZFxuICAgICAqIGluIHRoZSBET00gZGlyZWN0bHkgaW4gdGhlIHJvb3QgYXBwbGljYXRpb24gY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQb3B1cFNldHRpbmdzfSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgd2hpY2ggZGVmaW5lIHRoZSBQb3B1cC5cbiAgICAgKiBAcmV0dXJucyB7Q29tcG9uZW50UmVmPFBvcHVwQ29tcG9uZW50Pn0gLSBBIHJlZmVyZW5jZSB0byB0aGUgUG9wdXAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYHRzLW5vLXJ1blxuICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgKiAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgKiAgIHRlbXBsYXRlOiBgXG4gICAgICogICAgIDxuZy10ZW1wbGF0ZSAjdGVtcGxhdGU+XG4gICAgICogICAgICBQb3B1cCBjb250ZW50XG4gICAgICogICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICogICAgIDxidXR0b24gI2FuY2hvciBrZW5kb0J1dHRvbiAoY2xpY2spPVwib3BlbihhbmNob3IsIHRlbXBsYXRlKVwiPk9wZW48L2J1dHRvbj5cbiAgICAgKiAgIGBcbiAgICAgKiB9KVxuICAgICAqIGV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQge1xuICAgICAqICAgICBwdWJsaWMgcG9wdXBSZWY6IFBvcHVwUmVmO1xuICAgICAqXG4gICAgICogICAgIGNvbnN0cnVjdG9yKCBwcml2YXRlIHBvcHVwU2VydmljZTogUG9wdXBTZXJ2aWNlICkge31cbiAgICAgKlxuICAgICAqICAgICBwdWJsaWMgb3BlbihhbmNob3I6IEVsZW1lbnRSZWYsIHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+KTogdm9pZCB7XG4gICAgICogICAgICAgICBpZiAodGhpcy5wb3B1cFJlZikge1xuICAgICAqICAgICAgICAgICAgICB0aGlzLnBvcHVwUmVmLmNsb3NlKCk7XG4gICAgICogICAgICAgICAgICAgIHRoaXMucG9wdXBSZWYgPSBudWxsO1xuICAgICAqICAgICAgICAgICAgICByZXR1cm47XG4gICAgICogICAgICAgICB9XG4gICAgICpcbiAgICAgKiAgICAgICAgIHRoaXMucG9wdXBSZWYgPSB0aGlzLnBvcHVwU2VydmljZS5vcGVuKHtcbiAgICAgKiAgICAgICAgICAgYW5jaG9yOiBhbmNob3IsXG4gICAgICogICAgICAgICAgIGNvbnRlbnQ6IHRlbXBsYXRlXG4gICAgICogICAgICAgICB9KTtcbiAgICAgKiAgICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBvcGVuKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IGNvbXBvbmVudCwgbm9kZXMgfSA9IHRoaXMuY29udGVudEZyb20ob3B0aW9ucy5jb250ZW50KTtcbiAgICAgICAgY29uc3QgcG9wdXBDb21wb25lbnRSZWYgPSB0aGlzLmFwcGVuZFBvcHVwKG5vZGVzLCBvcHRpb25zLmFwcGVuZFRvKTtcbiAgICAgICAgY29uc3QgcG9wdXBJbnN0YW5jZSA9IHBvcHVwQ29tcG9uZW50UmVmLmluc3RhbmNlO1xuICAgICAgICB0aGlzLnByb2plY3RDb21wb25lbnRJbnB1dHMocG9wdXBDb21wb25lbnRSZWYsIG9wdGlvbnMpO1xuICAgICAgICBwb3B1cENvbXBvbmVudFJlZi5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudC5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9wdXBFbGVtZW50ID0gdGhpcy5nZXRDb21wb25lbnRSb290Tm9kZShwb3B1cENvbXBvbmVudFJlZik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9wdXBDb21wb25lbnRSZWYuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIC8vIEFuZ3VsYXIgd2lsbCBub3QgcmVtb3ZlIHRoZSBlbGVtZW50IHVubGVzcyB0aGUgY2hhbmdlIGRldGVjdGlvbiBpcyB0cmlnZ2VyZWRcbiAgICAgICAgICAgICAgICByZW1vdmVFbGVtZW50KHBvcHVwRWxlbWVudCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udGVudDogY29tcG9uZW50LFxuICAgICAgICAgICAgcG9wdXA6IHBvcHVwQ29tcG9uZW50UmVmLFxuICAgICAgICAgICAgcG9wdXBBbmNob3JWaWV3cG9ydExlYXZlOiBwb3B1cEluc3RhbmNlLmFuY2hvclZpZXdwb3J0TGVhdmUsXG4gICAgICAgICAgICBwb3B1cENsb3NlOiBwb3B1cEluc3RhbmNlLmNsb3NlLFxuICAgICAgICAgICAgcG9wdXBFbGVtZW50OiBwb3B1cEVsZW1lbnQsXG4gICAgICAgICAgICBwb3B1cE9wZW46IHBvcHVwSW5zdGFuY2Uub3BlbixcbiAgICAgICAgICAgIHBvcHVwUG9zaXRpb25DaGFuZ2U6IHBvcHVwSW5zdGFuY2UucG9zaXRpb25DaGFuZ2VcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXBwZW5kUG9wdXAobm9kZXMsIGNvbnRhaW5lcikge1xuICAgICAgICBjb25zdCBwb3B1cENvbXBvbmVudFJlZiA9IHRoaXMuY3JlYXRlQ29tcG9uZW50KFBvcHVwQ29tcG9uZW50LCBub2RlcywgY29udGFpbmVyKTtcbiAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdFZpZXdDb250YWluZXJOb2RlLmFwcGVuZENoaWxkKHRoaXMuZ2V0Q29tcG9uZW50Um9vdE5vZGUocG9wdXBDb21wb25lbnRSZWYpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9wdXBDb21wb25lbnRSZWY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIEhUTUwgZWxlbWVudCBmb3IgYSBjb21wb25lbnQgcmVmZXJlbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDb21wb25lbnRSZWY8YW55Pn0gY29tcG9uZW50UmVmXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIGdldENvbXBvbmVudFJvb3ROb2RlKGNvbXBvbmVudFJlZikge1xuICAgICAgICByZXR1cm4gY29tcG9uZW50UmVmLmxvY2F0aW9uLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGBDb21wb25lbnRGYWN0b3J5YCBpbnN0YW5jZSBieSBpdHMgdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gY29tcG9uZW50Q2xhc3NcbiAgICAgKiBAcGFyYW0geyp9IG5vZGVzXG4gICAgICogQHJldHVybnMge0NvbXBvbmVudFJlZjxhbnk+fVxuICAgICAqL1xuICAgIGdldENvbXBvbmVudEZhY3RvcnkoY29tcG9uZW50Q2xhc3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KGNvbXBvbmVudENsYXNzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNvbXBvbmVudCByZWZlcmVuY2UgZnJvbSBhIGBDb21wb25lbnRgIHR5cGUgY2xhc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IGNvbXBvbmVudENsYXNzXG4gICAgICogQHBhcmFtIHsqfSBub2Rlc1xuICAgICAqIEByZXR1cm5zIHtDb21wb25lbnRSZWY8YW55Pn1cbiAgICAgKi9cbiAgICBjcmVhdGVDb21wb25lbnQoY29tcG9uZW50Q2xhc3MsIG5vZGVzLCBjb250YWluZXIpIHtcbiAgICAgICAgY29uc3QgZmFjdG9yeSA9IHRoaXMuZ2V0Q29tcG9uZW50RmFjdG9yeShjb21wb25lbnRDbGFzcyk7XG4gICAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250YWluZXIuY3JlYXRlQ29tcG9uZW50KGZhY3RvcnksIHVuZGVmaW5lZCwgdGhpcy5pbmplY3Rvciwgbm9kZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gZmFjdG9yeS5jcmVhdGUodGhpcy5pbmplY3Rvciwgbm9kZXMpO1xuICAgICAgICAgICAgdGhpcy5hcHBsaWNhdGlvblJlZi5hdHRhY2hWaWV3KGNvbXBvbmVudC5ob3N0Vmlldyk7XG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2plY3RzIHRoZSBpbnB1dHMgb24gdGhlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q29tcG9uZW50UmVmPGFueT59IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7Kn0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtDb21wb25lbnRSZWY8YW55Pn1cbiAgICAgKi9cbiAgICBwcm9qZWN0Q29tcG9uZW50SW5wdXRzKGNvbXBvbmVudCwgb3B0aW9ucykge1xuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvcHRpb25zKVxuICAgICAgICAgICAgLmZpbHRlcihwcm9wID0+IHByb3AgIT09ICdjb250ZW50JyB8fCBvcHRpb25zLmNvbnRlbnQgaW5zdGFuY2VvZiBUZW1wbGF0ZVJlZilcbiAgICAgICAgICAgIC5tYXAoKHByb3ApID0+IHtcbiAgICAgICAgICAgIGNvbXBvbmVudC5pbnN0YW5jZVtwcm9wXSA9IG9wdGlvbnNbcHJvcF07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29tcG9uZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjb21wb25lbnQgYW5kIHRoZSBub2RlcyB0byBhcHBlbmQgZnJvbSB0aGUgYGNvbnRlbnRgIG9wdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gY29udGVudFxuICAgICAqIEByZXR1cm5zIHthbnl9XG4gICAgICovXG4gICAgY29udGVudEZyb20oY29udGVudCkge1xuICAgICAgICBpZiAoIWNvbnRlbnQgfHwgY29udGVudCBpbnN0YW5jZW9mIFRlbXBsYXRlUmVmKSB7XG4gICAgICAgICAgICByZXR1cm4geyBjb21wb25lbnQ6IG51bGwsIG5vZGVzOiBbW11dIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gdGhpcy5jcmVhdGVDb21wb25lbnQoY29udGVudCk7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gY29tcG9uZW50ID8gW2NvbXBvbmVudC5sb2NhdGlvbi5uYXRpdmVFbGVtZW50XSA6IFtdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29tcG9uZW50OiBjb21wb25lbnQsXG4gICAgICAgICAgICBub2RlczogW1xuICAgICAgICAgICAgICAgIG5vZGVzIC8vIDxuZy1jb250ZW50PlxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgIH1cbn07XG5Qb3B1cFNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKCksXG4gICAgX19wYXJhbSgzLCBJbmplY3QoUE9QVVBfQ09OVEFJTkVSKSksIF9fcGFyYW0oMywgT3B0aW9uYWwoKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtBcHBsaWNhdGlvblJlZixcbiAgICAgICAgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICAgICAgICBJbmplY3RvcixcbiAgICAgICAgRWxlbWVudFJlZl0pXG5dLCBQb3B1cFNlcnZpY2UpO1xuXG5jb25zdCBQT1BVUF9ESVJFQ1RJVkVTID0gW1BvcHVwQ29tcG9uZW50XTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgW05nTW9kdWxlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyduZ21vZHVsZWFwaSddIH19KVxuICogZGVmaW5pdGlvbiBmb3IgdGhlIFBvcHVwIGNvbXBvbmVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzLW5vLXJ1blxuICogLy8gSW1wb3J0IHRoZSBQb3B1cCBtb2R1bGVcbiAqIGltcG9ydCB7IFBvcHVwTW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItcG9wdXAnO1xuICpcbiAqIC8vIFRoZSBicm93c2VyIHBsYXRmb3JtIHdpdGggYSBjb21waWxlclxuICogaW1wb3J0IHsgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYyc7XG4gKlxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiAvLyBJbXBvcnQgdGhlIGFwcCBjb21wb25lbnRcbiAqIGltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG4gKlxuICogLy8gRGVmaW5lIHRoZSBhcHAgbW9kdWxlXG4gKiBfQE5nTW9kdWxlKHtcbiAqICAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLCAvLyBkZWNsYXJlIGFwcCBjb21wb25lbnRcbiAqICAgICBpbXBvcnRzOiAgICAgIFtCcm93c2VyTW9kdWxlLCBQb3B1cE1vZHVsZV0sIC8vIGltcG9ydCBQb3B1cCBtb2R1bGVcbiAqICAgICBib290c3RyYXA6ICAgIFtBcHBDb21wb25lbnRdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7fVxuICpcbiAqIC8vIENvbXBpbGUgYW5kIGxhdW5jaCB0aGUgbW9kdWxlXG4gKiBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSk7XG4gKlxuICogYGBgXG4gKi9cbmxldCBQb3B1cE1vZHVsZSA9IGNsYXNzIFBvcHVwTW9kdWxlIHtcbn07XG5Qb3B1cE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbUE9QVVBfRElSRUNUSVZFU10sXG4gICAgICAgIGVudHJ5Q29tcG9uZW50czogW1BPUFVQX0RJUkVDVElWRVNdLFxuICAgICAgICBleHBvcnRzOiBbUE9QVVBfRElSRUNUSVZFU10sXG4gICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIFJlc2l6ZVNlbnNvck1vZHVsZV0sXG4gICAgICAgIHByb3ZpZGVyczogW1BvcHVwU2VydmljZV1cbiAgICB9KVxuXSwgUG9wdXBNb2R1bGUpO1xuXG4vKipcbiAqIEdlbmVyYXRlZCBidW5kbGUgaW5kZXguIERvIG5vdCBlZGl0LlxuICovXG5cbmV4cG9ydCB7IEFsaWduU2VydmljZSwgQW5pbWF0aW9uU2VydmljZSwgRE9NU2VydmljZSwgUG9zaXRpb25TZXJ2aWNlLCBSZXNpemVTZXJ2aWNlLCBTY3JvbGxhYmxlU2VydmljZSwgUG9wdXBTZXJ2aWNlLCBQT1BVUF9DT05UQUlORVIsIFBvcHVwQ29tcG9uZW50LCBQb3B1cE1vZHVsZSwgU0NBTEUgfTtcbiJdfQ==\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/skip.js\nvar operators_skip = __webpack_require__(\"zP0r\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/map.js\nvar operators_map = __webpack_require__(\"lJxs\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-angular-l10n/__ivy_ngcc__/dist/fesm2015/index.js\n/**-----------------------------------------------------------------------------------------\n* Copyright © 2020 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\n\n\n\n\n/* tslint:disable:max-line-length */\n/**\n * A base class for a service that returns localized messages.\n *\n * For more information, refer to the section on [using the message service]({% slug messages_l10n %}#toc-using-the-message-service).\n */\n\nlet fesm2015_MessageService = /*@__PURE__*/ (() => {\n    let MessageService = class MessageService {\n        /* tslint:disable:max-line-length */\n        /**\n         * A base class for a service that returns localized messages.\n         *\n         * For more information, refer to the section on [using the message service]({% slug messages_l10n %}#toc-using-the-message-service).\n         */\n        constructor() {\n            /**\n             * @hidden\n             */\n            this.changes = new Subject[\"a\" /* Subject */]();\n        }\n        /**\n         * Notifies the components that the messages were changed.\n         *\n         * @param rtl - (Optional) A new value for the [text direction token]({% slug api_l10n_rtl %}).\n         */\n        notify(rtl) {\n            this.changes.next({ rtl });\n        }\n        /**\n         * Returns a localized message for the supplied key.\n         *\n         * @param key - The message key. For example, `\"kendo.grid.noRecords\"`.\n         * @return - The localized message for this key or `undefined` if not found.\n         */\n        get(key) {\n            return undefined;\n        }\n    };\n    MessageService.ɵfac = function MessageService_Factory(t) { return new (t || MessageService)(); };\n    MessageService.ɵprov = core[\"Lb\" /* ɵɵdefineInjectable */]({ token: MessageService, factory: function (t) { return MessageService.ɵfac(t); } });\n    return MessageService;\n})();\nlet fesm2015_ComponentMessages = /*@__PURE__*/ (() => {\n    class ComponentMessages {\n        get override() {\n            return false;\n        }\n        ngOnChanges(changes) {\n            this.register(changes);\n            if (Object.keys(changes).some(field => !changes[field].isFirstChange())) {\n                this.service.notifyChanges();\n            }\n        }\n        ngOnInit() {\n            this.subscription = this.service.changes.pipe(Object(operators_skip[\"a\" /* skip */])(1)).subscribe(() => this.register(this));\n        }\n        register(changes) {\n            const keys = Object.keys(changes);\n            keys.forEach(key => this.service.register(key, this[key], this.override));\n        }\n        ngOnDestroy() {\n            if (this.subscription) {\n                this.subscription.unsubscribe();\n            }\n        }\n    }\n    ComponentMessages.ɵfac = function ComponentMessages_Factory(t) { return new (t || ComponentMessages)(); };\n    ComponentMessages.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: ComponentMessages, features: [core[\"Ab\" /* ɵɵNgOnChangesFeature */]] });\n    return ComponentMessages;\n})();\n/**\n * A token that specifies the text direction of Kendo UI for Angular components.\n *\n * @example\n * {% embed_file rtl/app.module.ts preview %}\n * {% embed_file rtl/app.component.ts %}\n * {% embed_file shared/main.ts hidden %}\n *\n */\nconst RTL = new core[\"s\" /* InjectionToken */](\"Kendo UI Right-to-Left token\");\n/**\n * Localization prefix for the component messages.\n *\n * For internal use.\n * @hidden\n */\nconst L10N_PREFIX = new core[\"s\" /* InjectionToken */]('Localization key prefix');\nlet fesm2015_LocalizationService = /*@__PURE__*/ (() => {\n    /**\n     * Component localization service.\n     *\n     * For internal use.\n     * @hidden\n     */\n    let LocalizationService = class LocalizationService {\n        constructor(prefix, messageService, _rtl) {\n            this.prefix = prefix;\n            this.messageService = messageService;\n            this._rtl = _rtl;\n            this.changes = new BehaviorSubject[\"a\" /* BehaviorSubject */]({ rtl: this._rtl });\n            this.dictionary = {};\n            if (messageService) {\n                this.subscription = messageService.changes\n                    .pipe(Object(operators_map[\"a\" /* map */])(({ rtl }) => rtl !== undefined ? rtl : this._rtl), Object(tap[\"a\" /* tap */])(rtl => this._rtl = rtl))\n                    .subscribe(rtl => {\n                    this.dictionary = {};\n                    this.changes.next({ rtl });\n                });\n            }\n        }\n        get rtl() {\n            return this._rtl;\n        }\n        ngOnDestroy() {\n            if (this.subscription) {\n                this.subscription.unsubscribe();\n            }\n        }\n        get(shortKey) {\n            const key = this.key(shortKey);\n            return this.dictionary[key];\n        }\n        register(shortKey, value, override = false) {\n            const key = this.key(shortKey);\n            let message = value;\n            if (!override) {\n                if (this.dictionary.hasOwnProperty(key)) {\n                    return;\n                }\n                message = this.defaultValue(key, value);\n            }\n            this.dictionary[key] = message;\n        }\n        notifyChanges() {\n            this.changes.next({ rtl: this.rtl });\n        }\n        key(shortKey) {\n            return this.prefix + '.' + shortKey;\n        }\n        defaultValue(key, value) {\n            if (!this.messageService) {\n                return value;\n            }\n            const alt = this.messageService.get(key);\n            return (alt === undefined) ? value : alt;\n        }\n    };\n    LocalizationService.ɵfac = function LocalizationService_Factory(t) { return new (t || LocalizationService)(core[\"cc\" /* ɵɵinject */](L10N_PREFIX), core[\"cc\" /* ɵɵinject */](fesm2015_MessageService, 8), core[\"cc\" /* ɵɵinject */](RTL, 8)); };\n    LocalizationService.ɵprov = core[\"Lb\" /* ɵɵdefineInjectable */]({ token: LocalizationService, factory: function (t) { return LocalizationService.ɵfac(t); } });\n    LocalizationService = __decorate([__param(0, Object(core[\"q\" /* Inject */])(L10N_PREFIX)),\n        __param(1, Object(core[\"C\" /* Optional */])()),\n        __param(2, Object(core[\"C\" /* Optional */])()), __param(2, Object(core[\"q\" /* Inject */])(RTL)),\n        __metadata(\"design:paramtypes\", [String, fesm2015_MessageService, Boolean])\n    ], LocalizationService);\n    return LocalizationService;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7c0lBR21CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7d0hBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3FKQUFFO0FBQ0Ysa0NBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7a0NBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIENvcHlyaWdodCDCqSAyMDIwIFByb2dyZXNzIFNvZnR3YXJlIENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciBjb21tZXJjaWFsIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IF9fZGVjb3JhdGUsIF9fcGFyYW0sIF9fbWV0YWRhdGEgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3Rpb25Ub2tlbiwgSW5qZWN0LCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCwgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBza2lwLCBtYXAsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIEEgYmFzZSBjbGFzcyBmb3IgYSBzZXJ2aWNlIHRoYXQgcmV0dXJucyBsb2NhbGl6ZWQgbWVzc2FnZXMuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIHRoZSBzZWN0aW9uIG9uIFt1c2luZyB0aGUgbWVzc2FnZSBzZXJ2aWNlXSh7JSBzbHVnIG1lc3NhZ2VzX2wxMG4gJX0jdG9jLXVzaW5nLXRoZS1tZXNzYWdlLXNlcnZpY2UpLlxuICovXG5sZXQgTWVzc2FnZVNlcnZpY2UgPSBjbGFzcyBNZXNzYWdlU2VydmljZSB7XG4gICAgLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4gICAgLyoqXG4gICAgICogQSBiYXNlIGNsYXNzIGZvciBhIHNlcnZpY2UgdGhhdCByZXR1cm5zIGxvY2FsaXplZCBtZXNzYWdlcy5cbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgc2VjdGlvbiBvbiBbdXNpbmcgdGhlIG1lc3NhZ2Ugc2VydmljZV0oeyUgc2x1ZyBtZXNzYWdlc19sMTBuICV9I3RvYy11c2luZy10aGUtbWVzc2FnZS1zZXJ2aWNlKS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IG5ldyBTdWJqZWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vdGlmaWVzIHRoZSBjb21wb25lbnRzIHRoYXQgdGhlIG1lc3NhZ2VzIHdlcmUgY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBydGwgLSAoT3B0aW9uYWwpIEEgbmV3IHZhbHVlIGZvciB0aGUgW3RleHQgZGlyZWN0aW9uIHRva2VuXSh7JSBzbHVnIGFwaV9sMTBuX3J0bCAlfSkuXG4gICAgICovXG4gICAgbm90aWZ5KHJ0bCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMubmV4dCh7IHJ0bCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxvY2FsaXplZCBtZXNzYWdlIGZvciB0aGUgc3VwcGxpZWQga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGtleSAtIFRoZSBtZXNzYWdlIGtleS4gRm9yIGV4YW1wbGUsIGBcImtlbmRvLmdyaWQubm9SZWNvcmRzXCJgLlxuICAgICAqIEByZXR1cm4gLSBUaGUgbG9jYWxpemVkIG1lc3NhZ2UgZm9yIHRoaXMga2V5IG9yIGB1bmRlZmluZWRgIGlmIG5vdCBmb3VuZC5cbiAgICAgKi9cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufTtcbk1lc3NhZ2VTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpXG5dLCBNZXNzYWdlU2VydmljZSk7XG5cbi8qKlxuICogQmFzZSBjbGFzcyB0aGF0IGFjdHMgYXMgYSBjb21wb25lbnQgbWVzc2FnZXMgY29udGFpbmVyLlxuICpcbiAqIEZvciBpbnRlcm5hbCB1c2UuXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIENvbXBvbmVudE1lc3NhZ2VzIHtcbiAgICBnZXQgb3ZlcnJpZGUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKGNoYW5nZXMpO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMoY2hhbmdlcykuc29tZShmaWVsZCA9PiAhY2hhbmdlc1tmaWVsZF0uaXNGaXJzdENoYW5nZSgpKSkge1xuICAgICAgICAgICAgdGhpcy5zZXJ2aWNlLm5vdGlmeUNoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLnNlcnZpY2UuY2hhbmdlcy5waXBlKHNraXAoMSkpLnN1YnNjcmliZSgoKSA9PiB0aGlzLnJlZ2lzdGVyKHRoaXMpKTtcbiAgICB9XG4gICAgcmVnaXN0ZXIoY2hhbmdlcykge1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoY2hhbmdlcyk7XG4gICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gdGhpcy5zZXJ2aWNlLnJlZ2lzdGVyKGtleSwgdGhpc1trZXldLCB0aGlzLm92ZXJyaWRlKSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQSB0b2tlbiB0aGF0IHNwZWNpZmllcyB0aGUgdGV4dCBkaXJlY3Rpb24gb2YgS2VuZG8gVUkgZm9yIEFuZ3VsYXIgY29tcG9uZW50cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogeyUgZW1iZWRfZmlsZSBydGwvYXBwLm1vZHVsZS50cyBwcmV2aWV3ICV9XG4gKiB7JSBlbWJlZF9maWxlIHJ0bC9hcHAuY29tcG9uZW50LnRzICV9XG4gKiB7JSBlbWJlZF9maWxlIHNoYXJlZC9tYWluLnRzIGhpZGRlbiAlfVxuICpcbiAqL1xuY29uc3QgUlRMID0gbmV3IEluamVjdGlvblRva2VuKFwiS2VuZG8gVUkgUmlnaHQtdG8tTGVmdCB0b2tlblwiKTtcblxuLyoqXG4gKiBMb2NhbGl6YXRpb24gcHJlZml4IGZvciB0aGUgY29tcG9uZW50IG1lc3NhZ2VzLlxuICpcbiAqIEZvciBpbnRlcm5hbCB1c2UuXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IEwxME5fUFJFRklYID0gbmV3IEluamVjdGlvblRva2VuKCdMb2NhbGl6YXRpb24ga2V5IHByZWZpeCcpO1xuLyoqXG4gKiBDb21wb25lbnQgbG9jYWxpemF0aW9uIHNlcnZpY2UuXG4gKlxuICogRm9yIGludGVybmFsIHVzZS5cbiAqIEBoaWRkZW5cbiAqL1xubGV0IExvY2FsaXphdGlvblNlcnZpY2UgPSBjbGFzcyBMb2NhbGl6YXRpb25TZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihwcmVmaXgsIG1lc3NhZ2VTZXJ2aWNlLCBfcnRsKSB7XG4gICAgICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgICAgICB0aGlzLm1lc3NhZ2VTZXJ2aWNlID0gbWVzc2FnZVNlcnZpY2U7XG4gICAgICAgIHRoaXMuX3J0bCA9IF9ydGw7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IG5ldyBCZWhhdmlvclN1YmplY3QoeyBydGw6IHRoaXMuX3J0bCB9KTtcbiAgICAgICAgdGhpcy5kaWN0aW9uYXJ5ID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlU2VydmljZSkge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSBtZXNzYWdlU2VydmljZS5jaGFuZ2VzXG4gICAgICAgICAgICAgICAgLnBpcGUobWFwKCh7IHJ0bCB9KSA9PiBydGwgIT09IHVuZGVmaW5lZCA/IHJ0bCA6IHRoaXMuX3J0bCksIHRhcChydGwgPT4gdGhpcy5fcnRsID0gcnRsKSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKHJ0bCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaWN0aW9uYXJ5ID0ge307XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VzLm5leHQoeyBydGwgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgcnRsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcnRsO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldChzaG9ydEtleSkge1xuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmtleShzaG9ydEtleSk7XG4gICAgICAgIHJldHVybiB0aGlzLmRpY3Rpb25hcnlba2V5XTtcbiAgICB9XG4gICAgcmVnaXN0ZXIoc2hvcnRLZXksIHZhbHVlLCBvdmVycmlkZSA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMua2V5KHNob3J0S2V5KTtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB2YWx1ZTtcbiAgICAgICAgaWYgKCFvdmVycmlkZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGljdGlvbmFyeS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVzc2FnZSA9IHRoaXMuZGVmYXVsdFZhbHVlKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGljdGlvbmFyeVtrZXldID0gbWVzc2FnZTtcbiAgICB9XG4gICAgbm90aWZ5Q2hhbmdlcygpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLm5leHQoeyBydGw6IHRoaXMucnRsIH0pO1xuICAgIH1cbiAgICBrZXkoc2hvcnRLZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlZml4ICsgJy4nICsgc2hvcnRLZXk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZShrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5tZXNzYWdlU2VydmljZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFsdCA9IHRoaXMubWVzc2FnZVNlcnZpY2UuZ2V0KGtleSk7XG4gICAgICAgIHJldHVybiAoYWx0ID09PSB1bmRlZmluZWQpID8gdmFsdWUgOiBhbHQ7XG4gICAgfVxufTtcbkxvY2FsaXphdGlvblNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKCksXG4gICAgX19wYXJhbSgwLCBJbmplY3QoTDEwTl9QUkVGSVgpKSxcbiAgICBfX3BhcmFtKDEsIE9wdGlvbmFsKCkpLFxuICAgIF9fcGFyYW0oMiwgT3B0aW9uYWwoKSksIF9fcGFyYW0oMiwgSW5qZWN0KFJUTCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nLCBNZXNzYWdlU2VydmljZSwgQm9vbGVhbl0pXG5dLCBMb2NhbGl6YXRpb25TZXJ2aWNlKTtcblxuLyoqXG4gKiBHZW5lcmF0ZWQgYnVuZGxlIGluZGV4LiBEbyBub3QgZWRpdC5cbiAqL1xuXG5leHBvcnQgeyBNZXNzYWdlU2VydmljZSwgQ29tcG9uZW50TWVzc2FnZXMsIEwxME5fUFJFRklYLCBMb2NhbGl6YXRpb25TZXJ2aWNlLCBSVEwgfTtcbiJdfQ==\n\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/cldr/default-data.js\nconst defaultData = {\n    en: {\n        name: \"en\",\n        identity: {\n            version: {\n                _number: \"$Revision: 12418 $\",\n                _cldrVersion: \"29\"\n            },\n            language: \"en\"\n        },\n        territory: \"US\",\n        numbers: {\n            symbols: {\n                decimal: \".\",\n                group: \",\",\n                list: \";\",\n                percentSign: \"%\",\n                plusSign: \"+\",\n                minusSign: \"-\",\n                exponential: \"E\",\n                superscriptingExponent: \"×\",\n                perMille: \"‰\",\n                infinity: \"∞\",\n                nan: \"NaN\",\n                timeSeparator: \":\"\n            },\n            decimal: {\n                patterns: [\n                    \"n\"\n                ],\n                groupSize: [\n                    3\n                ]\n            },\n            scientific: {\n                patterns: [\n                    \"nEn\"\n                ],\n                groupSize: []\n            },\n            percent: {\n                patterns: [\n                    \"n%\"\n                ],\n                groupSize: [\n                    3\n                ]\n            },\n            currency: {\n                patterns: [\n                    \"$n\"\n                ],\n                groupSize: [\n                    3\n                ],\n                \"unitPattern-count-one\": \"n $\",\n                \"unitPattern-count-other\": \"n $\"\n            },\n            currencies: {\n                BGN: {\n                    displayName: \"Bulgarian Lev\",\n                    \"displayName-count-one\": \"Bulgarian lev\",\n                    \"displayName-count-other\": \"Bulgarian leva\",\n                    symbol: \"BGN\"\n                },\n                EUR: {\n                    displayName: \"Euro\",\n                    \"displayName-count-one\": \"euro\",\n                    \"displayName-count-other\": \"euros\",\n                    symbol: \"€\",\n                    \"symbol-alt-narrow\": \"€\"\n                },\n                USD: {\n                    displayName: \"US Dollar\",\n                    \"displayName-count-one\": \"US dollar\",\n                    \"displayName-count-other\": \"US dollars\",\n                    symbol: \"$\",\n                    \"symbol-alt-narrow\": \"$\"\n                }\n            },\n            localeCurrency: \"USD\",\n            accounting: {\n                patterns: [\n                    \"$n\",\n                    \"($n)\"\n                ],\n                groupSize: [\n                    3\n                ]\n            }\n        },\n        calendar: {\n            gmtFormat: \"GMT{0}\",\n            gmtZeroFormat: \"GMT\",\n            patterns: {\n                d: \"M/d/y\",\n                D: \"EEEE, MMMM d, y\",\n                m: \"MMM d\",\n                M: \"MMMM d\",\n                y: \"MMM y\",\n                Y: \"MMMM y\",\n                F: \"EEEE, MMMM d, y h:mm:ss a\",\n                g: \"M/d/y h:mm a\",\n                G: \"M/d/y h:mm:ss a\",\n                t: \"h:mm a\",\n                T: \"h:mm:ss a\",\n                s: \"yyyy'-'MM'-'dd'T'HH':'mm':'ss\",\n                u: \"yyyy'-'MM'-'dd HH':'mm':'ss'Z'\"\n            },\n            dateTimeFormats: {\n                full: \"{1} 'at' {0}\",\n                long: \"{1} 'at' {0}\",\n                medium: \"{1}, {0}\",\n                short: \"{1}, {0}\",\n                availableFormats: {\n                    Bh: \"h B\",\n                    Bhm: \"h:mm B\",\n                    Bhms: \"h:mm:ss B\",\n                    d: \"d\",\n                    E: \"ccc\",\n                    EBhm: \"E h:mm B\",\n                    EBhms: \"E h:mm:ss B\",\n                    Ed: \"d E\",\n                    Ehm: \"E h:mm a\",\n                    EHm: \"E HH:mm\",\n                    Ehms: \"E h:mm:ss a\",\n                    EHms: \"E HH:mm:ss\",\n                    Gy: \"y G\",\n                    GyMMM: \"MMM y G\",\n                    GyMMMd: \"MMM d, y G\",\n                    GyMMMEd: \"E, MMM d, y G\",\n                    h: \"h a\",\n                    H: \"HH\",\n                    hm: \"h:mm a\",\n                    Hm: \"HH:mm\",\n                    hms: \"h:mm:ss a\",\n                    Hms: \"HH:mm:ss\",\n                    hmsv: \"h:mm:ss a v\",\n                    Hmsv: \"HH:mm:ss v\",\n                    hmv: \"h:mm a v\",\n                    Hmv: \"HH:mm v\",\n                    M: \"L\",\n                    Md: \"M/d\",\n                    MEd: \"E, M/d\",\n                    MMM: \"LLL\",\n                    MMMd: \"MMM d\",\n                    MMMEd: \"E, MMM d\",\n                    MMMMd: \"MMMM d\",\n                    \"MMMMW-count-one\": \"'week' W 'of' MMMM\",\n                    \"MMMMW-count-other\": \"'week' W 'of' MMMM\",\n                    ms: \"mm:ss\",\n                    y: \"y\",\n                    yM: \"M/y\",\n                    yMd: \"M/d/y\",\n                    yMEd: \"E, M/d/y\",\n                    yMMM: \"MMM y\",\n                    yMMMd: \"MMM d, y\",\n                    yMMMEd: \"E, MMM d, y\",\n                    yMMMM: \"MMMM y\",\n                    yQQQ: \"QQQ y\",\n                    yQQQQ: \"QQQQ y\",\n                    \"yw-count-one\": \"'week' w 'of' Y\",\n                    \"yw-count-other\": \"'week' w 'of' Y\"\n                }\n            },\n            timeFormats: {\n                full: \"h:mm:ss a zzzz\",\n                long: \"h:mm:ss a z\",\n                medium: \"h:mm:ss a\",\n                short: \"h:mm a\"\n            },\n            dateFormats: {\n                full: \"EEEE, MMMM d, y\",\n                long: \"MMMM d, y\",\n                medium: \"MMM d, y\",\n                short: \"M/d/yy\"\n            },\n            days: {\n                format: {\n                    abbreviated: [\n                        \"Sun\",\n                        \"Mon\",\n                        \"Tue\",\n                        \"Wed\",\n                        \"Thu\",\n                        \"Fri\",\n                        \"Sat\"\n                    ],\n                    narrow: [\n                        \"S\",\n                        \"M\",\n                        \"T\",\n                        \"W\",\n                        \"T\",\n                        \"F\",\n                        \"S\"\n                    ],\n                    short: [\n                        \"Su\",\n                        \"Mo\",\n                        \"Tu\",\n                        \"We\",\n                        \"Th\",\n                        \"Fr\",\n                        \"Sa\"\n                    ],\n                    wide: [\n                        \"Sunday\",\n                        \"Monday\",\n                        \"Tuesday\",\n                        \"Wednesday\",\n                        \"Thursday\",\n                        \"Friday\",\n                        \"Saturday\"\n                    ]\n                },\n                \"stand-alone\": {\n                    abbreviated: [\n                        \"Sun\",\n                        \"Mon\",\n                        \"Tue\",\n                        \"Wed\",\n                        \"Thu\",\n                        \"Fri\",\n                        \"Sat\"\n                    ],\n                    narrow: [\n                        \"S\",\n                        \"M\",\n                        \"T\",\n                        \"W\",\n                        \"T\",\n                        \"F\",\n                        \"S\"\n                    ],\n                    short: [\n                        \"Su\",\n                        \"Mo\",\n                        \"Tu\",\n                        \"We\",\n                        \"Th\",\n                        \"Fr\",\n                        \"Sa\"\n                    ],\n                    wide: [\n                        \"Sunday\",\n                        \"Monday\",\n                        \"Tuesday\",\n                        \"Wednesday\",\n                        \"Thursday\",\n                        \"Friday\",\n                        \"Saturday\"\n                    ]\n                }\n            },\n            months: {\n                format: {\n                    abbreviated: [\n                        \"Jan\",\n                        \"Feb\",\n                        \"Mar\",\n                        \"Apr\",\n                        \"May\",\n                        \"Jun\",\n                        \"Jul\",\n                        \"Aug\",\n                        \"Sep\",\n                        \"Oct\",\n                        \"Nov\",\n                        \"Dec\"\n                    ],\n                    narrow: [\n                        \"J\",\n                        \"F\",\n                        \"M\",\n                        \"A\",\n                        \"M\",\n                        \"J\",\n                        \"J\",\n                        \"A\",\n                        \"S\",\n                        \"O\",\n                        \"N\",\n                        \"D\"\n                    ],\n                    wide: [\n                        \"January\",\n                        \"February\",\n                        \"March\",\n                        \"April\",\n                        \"May\",\n                        \"June\",\n                        \"July\",\n                        \"August\",\n                        \"September\",\n                        \"October\",\n                        \"November\",\n                        \"December\"\n                    ]\n                },\n                \"stand-alone\": {\n                    abbreviated: [\n                        \"Jan\",\n                        \"Feb\",\n                        \"Mar\",\n                        \"Apr\",\n                        \"May\",\n                        \"Jun\",\n                        \"Jul\",\n                        \"Aug\",\n                        \"Sep\",\n                        \"Oct\",\n                        \"Nov\",\n                        \"Dec\"\n                    ],\n                    narrow: [\n                        \"J\",\n                        \"F\",\n                        \"M\",\n                        \"A\",\n                        \"M\",\n                        \"J\",\n                        \"J\",\n                        \"A\",\n                        \"S\",\n                        \"O\",\n                        \"N\",\n                        \"D\"\n                    ],\n                    wide: [\n                        \"January\",\n                        \"February\",\n                        \"March\",\n                        \"April\",\n                        \"May\",\n                        \"June\",\n                        \"July\",\n                        \"August\",\n                        \"September\",\n                        \"October\",\n                        \"November\",\n                        \"December\"\n                    ]\n                }\n            },\n            quarters: {\n                format: {\n                    abbreviated: [\n                        \"Q1\",\n                        \"Q2\",\n                        \"Q3\",\n                        \"Q4\"\n                    ],\n                    narrow: [\n                        \"1\",\n                        \"2\",\n                        \"3\",\n                        \"4\"\n                    ],\n                    wide: [\n                        \"1st quarter\",\n                        \"2nd quarter\",\n                        \"3rd quarter\",\n                        \"4th quarter\"\n                    ]\n                },\n                \"stand-alone\": {\n                    abbreviated: [\n                        \"Q1\",\n                        \"Q2\",\n                        \"Q3\",\n                        \"Q4\"\n                    ],\n                    narrow: [\n                        \"1\",\n                        \"2\",\n                        \"3\",\n                        \"4\"\n                    ],\n                    wide: [\n                        \"1st quarter\",\n                        \"2nd quarter\",\n                        \"3rd quarter\",\n                        \"4th quarter\"\n                    ]\n                }\n            },\n            dayPeriods: {\n                format: {\n                    abbreviated: {\n                        midnight: \"midnight\",\n                        am: \"AM\",\n                        \"am-alt-variant\": \"am\",\n                        noon: \"noon\",\n                        pm: \"PM\",\n                        \"pm-alt-variant\": \"pm\",\n                        morning1: \"in the morning\",\n                        afternoon1: \"in the afternoon\",\n                        evening1: \"in the evening\",\n                        night1: \"at night\"\n                    },\n                    narrow: {\n                        midnight: \"mi\",\n                        am: \"a\",\n                        \"am-alt-variant\": \"am\",\n                        noon: \"n\",\n                        pm: \"p\",\n                        \"pm-alt-variant\": \"pm\",\n                        morning1: \"in the morning\",\n                        afternoon1: \"in the afternoon\",\n                        evening1: \"in the evening\",\n                        night1: \"at night\"\n                    },\n                    wide: {\n                        midnight: \"midnight\",\n                        am: \"AM\",\n                        \"am-alt-variant\": \"am\",\n                        noon: \"noon\",\n                        pm: \"PM\",\n                        \"pm-alt-variant\": \"pm\",\n                        morning1: \"in the morning\",\n                        afternoon1: \"in the afternoon\",\n                        evening1: \"in the evening\",\n                        night1: \"at night\"\n                    }\n                },\n                \"stand-alone\": {\n                    abbreviated: {\n                        midnight: \"midnight\",\n                        am: \"AM\",\n                        \"am-alt-variant\": \"am\",\n                        noon: \"noon\",\n                        pm: \"PM\",\n                        \"pm-alt-variant\": \"pm\",\n                        morning1: \"morning\",\n                        afternoon1: \"afternoon\",\n                        evening1: \"evening\",\n                        night1: \"night\"\n                    },\n                    narrow: {\n                        midnight: \"midnight\",\n                        am: \"AM\",\n                        \"am-alt-variant\": \"am\",\n                        noon: \"noon\",\n                        pm: \"PM\",\n                        \"pm-alt-variant\": \"pm\",\n                        morning1: \"morning\",\n                        afternoon1: \"afternoon\",\n                        evening1: \"evening\",\n                        night1: \"night\"\n                    },\n                    wide: {\n                        midnight: \"midnight\",\n                        am: \"AM\",\n                        \"am-alt-variant\": \"am\",\n                        noon: \"noon\",\n                        pm: \"PM\",\n                        \"pm-alt-variant\": \"pm\",\n                        morning1: \"morning\",\n                        afternoon1: \"afternoon\",\n                        evening1: \"evening\",\n                        night1: \"night\"\n                    }\n                }\n            },\n            eras: {\n                format: {\n                    wide: {\n                        \"0\": \"Before Christ\",\n                        \"1\": \"Anno Domini\",\n                        \"0-alt-variant\": \"Before Common Era\",\n                        \"1-alt-variant\": \"Common Era\"\n                    },\n                    abbreviated: {\n                        \"0\": \"BC\",\n                        \"1\": \"AD\",\n                        \"0-alt-variant\": \"BCE\",\n                        \"1-alt-variant\": \"CE\"\n                    },\n                    narrow: {\n                        \"0\": \"B\",\n                        \"1\": \"A\",\n                        \"0-alt-variant\": \"BCE\",\n                        \"1-alt-variant\": \"CE\"\n                    }\n                }\n            },\n            dateFields: {\n                era: {\n                    wide: \"era\"\n                },\n                year: {\n                    wide: \"year\",\n                    short: \"yr.\",\n                    narrow: \"yr.\"\n                },\n                quarter: {\n                    wide: \"quarter\",\n                    short: \"qtr.\",\n                    narrow: \"qtr.\"\n                },\n                month: {\n                    wide: \"month\",\n                    short: \"mo.\",\n                    narrow: \"mo.\"\n                },\n                week: {\n                    wide: \"week\",\n                    short: \"wk.\",\n                    narrow: \"wk.\"\n                },\n                day: {\n                    wide: \"day\",\n                    short: \"day\",\n                    narrow: \"day\"\n                },\n                weekday: {\n                    wide: \"day of the week\"\n                },\n                dayperiod: {\n                    wide: \"AM/PM\"\n                },\n                hour: {\n                    wide: \"hour\",\n                    short: \"hr.\",\n                    narrow: \"hr.\"\n                },\n                minute: {\n                    wide: \"minute\",\n                    short: \"min.\",\n                    narrow: \"min.\"\n                },\n                second: {\n                    wide: \"second\",\n                    short: \"sec.\",\n                    narrow: \"sec.\"\n                },\n                millisecond: {\n                    wide: \"millisecond\",\n                    short: \"ms\",\n                    narrow: \"ms\"\n                },\n                zone: {\n                    wide: \"time zone\"\n                }\n            }\n        }\n    },\n    supplemental: {\n        likelySubtags: {\n            en: \"en-Latn-US\"\n        },\n        currencyData: {\n            region: {\n                US: [\n                    {\n                        USD: {\n                            _from: \"1792-01-01\"\n                        }\n                    }\n                ]\n            }\n        },\n        weekData: {\n            firstDay: {\n                US: \"sun\"\n            },\n            weekendStart: {\n                \"001\": \"sat\"\n            },\n            weekendEnd: {\n                \"001\": \"sun\"\n            }\n        }\n    }\n};\n/* harmony default export */ var default_data = (defaultData);\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/common/is-string.js\nfunction is_string_isString(value) {\n    return typeof value === \"string\";\n}\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/error-details.js\n//The error is represented by unique name and corresponding message\n//The message can contain placeholders with index, e.g. {0}, {1}\n\n/* harmony default export */ var error_details = ({\n    \"NoLocale\": \"Missing locale info for '{0}'\",\n    \"NoCurrency\": \"Cannot determine currency information. Please load the locale currencies data.\",\n    \"NoSupplementalCurrency\": \"Cannot determine currency. Please load the supplemental currencyData.\",\n    \"NoCurrencyRegion\": \"No currency data for region '{0}'\",\n    \"NoCurrencyDisplay\": \"Cannot determine currency display information. Please load the locale currencies data. The default culture does not include the all currencies data.\",\n    \"NoGMTInfo\": \"Cannot determine locale GMT format. Please load the locale timeZoneNames data.\",\n    \"NoWeekData\": \"Cannot determine locale first day of week. Please load the supplemental weekData.\",\n    \"NoFirstDay\": \"Cannot determine locale first day of week. Please load the supplemental weekData. The default culture includes only the 'en-US' first day info.\",\n    \"NoValidCurrency\": \"Cannot determine a default currency for the {0} locale. Please specify explicitly the currency with the format options.\",\n    \"NoDateFieldNames\": \"Cannot determine the locale date field names. Please load the locale dateFields data.\"\n});\n\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/errors.js\n\n\nconst formatRegExp = /\\{(\\d+)}?\\}/g;\n\nclass IntlError {\n    constructor({ name, message }) {\n        if (!name || !message) {\n            throw new Error(\"{ name: string, message: string } object is required!\");\n        }\n\n        this.name = name;\n        this.message = message;\n    }\n\n    formatMessage(...values) {\n        const flattenValues = flatten(values);\n\n        const formattedMessage = this.message.replace(formatRegExp, function(match, index) {\n            return flattenValues[parseInt(index, 10)];\n        });\n\n        return `${this.name}: ${formattedMessage}`;\n    }\n\n    error(...values) {\n        return new Error(this.formatMessage(values));\n    }\n}\n\nconst flatten = function(arr) {\n    return arr.reduce((a, b) => a.concat(b), []);\n};\n\nconst toIntlErrors = function(errors) {\n    const predicate = function(prev, name) {\n        prev[name] = new IntlError({ name, message: errors[name] });\n        return prev;\n    };\n\n    return Object.keys(errors).reduce(predicate, {});\n};\n\nconst errors = toIntlErrors(error_details);\n\n\n\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/cldr/info.js\n\n\n\n\nfunction availableLocaleInfo(fullName, suffixes) {\n    const parts = fullName.split(\"-\");\n    const language = parts[0];\n    const script = parts[1];\n    const territory = parts[2];\n\n    return cldr[fullName] || (suffixes.indexOf(territory) !== -1 && cldr[language + \"-\" + territory]) || (suffixes.indexOf(script) !== -1 && cldr[language + \"-\" + script]) || cldr[language];\n}\n\nfunction localeFullName(language, suffixes) {\n    const likelySubtags = cldr.supplemental.likelySubtags;\n\n    for (let idx = 0; idx < suffixes.length; idx++) {\n        let name = likelySubtags[language + \"-\" + suffixes[idx ]];\n        if (name) {\n            return name;\n        }\n    }\n\n    if (likelySubtags[language]) {\n        return likelySubtags[language];\n    }\n}\n\nconst cldr = default_data;\n\nfunction getLocaleInfo(locale) {\n    let info;\n    if (is_string_isString(locale)) {\n        info = info_localeInfo(locale);\n    } else {\n        info = locale;\n    }\n    return info;\n}\n\nfunction info_localeInfo(locale) {\n    if (cldr[locale]) {\n        return cldr[locale];\n    }\n\n    const likelySubtags = cldr.supplemental.likelySubtags;\n    if (likelySubtags) {\n        const parts = locale.split(\"-\");\n        const language = parts[0];\n        const suffixes = parts.slice(1);\n        const fullName = localeFullName(language, suffixes);\n        const info = fullName ? availableLocaleInfo(fullName, suffixes) : null;\n        if (info) {\n            return info;\n        }\n    }\n\n    throw errors.NoLocale.error(locale);\n}\n\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/common/constants.js\nconst DECIMAL = \"decimal\";\nconst CURRENCY = \"currency\";\nconst ACCOUNTING = \"accounting\";\nconst PERCENT = \"percent\";\nconst SCIENTIFIC = \"scientific\";\n\nconst CURRENCY_PLACEHOLDER = \"$\";\nconst PERCENT_PLACEHOLDER = \"%\";\nconst NUMBER_PLACEHOLDER = \"n\";\n\nconst LIST_SEPARATOR = \";\";\nconst GROUP_SEPARATOR = \",\";\n\nconst POINT = \".\";\nconst EMPTY = \"\";\n\nconst DEFAULT_LOCALE = \"en\";\n\n\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/cldr/load-numbers.js\n\n\n\nconst LATIN_NUMBER_FORMATS = \"Formats-numberSystem-latn\";\nconst LATIN_NUMBER_SYMBOLS = \"symbols-numberSystem-latn\";\n\nconst patternRegExp = /([#,0.]+)/g;\nconst cldrCurrencyRegExp = /¤/g;\n\nfunction getPatterns(pattern) {\n    patternRegExp.lastIndex = 0;\n\n    return pattern.replace(cldrCurrencyRegExp, CURRENCY_PLACEHOLDER).replace(patternRegExp, NUMBER_PLACEHOLDER).split(LIST_SEPARATOR);\n}\n\nfunction getGroupSize(pattern) {\n    patternRegExp.lastIndex = 0;\n\n    const numberPatterns = patternRegExp.exec(pattern.split(LIST_SEPARATOR)[0])[0].split(POINT);\n    const integer = numberPatterns[0];\n\n    const groupSize = integer.split(GROUP_SEPARATOR).slice(1).map(function(group) {\n        return group.length;\n    }).reverse();\n\n    return groupSize;\n}\n\nfunction loadCurrencyUnitPatterns(currencyInfo, currencyFormats) {\n    for (let field in currencyFormats) {\n        if (field.startsWith(\"unitPattern\")) {\n            currencyInfo[field] = currencyFormats[field].replace(\"{0}\", NUMBER_PLACEHOLDER).replace(\"{1}\", CURRENCY_PLACEHOLDER);\n        }\n    }\n}\n\nfunction loadNumbersInfo(locale, info) {\n    const localeInfo = cldr[locale];\n    const numbers = localeInfo.numbers = localeInfo.numbers || {};\n    numbers.symbols = numbers.symbols || {};\n    for (let field in info) {\n        if (field === LATIN_NUMBER_SYMBOLS) {\n            Object.assign(numbers.symbols, info[field]);\n        } else if (field.includes(LATIN_NUMBER_FORMATS)) {\n            const style = field.substr(0, field.indexOf(LATIN_NUMBER_FORMATS));\n            const pattern = info[field].standard;\n            numbers[style] = {\n                patterns: getPatterns(pattern)\n            };\n            if (style === CURRENCY) {\n                numbers[style].groupSize = getGroupSize((info[DECIMAL + LATIN_NUMBER_FORMATS] || info[field]).standard);\n                loadCurrencyUnitPatterns(numbers[style], info[field]);\n                numbers[ACCOUNTING] = {\n                    patterns: getPatterns(info[field][ACCOUNTING]),\n                    groupSize: numbers[style].groupSize\n                };\n            } else {\n                numbers[style].groupSize = getGroupSize(pattern);\n            }\n        } else if (field === \"currencies\") {\n            numbers.currencies = info[field];\n        }\n    }\n}\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/cldr/load-dates.js\n\n\nconst predefinedDatePatterns = {\n    s: \"yyyy'-'MM'-'dd'T'HH':'mm':'ss\",\n    u: \"yyyy'-'MM'-'dd HH':'mm':'ss'Z'\"\n};\n\nconst YEAR_REGEX = /y+/g;\nconst SHORT_DATE = [ [ \"dateFormats\", \"short\" ] ];\n\nconst datePatterns = {\n    D: [ [ \"dateFormats\", \"full\" ] ],\n    m: [ [ \"dateTimeFormats\", \"availableFormats\", \"MMMd\" ] ],\n    M: [ [ \"dateTimeFormats\", \"availableFormats\", \"MMMMd\" ] ],\n    y: [ [ \"dateTimeFormats\", \"availableFormats\", \"yMMM\" ] ],\n    Y: [ [ \"dateTimeFormats\", \"availableFormats\", \"yMMMM\" ] ],\n    F: [ [ \"dateFormats\", \"full\" ], [ \"timeFormats\", \"medium\" ] ],\n    g: [ [ \"dateTimeFormats\", \"availableFormats\", \"yMd\" ], [ \"timeFormats\", \"short\" ] ],\n    G: [ [ \"dateTimeFormats\", \"availableFormats\", \"yMd\" ], [ \"timeFormats\", \"medium\" ] ],\n    t: [ [ \"timeFormats\", \"short\" ] ],\n    T: [ [ \"timeFormats\", \"medium\" ] ]\n};\n\nfunction toArray(obj) {\n    let result = [];\n    let names = Object.getOwnPropertyNames(obj);\n    for (let idx = 0; idx < names.length; idx++) {\n        let value = obj[names[idx]];\n        result.push(value);\n    }\n    return result;\n}\n\nfunction getCalendarNames(info, isObj) {\n    const result = {};\n    for (let formatType in info) {\n        let names = result[formatType] = {};\n        for (let format in info[formatType]) {\n            let formats = info[formatType][format];\n            names[format] = isObj ? formats : toArray(formats);\n        }\n    }\n    return result;\n}\n\nfunction getEraNames(eras) {\n    const result = {};\n    const format = result.format = {};\n    const eraNameMap = {\n        eraAbbr: \"abbreviated\",\n        eraNames: \"wide\",\n        eraNarrow: \"narrow\"\n    };\n\n    for (let eraFormatName in eras) {\n        let formatName = eraNameMap[eraFormatName];\n        format[formatName] = eras[eraFormatName];\n    }\n\n    return result;\n}\n\nfunction loadCalendarNames(locale, calendar) {\n    const localeCalendar = cldr[locale].calendar;\n    localeCalendar.days = getCalendarNames(calendar.days);\n    localeCalendar.months = getCalendarNames(calendar.months);\n    localeCalendar.quarters = getCalendarNames(calendar.quarters);\n    localeCalendar.dayPeriods = getCalendarNames(calendar.dayPeriods, true);\n\n    localeCalendar.eras = getEraNames(calendar.eras);\n}\n\nfunction loadCalendarDateFields(locale, fields) {\n    const localeCalendar = cldr[locale].calendar;\n    const dateFields = {};\n\n    for (let field in fields) {\n        const [ fieldName, formatType = 'wide' ] = field.split('-');\n        const fieldInfo = dateFields[fieldName] || {};\n        const displayName = fields[field].displayName;\n\n        if (!displayName) { continue; }\n\n        fieldInfo[formatType] = displayName;\n        dateFields[fieldName] = fieldInfo;\n    }\n\n    localeCalendar.dateFields = dateFields;\n}\n\nfunction getPredefinedFormat(paths, calendar) {\n    const result = [];\n\n    for (let pathIdx = 0; pathIdx < paths.length; pathIdx++) {\n        let fields = paths[ pathIdx ];\n        let pattern = calendar;\n        for (let idx = 0; idx < fields.length; idx++) {\n            pattern = pattern[fields[idx]];\n        }\n        result.push(pattern);\n    }\n\n    return result.join(\" \");\n}\n\nfunction loadCalendarPatterns(locale, calendar) {\n    const cldrCalendar = cldr[locale].calendar;\n    const patterns = cldrCalendar.patterns = {};\n\n    patterns.d = getPredefinedFormat(SHORT_DATE, calendar).replace(YEAR_REGEX, 'y');\n\n    for (let pattern in datePatterns) {\n        patterns[pattern] = getPredefinedFormat(datePatterns[pattern], calendar);\n    }\n\n    for (let pattern in predefinedDatePatterns) {\n        patterns[pattern] = predefinedDatePatterns[pattern];\n    }\n\n    const dateTimeFormats = calendar.dateTimeFormats;\n    cldrCalendar.dateTimeFormats = {\n        full: dateTimeFormats.full,\n        long: dateTimeFormats.long,\n        medium: dateTimeFormats.medium,\n        short: dateTimeFormats.short,\n        availableFormats: dateTimeFormats.availableFormats\n    };\n    cldrCalendar.timeFormats = calendar.timeFormats;\n    cldrCalendar.dateFormats = calendar.dateFormats;\n}\n\n\nfunction loadCalendarInfo(locale, info) {\n    const calendar = cldr[locale].calendar = cldr[locale].calendar || {};\n    for (let field in info) {\n        if (field === \"timeZoneNames\") {\n            calendar.gmtFormat = info[field].gmtFormat;\n            calendar.gmtZeroFormat = info[field].gmtZeroFormat;\n        } else if (field === \"calendars\" && info[field].gregorian) {\n            loadCalendarPatterns(locale, info[field].gregorian);\n            loadCalendarNames(locale, info[field].gregorian);\n        } else if (field === \"fields\") {\n            loadCalendarDateFields(locale, info.fields);\n        }\n    }\n}\n\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/cldr/territory.js\n\n\nfunction territoryFromName(name, identity) {\n    const likelySubtags = cldr.supplemental.likelySubtags;\n    let parts = name.split(\"-\");\n    if (likelySubtags) {\n        const likelyName = likelySubtags[name] || likelySubtags[parts[0]];\n        if (likelyName) {\n            parts = likelyName.split(\"-\");\n        }\n    }\n\n    if (identity) {\n        for (let idx = parts.length - 1; idx >= 1; idx--) {\n            const part = parts[idx];\n            if (part === identity.variant || part === identity.script) {\n                parts.splice(idx, 1);\n            }\n        }\n    }\n\n    const length = parts.length;\n\n    if (length > 1) {\n        const territory = parts[length - 1];\n        return territory.toUpperCase();\n    }\n}\n\nfunction localeTerritory(info) {\n    if (info.territory) {\n        return info.territory;\n    }\n\n    const name = info.name;\n    const identity = info.identity;\n    let territory;\n\n    if (identity && identity.territory) {\n        territory = identity.territory;\n    } else {\n        territory = territoryFromName(name, identity);\n    }\n\n    info.territory = territory;\n\n    return territory;\n}\n\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/cldr/load.js\n\n\n\n\n\nfunction loadLocale(locale, info) {\n    for (let field in info) {\n        if (field === \"numbers\") {\n            loadNumbersInfo(locale, info[field]);\n        } else if (field === \"dates\") {\n            loadCalendarInfo(locale, info[field]);\n        }\n    }\n}\n\nfunction load() {\n    const length = arguments.length;\n    for (let idx = 0; idx < length; idx++) {\n        let entry = arguments[idx];\n        if (entry.main) {\n            let locale = Object.keys(entry.main)[0];\n            let info = entry.main[locale];\n            let localeInfo = cldr[locale] = cldr[locale] || {};\n\n            localeInfo.name = localeInfo.name || locale;\n            localeInfo.identity = localeInfo.identity || info.identity;\n\n            localeTerritory(localeInfo);\n            loadLocale(locale, info);\n        } else if (entry.supplemental) {\n            if (entry.supplemental.weekData) {\n                cldr.supplemental.weekData = {\n                    firstDay: entry.supplemental.weekData.firstDay,\n                    weekendStart: entry.supplemental.weekData.weekendStart,\n                    weekendEnd: entry.supplemental.weekData.weekendEnd\n                };\n            } else if (entry.supplemental.likelySubtags) {\n                cldr.supplemental.likelySubtags = Object.assign(cldr.supplemental.likelySubtags, entry.supplemental.likelySubtags);\n            } else if (entry.supplemental.currencyData) {\n                const currencyData = cldr.supplemental.currencyData;\n                currencyData.region = Object.assign(currencyData.region || {}, entry.supplemental.currencyData.region);\n                currencyData.fractions = Object.assign(currencyData.fractions || {}, entry.supplemental.currencyData.fractions);\n            }\n        }\n    }\n}\n\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/cldr/set-data.js\n\n\nfunction setData(data) {\n    const locale = data.name;\n    const info = cldr[locale] = cldr[locale] || {};\n    const supplemental = cldr.supplemental = cldr.supplemental || {};\n\n    if (data.likelySubtags) {\n        supplemental.likelySubtags = Object.assign(supplemental.likelySubtags || {}, data.likelySubtags);\n    }\n\n    if (data.currencyData) {\n        supplemental.currencyData = supplemental.currencyData || {};\n        supplemental.currencyData.fractions = Object.assign(supplemental.currencyData.fractions || {}, data.currencyData);\n    }\n\n    const numbers = info.numbers;\n\n    Object.assign(info, data);\n\n    if (numbers && data.numbers) {\n        info.numbers = Object.assign({}, numbers, data.numbers);\n    }\n}\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/cldr/date-field-name.js\n\n\n\n\nfunction dateFieldName(options, locale = DEFAULT_LOCALE) {\n    const info = info_localeInfo(locale);\n    const dateFields = info.calendar.dateFields;\n    if (!dateFields) {\n        throw errors.NoDateFieldNames.error();\n    }\n\n    const fieldNameInfo = dateFields[options.type] || {};\n\n    return fieldNameInfo[options.nameType] || fieldNameInfo['wide'];\n}\n\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/cldr/date-format-names.js\n\n\n\nfunction lowerArray(arr) {\n    const result = [];\n    for (let idx = 0; idx < arr.length; idx++) {\n        result.push(arr[idx].toLowerCase());\n    }\n    return result;\n}\n\nfunction lowerObject(obj) {\n    const result = {};\n    for (let field in obj) {\n        result[field] = obj[field].toLowerCase();\n    }\n    return result;\n}\n\nfunction cloneLower(obj) {\n    let result = Array.isArray(obj) ? lowerArray(obj) : lowerObject(obj);\n    return result;\n}\n\nfunction dateFormatNames(locale, options) {\n    const { type, nameType, standAlone, lower } = options;\n    const info = getLocaleInfo(locale);\n    const formatType = standAlone ? \"stand-alone\" : \"format\";\n    const lowerNameType = (lower ? \"lower-\" : EMPTY) + nameType;\n    const formatNames = info.calendar[type][formatType];\n    let result = formatNames[lowerNameType];\n    if (!result && lower) {\n        result = formatNames[lowerNameType] = cloneLower(formatNames[nameType]);\n    }\n    return result;\n}\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/cldr/parse-range-date.js\nfunction parseRangeDate(value) {\n    const parts = value.split('-');\n    const year = parseInt(parts[0], 10);\n    const month = parseInt(parts[1], 10) - 1;\n    const day = parseInt(parts[2], 10);\n\n    return new Date(year, month, day);\n}\n\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/cldr/currency.js\n\n\n\n\n\n/* eslint-disable consistent-return */\n\nconst {\n    NoCurrency,\n    NoCurrencyDisplay,\n    NoSupplementalCurrency,\n    NoCurrencyRegion,\n    NoValidCurrency\n} = errors;\n\nconst DEFAULT_CURRENCY_FRACTIONS = 2;\nconst SYMBOL = \"symbol\";\nconst INVALID_CURRENCY_CODE = 'XXX';\n\nconst GLOBAL_CURRENCIES = {\n    '001': 'USD', // 001 refers to world. not sure if it is correct to assume USD but seems better than throw an error\n    '150': 'EUR' // 150 territory for Europe\n\n};\n\nfunction getCurrencyInfo(locale, currency, throwIfNoValid) {\n    const info = getLocaleInfo(locale);\n    const currencies = info.numbers.currencies;\n    if (!currencies) {\n        if (throwIfNoValid) {\n            throw NoCurrency.error();\n        }\n\n        return;\n    }\n\n    const currencyDisplayInfo = currencies[currency];\n\n    if (!currencyDisplayInfo) {\n        if (throwIfNoValid) {\n            throw NoCurrencyDisplay.error();\n        }\n\n        return;\n    }\n\n    return currencyDisplayInfo;\n}\n\nfunction lengthComparer(a, b) {\n    return b.length - a.length;\n}\n\nfunction regionCurrency(regionCurrencies) {\n    let latestValidUntil, latestValidUntilRange;\n    let latestStillValid, latestStillValidDate;\n\n    for (let idx = 0; idx < regionCurrencies.length; idx++) {\n        const currency = regionCurrencies[idx];\n        const code = Object.keys(currency)[0];\n        const info = currency[code];\n        if (code !== INVALID_CURRENCY_CODE && info._tender !== 'false' && info._from) {\n            if (!info._to) {\n                const stillValidDate = parseRangeDate(info._from);\n                if (!latestStillValidDate || latestStillValidDate < stillValidDate) {\n                    latestStillValid = code;\n                    latestStillValidDate = stillValidDate;\n                }\n            } else if (!latestStillValid) {\n                const validFrom = parseRangeDate(info._from);\n                const validTo = parseRangeDate(info._to);\n                if (!latestValidUntilRange || latestValidUntilRange.to < validTo || latestValidUntilRange.from < validFrom) {\n                    latestValidUntil = code;\n                    latestValidUntilRange = {\n                        from: validFrom,\n                        to: validTo\n                    };\n                }\n            }\n        }\n    }\n\n    return latestStillValid || latestValidUntil;\n}\n\nfunction currencyDisplays(locale, currency, throwIfNoValid = true) {\n    const currencyInfo = getCurrencyInfo(locale, currency, throwIfNoValid);\n    if (!currencyInfo) {\n        return;\n    }\n\n    if (!currencyInfo.displays) {\n        const displays = [ currency ];\n        for (let field in currencyInfo) {\n            displays.push(currencyInfo[field]);\n        }\n        displays.sort(lengthComparer);\n        currencyInfo.displays = displays;\n    }\n\n    return currencyInfo.displays;\n}\n\nfunction currencyDisplay(locale, options) {\n    const { value, currency, currencyDisplay = SYMBOL } = options;\n\n    if (currencyDisplay === \"code\") {\n        return currency;\n    }\n\n    const currencyInfo = getCurrencyInfo(locale, currency, true);\n    let result;\n\n    if (currencyDisplay === SYMBOL) {\n        result = currencyInfo[\"symbol-alt-narrow\"] || currencyInfo[SYMBOL];\n    } else {\n        if (typeof value === undefined || value !== 1) {\n            result = currencyInfo[\"displayName-count-other\"];\n        } else {\n            result = currencyInfo[\"displayName-count-one\"];\n        }\n    }\n\n    return result;\n}\n\nfunction currencyFractionOptions(code) {\n    let minimumFractionDigits = DEFAULT_CURRENCY_FRACTIONS;\n    let maximumFractionDigits = DEFAULT_CURRENCY_FRACTIONS;\n\n    const fractions = ((cldr.supplemental.currencyData || {}).fractions || {})[code];\n\n    if (fractions && fractions._digits) {\n        maximumFractionDigits = minimumFractionDigits = parseInt(fractions._digits, 10);\n    }\n\n    return {\n        minimumFractionDigits: minimumFractionDigits,\n        maximumFractionDigits: maximumFractionDigits\n    };\n}\n\nfunction territoryCurrencyCode(territory, throwIfNoValid = true) {\n    if (GLOBAL_CURRENCIES[territory]) {\n        return GLOBAL_CURRENCIES[territory];\n    }\n\n    const currencyData = cldr.supplemental.currencyData;\n    if (!currencyData) {\n        if (throwIfNoValid) {\n            throw NoSupplementalCurrency.error();\n        }\n\n        return;\n    }\n\n    const regionCurrencies = currencyData.region[territory];\n\n    if (!regionCurrencies) {\n        if (throwIfNoValid) {\n            throw NoCurrencyRegion.error(territory);\n        }\n\n        return;\n    }\n\n    const currencyCode = regionCurrency(regionCurrencies);\n\n    return currencyCode;\n}\n\nfunction localeCurrency(locale, throwIfNoValid) {\n    const info = getLocaleInfo(locale);\n    const numbers = info.numbers;\n\n    if (!numbers.localeCurrency) {\n        const currency = territoryCurrencyCode(localeTerritory(info), throwIfNoValid);\n\n        if (!currency && throwIfNoValid) {\n            throw NoValidCurrency.error(info.name);\n        }\n\n        numbers.localeCurrency = currency;\n    }\n\n    return numbers.localeCurrency;\n}\n\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/cldr/constants.js\n\nconst DAYS_OF_WEEK = [ \"sun\", \"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\" ];\n\nconst DEFAULT_TERRITORY = '001';\n\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/cldr/first-day.js\n\n\n\n\n\n\nconst { NoWeekData, NoFirstDay } = errors;\n\nfunction cldr_first_day_firstDay(locale) {\n    const info = getLocaleInfo(locale);\n\n    if (!isNaN(info.firstDay)) {\n        return info.firstDay;\n    }\n\n    const weekData = cldr.supplemental.weekData;\n    if (!weekData) {\n        throw NoWeekData.error();\n    }\n\n    const firstDay = weekData.firstDay[localeTerritory(info)] || weekData.firstDay[DEFAULT_TERRITORY];\n\n    if (!firstDay) {\n        throw NoFirstDay.error();\n    }\n\n    info.firstDay = DAYS_OF_WEEK.indexOf(firstDay);\n\n    return info.firstDay;\n}\n\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/cldr/weekend-range.js\n\n\n\n\n\n\nconst { NoWeekData: weekend_range_NoWeekData } = errors;\n\nfunction weekendRange(locale) {\n    const info = getLocaleInfo(locale);\n\n    if (info.weekendRange) {\n        return info.weekendRange;\n    }\n\n    const weekData = cldr.supplemental.weekData;\n    if (!weekData) {\n        throw weekend_range_NoWeekData.error();\n    }\n\n    const territory = localeTerritory(info);\n    const start = weekData.weekendStart[territory] || weekData.weekendStart[DEFAULT_TERRITORY];\n    const end = weekData.weekendEnd[territory] || weekData.weekendEnd[DEFAULT_TERRITORY];\n\n    info.weekendRange = {\n        start: DAYS_OF_WEEK.indexOf(start),\n        end: DAYS_OF_WEEK.indexOf(end)\n    };\n\n    return info.weekendRange;\n}\n\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/cldr/number-symbols.js\n\n\nfunction numberSymbols(locale) {\n    const info = getLocaleInfo(locale);\n\n    return info.numbers.symbols;\n}\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/cldr.js\n\n\n\n\n\n\n\n\n\n\n\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/common/is-negative-zero.js\nfunction isNegativeZero(value) {\n    return (1 / value === -Infinity);\n}\n\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/numbers/format-currency-symbol.js\n\n\nfunction formatCurrencySymbol(info, options = {}) {\n    if (!options.currency) {\n        options.currency = localeCurrency(info, true);\n    }\n\n    const display = currencyDisplay(info, options);\n\n    return display;\n}\n\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/numbers/group-integer.js\nfunction groupInteger(number, start, end, options, info) {\n    const symbols = info.numbers.symbols;\n    const decimalIndex = number.indexOf(symbols.decimal);\n    const groupSizes = options.groupSize.slice();\n    let groupSize = groupSizes.shift();\n\n    let integerEnd = decimalIndex !== -1 ? decimalIndex : end + 1;\n\n    let integer = number.substring(start, integerEnd);\n    let result = number;\n    const integerLength = integer.length;\n\n    if (integerLength >= groupSize) {\n        let idx = integerLength;\n        let parts = [];\n\n        while (idx > -1) {\n            let value = integer.substring(idx - groupSize, idx);\n            if (value) {\n                parts.push(value);\n            }\n            idx -= groupSize;\n            let newGroupSize = groupSizes.shift();\n            groupSize = newGroupSize !== undefined ? newGroupSize : groupSize;\n\n            if (groupSize === 0) {\n                value = integer.substring(0, idx);\n                if (value) {\n                    parts.push(value);\n                }\n                break;\n            }\n        }\n\n        integer = parts.reverse().join(symbols.group);\n        result = number.substring(0, start) + integer + number.substring(integerEnd);\n    }\n\n    return result;\n}\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/numbers/is-currency-style.js\n\n\nfunction isCurrencyStyle(style) {\n    return style === CURRENCY || style === ACCOUNTING;\n}\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/common/pad.js\nfunction pad_pad(number, digits = 2, right = false) {\n    const count = digits - String(number).length;\n    let result = number;\n\n    if (count > 0) {\n        const padString = new Array(count + 1).join(\"0\");\n        result = right ? number + padString : padString + number;\n    }\n\n    return result;\n}\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/common/round.js\nconst MAX_PRECISION = 20;\n\nfunction round_round(value, precision) {\n    let result = value;\n    let decimals = precision || 0;\n\n    result = result.toString().split('e');\n    result = Math.round(Number(result[0] + 'e' + (result[1] ? (Number(result[1]) + decimals) : decimals)));\n\n    result = result.toString().split('e');\n    result = Number(result[0] + 'e' + (result[1] ? (Number(result[1]) - decimals) : -decimals));\n\n    return result.toFixed(Math.min(decimals, MAX_PRECISION));\n}\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/numbers/standard-number-format.js\n\n\n\n\n\n\n\n\n\nconst DEFAULT_DECIMAL_ROUNDING = 3;\nconst DEFAULT_PERCENT_ROUNDING = 0;\n\nconst trailingZeroRegex = /0+$/;\n\nfunction fractionOptions(options) {\n    let { minimumFractionDigits, maximumFractionDigits, style } = options;\n    const isCurrency = isCurrencyStyle(style);\n    let currencyFractions;\n    if (isCurrency) {\n        currencyFractions = currencyFractionOptions(options.currency);\n    }\n\n    if (minimumFractionDigits === undefined) {\n        minimumFractionDigits = isCurrency ? currencyFractions.minimumFractionDigits : 0;\n    }\n\n    if (maximumFractionDigits === undefined) {\n        if (style === PERCENT) {\n            maximumFractionDigits = Math.max(minimumFractionDigits, DEFAULT_PERCENT_ROUNDING);\n        } else if (isCurrency) {\n            maximumFractionDigits = Math.max(minimumFractionDigits, currencyFractions.maximumFractionDigits);\n        } else {\n            maximumFractionDigits = Math.max(minimumFractionDigits, DEFAULT_DECIMAL_ROUNDING);\n        }\n    }\n\n    return {\n        minimumFractionDigits: minimumFractionDigits,\n        maximumFractionDigits: maximumFractionDigits\n    };\n}\n\nfunction applyPattern(value, pattern, symbol) {\n    let result = EMPTY;\n    for (let idx = 0, length = pattern.length; idx < length; idx++) {\n        let ch = pattern.charAt(idx);\n\n        if (ch === NUMBER_PLACEHOLDER) {\n            result += value;\n        } else if (ch === CURRENCY_PLACEHOLDER || ch === PERCENT_PLACEHOLDER) {\n            result += symbol;\n        } else {\n            result += ch;\n        }\n    }\n    return result;\n}\n\nfunction currencyUnitPattern(info, value) {\n    const currencyInfo = info.numbers.currency;\n    let pattern = value !== 1 ? currencyInfo[\"unitPattern-count-other\"] : currencyInfo[\"unitPattern-count-one\"];\n    if (value < 0) {\n        pattern = pattern.replace(NUMBER_PLACEHOLDER, `-${ NUMBER_PLACEHOLDER }`);\n    }\n\n    return pattern;\n}\n\n\nfunction standardNumberFormat(number, options, info) {\n    const symbols = info.numbers.symbols;\n    const { style } = options;\n    const isCurrency = isCurrencyStyle(style);\n\n    //return number in exponential format\n    if (style === SCIENTIFIC) {\n        let exponential = options.minimumFractionDigits !== undefined ? number.toExponential(options.minimumFractionDigits) : number.toExponential();\n        return exponential.replace(POINT, symbols.decimal);\n    }\n\n    let value = number;\n    let symbol;\n\n    if (isCurrency) {\n        options.value = value;\n        symbol = formatCurrencySymbol(info, options);\n    }\n\n    if (style === PERCENT) {\n        value *= 100;\n        symbol = symbols.percentSign;\n    }\n\n    const { minimumFractionDigits, maximumFractionDigits } = fractionOptions(options);\n\n    value = round_round(value, maximumFractionDigits);\n\n    const negative = value < 0;\n    const negativeZero = isNegativeZero(number);\n\n    const parts = value.split(POINT);\n\n    let integer = parts[0];\n    let fraction = pad_pad(parts[1] ? parts[1].replace(trailingZeroRegex, EMPTY) : EMPTY, minimumFractionDigits, true);\n\n    //exclude \"-\" if number is negative.\n    if (negative) {\n        integer = integer.substring(1);\n    }\n\n    if (options.minimumIntegerDigits) {\n        integer = pad_pad(integer, options.minimumIntegerDigits);\n    }\n\n    let formattedValue = options.useGrouping !== false ? groupInteger(integer, 0, integer.length, options, info) : integer;\n\n    if (fraction) {\n        formattedValue += symbols.decimal + fraction;\n    }\n\n    let pattern;\n\n    if (isCurrency && options.currencyDisplay === \"name\") {\n        pattern = currencyUnitPattern(info, number);\n    } else {\n        const patterns = options.patterns;\n        pattern = (negative || negativeZero) ? patterns[1] || (\"-\" + patterns[0]) : patterns[0];\n    }\n\n    if (pattern === NUMBER_PLACEHOLDER && !negative) {\n        return formattedValue;\n    }\n\n    const result = applyPattern(formattedValue, pattern, symbol);\n\n    return result;\n}\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/numbers/utils.js\n\n\n\nconst literalRegExp = /(\\\\.)|(['][^']*[']?)|([\"][^\"]*[\"]?)/g;\nconst PLACEHOLDER = \"__??__\";\n\nfunction setStyleOptions(formatOptions, info) {\n    const format = formatOptions.format;\n\n    //multiply number if the format has percent\n    if (format.indexOf(PERCENT_PLACEHOLDER) !== -1) {\n        formatOptions.style = PERCENT;\n        formatOptions.symbol = info.numbers.symbols.percentSign;\n        formatOptions.number *= 100;\n    }\n\n    if (format.indexOf(CURRENCY_PLACEHOLDER) !== -1) {\n        formatOptions.style = CURRENCY;\n        formatOptions.symbol = formatCurrencySymbol(info);\n    }\n}\n\nfunction setFormatLiterals(formatOptions) {\n    let format = formatOptions.format;\n    if (format.indexOf(\"'\") > -1 || format.indexOf(\"\\\"\") > -1 || format.indexOf(\"\\\\\") > -1) {\n        const literals = formatOptions.literals = [];\n        formatOptions.format = format.replace(literalRegExp, function(match) {\n            const quoteChar = match.charAt(0).replace(\"\\\\\", EMPTY);\n            const literal = match.slice(1).replace(quoteChar, EMPTY);\n\n            literals.push(literal);\n\n            return PLACEHOLDER;\n        });\n    }\n}\n\nfunction replaceLiterals(number, literals) {\n    let result = number;\n    if (literals) {\n        const length = literals.length;\n        for (let idx = 0; idx < length; idx++) {\n            result = result.replace(PLACEHOLDER, literals[idx]);\n        }\n    }\n    return result;\n}\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/numbers/custom-number-format.js\n\n\n\n\n\n\nconst SHARP = \"#\";\nconst custom_number_format_ZERO = \"0\";\n\nconst trailingZerosRegExp = /(\\.(?:[0-9]*[1-9])?)0+$/g;\nconst trailingPointRegExp = /\\.$/;\nconst commaRegExp = /\\,/g;\n\nfunction trimTrailingZeros(value, lastZero) {\n    let trimRegex;\n\n    if (lastZero === 0) {\n        trimRegex = trailingZerosRegExp;\n    } else {\n        trimRegex = new RegExp(`(\\\\.[0-9]{${ lastZero }}[1-9]*)0+$`, 'g');\n    }\n\n    return value.replace(trimRegex, '$1').replace(trailingPointRegExp, EMPTY);\n}\n\nfunction roundNumber(formatOptions) {\n    let { number, format } = formatOptions;\n    let decimalIndex = format.indexOf(POINT);\n\n    if (decimalIndex !== -1) {\n        const zeroIndex = format.lastIndexOf(custom_number_format_ZERO) - decimalIndex;\n        const sharpIndex = format.lastIndexOf(SHARP) - decimalIndex;\n        const hasZero = zeroIndex > -1;\n        const hasSharp = sharpIndex > -1;\n        let fraction = number.toString().split(\"e\");\n\n        if (fraction[1]) {\n            fraction = round_round(number, Math.abs(fraction[1]));\n        } else {\n            fraction = fraction[0];\n        }\n        fraction = fraction.split(POINT)[1] || EMPTY;\n\n        let precision = fraction.length;\n        let trailingZeros = -1;\n\n        if (!hasZero && !hasSharp) {\n            formatOptions.format = format.substring(0, decimalIndex) + format.substring(decimalIndex + 1);\n            decimalIndex = -1;\n            precision = 0;\n        } else if (hasZero && zeroIndex > sharpIndex) {\n            precision = zeroIndex;\n        } else if (sharpIndex > zeroIndex) {\n            if (hasSharp && precision > sharpIndex) {\n                precision = sharpIndex;\n            } else if (hasZero && precision < zeroIndex) {\n                precision = zeroIndex;\n            }\n\n            trailingZeros = hasZero ? zeroIndex : 0;\n        }\n\n        if (precision > -1) {\n            number = round_round(number, precision);\n            if (trailingZeros > -1) {\n                number = trimTrailingZeros(number, trailingZeros);\n            }\n        }\n    } else {\n        number = round_round(number);\n    }\n\n    if (formatOptions.negative && (number * -1) >= 0 && !formatOptions.negativeZero) {\n        formatOptions.negative = false;\n    }\n\n    formatOptions.number = number;\n    formatOptions.decimalIndex = decimalIndex;\n}\n\nfunction isConstantFormat(format) {\n    return format.indexOf(SHARP) === -1 && format.indexOf(custom_number_format_ZERO) === -1;\n}\n\nfunction setValueSpecificFormat(formatOptions) {\n    let { number, format } = formatOptions;\n    format = format.split(LIST_SEPARATOR);\n    if ((formatOptions.negative || formatOptions.negativeZero) && format[1]) {\n        format = format[1];\n        formatOptions.hasNegativeFormat = true;\n    } else if (number === 0) {\n        const zeroFormat = format[2];\n        format = zeroFormat || format[0];\n        if (zeroFormat && isConstantFormat(zeroFormat)) {\n            formatOptions.constant = zeroFormat;\n        }\n    } else {\n        format = format[0];\n    }\n\n    formatOptions.format = format;\n}\n\nfunction setGroupOptions(formatOptions) {\n    formatOptions.hasGroup = formatOptions.format.indexOf(GROUP_SEPARATOR) > -1;\n    if (formatOptions.hasGroup) {\n        formatOptions.format = formatOptions.format.replace(commaRegExp, EMPTY);\n    }\n}\n\nfunction placeholderIndex(index1, index2, start) {\n    let index;\n    if (index1 === -1 && index2 !== -1) {\n        index = index2;\n    } else if (index1 !== -1 && index2 === -1) {\n        index = index1;\n    } else {\n        index = start ? Math.min(index1, index2) : Math.max(index1, index2);\n    }\n    return index;\n}\n\nfunction setPlaceholderIndices(formatOptions) {\n    const format = formatOptions.format;\n    let sharpIndex = format.indexOf(SHARP);\n    let zeroIndex = format.indexOf(custom_number_format_ZERO);\n\n    let start = placeholderIndex(sharpIndex, zeroIndex, true);\n\n    sharpIndex = format.lastIndexOf(SHARP);\n    zeroIndex = format.lastIndexOf(custom_number_format_ZERO);\n\n    let end = placeholderIndex(sharpIndex, zeroIndex);\n\n    if (start === format.length) {\n        end = start;\n    }\n\n    formatOptions.start = start;\n    formatOptions.end = end;\n    formatOptions.lastZeroIndex = zeroIndex;\n}\n\nfunction replaceStyleSymbols(number, style, symbol) {\n    let result = number;\n    if (style === CURRENCY || style === PERCENT) {\n        result = EMPTY;\n        for (let idx = 0, length = number.length; idx < length; idx++) {\n            let ch = number.charAt(idx);\n            result += (ch === CURRENCY_PLACEHOLDER || ch === PERCENT_PLACEHOLDER) ? symbol : ch;\n        }\n    }\n    return result;\n}\n\nfunction replacePlaceHolders(formatOptions, info) {\n    const { start, end, negative, negativeZero, format, decimalIndex, lastZeroIndex, hasNegativeFormat, hasGroup } = formatOptions;\n    let number = formatOptions.number;\n    const value = number.toString().split(POINT);\n    const length = format.length;\n    const integer = value[0];\n    const fraction = value[1] || EMPTY;\n    const integerLength = integer.length;\n    let replacement = EMPTY;\n\n    number = format.substring(0, start);\n\n    if ((negative || negativeZero) && !hasNegativeFormat) {\n        number += \"-\";\n    }\n\n    for (let idx = start; idx < length; idx++) {\n        let ch = format.charAt(idx);\n\n        if (decimalIndex === -1) {\n            if (end - idx < integerLength) {\n\n                number += integer;\n                break;\n            }\n        } else {\n            if (lastZeroIndex !== -1 && lastZeroIndex < idx) {\n                replacement = EMPTY;\n            }\n\n            if ((decimalIndex - idx) <= integerLength && decimalIndex - idx > -1) {\n                number += integer;\n                idx = decimalIndex;\n            }\n\n            if (decimalIndex === idx) {\n                number += (fraction ? info.numbers.symbols.decimal : EMPTY) + fraction;\n                idx += end - decimalIndex + 1;\n                continue;\n            }\n        }\n\n        if (ch === custom_number_format_ZERO) {\n            number += ch;\n            replacement = ch;\n        } else if (ch === SHARP) {\n            number += replacement;\n        }\n    }\n\n    if (hasGroup) {\n        number = groupInteger(number, start + (negative && !hasNegativeFormat ? 1 : 0), Math.max(end, (integerLength + start)), info.numbers.decimal, info);\n    }\n\n    if (end >= start) {\n        number += format.substring(end + 1);\n    }\n\n    return number;\n}\n\nfunction applyCustomFormat(formatOptions, info) {\n    let number = formatOptions.number;\n    if (formatOptions.start !== -1) {\n        number = replacePlaceHolders(formatOptions, info);\n        number = replaceStyleSymbols(number, formatOptions.style, formatOptions.symbol);\n        number = replaceLiterals(number, formatOptions.literals);\n    }\n\n    return number;\n}\n\nfunction customNumberFormat(number, format, info) {\n    const formatOptions = {\n        negative: number < 0,\n        number: Math.abs(number),\n        negativeZero: isNegativeZero(number),\n        format: format\n    };\n\n    setValueSpecificFormat(formatOptions);\n\n    if (formatOptions.constant) {\n        return formatOptions.constant;\n    }\n\n    setFormatLiterals(formatOptions);\n    setStyleOptions(formatOptions, info);\n    setGroupOptions(formatOptions);\n    roundNumber(formatOptions);\n    setPlaceholderIndices(formatOptions);\n\n    return applyCustomFormat(formatOptions, info);\n}\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/numbers/format-options.js\n\n\n\nconst standardFormatRegExp = /^(n|c|p|e|a)(\\d*)$/i;\n\nfunction standardFormatOptions(format) {\n    const formatAndPrecision = standardFormatRegExp.exec(format);\n\n    if (formatAndPrecision) {\n        const options = {\n            style: DECIMAL\n        };\n\n        let style = formatAndPrecision[1].toLowerCase();\n\n        if (style === \"c\") {\n            options.style = CURRENCY;\n        } else if (style === \"a\") {\n            options.style = ACCOUNTING;\n        } else if (style === \"p\") {\n            options.style = PERCENT;\n        } else if (style === \"e\") {\n            options.style = SCIENTIFIC;\n        }\n\n        if (formatAndPrecision[2]) {\n            options.minimumFractionDigits = options.maximumFractionDigits = parseInt(formatAndPrecision[2], 10);\n        }\n\n        return options;\n    }\n}\n\nfunction format_options_formatOptions(format) {\n    let options;\n    if (is_string_isString(format)) {\n        options = standardFormatOptions(format);\n    } else {\n        options = format;\n    }\n\n    return options;\n}\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/numbers/format-number.js\n\n\n\n\n\n\nfunction formatNumber(number, format = NUMBER_PLACEHOLDER, locale = DEFAULT_LOCALE) {\n    if (number === undefined || number === null) {\n        return EMPTY;\n    }\n\n    if (!isFinite(number)) {\n        return String(number);\n    }\n\n    const info = info_localeInfo(locale);\n    const options = format_options_formatOptions(format);\n\n    let result;\n    if (options) {\n        const style = options.style || DECIMAL;\n        result = standardNumberFormat(number, Object.assign({}, info.numbers[style], options), info);\n    } else {\n        result = customNumberFormat(number, format, info);\n    }\n\n    return result;\n}\n\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/common/is-number.js\nfunction is_number_isNumber(value) {\n    return typeof value === \"number\";\n}\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/numbers/parse-number.js\n\n\n\n\n\n\n\n\nconst exponentRegExp = /[eE][\\-+]?[0-9]+/;\nconst nonBreakingSpaceRegExp = /\\u00A0/g;\n\nfunction cleanNegativePattern(number, patterns) {\n    if (patterns.length > 1) {\n        const parts = (patterns[1] || EMPTY).replace(CURRENCY_PLACEHOLDER, EMPTY).split(NUMBER_PLACEHOLDER);\n        if (number.indexOf(parts[0]) > -1 && number.indexOf(parts[1]) > -1) {\n            return number.replace(parts[0], EMPTY).replace(parts[1], EMPTY);\n        }\n    }\n}\n\nfunction cleanCurrencyNumber(value, info, format) {\n    const options = format_options_formatOptions(format) || {};\n    let isCurrency = isCurrencyStyle(options.style);\n    let number = value;\n    let negative;\n\n    const currency = options.currency || localeCurrency(info, isCurrency);\n\n    if (currency) {\n        const displays = currencyDisplays(info, currency, isCurrency);\n        if (displays) {\n            for (let idx = 0; idx < displays.length; idx++) {\n                let display = displays[idx];\n                if (number.includes(display)) {\n                    number = number.replace(display, EMPTY);\n                    isCurrency = true;\n                    break;\n                }\n            }\n        }\n\n        if (isCurrency) {\n            const cleanNumber = cleanNegativePattern(number, info.numbers.currency.patterns) ||\n                cleanNegativePattern(number, info.numbers.accounting.patterns);\n\n            if (cleanNumber) {\n                negative = true;\n                number = cleanNumber;\n            }\n\n        }\n    }\n\n    return {\n        number: number,\n        negative: negative\n    };\n}\n\nfunction cleanLiterals(number, formatOptions) {\n    const literals = formatOptions.literals;\n    let result = number;\n\n    if (literals) {\n        for (let idx = 0; idx < literals.length; idx++) {\n            result = result.replace(literals[idx], EMPTY);\n        }\n    }\n\n    return result;\n}\n\nfunction parseNumber(value, locale = DEFAULT_LOCALE, format = {}) {\n    if (!value && value !== 0) {\n        return null;\n    }\n\n    if (is_number_isNumber(value)) {\n        return value;\n    }\n\n    const info = info_localeInfo(locale);\n    const symbols = info.numbers.symbols;\n\n    let number = value.toString();\n    let formatOptions = format || {};\n    let isPercent;\n\n    if (is_string_isString(format)) {\n        formatOptions = { format: format };\n        setFormatLiterals(formatOptions);\n        number = cleanLiterals(number, formatOptions);\n\n        setStyleOptions(formatOptions, info);\n    }\n\n    if (formatOptions.style === PERCENT || number.indexOf(symbols.percentSign) > -1) {\n        number = number.replace(symbols.percentSign, EMPTY);\n        isPercent = true;\n    }\n\n    if (exponentRegExp.test(number)) {\n        number = parseFloat(number.replace(symbols.decimal, POINT));\n        return isNaN(number) ? null : number;\n    }\n\n    const { negative: negativeCurrency, number: currencyNumber } = cleanCurrencyNumber(number, info, formatOptions);\n    number = String(currencyNumber).trim();\n\n    const negativeSignIndex = number.indexOf(\"-\");\n    if (negativeSignIndex > 0) {\n        return null;\n    }\n\n    let isNegative = negativeSignIndex > -1;\n\n    isNegative = negativeCurrency !== undefined ? negativeCurrency : isNegative;\n\n    number = number.replace(\"-\", EMPTY)\n          .replace(nonBreakingSpaceRegExp, \" \")\n          .split(symbols.group.replace(nonBreakingSpaceRegExp, \" \")).join(EMPTY)\n          .replace(symbols.decimal, POINT);\n\n    number = parseFloat(number);\n\n    if (isNaN(number)) {\n        number = null;\n    } else if (isNegative) {\n        number *= -1;\n    }\n\n    if (number && isPercent) {\n        number /= 100;\n    }\n\n    return number;\n}\n\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/numbers.js\n\n\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/common/format-string.js\nconst format_string_formatRegExp = /\\{(\\d+)}/g;\n\nfunction format_string_formatString(format) {\n    const values = arguments;\n\n    return format.replace(format_string_formatRegExp, (match, index) => {\n        const value = values[parseInt(index, 10) + 1];\n\n        return value;\n    });\n}\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/dates/date-pattern.js\n\n\n\n\nconst REMOVAL_PENALTY = 120;\nconst ADDITION_PENALTY = 20;\nconst LENGHT_DELTA = [ 2, 1, 5, 3, 4 ];\nconst LONG_LESS_PENALTY_DELTA = -2;\nconst SHORT_LESS_PENALTY_DELTA = -1;\nconst SHORT_MORE_PENALTY_DELTA = 1;\nconst LONG_MORE_PENALTY_DELTA = 2;\n\nconst PENALTIES = {\n    [LONG_LESS_PENALTY_DELTA.toString()]: 8,\n    [SHORT_LESS_PENALTY_DELTA.toString()]: 6,\n    [LONG_MORE_PENALTY_DELTA.toString()]: 6,\n    [SHORT_MORE_PENALTY_DELTA.toString()]: 3\n};\n\nconst VALUE_FORMAT_LENGTH = {\n    numeric: 1,\n    \"2-digit\": 2,\n    short: 3,\n    long: 4,\n    narrow: 5\n};\n\nconst TIME_SPECIFIERS_REGEX = /[hHmsSzZoOvVxX]/;\n\nfunction getHourSpecifier(options) {\n    return options.hour12 ? \"h\" : \"H\";\n}\n\nconst DATE_OPTIONS_MAP = [ {\n    key: \"era\",\n    specifier: \"G\"\n}, {\n    key: \"year\",\n    specifier: \"y\"\n}, {\n    key: \"month\",\n    specifier: \"M\"\n}, {\n    key: \"day\",\n    specifier: \"d\"\n}, {\n    key: \"weekday\",\n    specifier: \"E\"\n}, {\n    key: \"hour\",\n    getSpecifier: getHourSpecifier\n}, {\n    key: \"minute\",\n    specifier: \"m\"\n}, {\n    key: \"second\",\n    specifier: \"s\"\n}, {\n    key: \"timeZoneName\",\n    specifier: \"z\"\n} ];\n\nconst STAND_ALONE_SPECIFIERS = {\n    e: 'c',\n    E: 'c',\n    M: 'L',\n    Q: 'q'\n};\n\nconst specifiersRegex = {};\nconst resolvedFormats = {};\n\nfunction getSpecifierRegex(specifier) {\n    if (!specifiersRegex[specifier]) {\n        specifiersRegex[specifier] = new RegExp(specifier + \"+\");\n    }\n    return specifiersRegex[specifier];\n}\n\nfunction skeletonSpecifiers(skeleton) {\n    const result = [];\n    let current = skeleton.charAt(0);\n    let specifier = current;\n    for (let idx = 1; idx < skeleton.length; idx++) {\n        let character = skeleton.charAt(idx);\n        if (character === specifier) {\n            current += character;\n        } else {\n            result.push(current);\n            current = specifier = character;\n        }\n    }\n\n    result.push(current);\n\n    return result;\n}\n\nfunction findBestMatch(specifiers, availableFormats) {\n    const specifiersLength = specifiers.length;\n    let maxScore = -Number.MAX_VALUE;\n    let bestMatches, result;\n    for (let format in availableFormats) {\n        const matches = [];\n        let currentFormat = format.replace(\"v\", \"z\");\n        let score = 0;\n        for (let idx = 0; idx < specifiersLength; idx++) {\n            const specifier = specifiers[idx];\n            let specifierRegex = getSpecifierRegex(specifier[0]);\n            let match = (specifierRegex.exec(currentFormat) || [])[0];\n\n            if (!match) {\n                score -= REMOVAL_PENALTY;\n            } else {\n                currentFormat = currentFormat.replace(match, EMPTY);\n                if (match.length !== specifier.length) {\n                    let delta = Math.max(Math.min(LENGHT_DELTA[match.length] - LENGHT_DELTA[specifier.length], 2), -2);\n                    score -= PENALTIES[delta];\n                }\n            }\n\n            matches.push(match);\n\n            if (score < maxScore) {\n                break;\n            }\n        }\n\n        if (currentFormat.length) {\n            score -= skeletonSpecifiers(currentFormat).length * ADDITION_PENALTY;\n        }\n\n        if (score > maxScore) {\n            maxScore = score;\n            bestMatches = matches;\n            result = availableFormats[format];\n        }\n    }\n\n    result = result.replace(\"v\", \"z\");\n\n    for (let idx = 0; idx < specifiersLength; idx++) {\n        const bestMatch = bestMatches[idx];\n        if (bestMatch && bestMatch !== specifiers[idx]) {\n            const matchSpecifier = bestMatches[idx][0];\n            result = result.replace(getSpecifierRegex(matchSpecifier), specifiers[idx]);\n            if (STAND_ALONE_SPECIFIERS[matchSpecifier]) {\n                result = result.replace(getSpecifierRegex(STAND_ALONE_SPECIFIERS[matchSpecifier]), specifiers[idx]);\n            }\n        }\n    }\n\n    return result;\n}\n\nfunction cacheFormat(skeleton, format, locale) {\n    if (!resolvedFormats[locale]) {\n        resolvedFormats[locale] = {};\n    }\n    resolvedFormats[locale][skeleton] = format;\n}\n\n\nfunction skeletonFormat(skeleton, info) {\n    const availableFormats = info.calendar.dateTimeFormats.availableFormats;\n    if (availableFormats[skeleton]) {\n        return availableFormats[skeleton];\n    }\n    if (resolvedFormats[info.name] && resolvedFormats[info.name][skeleton]) {\n        return resolvedFormats[info.name][skeleton];\n    }\n    const timeStartIndex = skeleton.search(TIME_SPECIFIERS_REGEX);\n    let result;\n    if (timeStartIndex > 0) {\n        const dateSkeleton = skeleton.substr(0, timeStartIndex);\n        const timeSkeleton = skeleton.substr(timeStartIndex);\n\n        result = format_string_formatString(info.calendar.dateTimeFormats.short, //should be deterimed based on specifiers\n            availableFormats[timeSkeleton] || findBestMatch(skeletonSpecifiers(timeSkeleton), availableFormats),\n            availableFormats[dateSkeleton] || findBestMatch(skeletonSpecifiers(dateSkeleton), availableFormats));\n    } else {\n        result = findBestMatch(skeletonSpecifiers(skeleton), availableFormats);\n    }\n\n    cacheFormat(skeleton, result, info.name);\n    return result;\n}\n\nfunction skeletonFromOptions(options) {\n    let result = [];\n    for (let idx = 0; idx < DATE_OPTIONS_MAP.length; idx++) {\n        let option = DATE_OPTIONS_MAP[idx];\n        let field = option.key;\n        let value = options[field];\n        if (value) {\n            let spcifier = option.specifier || option.getSpecifier(options);\n            result.push(spcifier.repeat(VALUE_FORMAT_LENGTH[value]));\n        }\n    }\n\n    return result.join(EMPTY);\n}\n\nfunction datePattern(format, info) {\n    const calendar = info.calendar;\n    let result;\n    if (is_string_isString(format)) {\n        if (calendar.patterns[format]) {\n            result = calendar.patterns[format];\n        } else {\n            result = format;\n        }\n    } else if (format) {\n        if (format.pattern) {\n            return format.pattern;\n        }\n\n        let skeleton = format.skeleton;\n        if (!skeleton) {\n            if (format.datetime) {\n                result = format_string_formatString(calendar.dateTimeFormats[format.datetime], calendar.timeFormats[format.datetime], calendar.dateFormats[format.datetime]);\n            } else if (format.date) {\n                result = calendar.dateFormats[format.date];\n            } else if (format.time) {\n                result = calendar.timeFormats[format.time];\n            } else {\n                skeleton = skeletonFromOptions(format);\n            }\n        }\n\n        if (skeleton) {\n            result = skeletonFormat(skeleton, info);\n        }\n    }\n\n    if (!result) {\n        result = calendar.patterns.d;\n    }\n\n    return result;\n}\n\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/dates/date-name-type.js\nfunction dateNameType(formatLength) {\n    let nameType;\n    if (formatLength <= 3) {\n        nameType = \"abbreviated\";\n    } else if (formatLength === 4) {\n        nameType = \"wide\";\n    } else if (formatLength === 5) {\n        nameType = \"narrow\";\n    } else if (formatLength === 6) {\n        nameType = \"short\";\n    }\n\n    return nameType;\n}\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/dates/format-names.js\n\n\n\nfunction format_names_formatNames(locale, type, formatLength, standAlone, lower) {\n    return dateFormatNames(locale, {\n        type: type,\n        nameType: dateNameType(formatLength),\n        standAlone: standAlone,\n        lower: lower\n    });\n}\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/common/is-date.js\nfunction is_date_isFunction(fun) {\n    return typeof(fun) === 'function';\n}\n\nfunction isDate(value) {\n    return Boolean(value) && is_date_isFunction(value.getTime) && is_date_isFunction(value.getMonth);\n}\n\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/dates/constants.js\nconst MONTH = 'month';\nconst HOUR = 'hour';\nconst ZONE = 'zone';\nconst WEEKDAY = 'weekday';\nconst QUARTER = 'quarter';\n\nconst DATE_FIELD_MAP = {\n    'G': 'era',\n    'y': 'year',\n    'q': QUARTER,\n    'Q': QUARTER,\n    'M': MONTH,\n    'L': MONTH,\n    'd': 'day',\n    'E': WEEKDAY,\n    'c': WEEKDAY,\n    'e': WEEKDAY,\n    'h': HOUR,\n    'H': HOUR,\n    'k': HOUR,\n    'K': HOUR,\n    'm': 'minute',\n    's': 'second',\n    'S': 'millisecond',\n    'a': 'dayperiod',\n    'x': ZONE,\n    'X': ZONE,\n    'z': ZONE,\n    'Z': ZONE\n};\n\nconst dateFormatRegExp = /d{1,2}|E{1,6}|e{1,6}|c{3,6}|c{1}|M{1,5}|L{1,5}|y{1,4}|H{1,2}|h{1,2}|k{1,2}|K{1,2}|m{1,2}|a{1,5}|s{1,2}|S{1,3}|z{1,4}|Z{1,5}|x{1,5}|X{1,5}|G{1,5}|q{1,5}|Q{1,5}|\"[^\"]*\"|'[^']*'/g;\n\n\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/dates/format-date.js\n\n\n\n\n\n\n\n\n\nfunction formatDayOfWeekIndex(day, formatLength, localeInfo) {\n    const firstDayIndex = cldr_first_day_firstDay(localeInfo);\n    let dayIndex;\n    if (day < firstDayIndex) {\n        dayIndex = 7 - firstDayIndex + day;\n    } else {\n        dayIndex = day - firstDayIndex;\n    }\n\n    return dayIndex + 1;\n}\n\nfunction formatMonth(month, formatLength, info, standAlone) {\n    if (formatLength <= 2) {\n        return pad_pad(month + 1, formatLength);\n    }\n    return format_names_formatNames(info, \"months\", formatLength, standAlone)[month];\n}\n\nfunction formatQuarter(date, formatLength, info, standAlone) {\n    const quarter = Math.floor(date.getMonth() / 3);\n    if (formatLength < 3) {\n        return quarter + 1;\n    }\n\n    return format_names_formatNames(info, \"quarters\", formatLength, standAlone)[quarter];\n}\n\n\nfunction formatTimeZone(date, info, options) {\n    const { shortHours, optionalMinutes, separator, localizedName, zZeroOffset } = options;\n    const offset = date.getTimezoneOffset() / 60;\n    if (offset === 0 && zZeroOffset) {\n        return \"Z\";\n    }\n    const sign = offset <= 0 ? \"+\" : \"-\";\n    const hoursMinutes = Math.abs(offset).toString().split(\".\");\n    const minutes = hoursMinutes[1] || 0;\n    let result = sign + (shortHours ? hoursMinutes[0] : pad_pad(hoursMinutes[0], 2));\n    if (minutes || !optionalMinutes) {\n        result += (separator ? \":\" : EMPTY) + pad_pad(minutes, 2);\n    }\n\n    if (localizedName) {\n        const localizedFormat = offset === 0 ? info.calendar.gmtZeroFormat : info.calendar.gmtFormat;\n        result = format_string_formatString(localizedFormat, result);\n    }\n\n    return result;\n}\n\nfunction formatDayOfWeek(date, formatLength, info, standAlone) {\n    let result;\n    if (formatLength < 3) {\n        result = formatDayOfWeekIndex(date.getDay(), formatLength, info);\n    } else {\n        result = format_names_formatNames(info, \"days\", formatLength, standAlone)[date.getDay()];\n    }\n    return result;\n}\n\nconst formatters = {};\n\nformatters.d = function(date, formatLength) {\n    return pad_pad(date.getDate(), formatLength);\n};\n\nformatters.E = function(date, formatLength, info) {\n    return format_names_formatNames(info, \"days\", formatLength)[date.getDay()];\n};\n\nformatters.M = function(date, formatLength, info) {\n    return formatMonth(date.getMonth(), formatLength, info, false);\n};\n\nformatters.L = function(date, formatLength, info) {\n    return formatMonth(date.getMonth(), formatLength, info, true);\n};\n\nformatters.y = function(date, formatLength) {\n    let year = date.getFullYear();\n    if (formatLength === 2) {\n        year = year % 100;\n    }\n    return pad_pad(year, formatLength);\n};\n\nformatters.h = function(date, formatLength) {\n    const hours = date.getHours() % 12 || 12;\n    return pad_pad(hours, formatLength);\n};\n\nformatters.H = function(date, formatLength) {\n    return pad_pad(date.getHours(), formatLength);\n};\n\nformatters.k = function(date, formatLength) {\n    return pad_pad(date.getHours() || 24, formatLength);\n};\n\nformatters.K = function(date, formatLength) {\n    return pad_pad(date.getHours() % 12, formatLength);\n};\n\nformatters.m = function(date, formatLength) {\n    return pad_pad(date.getMinutes(), formatLength);\n};\n\nformatters.s = function(date, formatLength) {\n    return pad_pad(date.getSeconds(), formatLength);\n};\n\nformatters.S = function(date, formatLength) {\n    const milliseconds = date.getMilliseconds();\n    let result;\n    if (milliseconds !== 0) {\n        result = pad_pad(String(milliseconds / 1000).split(\".\")[1].substr(0, formatLength), formatLength, true);\n    } else {\n        result = pad_pad(EMPTY, formatLength);\n    }\n    return result;\n};\n\nformatters.a = function(date, formatLength, info) {\n    return format_names_formatNames(info, \"dayPeriods\", formatLength)[date.getHours() < 12 ? \"am\" : \"pm\"];\n};\n\nformatters.z = function(date, formatLength, info) {\n    return formatTimeZone(date, info, {\n        shortHours: formatLength < 4,\n        optionalMinutes: formatLength < 4,\n        separator: true,\n        localizedName: true\n    });\n};\n\nformatters.Z = function(date, formatLength, info) {\n    return formatTimeZone(date, info, {\n        separator: formatLength > 3,\n        localizedName: formatLength === 4,\n        zZeroOffset: formatLength === 5\n    });\n};\n\nformatters.x = function(date, formatLength, info) {\n    return formatTimeZone(date, info, {\n        optionalMinutes: formatLength === 1,\n        separator: formatLength === 3 || formatLength === 5\n    });\n};\n\nformatters.X = function(date, formatLength, info) {\n    return formatTimeZone(date, info, {\n        optionalMinutes: formatLength === 1,\n        separator: formatLength === 3 || formatLength === 5,\n        zZeroOffset: true\n    });\n};\n\nformatters.G = function(date, formatLength, info) {\n    let era = date.getFullYear() >= 0 ? 1 : 0;\n    return format_names_formatNames(info, \"eras\", formatLength)[era];\n};\n\nformatters.e = formatDayOfWeek;\n\nformatters.c = function(date, formatLength, info) {\n    return formatDayOfWeek(date, formatLength, info, true);\n};\n\nformatters.q = function(date, formatLength, info) {\n    return formatQuarter(date, formatLength, info, true);\n};\n\nformatters.Q = formatQuarter;\n\nfunction formatDate(date, format, locale = DEFAULT_LOCALE) {\n    if (!isDate(date)) {\n        if (date === undefined || date === null) {\n            return EMPTY;\n        }\n        return date;\n    }\n\n    const info = info_localeInfo(locale);\n    const pattern = datePattern(format, info);\n\n    return pattern.replace(dateFormatRegExp, function(match) {\n        let formatLength = match.length;\n        let result;\n\n        if (match.includes(\"'\") || match.includes(\"\\\"\")) {\n            result = match.slice(1, formatLength - 1);\n        } else {\n            result = formatters[match[0]](date, formatLength, info);\n        }\n\n        return result;\n    });\n}\n\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/dates/time-utils.js\nfunction convertTimeZone(date, fromOffset, toOffset) {\n    const fromLocalOffset = date.getTimezoneOffset();\n\n    const offsetDate = new Date(date.getTime() + (fromOffset - toOffset) * 60000);\n\n    const toLocalOffset = offsetDate.getTimezoneOffset();\n\n    return new Date(offsetDate.getTime() + (toLocalOffset - fromLocalOffset) * 60000);\n}\n\nfunction time_utils_adjustDST(date, hours) {\n    if (!hours && date.getHours() === 23) {\n        date.setHours(date.getHours() + 2);\n    }\n}\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/dates/parse-date.js\n\n\n\n\n\n\n\n\n\nconst timeZoneOffsetRegExp = /([+|\\-]\\d{1,2})(:?)(\\d{2})?/;\nconst dateRegExp = /^\\/Date\\((.*?)\\)\\/$/;\nconst offsetRegExp = /[+-]\\d*/;\nconst numberRegExp = {\n    2: /^\\d{1,2}/,\n    3: /^\\d{1,3}/,\n    4: /^\\d{4}/\n};\nconst numberRegex = /\\d+/;\nconst parse_date_PLACEHOLDER = \"{0}\";\n\nconst leadingSpacesRegex = /^ */;\nconst trailingSpacesRegex = / *$/;\n\nconst standardDateFormats = [\n    \"yyyy/MM/dd HH:mm:ss\",\n    \"yyyy/MM/dd HH:mm\",\n    \"yyyy/MM/dd\",\n    \"E MMM dd yyyy HH:mm:ss\",\n    \"yyyy-MM-ddTHH:mm:ss.SSSSSSSXXX\",\n    \"yyyy-MM-ddTHH:mm:ss.SSSXXX\",\n    \"yyyy-MM-ddTHH:mm:ss.SSXXX\",\n    \"yyyy-MM-ddTHH:mm:ssXXX\",\n    \"yyyy-MM-ddTHH:mm:ss.SSSSSSS\",\n    \"yyyy-MM-ddTHH:mm:ss.SSS\",\n    \"yyyy-MM-ddTHH:mmXXX\",\n    \"yyyy-MM-ddTHH:mmX\",\n    \"yyyy-MM-ddTHH:mm:ss\",\n    \"yyyy-MM-ddTHH:mm\",\n    \"yyyy-MM-dd HH:mm:ss\",\n    \"yyyy-MM-dd HH:mm\",\n    \"yyyy-MM-dd\",\n    \"HH:mm:ss\",\n    \"HH:mm\"\n];\nconst FORMATS_SEQUENCE = [ \"G\", \"g\", \"F\", \"Y\", \"y\", \"M\", \"m\", \"D\", \"d\", \"y\", \"T\", \"t\" ];\nconst TWO_DIGIT_YEAR_MAX = 2029;\n\nfunction outOfRange(value, start, end) {\n    return !(value >= start && value <= end);\n}\n\nfunction lookAhead(match, state) {\n    let { format, idx } = state;\n    let i = 0;\n    while (format[idx] === match) {\n        i++;\n        idx++;\n    }\n    if (i > 0) {\n        idx -= 1;\n    }\n    state.idx = idx;\n    return i;\n}\n\nfunction getNumber(size, state) {\n    let regex = size ? (numberRegExp[size] || new RegExp('^\\\\d{1,' + size + '}')) : numberRegex,\n        match = state.value.substr(state.valueIdx, size).match(regex);\n\n    if (match) {\n        match = match[0];\n        state.valueIdx += match.length;\n        return parseInt(match, 10);\n    }\n    return null;\n}\n\nfunction getIndexByName(names, state, lower) {\n    let i = 0,\n        length = names.length,\n        name, nameLength,\n        matchLength = 0,\n        matchIdx = 0,\n        subValue;\n\n    for (; i < length; i++) {\n        name = names[i];\n        nameLength = name.length;\n        subValue = state.value.substr(state.valueIdx, nameLength);\n\n        if (lower) {\n            subValue = subValue.toLowerCase();\n        }\n\n        if (subValue === name && nameLength > matchLength) {\n            matchLength = nameLength;\n            matchIdx = i;\n        }\n    }\n\n    if (matchLength) {\n        state.valueIdx += matchLength;\n        return matchIdx + 1;\n    }\n\n    return null;\n}\n\nfunction checkLiteral(state) {\n    let result = false;\n    if (state.value.charAt(state.valueIdx) === state.format[state.idx]) {\n        state.valueIdx++;\n        result = true;\n    }\n    return result;\n}\n\nfunction calendarGmtFormats(calendar) {\n    const { gmtFormat, gmtZeroFormat } = calendar;\n    if (!gmtFormat) {\n        throw errors.NoGMTInfo.error();\n    }\n\n    return [ gmtFormat.replace(parse_date_PLACEHOLDER, EMPTY).toLowerCase(), gmtZeroFormat.replace(parse_date_PLACEHOLDER, EMPTY).toLowerCase() ];\n}\n\nfunction parseTimeZoneOffset(state, info, options) {\n    const { shortHours, noSeparator, optionalMinutes, localizedName, zLiteral } = options;\n    state.UTC = true;\n\n    if (zLiteral && state.value.charAt(state.valueIdx) === \"Z\") {\n        state.valueIdx++;\n        return false;\n    }\n\n    if (localizedName && !getIndexByName(calendarGmtFormats(info.calendar), state, true)) {\n        return true;\n    }\n\n    const matches = timeZoneOffsetRegExp.exec(state.value.substr(state.valueIdx, 6));\n    if (!matches) {\n        return !localizedName;\n    }\n\n    const hoursMatch = matches[1];\n    const minutesMatch = matches[3];\n    const hoursOffset = parseInt(hoursMatch, 10);\n    const separator = matches[2];\n    let minutesOffset = parseInt(minutesMatch, 10);\n\n    if (isNaN(hoursOffset) || (!shortHours && hoursMatch.length !== 3) || (!optionalMinutes && isNaN(minutesOffset)) || (noSeparator && separator)) {\n        return true;\n    }\n\n    if (isNaN(minutesOffset)) {\n        minutesOffset = null;\n    }\n\n    if (outOfRange(hoursOffset, -12, 13) || (minutesOffset && outOfRange(minutesOffset, 0, 59))) {\n        return true;\n    }\n\n    state.valueIdx += matches[0].length;\n    state.hoursOffset = hoursOffset;\n    state.minutesOffset = minutesOffset;\n}\n\nfunction parseMonth(ch, state, info) {\n    const count = lookAhead(ch, state);\n    const names = format_names_formatNames(info, \"months\", count, ch === \"L\", true);\n\n    const month = count < 3 ? getNumber(2, state) : getIndexByName(names, state, true);\n\n    if (month === null || outOfRange(month, 1, 12)) {\n        return true;\n    }\n    state.month = month - 1;\n}\n\nfunction parseDayOfWeek(ch, state, info) {\n    const count = lookAhead(ch, state);\n    const names = format_names_formatNames(info, \"days\", count, ch === \"c\", true);\n    let dayOfWeek = count < 3 ? getNumber(1, state) : getIndexByName(names, state, true);\n    if ((!dayOfWeek && dayOfWeek !== 0) || outOfRange(dayOfWeek, 1, 7)) {\n        return true;\n    }\n}\n\nconst parsers = {};\n\nparsers.d = function(state) {\n    lookAhead(\"d\", state);\n    const day = getNumber(2, state);\n\n    if (day === null || outOfRange(day, 1, 31)) {\n        return true;\n    }\n\n    if (state.day === null) {\n        state.day = day;\n    }\n};\n\nparsers.E = function(state, info) {\n    const count = lookAhead(\"E\", state);\n    //validate if it matches the day?\n    let dayOfWeek = getIndexByName(format_names_formatNames(info, \"days\", count, false, true), state, true);\n    if (dayOfWeek === null) {\n        return true;\n    }\n};\n\nparsers.M = function(state, info) {\n    return parseMonth(\"M\", state, info);\n};\n\nparsers.L = function(state, info) {\n    return parseMonth(\"L\", state, info);\n};\n\nparsers.y = function(state) {\n    const count = lookAhead(\"y\", state);\n    let year = getNumber(count === 1 ? undefined : count, state);\n\n    if (year === null) {\n        return true;\n    }\n\n    if (count === 2) {\n        const currentYear = new Date().getFullYear();\n        year = (currentYear - currentYear % 100) + year;\n        if (year > TWO_DIGIT_YEAR_MAX) {\n            year -= 100;\n        }\n    }\n\n    state.year = year;\n};\n\nparsers.h = function(state) {\n    lookAhead(\"h\", state);\n\n    let hours = getNumber(2, state);\n    if (hours === 12) {\n        hours = 0;\n    }\n\n    if (hours === null || outOfRange(hours, 0, 11)) {\n        return true;\n    }\n\n    state.hours = hours;\n};\n\nparsers.K = function(state) {\n    lookAhead(\"K\", state);\n\n    let hours = getNumber(2, state);\n\n    if (hours === null || outOfRange(hours, 0, 11)) {\n        return true;\n    }\n\n    state.hours = hours;\n};\n\nparsers.a = function(state, info) {\n    const count = lookAhead(\"a\", state);\n    let periodFormats = format_names_formatNames(info, \"dayPeriods\", count, false, true);\n\n    const pmHour = getIndexByName([ periodFormats.pm ], state, true);\n    if (!pmHour && !getIndexByName([ periodFormats.am ], state, true)) {\n        return true;\n    }\n\n    state.pmHour = pmHour;\n};\n\nparsers.H = function(state) {\n    lookAhead(\"H\", state);\n    const hours = getNumber(2, state);\n    if (hours === null || outOfRange(hours, 0, 23)) {\n        return true;\n    }\n    state.hours = hours;\n};\n\nparsers.k = function(state) {\n    lookAhead(\"k\", state);\n\n    let hours = getNumber(2, state);\n\n    if (hours === null || outOfRange(hours, 1, 24)) {\n        return true;\n    }\n\n    state.hours = hours === 24 ? 0 : hours;\n};\n\nparsers.m = function(state) {\n    lookAhead(\"m\", state);\n    const minutes = getNumber(2, state);\n\n    if (minutes === null || outOfRange(minutes, 0, 59)) {\n        return true;\n    }\n\n    state.minutes = minutes;\n};\n\nparsers.s = function(state) {\n    lookAhead(\"s\", state);\n    const seconds = getNumber(2, state);\n    if (seconds === null || outOfRange(seconds, 0, 59)) {\n        return true;\n    }\n    state.seconds = seconds;\n};\n\nparsers.S = function(state) {\n    const count = lookAhead(\"S\", state);\n    const match = state.value.substr(state.valueIdx, count);\n    let milliseconds = null;\n\n    if (!isNaN(parseInt(match, 10))) {\n        milliseconds = parseFloat(\"0.\" + match, 10);\n        milliseconds = round_round(milliseconds, 3);\n        milliseconds *= 1000;\n        state.valueIdx += count;\n    }\n\n    if (milliseconds === null || outOfRange(milliseconds, 0, 999)) {\n        return true;\n    }\n\n    state.milliseconds = milliseconds;\n};\n\nparsers.z = function(state, info) {\n    const count = lookAhead(\"z\", state);\n\n    const shortFormat = count < 4;\n\n    const invalid = parseTimeZoneOffset(state, info, {\n        shortHours: shortFormat,\n        optionalMinutes: shortFormat,\n        localizedName: true\n    });\n\n    if (invalid) {\n        return invalid;\n    }\n};\n\nparsers.Z = function(state, info) {\n    const count = lookAhead(\"Z\", state);\n\n    const invalid = parseTimeZoneOffset(state, info, {\n        noSeparator: count < 4,\n        zLiteral: count === 5,\n        localizedName: count === 4\n    });\n\n    if (invalid) {\n        return invalid;\n    }\n};\n\nparsers.x = function(state, info) {\n    const count = lookAhead(\"x\", state);\n\n    const invalid = parseTimeZoneOffset(state, info, {\n        noSeparator: count !== 3 && count !== 5,\n        optionalMinutes: count === 1\n    });\n    if (invalid) {\n        return invalid;\n    }\n};\n\nparsers.X = function(state, info) {\n    const count = lookAhead(\"X\", state);\n\n    const invalid = parseTimeZoneOffset(state, info, {\n        noSeparator: count !== 3 && count !== 5,\n        optionalMinutes: count === 1,\n        zLiteral: true\n    });\n    if (invalid) {\n        return invalid;\n    }\n};\n\nparsers.G = function(state, info) {\n    const count = lookAhead(\"G\", state);\n    const eras = format_names_formatNames(info, \"eras\", count, false, true);\n    const era = getIndexByName([ eras[0], eras[1] ], state, true);\n\n    if (era === null) {\n        return true;\n    }\n};\n\nparsers.e = function(state, info) {\n    return parseDayOfWeek(\"e\", state, info);\n};\n\nparsers.c = function(state, info) {\n    return parseDayOfWeek(\"c\", state, info);\n};\n\nfunction createDate(state) {\n    let { year, month, day, hours, minutes, seconds, milliseconds, pmHour, UTC, hoursOffset, minutesOffset } = state;\n    const hasTime = hours !== null || minutes !== null || seconds || null;\n    const date = new Date();\n    let result;\n\n    if (year === null && month === null && day === null && hasTime) {\n        year = date.getFullYear();\n        month = date.getMonth();\n        day = date.getDate();\n    } else {\n        if (year === null) {\n            year = date.getFullYear();\n        }\n\n        if (day === null) {\n            day = 1;\n        }\n    }\n\n    if (pmHour && hours < 12) {\n        hours += 12;\n    }\n\n    if (UTC) {\n        if (hoursOffset) {\n            hours += -hoursOffset;\n        }\n\n        if (minutesOffset) {\n            minutes += -minutesOffset * (hoursOffset < 0 ? -1 : 1);\n        }\n\n        result = new Date(Date.UTC(year, month, day, hours, minutes, seconds, milliseconds));\n    } else {\n        result = new Date(year, month, day, hours, minutes, seconds, milliseconds);\n        time_utils_adjustDST(result, hours);\n    }\n\n    if (year < 100) {\n        result.setFullYear(year);\n    }\n\n    if (result.getDate() !== day && UTC === undefined) {\n        return null;\n    }\n\n    return result;\n}\n\nfunction addFormatSpaces(value, format) {\n    const leadingSpaces = leadingSpacesRegex.exec(format)[0];\n    const trailingSpaces = trailingSpacesRegex.exec(format)[0];\n\n    return `${ leadingSpaces }${ value }${ trailingSpaces }`;\n}\n\nfunction parseExact(value, format, info) {\n    let pattern = datePattern(format, info).split(EMPTY);\n\n    const state = {\n        format: pattern,\n        idx: 0,\n        value: addFormatSpaces(value, format),\n        valueIdx: 0,\n        year: null,\n        month: null,\n        day: null,\n        hours: null,\n        minutes: null,\n        seconds: null,\n        milliseconds: null\n    };\n    const length = pattern.length;\n    let literal = false;\n\n    for (; state.idx < length; state.idx++) {\n        let ch = pattern[state.idx];\n\n        if (literal) {\n            if (ch === \"'\") {\n                literal = false;\n            }\n\n            checkLiteral(state);\n        } else {\n            if (parsers[ch]) {\n                let invalid = parsers[ch](state, info);\n                if (invalid) {\n                    return null;\n                }\n            } else if (ch === \"'\") {\n                literal = true;\n                checkLiteral(state);\n            } else if (!checkLiteral(state)) {\n                return null;\n            }\n        }\n    }\n\n    if (state.valueIdx < value.length) {\n        return null;\n    }\n\n    return createDate(state) || null;\n}\n\nfunction parseMicrosoftDateOffset(offset) {\n    const sign = offset.substr(0, 1) === \"-\" ? -1 : 1;\n\n    let result = offset.substring(1);\n    result = (parseInt(result.substr(0, 2), 10) * 60) + parseInt(result.substring(2), 10);\n\n    return sign * result;\n}\n\nfunction parseMicrosoftDateFormat(value) {\n    if (value && value.indexOf(\"/D\") === 0) {\n        let date = dateRegExp.exec(value);\n        if (date) {\n            date = date[1];\n            let tzoffset = offsetRegExp.exec(date.substring(1));\n\n            date = new Date(parseInt(date, 10));\n\n            if (tzoffset) {\n                tzoffset = parseMicrosoftDateOffset(tzoffset[0]);\n                date = convertTimeZone(date, date.getTimezoneOffset(), 0);\n                date = convertTimeZone(date, 0, -1 * tzoffset);\n            }\n\n            return date;\n        }\n    }\n}\n\nfunction defaultFormats(calendar) {\n    const formats = [];\n    const patterns = calendar.patterns;\n    const length = FORMATS_SEQUENCE.length;\n\n    for (let idx = 0; idx < length; idx++) {\n        formats.push(patterns[FORMATS_SEQUENCE[idx]]);\n    }\n\n    return formats.concat(standardDateFormats);\n}\n\nfunction dates_parse_date_parseDate(value, formats, locale = DEFAULT_LOCALE) {\n    if (!value) {\n        return null;\n    }\n\n    if (isDate(value)) {\n        return value;\n    }\n\n    let parseValue = String(value).trim();\n    let date = parseMicrosoftDateFormat(parseValue);\n    if (date) {\n        return date;\n    }\n\n    const info = info_localeInfo(locale);\n    let parseFormats = formats || defaultFormats(info.calendar);\n    parseFormats = Array.isArray(parseFormats) ? parseFormats : [ parseFormats ];\n\n    const length = parseFormats.length;\n\n    for (let idx = 0; idx < length; idx++) {\n        date = parseExact(parseValue, parseFormats[idx], info);\n        if (date) {\n            return date;\n        }\n    }\n\n    return date;\n}\n\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/dates/split-date-format.js\n\n\n\n\n\n\n\nconst NAME_TYPES = {\n    month: {\n        type: 'months',\n        minLength: 3,\n        standAlone: 'L'\n    },\n\n    quarter: {\n        type: 'quarters',\n        minLength: 3,\n        standAlone: 'q'\n    },\n\n    weekday: {\n        type: 'days',\n        minLength: {\n            E: 0,\n            c: 3,\n            e: 3\n        },\n        standAlone: 'c'\n    },\n\n    dayperiod: {\n        type: 'dayPeriods',\n        minLength: 0\n    },\n\n    era: {\n        type: 'eras',\n        minLength: 0\n    }\n};\n\nconst LITERAL = 'literal';\n\nfunction addLiteral(parts, value) {\n    const lastPart = parts[parts.length - 1];\n    if (lastPart && lastPart.type === LITERAL) {\n        lastPart.pattern += value;\n    } else {\n        parts.push({\n            type: LITERAL,\n            pattern: value\n        });\n    }\n}\n\nfunction isHour12(pattern) {\n    return pattern === 'h' || pattern === 'K';\n}\n\nfunction splitDateFormat(format, locale = DEFAULT_LOCALE) {\n    const info = info_localeInfo(locale);\n    const pattern = datePattern(format, info);\n    const parts = [];\n    let lastIndex = dateFormatRegExp.lastIndex = 0;\n    let match = dateFormatRegExp.exec(pattern);\n\n    while (match) {\n        let value = match[0];\n\n        if (lastIndex < match.index) {\n            addLiteral(parts, pattern.substring(lastIndex, match.index));\n        }\n\n        if (value.startsWith('\"') || value.startsWith(\"'\")) {\n            addLiteral(parts, value);\n        } else {\n            const specifier = value[0];\n            const type = DATE_FIELD_MAP[specifier];\n            const part = {\n                type: type,\n                pattern: value\n            };\n\n            if (type === 'hour') {\n                part.hour12 = isHour12(value);\n            }\n\n            const names = NAME_TYPES[type];\n\n            if (names) {\n                const minLength = is_number_isNumber(names.minLength) ? names.minLength : names.minLength[specifier];\n                const patternLength = value.length;\n\n                if (patternLength >= minLength) {\n                    part.names = {\n                        type: names.type,\n                        nameType: dateNameType(patternLength),\n                        standAlone: names.standAlone === specifier\n                    };\n                }\n            }\n\n            parts.push(part);\n        }\n\n        lastIndex = dateFormatRegExp.lastIndex;\n        match = dateFormatRegExp.exec(pattern);\n    }\n\n    if (lastIndex < pattern.length) {\n        addLiteral(parts, pattern.substring(lastIndex));\n    }\n\n    return parts;\n}\n\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/dates.js\n\n\n\n\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/format.js\n\n\n\n\n\n\nconst format_formatRegExp = /\\{(\\d+)(:[^\\}]+)?\\}/g;\n\nfunction format_toString(value, format, locale) {\n    if (format) {\n        if (isDate(value)) {\n            return formatDate(value, format, locale);\n        } else if (is_number_isNumber(value)) {\n            return formatNumber(value, format, locale);\n        }\n    }\n\n    return value !== undefined && value !== null ? value : EMPTY;\n}\n\nfunction format_format(format, values, locale) {\n    return format.replace(format_formatRegExp, function(match, index, placeholderFormat) {\n        let value = values[parseInt(index, 10)];\n\n        return format_toString(value, placeholderFormat ? placeholderFormat.substring(1) : EMPTY, locale);\n    });\n}\n\n// CONCATENATED MODULE: ./node_modules/@telerik/kendo-intl/dist/es2015/main.js\n\n\n\n\n\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-angular-intl/__ivy_ngcc__/dist/fesm2015/index.js\n/**-----------------------------------------------------------------------------------------\n* Copyright © 2020 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\n\n\n\n\n/**\n * @hidden\n */\n\nconst fesm2015_packageMetadata = {\n    name: '@progress/kendo-angular-intl',\n    productName: 'Kendo UI for Angular',\n    productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],\n    publishDate: 1620213344,\n    version: '',\n    licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'\n};\nconst DOCS_URL = 'http://www.telerik.com/kendo-angular-ui/components/internationalization/troubleshooting/';\n/**\n * @hidden\n */\nconst errorSolutions = {\n    'NoCurrency': `Solution: ${DOCS_URL}#toc-no-currency`,\n    'NoCurrencyDisplay': `Solution: ${DOCS_URL}#toc-no-currency-display`,\n    'NoCurrencyRegion': `Solution: ${DOCS_URL}#toc-no-currency-region`,\n    'NoDateFieldNames': `Solution: ${DOCS_URL}#toc-no-date-filed-names`,\n    'NoFirstDay': `Solution: ${DOCS_URL}#toc-no-first-day`,\n    'NoGMTInfo': `Solution: ${DOCS_URL}#toc-no-gmt-info`,\n    'NoLocale': `Solution: ${DOCS_URL}#toc-no-locale`,\n    'NoValidCurrency': `Solution: ${DOCS_URL}#toc-no-valid-currency`,\n    'NoWeekData': `Solution: ${DOCS_URL}#toc-no-week-data`\n};\nfunction formatMessage(error) {\n    const message = error.message;\n    const errorSolution = errorSolutions[Object.keys(errorSolutions).filter(key => message.indexOf(key) === 0)[0]];\n    return errorSolution ? `${message} ${errorSolution}` : message;\n}\nfunction intlMethod(fn) {\n    return function (...values) {\n        try {\n            return fn.apply(null, values);\n        }\n        catch (error) {\n            error.message = formatMessage(error);\n            throw error;\n        }\n    };\n}\n/**\n * @hidden\n */\nconst dateFormatNames$1 = intlMethod(dateFormatNames);\n/**\n * @hidden\n */\nconst dateFieldName$1 = intlMethod(dateFieldName);\n/**\n * @hidden\n */\nconst firstDay$1 = intlMethod(cldr_first_day_firstDay);\n/**\n * @hidden\n */\nconst format$1 = intlMethod(format_format);\n/**\n * @hidden\n */\nconst formatDate$1 = intlMethod(formatDate);\n/**\n * @hidden\n */\nconst formatNumber$1 = intlMethod(formatNumber);\n/**\n * @hidden\n */\nconst load$1 = intlMethod(load);\n/**\n * @hidden\n */\nconst numberSymbols$1 = intlMethod(numberSymbols);\n/**\n * @hidden\n */\nconst parseDate$1 = intlMethod(dates_parse_date_parseDate);\n/**\n * @hidden\n */\nconst parseNumber$1 = intlMethod(parseNumber);\n/**\n * @hidden\n */\nconst splitDateFormat$1 = intlMethod(splitDateFormat);\n/**\n * @hidden\n */\nconst toString$1 = intlMethod(format_toString);\n/**\n * @hidden\n */\nconst weekendRange$1 = intlMethod(weekendRange);\n/**\n * Sets a pre-built locale.\n *\n * @params data - The pre-built locale data.\n */\nconst setData$1 = (data) => setData(data);\n/**\n * Retrieves the locale data for the specified locale.\n *\n * @params locale - The locale id.\n * @returns data - The locale data.\n */\nconst localeData = (locale) => {\n    try {\n        return info_localeInfo(locale);\n    }\n    catch (error) {\n        error.message = formatMessage(error);\n        throw error;\n    }\n};\nconst LOCALE_REGEX = /_/g;\n/**\n * @hidden\n */\nfunction cldrServiceFactory(localeId) {\n    return new fesm2015_CldrIntlService(localeId);\n}\nlet fesm2015_IntlService = /*@__PURE__*/ (() => {\n    /**\n     * An abstract base class that implements\n     * the Internationalization service methods\n     * for the current locale.\n     */\n    let IntlService = class IntlService {\n        /**\n         * @hidden\n         */\n        constructor() {\n            /**\n             * @hidden\n             */\n            this.changes = new core[\"o\" /* EventEmitter */]();\n            validatePackage(fesm2015_packageMetadata);\n        }\n        /**\n         * Notifies that the service was changed.\n         */\n        notify() {\n            this.changes.emit();\n        }\n    };\n    IntlService.ɵfac = function IntlService_Factory(t) { return new (t || IntlService)(); };\n    IntlService.ɵprov = core[\"Lb\" /* ɵɵdefineInjectable */]({ token: IntlService, factory: function IntlService_Factory(t) {\n            let r = null;\n            if (t) {\n                r = new t();\n            }\n            else {\n                r = cldrServiceFactory(core[\"cc\" /* ɵɵinject */](core[\"w\" /* LOCALE_ID */]));\n            }\n            return r;\n        }, providedIn: 'root' });\n    IntlService.ngInjectableDef = Object(core[\"Lb\" /* ɵɵdefineInjectable */])({ factory: function IntlService_Factory() { return cldrServiceFactory(Object(core[\"cc\" /* ɵɵinject */])(core[\"w\" /* LOCALE_ID */])); }, token: IntlService, providedIn: \"root\" });\n    IntlService = __decorate([__metadata(\"design:paramtypes\", [])\n    ], IntlService);\n    return IntlService;\n})();\nlet fesm2015_CldrIntlService = /*@__PURE__*/ (() => {\n    /**\n     * The Internationalization service implemented by using\n     * the CLDR Database via the `@telerik/kendo-intl` package.\n     */\n    let CldrIntlService = class CldrIntlService extends fesm2015_IntlService {\n        /**\n         * Creates a new instance of the service with the ID of the specified locale.\n         *\n         * Note that the parts of the locale ID can be separated by either `_` (underscore)\n         * or `-` (dash).\n         *\n         * @param localeId - The default locale ID.\n         */\n        constructor(localeId) {\n            super();\n            this.localeId = localeId;\n        }\n        /**\n         * Gets or sets the current locale ID.\n         */\n        get localeId() {\n            return this.locale;\n        }\n        set localeId(value) {\n            // Angular locales use underscore, for example, en_US\n            // while IETF BCP-47 specifies a dash.\n            // https://tools.ietf.org/html/bcp47\n            const locale = value.replace(LOCALE_REGEX, '-');\n            if (locale !== this.locale) {\n                this.locale = locale;\n                this.notify();\n            }\n        }\n        /**\n         * Formats a string with placeholders such as\n         * `Total amount {0:c}`.\n         *\n         * @param format - The format string.\n         * @param values - One or more values to output in the format string placeholders.\n         * @return - The formatted string.\n         */\n        format(format$$1, ...values) {\n            return format$1(format$$1, values, this.localeId);\n        }\n        /**\n         * Converts an object into a string based on the specified format.\n         *\n         * @param value - The value to format.\n         * @param format - The format to use.\n         * @param localeId - The locale ID to use in place of the default one. Optional.\n         * @return The formatted object.\n         */\n        toString(value, format$$1, localeId) {\n            return toString$1(value, format$$1, localeId || this.localeId);\n        }\n        /**\n         * Converts a `Date` object into a string based on the specified format.\n         * If no format is provided, the default short date format is used.\n         *\n         * @param value - The date to format.\n         * @param format - The format string or options.\n         * @param localeId - The locale ID to use in place of the default one. Optional.\n         * @return The formatted date.\n         */\n        formatDate(value, format$$1, localeId) {\n            return formatDate$1(value, format$$1, localeId || this.localeId);\n        }\n        /**\n         * Converts a string into a `Date` object based on the specified format.\n         *\n         * @param value - The string to convert.\n         * @param format - The format strings or options.\n         * @param localeId - The locale ID to use in place of the default one. Optional.\n         * @return The parsed date.\n         */\n        parseDate(value, format$$1, localeId) {\n            return parseDate$1(value, format$$1, localeId || this.localeId);\n        }\n        /**\n         * Converts a string into a `Number`.\n         *\n         * @param value - The string to convert.\n         * @param format - The format string or options.\n         * @param localeId - The locale ID to use in place of the default one. Optional.\n         * @return The parsed number.\n         */\n        parseNumber(value, format$$1, localeId) {\n            return parseNumber$1(value, localeId || this.localeId, format$$1);\n        }\n        /**\n         * Converts a `Number` into a string based on the specified format.\n         *\n         * @param value - The number to format.\n         * @param format - The format string or options.\n         * @param localeId - The locale ID to use in place of the default one. Optional.\n         * @return The formatted number.\n         */\n        formatNumber(value, format$$1, localeId) {\n            return formatNumber$1(value, format$$1, localeId || this.localeId);\n        }\n        /**\n         * Returns the date names from the current locale based on the option.\n         *\n         * The available `type` values are:\n         * - `era`\n         * - `year`\n         * - `quarter`\n         * - `month`\n         * - `week`\n         * - `day`\n         * - `dayperiod`\n         * - `hour`\n         * - `minute`\n         * - `second`\n         * - `zone`\n         *\n         * The available `nameType` values are:\n         * - `wide`\n         * - `narrow`\n         * - `short`\n         *\n         * @param options - Detailed configuration for the desired date field name.\n         * @param localeId - The locale ID to use in place of the default one. Optional.\n         * @return - The day names from the current locale based on the option.\n         * @returns The localized date field name from the current locale based on the option.\n         *\n         * @example\n         * ```\n         * dateFieldName({ type: 'day' });                      //returns 'day';\n         * dateFieldName({ type: 'day', nameType: 'wide' });    //returns 'day';\n         * dateFieldName({ type: 'month', nameType: 'short' }); //returns 'mo.';\n         * dateFieldName({ type: 'month', nameType: 'wide' });  //returns 'month';\n         * ```\n         */\n        dateFieldName(options, localeId) {\n            return dateFieldName$1(options, localeId || this.localeId);\n        }\n        /**\n         * Returns a localized date field name based on specific dateFieldName options.\n         *\n         * The available type values are:\n         * - `day`\n         * - `dayperiod`\n         * - `months`\n         * - `quarters`\n         * - `eras`\n         *\n         * @param options - Detailed configuration for the desired date format.\n         * @param localeId - The locale ID to use in place of the default one. Optional.\n         * @return - The day names from the current locale based on the option.\n         */\n        dateFormatNames(options, localeId) {\n            return dateFormatNames$1(localeId || this.localeId, options);\n        }\n        /**\n         * Splits the date format into objects containing information about each part of the pattern.\n         *\n         * @param format The format string or options.\n         * @param localeId The optional locale id. If not specified, the `\"en\"` locale id is used.\n         * @returns The date format parts.\n         */\n        splitDateFormat(format$$1, localeId) {\n            return splitDateFormat$1(format$$1, localeId || this.localeId);\n        }\n        /**\n         * Returns the number symbols from the current locale based on the option.\n         *\n         * @param localeId - The locale ID to use in place of the default one. Optional.\n         * @return - The number symbols from the current locale.\n         */\n        numberSymbols(localeId) {\n            return numberSymbols$1(localeId || this.localeId);\n        }\n        /**\n         * Returns the first day index starting from Sunday.\n         *\n         * @param localeId - The locale ID. Defaults to the current locale ID.\n         * @return - The index of the first day of the week (0 == Sunday).\n         */\n        firstDay(localeId) {\n            return firstDay$1(localeId || this.localeId);\n        }\n        /**\n         * Returns the start and end index of the locale weekend starting from Sunday.\n         *\n         * @param localeId - The locale ID. Defaults to the current locale ID.\n         * @return - The the start and end index of the locale weekend (0 == Sunday).\n         */\n        weekendRange(localeId) {\n            return weekendRange$1(localeId || this.localeId);\n        }\n    };\n    CldrIntlService.ɵfac = function CldrIntlService_Factory(t) { return new (t || CldrIntlService)(core[\"cc\" /* ɵɵinject */](core[\"w\" /* LOCALE_ID */])); };\n    CldrIntlService.ɵprov = core[\"Lb\" /* ɵɵdefineInjectable */]({ token: CldrIntlService, factory: function (t) { return CldrIntlService.ɵfac(t); } });\n    CldrIntlService = __decorate([__param(0, Object(core[\"q\" /* Inject */])(core[\"w\" /* LOCALE_ID */])),\n        __metadata(\"design:paramtypes\", [String])\n    ], CldrIntlService);\n    return CldrIntlService;\n})();\nconst isNumeric = (value) => !isNaN(value - parseFloat(value));\nconst ɵ0 = isNumeric;\nlet fesm2015_DatePipe = /*@__PURE__*/ (() => {\n    /**\n     * Formats a date value to a string based on the requested format.\n     * This pipe uses the [IntlService]({% slug api_intl_intlservice %}).\n     *\n     * @example\n     * ```ng-template-no-run\n     * <ul>\n     *    <li>{{date | kendoDate }}</li>\n     *    <li>{{milliseconds | kendoDate: 'M/dd/yyy' }}</li>\n     *    <li>{{stringDate | kendoDate: 'G' }}</li>\n     * </ul>\n     * ```\n     */\n    let DatePipe = class DatePipe {\n        /**\n         * @hidden\n         */\n        constructor(intlService) {\n            this.intlService = intlService;\n        }\n        /**\n         * Converts a `Date` object into a string based on the specified format.\n         * If no format is provided, the default short date format is used.\n         *\n         * @param value - The date to format.\n         * @param format - The format string or options.\n         * @param localeId - (Optional) The ID of the locale which will be used instead of the default one.\n         * @return - The formatted date.\n         */\n        transform(value, format$$1 = \"\", localeId) {\n            value = this.normalize(value);\n            if (value) {\n                return this.intlService.formatDate(value, format$$1, localeId);\n            }\n            return value;\n        }\n        normalize(value) {\n            if (value && typeof value === 'string') {\n                value = this.intlService.parseDate(value);\n            }\n            else if (value && isNumeric(value)) {\n                value = new Date(parseFloat(value));\n            }\n            return value;\n        }\n    };\n    DatePipe.ɵfac = function DatePipe_Factory(t) { return new (t || DatePipe)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_IntlService)); };\n    DatePipe.ɵpipe = core[\"Ob\" /* ɵɵdefinePipe */]({ name: \"kendoDate\", type: DatePipe, pure: true });\n    DatePipe = __decorate([__metadata(\"design:paramtypes\", [fesm2015_IntlService])\n    ], DatePipe);\n    return DatePipe;\n})();\nlet fesm2015_NumberPipe = /*@__PURE__*/ (() => {\n    /**\n     * Formats a number value to a string based on the requested format.\n     * This pipe uses the [`IntlService`]({% slug api_intl_intlservice %}).\n     *\n     * @example\n     * ```ng-template-no-run\n     *   <ul>\n     *     <li>{{decimal | kendoNumber:'c' }}</li>\n     *     <li>{{stringNumber | kendoNumber:'p' }}</li>\n     *     <li>{{int | kendoNumber:'##.00' }}</li>\n     *  </ul>\n     * ```\n     */\n    let NumberPipe = class NumberPipe {\n        /**\n         * @hidden\n         */\n        constructor(intlService) {\n            this.intlService = intlService;\n        }\n        /**\n         * Converts a `Number` object into a string based on the specified format.\n         * If no format is provided, the value is formatted as decimal number using the\n         * [`\"n\"`](https://github.com/telerik/kendo-intl/blob/master/docs/num-formatting/index.md#standard) format.\n         *\n         * @param value - The numer that will be formatted.\n         * @param format - The format string or options.\n         * @param localeId - (Optional) The locale ID that will be used in place of the default one.\n         * @return - The formatted number.\n         */\n        transform(value, format$$1, localeId) {\n            if (typeof value === 'string') {\n                value = this.intlService.parseNumber(value);\n            }\n            if (value !== null && value !== undefined) {\n                return this.intlService.formatNumber(value, format$$1, localeId);\n            }\n            return value;\n        }\n    };\n    NumberPipe.ɵfac = function NumberPipe_Factory(t) { return new (t || NumberPipe)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_IntlService)); };\n    NumberPipe.ɵpipe = core[\"Ob\" /* ɵɵdefinePipe */]({ name: \"kendoNumber\", type: NumberPipe, pure: true });\n    NumberPipe = __decorate([__metadata(\"design:paramtypes\", [fesm2015_IntlService])\n    ], NumberPipe);\n    return NumberPipe;\n})();\nconst pipes = [\n    fesm2015_DatePipe,\n    fesm2015_NumberPipe\n];\nlet fesm2015_IntlModule = /*@__PURE__*/ (() => {\n    /**\n     * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }}docs/ts/latest/guide/ngmodule.html)\n     * definition for the Intl services.\n     */\n    let IntlModule = class IntlModule {\n    };\n    IntlModule.ɵmod = core[\"Nb\" /* ɵɵdefineNgModule */]({ type: IntlModule });\n    IntlModule.ɵinj = core[\"Mb\" /* ɵɵdefineInjector */]({ factory: function IntlModule_Factory(t) { return new (t || IntlModule)(); } });\n    return IntlModule;\n})();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ec\" /* ɵɵsetNgModuleScope */](fesm2015_IntlModule, { declarations: [fesm2015_DatePipe, fesm2015_NumberPipe], exports: [fesm2015_DatePipe, fesm2015_NumberPipe] }); })();\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozt5Q0FBRTtBQUNGO0FBQ0EsMEJBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7eUlBQUU7QUFDRiw4QkFFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7d0ZBQUU7QUFDRix1QkFJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OEZBQUU7QUFDRix5QkFJRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQU1lO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiLyoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiogQ29weXJpZ2h0IMKpIDIwMjAgUHJvZ3Jlc3MgU29mdHdhcmUgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qIExpY2Vuc2VkIHVuZGVyIGNvbW1lcmNpYWwgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbW9yZSBpbmZvcm1hdGlvblxuKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgX19kZWNvcmF0ZSwgX19tZXRhZGF0YSwgX19wYXJhbSB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciwgybXJtWRlZmluZUluamVjdGFibGUsIMm1ybVpbmplY3QsIExPQ0FMRV9JRCwgSW5qZWN0YWJsZSwgSW5qZWN0LCBQaXBlLCBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgdmFsaWRhdGVQYWNrYWdlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWxpY2Vuc2luZyc7XG5pbXBvcnQgeyBkYXRlRm9ybWF0TmFtZXMsIGRhdGVGaWVsZE5hbWUsIGZpcnN0RGF5LCBmb3JtYXQsIGZvcm1hdERhdGUsIGZvcm1hdE51bWJlciwgbG9hZCwgbnVtYmVyU3ltYm9scywgcGFyc2VEYXRlLCBwYXJzZU51bWJlciwgc3BsaXREYXRlRm9ybWF0LCB0b1N0cmluZywgd2Vla2VuZFJhbmdlLCBzZXREYXRhLCBsb2NhbGVJbmZvIH0gZnJvbSAnQHRlbGVyaWsva2VuZG8taW50bCc7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBwYWNrYWdlTWV0YWRhdGEgPSB7XG4gICAgbmFtZTogJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWludGwnLFxuICAgIHByb2R1Y3ROYW1lOiAnS2VuZG8gVUkgZm9yIEFuZ3VsYXInLFxuICAgIHByb2R1Y3RDb2RlczogWydLRU5ET1VJQU5HVUxBUicsICdLRU5ET1VJQ09NUExFVEUnXSxcbiAgICBwdWJsaXNoRGF0ZTogMTYyMDIxMzM0NCxcbiAgICB2ZXJzaW9uOiAnJyxcbiAgICBsaWNlbnNpbmdEb2NzVXJsOiAnaHR0cHM6Ly93d3cudGVsZXJpay5jb20va2VuZG8tYW5ndWxhci11aS9teS1saWNlbnNlLz91dG1fbWVkaXVtPXByb2R1Y3QmdXRtX3NvdXJjZT1rZW5kb2FuZ3VsYXImdXRtX2NhbXBhaWduPWtlbmRvLXVpLWFuZ3VsYXItcHVyY2hhc2UtbGljZW5zZS1rZXlzLXdhcm5pbmcnXG59O1xuXG5jb25zdCBET0NTX1VSTCA9ICdodHRwOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvY29tcG9uZW50cy9pbnRlcm5hdGlvbmFsaXphdGlvbi90cm91Ymxlc2hvb3RpbmcvJztcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBlcnJvclNvbHV0aW9ucyA9IHtcbiAgICAnTm9DdXJyZW5jeSc6IGBTb2x1dGlvbjogJHtET0NTX1VSTH0jdG9jLW5vLWN1cnJlbmN5YCxcbiAgICAnTm9DdXJyZW5jeURpc3BsYXknOiBgU29sdXRpb246ICR7RE9DU19VUkx9I3RvYy1uby1jdXJyZW5jeS1kaXNwbGF5YCxcbiAgICAnTm9DdXJyZW5jeVJlZ2lvbic6IGBTb2x1dGlvbjogJHtET0NTX1VSTH0jdG9jLW5vLWN1cnJlbmN5LXJlZ2lvbmAsXG4gICAgJ05vRGF0ZUZpZWxkTmFtZXMnOiBgU29sdXRpb246ICR7RE9DU19VUkx9I3RvYy1uby1kYXRlLWZpbGVkLW5hbWVzYCxcbiAgICAnTm9GaXJzdERheSc6IGBTb2x1dGlvbjogJHtET0NTX1VSTH0jdG9jLW5vLWZpcnN0LWRheWAsXG4gICAgJ05vR01USW5mbyc6IGBTb2x1dGlvbjogJHtET0NTX1VSTH0jdG9jLW5vLWdtdC1pbmZvYCxcbiAgICAnTm9Mb2NhbGUnOiBgU29sdXRpb246ICR7RE9DU19VUkx9I3RvYy1uby1sb2NhbGVgLFxuICAgICdOb1ZhbGlkQ3VycmVuY3knOiBgU29sdXRpb246ICR7RE9DU19VUkx9I3RvYy1uby12YWxpZC1jdXJyZW5jeWAsXG4gICAgJ05vV2Vla0RhdGEnOiBgU29sdXRpb246ICR7RE9DU19VUkx9I3RvYy1uby13ZWVrLWRhdGFgXG59O1xuXG5mdW5jdGlvbiBmb3JtYXRNZXNzYWdlKGVycm9yKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgY29uc3QgZXJyb3JTb2x1dGlvbiA9IGVycm9yU29sdXRpb25zW09iamVjdC5rZXlzKGVycm9yU29sdXRpb25zKS5maWx0ZXIoa2V5ID0+IG1lc3NhZ2UuaW5kZXhPZihrZXkpID09PSAwKVswXV07XG4gICAgcmV0dXJuIGVycm9yU29sdXRpb24gPyBgJHttZXNzYWdlfSAke2Vycm9yU29sdXRpb259YCA6IG1lc3NhZ2U7XG59XG5mdW5jdGlvbiBpbnRsTWV0aG9kKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi52YWx1ZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCB2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9IGZvcm1hdE1lc3NhZ2UoZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGRhdGVGb3JtYXROYW1lcyQxID0gaW50bE1ldGhvZChkYXRlRm9ybWF0TmFtZXMpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGRhdGVGaWVsZE5hbWUkMSA9IGludGxNZXRob2QoZGF0ZUZpZWxkTmFtZSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZmlyc3REYXkkMSA9IGludGxNZXRob2QoZmlyc3REYXkpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGZvcm1hdCQxID0gaW50bE1ldGhvZChmb3JtYXQpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IGZvcm1hdERhdGUkMSA9IGludGxNZXRob2QoZm9ybWF0RGF0ZSk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZm9ybWF0TnVtYmVyJDEgPSBpbnRsTWV0aG9kKGZvcm1hdE51bWJlcik7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgbG9hZCQxID0gaW50bE1ldGhvZChsb2FkKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBudW1iZXJTeW1ib2xzJDEgPSBpbnRsTWV0aG9kKG51bWJlclN5bWJvbHMpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHBhcnNlRGF0ZSQxID0gaW50bE1ldGhvZChwYXJzZURhdGUpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHBhcnNlTnVtYmVyJDEgPSBpbnRsTWV0aG9kKHBhcnNlTnVtYmVyKTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBzcGxpdERhdGVGb3JtYXQkMSA9IGludGxNZXRob2Qoc3BsaXREYXRlRm9ybWF0KTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCB0b1N0cmluZyQxID0gaW50bE1ldGhvZCh0b1N0cmluZyk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3Qgd2Vla2VuZFJhbmdlJDEgPSBpbnRsTWV0aG9kKHdlZWtlbmRSYW5nZSk7XG4vKipcbiAqIFNldHMgYSBwcmUtYnVpbHQgbG9jYWxlLlxuICpcbiAqIEBwYXJhbXMgZGF0YSAtIFRoZSBwcmUtYnVpbHQgbG9jYWxlIGRhdGEuXG4gKi9cbmNvbnN0IHNldERhdGEkMSA9IChkYXRhKSA9PiBzZXREYXRhKGRhdGEpO1xuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGxvY2FsZSBkYXRhIGZvciB0aGUgc3BlY2lmaWVkIGxvY2FsZS5cbiAqXG4gKiBAcGFyYW1zIGxvY2FsZSAtIFRoZSBsb2NhbGUgaWQuXG4gKiBAcmV0dXJucyBkYXRhIC0gVGhlIGxvY2FsZSBkYXRhLlxuICovXG5jb25zdCBsb2NhbGVEYXRhID0gKGxvY2FsZSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBsb2NhbGVJbmZvKGxvY2FsZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBlcnJvci5tZXNzYWdlID0gZm9ybWF0TWVzc2FnZShlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn07XG5cbmNvbnN0IExPQ0FMRV9SRUdFWCA9IC9fL2c7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gY2xkclNlcnZpY2VGYWN0b3J5KGxvY2FsZUlkKSB7XG4gICAgcmV0dXJuIG5ldyBDbGRySW50bFNlcnZpY2UobG9jYWxlSWQpO1xufVxuLyoqXG4gKiBBbiBhYnN0cmFjdCBiYXNlIGNsYXNzIHRoYXQgaW1wbGVtZW50c1xuICogdGhlIEludGVybmF0aW9uYWxpemF0aW9uIHNlcnZpY2UgbWV0aG9kc1xuICogZm9yIHRoZSBjdXJyZW50IGxvY2FsZS5cbiAqL1xubGV0IEludGxTZXJ2aWNlID0gY2xhc3MgSW50bFNlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdmFsaWRhdGVQYWNrYWdlKHBhY2thZ2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vdGlmaWVzIHRoYXQgdGhlIHNlcnZpY2Ugd2FzIGNoYW5nZWQuXG4gICAgICovXG4gICAgbm90aWZ5KCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMuZW1pdCgpO1xuICAgIH1cbn07XG5JbnRsU2VydmljZS5uZ0luamVjdGFibGVEZWYgPSDJtcm1ZGVmaW5lSW5qZWN0YWJsZSh7IGZhY3Rvcnk6IGZ1bmN0aW9uIEludGxTZXJ2aWNlX0ZhY3RvcnkoKSB7IHJldHVybiBjbGRyU2VydmljZUZhY3RvcnkoybXJtWluamVjdChMT0NBTEVfSUQpKTsgfSwgdG9rZW46IEludGxTZXJ2aWNlLCBwcm92aWRlZEluOiBcInJvb3RcIiB9KTtcbkludGxTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSh7XG4gICAgICAgIHByb3ZpZGVkSW46ICdyb290JyxcbiAgICAgICAgdXNlRmFjdG9yeTogY2xkclNlcnZpY2VGYWN0b3J5LFxuICAgICAgICBkZXBzOiBbTE9DQUxFX0lEXVxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIEludGxTZXJ2aWNlKTtcbi8qKlxuICogVGhlIEludGVybmF0aW9uYWxpemF0aW9uIHNlcnZpY2UgaW1wbGVtZW50ZWQgYnkgdXNpbmdcbiAqIHRoZSBDTERSIERhdGFiYXNlIHZpYSB0aGUgYEB0ZWxlcmlrL2tlbmRvLWludGxgIHBhY2thZ2UuXG4gKi9cbmxldCBDbGRySW50bFNlcnZpY2UgPSBjbGFzcyBDbGRySW50bFNlcnZpY2UgZXh0ZW5kcyBJbnRsU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgc2VydmljZSB3aXRoIHRoZSBJRCBvZiB0aGUgc3BlY2lmaWVkIGxvY2FsZS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGUgcGFydHMgb2YgdGhlIGxvY2FsZSBJRCBjYW4gYmUgc2VwYXJhdGVkIGJ5IGVpdGhlciBgX2AgKHVuZGVyc2NvcmUpXG4gICAgICogb3IgYC1gIChkYXNoKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBkZWZhdWx0IGxvY2FsZSBJRC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGVJZCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxvY2FsZUlkID0gbG9jYWxlSWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgY3VycmVudCBsb2NhbGUgSUQuXG4gICAgICovXG4gICAgZ2V0IGxvY2FsZUlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGU7XG4gICAgfVxuICAgIHNldCBsb2NhbGVJZCh2YWx1ZSkge1xuICAgICAgICAvLyBBbmd1bGFyIGxvY2FsZXMgdXNlIHVuZGVyc2NvcmUsIGZvciBleGFtcGxlLCBlbl9VU1xuICAgICAgICAvLyB3aGlsZSBJRVRGIEJDUC00NyBzcGVjaWZpZXMgYSBkYXNoLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvYmNwNDdcbiAgICAgICAgY29uc3QgbG9jYWxlID0gdmFsdWUucmVwbGFjZShMT0NBTEVfUkVHRVgsICctJyk7XG4gICAgICAgIGlmIChsb2NhbGUgIT09IHRoaXMubG9jYWxlKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZTtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9ybWF0cyBhIHN0cmluZyB3aXRoIHBsYWNlaG9sZGVycyBzdWNoIGFzXG4gICAgICogYFRvdGFsIGFtb3VudCB7MDpjfWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCBzdHJpbmcuXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIE9uZSBvciBtb3JlIHZhbHVlcyB0byBvdXRwdXQgaW4gdGhlIGZvcm1hdCBzdHJpbmcgcGxhY2Vob2xkZXJzLlxuICAgICAqIEByZXR1cm4gLSBUaGUgZm9ybWF0dGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBmb3JtYXQoZm9ybWF0JCQxLCAuLi52YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdCQxKGZvcm1hdCQkMSwgdmFsdWVzLCB0aGlzLmxvY2FsZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gb2JqZWN0IGludG8gYSBzdHJpbmcgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZm9ybWF0LlxuICAgICAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgbG9jYWxlIElEIHRvIHVzZSBpbiBwbGFjZSBvZiB0aGUgZGVmYXVsdCBvbmUuIE9wdGlvbmFsLlxuICAgICAqIEByZXR1cm4gVGhlIGZvcm1hdHRlZCBvYmplY3QuXG4gICAgICovXG4gICAgdG9TdHJpbmcodmFsdWUsIGZvcm1hdCQkMSwgbG9jYWxlSWQpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nJDEodmFsdWUsIGZvcm1hdCQkMSwgbG9jYWxlSWQgfHwgdGhpcy5sb2NhbGVJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgYERhdGVgIG9iamVjdCBpbnRvIGEgc3RyaW5nIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgZm9ybWF0LlxuICAgICAqIElmIG5vIGZvcm1hdCBpcyBwcm92aWRlZCwgdGhlIGRlZmF1bHQgc2hvcnQgZGF0ZSBmb3JtYXQgaXMgdXNlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBkYXRlIHRvIGZvcm1hdC5cbiAgICAgKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCBzdHJpbmcgb3Igb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gbG9jYWxlSWQgLSBUaGUgbG9jYWxlIElEIHRvIHVzZSBpbiBwbGFjZSBvZiB0aGUgZGVmYXVsdCBvbmUuIE9wdGlvbmFsLlxuICAgICAqIEByZXR1cm4gVGhlIGZvcm1hdHRlZCBkYXRlLlxuICAgICAqL1xuICAgIGZvcm1hdERhdGUodmFsdWUsIGZvcm1hdCQkMSwgbG9jYWxlSWQpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdERhdGUkMSh2YWx1ZSwgZm9ybWF0JCQxLCBsb2NhbGVJZCB8fCB0aGlzLmxvY2FsZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBzdHJpbmcgaW50byBhIGBEYXRlYCBvYmplY3QgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIGZvcm1hdCAtIFRoZSBmb3JtYXQgc3RyaW5ncyBvciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0IG9uZS4gT3B0aW9uYWwuXG4gICAgICogQHJldHVybiBUaGUgcGFyc2VkIGRhdGUuXG4gICAgICovXG4gICAgcGFyc2VEYXRlKHZhbHVlLCBmb3JtYXQkJDEsIGxvY2FsZUlkKSB7XG4gICAgICAgIHJldHVybiBwYXJzZURhdGUkMSh2YWx1ZSwgZm9ybWF0JCQxLCBsb2NhbGVJZCB8fCB0aGlzLmxvY2FsZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBzdHJpbmcgaW50byBhIGBOdW1iZXJgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IHN0cmluZyBvciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0IG9uZS4gT3B0aW9uYWwuXG4gICAgICogQHJldHVybiBUaGUgcGFyc2VkIG51bWJlci5cbiAgICAgKi9cbiAgICBwYXJzZU51bWJlcih2YWx1ZSwgZm9ybWF0JCQxLCBsb2NhbGVJZCkge1xuICAgICAgICByZXR1cm4gcGFyc2VOdW1iZXIkMSh2YWx1ZSwgbG9jYWxlSWQgfHwgdGhpcy5sb2NhbGVJZCwgZm9ybWF0JCQxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBgTnVtYmVyYCBpbnRvIGEgc3RyaW5nIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgZm9ybWF0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIG51bWJlciB0byBmb3JtYXQuXG4gICAgICogQHBhcmFtIGZvcm1hdCAtIFRoZSBmb3JtYXQgc3RyaW5nIG9yIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIC0gVGhlIGxvY2FsZSBJRCB0byB1c2UgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgb25lLiBPcHRpb25hbC5cbiAgICAgKiBAcmV0dXJuIFRoZSBmb3JtYXR0ZWQgbnVtYmVyLlxuICAgICAqL1xuICAgIGZvcm1hdE51bWJlcih2YWx1ZSwgZm9ybWF0JCQxLCBsb2NhbGVJZCkge1xuICAgICAgICByZXR1cm4gZm9ybWF0TnVtYmVyJDEodmFsdWUsIGZvcm1hdCQkMSwgbG9jYWxlSWQgfHwgdGhpcy5sb2NhbGVJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRhdGUgbmFtZXMgZnJvbSB0aGUgY3VycmVudCBsb2NhbGUgYmFzZWQgb24gdGhlIG9wdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZSBhdmFpbGFibGUgYHR5cGVgIHZhbHVlcyBhcmU6XG4gICAgICogLSBgZXJhYFxuICAgICAqIC0gYHllYXJgXG4gICAgICogLSBgcXVhcnRlcmBcbiAgICAgKiAtIGBtb250aGBcbiAgICAgKiAtIGB3ZWVrYFxuICAgICAqIC0gYGRheWBcbiAgICAgKiAtIGBkYXlwZXJpb2RgXG4gICAgICogLSBgaG91cmBcbiAgICAgKiAtIGBtaW51dGVgXG4gICAgICogLSBgc2Vjb25kYFxuICAgICAqIC0gYHpvbmVgXG4gICAgICpcbiAgICAgKiBUaGUgYXZhaWxhYmxlIGBuYW1lVHlwZWAgdmFsdWVzIGFyZTpcbiAgICAgKiAtIGB3aWRlYFxuICAgICAqIC0gYG5hcnJvd2BcbiAgICAgKiAtIGBzaG9ydGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gRGV0YWlsZWQgY29uZmlndXJhdGlvbiBmb3IgdGhlIGRlc2lyZWQgZGF0ZSBmaWVsZCBuYW1lLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQgdG8gdXNlIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0IG9uZS4gT3B0aW9uYWwuXG4gICAgICogQHJldHVybiAtIFRoZSBkYXkgbmFtZXMgZnJvbSB0aGUgY3VycmVudCBsb2NhbGUgYmFzZWQgb24gdGhlIG9wdGlvbi5cbiAgICAgKiBAcmV0dXJucyBUaGUgbG9jYWxpemVkIGRhdGUgZmllbGQgbmFtZSBmcm9tIHRoZSBjdXJyZW50IGxvY2FsZSBiYXNlZCBvbiB0aGUgb3B0aW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBcbiAgICAgKiBkYXRlRmllbGROYW1lKHsgdHlwZTogJ2RheScgfSk7ICAgICAgICAgICAgICAgICAgICAgIC8vcmV0dXJucyAnZGF5JztcbiAgICAgKiBkYXRlRmllbGROYW1lKHsgdHlwZTogJ2RheScsIG5hbWVUeXBlOiAnd2lkZScgfSk7ICAgIC8vcmV0dXJucyAnZGF5JztcbiAgICAgKiBkYXRlRmllbGROYW1lKHsgdHlwZTogJ21vbnRoJywgbmFtZVR5cGU6ICdzaG9ydCcgfSk7IC8vcmV0dXJucyAnbW8uJztcbiAgICAgKiBkYXRlRmllbGROYW1lKHsgdHlwZTogJ21vbnRoJywgbmFtZVR5cGU6ICd3aWRlJyB9KTsgIC8vcmV0dXJucyAnbW9udGgnO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGRhdGVGaWVsZE5hbWUob3B0aW9ucywgbG9jYWxlSWQpIHtcbiAgICAgICAgcmV0dXJuIGRhdGVGaWVsZE5hbWUkMShvcHRpb25zLCBsb2NhbGVJZCB8fCB0aGlzLmxvY2FsZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxvY2FsaXplZCBkYXRlIGZpZWxkIG5hbWUgYmFzZWQgb24gc3BlY2lmaWMgZGF0ZUZpZWxkTmFtZSBvcHRpb25zLlxuICAgICAqXG4gICAgICogVGhlIGF2YWlsYWJsZSB0eXBlIHZhbHVlcyBhcmU6XG4gICAgICogLSBgZGF5YFxuICAgICAqIC0gYGRheXBlcmlvZGBcbiAgICAgKiAtIGBtb250aHNgXG4gICAgICogLSBgcXVhcnRlcnNgXG4gICAgICogLSBgZXJhc2BcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gRGV0YWlsZWQgY29uZmlndXJhdGlvbiBmb3IgdGhlIGRlc2lyZWQgZGF0ZSBmb3JtYXQuXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIC0gVGhlIGxvY2FsZSBJRCB0byB1c2UgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgb25lLiBPcHRpb25hbC5cbiAgICAgKiBAcmV0dXJuIC0gVGhlIGRheSBuYW1lcyBmcm9tIHRoZSBjdXJyZW50IGxvY2FsZSBiYXNlZCBvbiB0aGUgb3B0aW9uLlxuICAgICAqL1xuICAgIGRhdGVGb3JtYXROYW1lcyhvcHRpb25zLCBsb2NhbGVJZCkge1xuICAgICAgICByZXR1cm4gZGF0ZUZvcm1hdE5hbWVzJDEobG9jYWxlSWQgfHwgdGhpcy5sb2NhbGVJZCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNwbGl0cyB0aGUgZGF0ZSBmb3JtYXQgaW50byBvYmplY3RzIGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgZWFjaCBwYXJ0IG9mIHRoZSBwYXR0ZXJuLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZvcm1hdCBUaGUgZm9ybWF0IHN0cmluZyBvciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCBUaGUgb3B0aW9uYWwgbG9jYWxlIGlkLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgYFwiZW5cImAgbG9jYWxlIGlkIGlzIHVzZWQuXG4gICAgICogQHJldHVybnMgVGhlIGRhdGUgZm9ybWF0IHBhcnRzLlxuICAgICAqL1xuICAgIHNwbGl0RGF0ZUZvcm1hdChmb3JtYXQkJDEsIGxvY2FsZUlkKSB7XG4gICAgICAgIHJldHVybiBzcGxpdERhdGVGb3JtYXQkMShmb3JtYXQkJDEsIGxvY2FsZUlkIHx8IHRoaXMubG9jYWxlSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgc3ltYm9scyBmcm9tIHRoZSBjdXJyZW50IGxvY2FsZSBiYXNlZCBvbiB0aGUgb3B0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIC0gVGhlIGxvY2FsZSBJRCB0byB1c2UgaW4gcGxhY2Ugb2YgdGhlIGRlZmF1bHQgb25lLiBPcHRpb25hbC5cbiAgICAgKiBAcmV0dXJuIC0gVGhlIG51bWJlciBzeW1ib2xzIGZyb20gdGhlIGN1cnJlbnQgbG9jYWxlLlxuICAgICAqL1xuICAgIG51bWJlclN5bWJvbHMobG9jYWxlSWQpIHtcbiAgICAgICAgcmV0dXJuIG51bWJlclN5bWJvbHMkMShsb2NhbGVJZCB8fCB0aGlzLmxvY2FsZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgZGF5IGluZGV4IHN0YXJ0aW5nIGZyb20gU3VuZGF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGxvY2FsZUlkIC0gVGhlIGxvY2FsZSBJRC4gRGVmYXVsdHMgdG8gdGhlIGN1cnJlbnQgbG9jYWxlIElELlxuICAgICAqIEByZXR1cm4gLSBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlayAoMCA9PSBTdW5kYXkpLlxuICAgICAqL1xuICAgIGZpcnN0RGF5KGxvY2FsZUlkKSB7XG4gICAgICAgIHJldHVybiBmaXJzdERheSQxKGxvY2FsZUlkIHx8IHRoaXMubG9jYWxlSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdGFydCBhbmQgZW5kIGluZGV4IG9mIHRoZSBsb2NhbGUgd2Vla2VuZCBzdGFydGluZyBmcm9tIFN1bmRheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIFRoZSBsb2NhbGUgSUQuIERlZmF1bHRzIHRvIHRoZSBjdXJyZW50IGxvY2FsZSBJRC5cbiAgICAgKiBAcmV0dXJuIC0gVGhlIHRoZSBzdGFydCBhbmQgZW5kIGluZGV4IG9mIHRoZSBsb2NhbGUgd2Vla2VuZCAoMCA9PSBTdW5kYXkpLlxuICAgICAqL1xuICAgIHdlZWtlbmRSYW5nZShsb2NhbGVJZCkge1xuICAgICAgICByZXR1cm4gd2Vla2VuZFJhbmdlJDEobG9jYWxlSWQgfHwgdGhpcy5sb2NhbGVJZCk7XG4gICAgfVxufTtcbkNsZHJJbnRsU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX3BhcmFtKDAsIEluamVjdChMT0NBTEVfSUQpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBDbGRySW50bFNlcnZpY2UpO1xuXG5jb25zdCBpc051bWVyaWMgPSAodmFsdWUpID0+ICFpc05hTih2YWx1ZSAtIHBhcnNlRmxvYXQodmFsdWUpKTtcbmNvbnN0IMm1MCA9IGlzTnVtZXJpYztcbi8qKlxuICogRm9ybWF0cyBhIGRhdGUgdmFsdWUgdG8gYSBzdHJpbmcgYmFzZWQgb24gdGhlIHJlcXVlc3RlZCBmb3JtYXQuXG4gKiBUaGlzIHBpcGUgdXNlcyB0aGUgW0ludGxTZXJ2aWNlXSh7JSBzbHVnIGFwaV9pbnRsX2ludGxzZXJ2aWNlICV9KS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgbmctdGVtcGxhdGUtbm8tcnVuXG4gKiA8dWw+XG4gKiAgICA8bGk+e3tkYXRlIHwga2VuZG9EYXRlIH19PC9saT5cbiAqICAgIDxsaT57e21pbGxpc2Vjb25kcyB8IGtlbmRvRGF0ZTogJ00vZGQveXl5JyB9fTwvbGk+XG4gKiAgICA8bGk+e3tzdHJpbmdEYXRlIHwga2VuZG9EYXRlOiAnRycgfX08L2xpPlxuICogPC91bD5cbiAqIGBgYFxuICovXG5sZXQgRGF0ZVBpcGUgPSBjbGFzcyBEYXRlUGlwZSB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGludGxTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuaW50bFNlcnZpY2UgPSBpbnRsU2VydmljZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBgRGF0ZWAgb2JqZWN0IGludG8gYSBzdHJpbmcgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBmb3JtYXQuXG4gICAgICogSWYgbm8gZm9ybWF0IGlzIHByb3ZpZGVkLCB0aGUgZGVmYXVsdCBzaG9ydCBkYXRlIGZvcm1hdCBpcyB1c2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIGRhdGUgdG8gZm9ybWF0LlxuICAgICAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IHN0cmluZyBvciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIChPcHRpb25hbCkgVGhlIElEIG9mIHRoZSBsb2NhbGUgd2hpY2ggd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgb25lLlxuICAgICAqIEByZXR1cm4gLSBUaGUgZm9ybWF0dGVkIGRhdGUuXG4gICAgICovXG4gICAgdHJhbnNmb3JtKHZhbHVlLCBmb3JtYXQkJDEgPSBcIlwiLCBsb2NhbGVJZCkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMubm9ybWFsaXplKHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRsU2VydmljZS5mb3JtYXREYXRlKHZhbHVlLCBmb3JtYXQkJDEsIGxvY2FsZUlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIG5vcm1hbGl6ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmludGxTZXJ2aWNlLnBhcnNlRGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgJiYgaXNOdW1lcmljKHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZShwYXJzZUZsb2F0KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn07XG5EYXRlUGlwZSA9IF9fZGVjb3JhdGUoW1xuICAgIFBpcGUoe1xuICAgICAgICBuYW1lOiAna2VuZG9EYXRlJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbSW50bFNlcnZpY2VdKVxuXSwgRGF0ZVBpcGUpO1xuXG4vKipcbiAqIEZvcm1hdHMgYSBudW1iZXIgdmFsdWUgdG8gYSBzdHJpbmcgYmFzZWQgb24gdGhlIHJlcXVlc3RlZCBmb3JtYXQuXG4gKiBUaGlzIHBpcGUgdXNlcyB0aGUgW2BJbnRsU2VydmljZWBdKHslIHNsdWcgYXBpX2ludGxfaW50bHNlcnZpY2UgJX0pLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBuZy10ZW1wbGF0ZS1uby1ydW5cbiAqICAgPHVsPlxuICogICAgIDxsaT57e2RlY2ltYWwgfCBrZW5kb051bWJlcjonYycgfX08L2xpPlxuICogICAgIDxsaT57e3N0cmluZ051bWJlciB8IGtlbmRvTnVtYmVyOidwJyB9fTwvbGk+XG4gKiAgICAgPGxpPnt7aW50IHwga2VuZG9OdW1iZXI6JyMjLjAwJyB9fTwvbGk+XG4gKiAgPC91bD5cbiAqIGBgYFxuICovXG5sZXQgTnVtYmVyUGlwZSA9IGNsYXNzIE51bWJlclBpcGUge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpbnRsU2VydmljZSkge1xuICAgICAgICB0aGlzLmludGxTZXJ2aWNlID0gaW50bFNlcnZpY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgYE51bWJlcmAgb2JqZWN0IGludG8gYSBzdHJpbmcgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBmb3JtYXQuXG4gICAgICogSWYgbm8gZm9ybWF0IGlzIHByb3ZpZGVkLCB0aGUgdmFsdWUgaXMgZm9ybWF0dGVkIGFzIGRlY2ltYWwgbnVtYmVyIHVzaW5nIHRoZVxuICAgICAqIFtgXCJuXCJgXShodHRwczovL2dpdGh1Yi5jb20vdGVsZXJpay9rZW5kby1pbnRsL2Jsb2IvbWFzdGVyL2RvY3MvbnVtLWZvcm1hdHRpbmcvaW5kZXgubWQjc3RhbmRhcmQpIGZvcm1hdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBudW1lciB0aGF0IHdpbGwgYmUgZm9ybWF0dGVkLlxuICAgICAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IHN0cmluZyBvciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBsb2NhbGVJZCAtIChPcHRpb25hbCkgVGhlIGxvY2FsZSBJRCB0aGF0IHdpbGwgYmUgdXNlZCBpbiBwbGFjZSBvZiB0aGUgZGVmYXVsdCBvbmUuXG4gICAgICogQHJldHVybiAtIFRoZSBmb3JtYXR0ZWQgbnVtYmVyLlxuICAgICAqL1xuICAgIHRyYW5zZm9ybSh2YWx1ZSwgZm9ybWF0JCQxLCBsb2NhbGVJZCkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmludGxTZXJ2aWNlLnBhcnNlTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50bFNlcnZpY2UuZm9ybWF0TnVtYmVyKHZhbHVlLCBmb3JtYXQkJDEsIGxvY2FsZUlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufTtcbk51bWJlclBpcGUgPSBfX2RlY29yYXRlKFtcbiAgICBQaXBlKHtcbiAgICAgICAgbmFtZTogJ2tlbmRvTnVtYmVyJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbSW50bFNlcnZpY2VdKVxuXSwgTnVtYmVyUGlwZSk7XG5cbmNvbnN0IHBpcGVzID0gW1xuICAgIERhdGVQaXBlLFxuICAgIE51bWJlclBpcGVcbl07XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFtOZ01vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVhcGknXSB9fWRvY3MvdHMvbGF0ZXN0L2d1aWRlL25nbW9kdWxlLmh0bWwpXG4gKiBkZWZpbml0aW9uIGZvciB0aGUgSW50bCBzZXJ2aWNlcy5cbiAqL1xubGV0IEludGxNb2R1bGUgPSBjbGFzcyBJbnRsTW9kdWxlIHtcbn07XG5JbnRsTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBkZWNsYXJhdGlvbnM6IFtwaXBlc10sXG4gICAgICAgIGV4cG9ydHM6IFtwaXBlc11cbiAgICB9KVxuXSwgSW50bE1vZHVsZSk7XG5cbi8qKlxuICogR2VuZXJhdGVkIGJ1bmRsZSBpbmRleC4gRG8gbm90IGVkaXQuXG4gKi9cblxuZXhwb3J0IHsgY2xkclNlcnZpY2VGYWN0b3J5LCBJbnRsU2VydmljZSwgQ2xkckludGxTZXJ2aWNlLCBEYXRlUGlwZSwgybUwLCBOdW1iZXJQaXBlLCBJbnRsTW9kdWxlLCBkYXRlRm9ybWF0TmFtZXMkMSBhcyBkYXRlRm9ybWF0TmFtZXMsIGRhdGVGaWVsZE5hbWUkMSBhcyBkYXRlRmllbGROYW1lLCBmaXJzdERheSQxIGFzIGZpcnN0RGF5LCBmb3JtYXQkMSBhcyBmb3JtYXQsIGZvcm1hdERhdGUkMSBhcyBmb3JtYXREYXRlLCBmb3JtYXROdW1iZXIkMSBhcyBmb3JtYXROdW1iZXIsIGxvYWQkMSBhcyBsb2FkLCBudW1iZXJTeW1ib2xzJDEgYXMgbnVtYmVyU3ltYm9scywgcGFyc2VEYXRlJDEgYXMgcGFyc2VEYXRlLCBwYXJzZU51bWJlciQxIGFzIHBhcnNlTnVtYmVyLCBzcGxpdERhdGVGb3JtYXQkMSBhcyBzcGxpdERhdGVGb3JtYXQsIHRvU3RyaW5nJDEgYXMgdG9TdHJpbmcsIHdlZWtlbmRSYW5nZSQxIGFzIHdlZWtlbmRSYW5nZSwgc2V0RGF0YSQxIGFzIHNldERhdGEsIGxvY2FsZURhdGEgfTtcbiJdfQ==\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/canvas/export-image.js\nvar export_image = __webpack_require__(\"uekK\");\n\n// EXTERNAL MODULE: ./node_modules/@progress/kendo-drawing/dist/es2015/svg/export-svg.js\nvar export_svg = __webpack_require__(\"eO0B\");\n\n// CONCATENATED MODULE: ./node_modules/@progress/kendo-angular-charts/__ivy_ngcc__/dist/fesm2015/index.js\n/**-----------------------------------------------------------------------------------------\n* Copyright © 2020 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst fesm2015_c0 = [\"content\"];\nfunction TooltipPopupComponent_ng_template_0_1_ng_template_0_Template(rf, ctx) { }\nfunction TooltipPopupComponent_ng_template_0_1_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Kc\" /* ɵɵtemplate */](0, TooltipPopupComponent_ng_template_0_1_ng_template_0_Template, 0, 0, \"ng-template\", 5);\n    }\n    if (rf & 2) {\n        const ctx_r4 = core[\"kc\" /* ɵɵnextContext */](2);\n        core[\"pc\" /* ɵɵproperty */](\"ngTemplateOutlet\", ctx_r4.seriesTooltipTemplateRef)(\"ngTemplateOutletContext\", ctx_r4.seriesTooltipContext);\n    }\n}\nfunction TooltipPopupComponent_ng_template_0_2_ng_template_0_Template(rf, ctx) { }\nfunction TooltipPopupComponent_ng_template_0_2_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Kc\" /* ɵɵtemplate */](0, TooltipPopupComponent_ng_template_0_2_ng_template_0_Template, 0, 0, \"ng-template\", 5);\n    }\n    if (rf & 2) {\n        const ctx_r5 = core[\"kc\" /* ɵɵnextContext */](2);\n        core[\"pc\" /* ɵɵproperty */](\"ngTemplateOutlet\", ctx_r5.seriesSharedTooltipTemplateRef)(\"ngTemplateOutletContext\", ctx_r5.seriesSharedTooltipContext);\n    }\n}\nfunction TooltipPopupComponent_ng_template_0_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Vb\" /* ɵɵelementStart */](0, \"div\", 3);\n        core[\"Kc\" /* ɵɵtemplate */](1, TooltipPopupComponent_ng_template_0_1_Template, 1, 2, undefined, 4);\n        core[\"Kc\" /* ɵɵtemplate */](2, TooltipPopupComponent_ng_template_0_2_Template, 1, 2, undefined, 4);\n        core[\"Ub\" /* ɵɵelementEnd */]();\n    }\n    if (rf & 2) {\n        const ctx_r1 = core[\"kc\" /* ɵɵnextContext */]();\n        core[\"pc\" /* ɵɵproperty */](\"ngClass\", ctx_r1.popupClasses)(\"ngStyle\", ctx_r1.style);\n        core[\"Cb\" /* ɵɵadvance */](1);\n        core[\"pc\" /* ɵɵproperty */](\"ngIf\", !ctx_r1.shared);\n        core[\"Cb\" /* ɵɵadvance */](1);\n        core[\"pc\" /* ɵɵproperty */](\"ngIf\", ctx_r1.shared);\n    }\n}\nfunction TooltipPopupComponent_ng_template_2_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Qb\" /* ɵɵelement */](0, \"span\", 6);\n    }\n    if (rf & 2) {\n        const formattedValue_r8 = ctx.formattedValue;\n        core[\"pc\" /* ɵɵproperty */](\"innerHTML\", formattedValue_r8, core[\"Bc\" /* ɵɵsanitizeHtml */]);\n    }\n}\nfunction TooltipPopupComponent_ng_template_3_tr_4_td_1_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Vb\" /* ɵɵelementStart */](0, \"td\");\n        core[\"Qb\" /* ɵɵelement */](1, \"span\", 8);\n        core[\"Ub\" /* ɵɵelementEnd */]();\n    }\n    if (rf & 2) {\n        const point_r15 = core[\"kc\" /* ɵɵnextContext */]().$implicit;\n        core[\"Cb\" /* ɵɵadvance */](1);\n        core[\"Hc\" /* ɵɵstyleProp */](\"background-color\", point_r15.series.color);\n    }\n}\nfunction TooltipPopupComponent_ng_template_3_tr_4_td_2_ng_container_1_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Tb\" /* ɵɵelementContainerStart */](0);\n        core[\"Mc\" /* ɵɵtext */](1);\n        core[\"Sb\" /* ɵɵelementContainerEnd */]();\n    }\n    if (rf & 2) {\n        const point_r15 = core[\"kc\" /* ɵɵnextContext */](2).$implicit;\n        core[\"Cb\" /* ɵɵadvance */](1);\n        core[\"Nc\" /* ɵɵtextInterpolate */](point_r15.series.name);\n    }\n}\nfunction TooltipPopupComponent_ng_template_3_tr_4_td_2_ng_container_2_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Tb\" /* ɵɵelementContainerStart */](0);\n        core[\"Mc\" /* ɵɵtext */](1, \"\\u00A0\");\n        core[\"Sb\" /* ɵɵelementContainerEnd */]();\n    }\n}\nfunction TooltipPopupComponent_ng_template_3_tr_4_td_2_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Vb\" /* ɵɵelementStart */](0, \"td\");\n        core[\"Kc\" /* ɵɵtemplate */](1, TooltipPopupComponent_ng_template_3_tr_4_td_2_ng_container_1_Template, 2, 1, \"ng-container\", 4);\n        core[\"Kc\" /* ɵɵtemplate */](2, TooltipPopupComponent_ng_template_3_tr_4_td_2_ng_container_2_Template, 2, 0, \"ng-container\", 4);\n        core[\"Ub\" /* ɵɵelementEnd */]();\n    }\n    if (rf & 2) {\n        const point_r15 = core[\"kc\" /* ɵɵnextContext */]().$implicit;\n        core[\"Cb\" /* ɵɵadvance */](1);\n        core[\"pc\" /* ɵɵproperty */](\"ngIf\", point_r15.series.name !== undefined);\n        core[\"Cb\" /* ɵɵadvance */](1);\n        core[\"pc\" /* ɵɵproperty */](\"ngIf\", point_r15.series.name === undefined);\n    }\n}\nfunction TooltipPopupComponent_ng_template_3_tr_4_ng_template_4_Template(rf, ctx) { }\nfunction TooltipPopupComponent_ng_template_3_tr_4_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Vb\" /* ɵɵelementStart */](0, \"tr\");\n        core[\"Kc\" /* ɵɵtemplate */](1, TooltipPopupComponent_ng_template_3_tr_4_td_1_Template, 2, 2, \"td\", 4);\n        core[\"Kc\" /* ɵɵtemplate */](2, TooltipPopupComponent_ng_template_3_tr_4_td_2_Template, 3, 2, \"td\", 4);\n        core[\"Vb\" /* ɵɵelementStart */](3, \"td\");\n        core[\"Kc\" /* ɵɵtemplate */](4, TooltipPopupComponent_ng_template_3_tr_4_ng_template_4_Template, 0, 0, \"ng-template\", 5);\n        core[\"Ub\" /* ɵɵelementEnd */]();\n        core[\"Ub\" /* ɵɵelementEnd */]();\n    }\n    if (rf & 2) {\n        const point_r15 = ctx.$implicit;\n        const ctx_r24 = core[\"kc\" /* ɵɵnextContext */]();\n        const colorMarker_r12 = ctx_r24.colorMarker;\n        const nameColumn_r13 = ctx_r24.nameColumn;\n        core[\"Cb\" /* ɵɵadvance */](1);\n        core[\"pc\" /* ɵɵproperty */](\"ngIf\", colorMarker_r12);\n        core[\"Cb\" /* ɵɵadvance */](1);\n        core[\"pc\" /* ɵɵproperty */](\"ngIf\", nameColumn_r13);\n        core[\"Cb\" /* ɵɵadvance */](2);\n        core[\"pc\" /* ɵɵproperty */](\"ngTemplateOutlet\", point_r15.template)(\"ngTemplateOutletContext\", point_r15);\n    }\n}\nfunction TooltipPopupComponent_ng_template_3_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Vb\" /* ɵɵelementStart */](0, \"table\");\n        core[\"Vb\" /* ɵɵelementStart */](1, \"tr\");\n        core[\"Vb\" /* ɵɵelementStart */](2, \"th\");\n        core[\"Mc\" /* ɵɵtext */](3);\n        core[\"Ub\" /* ɵɵelementEnd */]();\n        core[\"Ub\" /* ɵɵelementEnd */]();\n        core[\"Kc\" /* ɵɵtemplate */](4, TooltipPopupComponent_ng_template_3_tr_4_Template, 5, 4, \"tr\", 7);\n        core[\"Ub\" /* ɵɵelementEnd */]();\n    }\n    if (rf & 2) {\n        const points_r9 = ctx.points;\n        const categoryText_r10 = ctx.categoryText;\n        const colspan_r11 = ctx.colspan;\n        core[\"Cb\" /* ɵɵadvance */](2);\n        core[\"Db\" /* ɵɵattribute */](\"colspan\", colspan_r11);\n        core[\"Cb\" /* ɵɵadvance */](1);\n        core[\"Oc\" /* ɵɵtextInterpolate1 */](\" \", categoryText_r10, \" \");\n        core[\"Cb\" /* ɵɵadvance */](1);\n        core[\"pc\" /* ɵɵproperty */](\"ngForOf\", points_r9);\n    }\n}\nfunction CrosshairTooltipComponent_ng_template_0_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Vb\" /* ɵɵelementStart */](0, \"div\", 1);\n        core[\"Mc\" /* ɵɵtext */](1);\n        core[\"Ub\" /* ɵɵelementEnd */]();\n    }\n    if (rf & 2) {\n        const ctx_r1 = core[\"kc\" /* ɵɵnextContext */]();\n        core[\"pc\" /* ɵɵproperty */](\"ngStyle\", ctx_r1.style);\n        core[\"Cb\" /* ɵɵadvance */](1);\n        core[\"Oc\" /* ɵɵtextInterpolate1 */](\" \", ctx_r1.value, \" \");\n    }\n}\nfunction CrosshairTooltipsContainerComponent_kendo_chart_crosshair_tooltip_0_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Qb\" /* ɵɵelement */](0, \"kendo-chart-crosshair-tooltip\", 1);\n    }\n    if (rf & 2) {\n        const key_r1 = ctx.$implicit;\n        const ctx_r0 = core[\"kc\" /* ɵɵnextContext */]();\n        core[\"pc\" /* ɵɵproperty */](\"key\", key_r1)(\"popupSettings\", ctx_r0.popupSettings);\n    }\n}\nconst fesm2015_c1 = [\"surface\"];\nfunction ChartComponent_div_5_ng_template_1_Template(rf, ctx) { }\nfunction ChartComponent_div_5_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Vb\" /* ɵɵelementStart */](0, \"div\", 6);\n        core[\"Kc\" /* ɵɵtemplate */](1, ChartComponent_div_5_ng_template_1_Template, 0, 0, \"ng-template\", 7);\n        core[\"Ub\" /* ɵɵelementEnd */]();\n    }\n    if (rf & 2) {\n        const ctx_r1 = core[\"kc\" /* ɵɵnextContext */]();\n        core[\"pc\" /* ɵɵproperty */](\"ngStyle\", ctx_r1.donutCenterStyle);\n        core[\"Cb\" /* ɵɵadvance */](1);\n        core[\"pc\" /* ɵɵproperty */](\"ngTemplateOutlet\", ctx_r1.donutCenterTemplate.templateRef);\n    }\n}\n\n\n\n\n\n\n\n/**\n * @hidden\n */\nconst dist_fesm2015_packageMetadata = {\n    name: '@progress/kendo-angular-charts',\n    productName: 'Kendo UI for Angular',\n    productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],\n    publishDate: 1620213099,\n    version: '',\n    licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'\n};\nlet fesm2015_ChartComponentGenerated = /*@__PURE__*/ (() => {\n    class ChartComponentGenerated {\n        constructor(configurationService) {\n            this.configurationService = configurationService;\n            /**\n             * Fires when the user clicks an axis label ([see example]({% slug overview_chart_charts %}#toc-events)).\n             */\n            this.axisLabelClick = new core[\"o\" /* EventEmitter */]();\n            /**\n             * Fires as long as the user is dragging the Chart with the mouse or through swipe gestures.\n             */\n            this.drag = new core[\"o\" /* EventEmitter */]();\n            /**\n             * Fires when the user stops dragging the Chart.\n             */\n            this.dragEnd = new core[\"o\" /* EventEmitter */]();\n            /**\n             * Fires when the user starts dragging the Chart.\n             */\n            this.dragStart = new core[\"o\" /* EventEmitter */]();\n            /**\n             * Fires when the user hovers over a legend item ([see example]({% slug overview_chart_charts %}#toc-events)).\n             */\n            this.legendItemHover = new core[\"o\" /* EventEmitter */]();\n            /**\n             * Fires when the cursor leaves a legend item.\n             */\n            this.legendItemLeave = new core[\"o\" /* EventEmitter */]();\n            /**\n             * Fires when the user clicks a note.\n             */\n            this.noteClick = new core[\"o\" /* EventEmitter */]();\n            /**\n             * Fires when the user hovers over a note.\n             */\n            this.noteHover = new core[\"o\" /* EventEmitter */]();\n            /**\n             * Fires when the cursor leaves a note.\n             */\n            this.noteLeave = new core[\"o\" /* EventEmitter */]();\n            /**\n             * Fires when a pane is rendered because the Chart:\n             * * Is rendered.\n             * * Performs panning or zooming.\n             * * Is exported with different options.\n             * The event is used to render custom visuals in the panes.\n             */\n            this.paneRender = new core[\"o\" /* EventEmitter */]();\n            /**\n             * Fires when the user clicks the plot area ([see example]({% slug overview_chart_charts %}#toc-events)).\n             * The `click` event is triggered by the `tap` and `contextmenu` events.\n             * To distinguish between the original events, inspect the `e.originalEvent.type` field.\n             */\n            this.plotAreaClick = new core[\"o\" /* EventEmitter */]();\n            /**\n             * Fires when the user hovers the plot area ([see example]({% slug overview_chart_charts %}#toc-events)).\n             */\n            this.plotAreaHover = new core[\"o\" /* EventEmitter */]();\n            /**\n             * Fires when the cursor leaves the plot area.\n             */\n            this.plotAreaLeave = new core[\"o\" /* EventEmitter */]();\n            /**\n             * Fires when the Chart is ready to render on screen ([see example]({% slug overview_chart_charts %}#toc-events)).\n             * For example, you can use it to remove loading indicators.\n             * Any changes made to the options are ignored.\n             */\n            this.render = new core[\"o\" /* EventEmitter */]();\n            /**\n             * Fires when the user modifies the selection.\n             *\n             * The range units are:\n             * - Generic axis&mdash;Category index (0-based).\n             * - Date axis&mdash;Date instance.\n             */\n            this.select = new core[\"o\" /* EventEmitter */]();\n            /**\n             * Fires when the user completes the modification of the selection.\n             *\n             * The range units are:\n             * - Generic axis&mdash;Category index (0-based).\n             * - Date axis&mdash;Date instance.\n             */\n            this.selectEnd = new core[\"o\" /* EventEmitter */]();\n            /**\n             * Fires when the user starts modifying the axis selection.\n             *\n             * The range units are:\n             * - Generic axis&mdash;Category index (0-based).\n             * - Date axis&mdash;Date instance.\n             */\n            this.selectStart = new core[\"o\" /* EventEmitter */]();\n            /**\n             * Fires when the user clicks the Chart series.\n             *\n             * The `click` event will be triggered by the `tap` and `contextmenu` events ([see example]({% slug overview_chart_charts %}#toc-events)).\n             * To distinguish between the original events, inspect the `e.originalEvent.type` field.\n             */\n            this.seriesClick = new core[\"o\" /* EventEmitter */]();\n            /**\n             * Fires when the user hovers the Chart series ([see example]({% slug overview_chart_charts %}#toc-events)).\n             */\n            this.seriesHover = new core[\"o\" /* EventEmitter */]();\n            /**\n             * Fires when the cursor enters a series.\n             */\n            this.seriesOver = new core[\"o\" /* EventEmitter */]();\n            /**\n             * Fires when the cursor leaves a series.\n             */\n            this.seriesLeave = new core[\"o\" /* EventEmitter */]();\n            /**\n             * Fires as long as the user is zooming the Chart by using the mousewheel operation.\n             */\n            this.zoom = new core[\"o\" /* EventEmitter */]();\n            /**\n             * Fires when the user stops zooming the Chart.\n             */\n            this.zoomEnd = new core[\"o\" /* EventEmitter */]();\n            /**\n             * Fires when the user uses the mousewheel to zoom the Chart.\n             */\n            this.zoomStart = new core[\"o\" /* EventEmitter */]();\n        }\n    }\n    ChartComponentGenerated.ɵfac = function ChartComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    ChartComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: ChartComponentGenerated, inputs: { pannable: \"pannable\", renderAs: \"renderAs\", seriesColors: \"seriesColors\", title: \"title\", transitions: \"transitions\", zoomable: \"zoomable\", axisDefaults: \"axisDefaults\", categoryAxis: \"categoryAxis\", chartArea: \"chartArea\", legend: \"legend\", panes: \"panes\", paneDefaults: \"paneDefaults\", plotArea: \"plotArea\", series: \"series\", seriesDefaults: \"seriesDefaults\", tooltip: \"tooltip\", valueAxis: \"valueAxis\", xAxis: \"xAxis\", yAxis: \"yAxis\" }, outputs: { axisLabelClick: \"axisLabelClick\", drag: \"drag\", dragEnd: \"dragEnd\", dragStart: \"dragStart\", legendItemHover: \"legendItemHover\", legendItemLeave: \"legendItemLeave\", noteClick: \"noteClick\", noteHover: \"noteHover\", noteLeave: \"noteLeave\", paneRender: \"paneRender\", plotAreaClick: \"plotAreaClick\", plotAreaHover: \"plotAreaHover\", plotAreaLeave: \"plotAreaLeave\", render: \"render\", select: \"select\", selectEnd: \"selectEnd\", selectStart: \"selectStart\", seriesClick: \"seriesClick\", seriesHover: \"seriesHover\", seriesOver: \"seriesOver\", seriesLeave: \"seriesLeave\", zoom: \"zoom\", zoomEnd: \"zoomEnd\", zoomStart: \"zoomStart\" } });\n    return ChartComponentGenerated;\n})();\n/**\n * @hidden\n */\nconst THROTTLE_MS = 1000 / 60;\n/**\n * @hidden\n */\nclass Change {\n    constructor(key, value) {\n        this.key = key;\n        this.value = value;\n    }\n}\nlet fesm2015_ConfigurationService = /*@__PURE__*/ (() => {\n    /**\n     * @hidden\n     */\n    let ConfigurationService = class ConfigurationService {\n        constructor(ngZone) {\n            this.ngZone = ngZone;\n            this.store = {};\n            this.source = new BehaviorSubject[\"a\" /* BehaviorSubject */]({});\n            this.initSource();\n        }\n        initSource() {\n            this.onFastChange$ = this.source.asObservable();\n            this.onChange$ = this.onFastChange$.pipe(Object(auditTime[\"a\" /* auditTime */])(THROTTLE_MS));\n        }\n        push(store) {\n            this.store = store;\n            this.next();\n        }\n        notify(change) {\n            this.set(change.key, change.value);\n            this.next();\n        }\n        set(field, value) {\n            let store = this.store;\n            const parts = field.split('.');\n            let key = parts.shift();\n            while (parts.length > 0) {\n                store = store[key] = store[key] || {};\n                key = parts.shift();\n            }\n            store[key] = value;\n        }\n        next() {\n            this.ngZone.runOutsideAngular(() => {\n                this.source.next(this.store);\n            });\n        }\n    };\n    ConfigurationService.ɵfac = function ConfigurationService_Factory(t) { return new (t || ConfigurationService)(core[\"cc\" /* ɵɵinject */](core[\"B\" /* NgZone */])); };\n    ConfigurationService.ɵprov = core[\"Lb\" /* ɵɵdefineInjectable */]({ token: ConfigurationService, factory: function (t) { return ConfigurationService.ɵfac(t); } });\n    ConfigurationService = __decorate([__metadata(\"design:paramtypes\", [core[\"B\" /* NgZone */]])\n    ], ConfigurationService);\n    return ConfigurationService;\n})();\n/**\n * @hidden\n */\nclass BaseEvent {\n    /**\n     * @hidden\n     */\n    constructor(sender) {\n        this.sender = sender;\n    }\n}\n/**\n * @hidden\n */\nclass fesm2015_PreventableEvent extends BaseEvent {\n    constructor() {\n        super(...arguments);\n        this.prevented = false;\n    }\n    /**\n     * Prevents the default action for a specified event.\n     * In this way, the source component suppresses\n     * the built-in behavior that follows the event.\n     */\n    preventDefault() {\n        this.prevented = true;\n    }\n    /**\n     * Returns `true` if the event was prevented\n     * by any of its subscribers.\n     *\n     * @returns `true` if the default action was prevented.\n     * Otherwise, returns `false`.\n     */\n    isDefaultPrevented() {\n        return this.prevented;\n    }\n}\n/**\n * @hidden\n */\nclass LegendEvent extends fesm2015_PreventableEvent {\n    /**\n     * @hidden\n     */\n    constructor(e, sender) {\n        super(sender);\n        this.series = e.series;\n        this.seriesIndex = e.seriesIndex;\n        this.pointIndex = e.pointIndex;\n        this.text = e.text;\n    }\n}\n/**\n * Arguments for the `legendItemClick` event.\n */\nclass LegendItemClickEvent extends LegendEvent {\n    /**\n     * If called, the series visibility is not toggled as a result of clicking the legend item.\n     */\n    preventDefault() {\n        super.preventDefault();\n    }\n}\n/**\n * Arguments for the `axisLabelClick` event.\n */\nclass AxisLabelClickEvent extends BaseEvent {\n    /**\n     * @hidden\n     */\n    constructor(e, sender) {\n        super(sender);\n        this.axis = e.axis;\n        this.dataItem = e.dataItem;\n        this.index = e.index;\n        this.text = e.text;\n        this.value = e.value;\n    }\n}\n/**\n * Arguments for the `drag` event.\n */\nclass DragEvent extends fesm2015_PreventableEvent {\n    /**\n     * @hidden\n     */\n    constructor(e, sender) {\n        super(sender);\n        this.axisRanges = e.axisRanges;\n        this.originalEvent = e.originalEvent;\n    }\n}\n/**\n * Arguments for the `dragEnd` event.\n */\nclass DragEndEvent extends BaseEvent {\n    /**\n     * @hidden\n     */\n    constructor(e, sender) {\n        super(sender);\n        this.axisRanges = e.axisRanges;\n        this.originalEvent = e.originalEvent;\n    }\n}\n/**\n * Arguments for the `dragStart` event.\n */\nclass DragStartEvent extends fesm2015_PreventableEvent {\n    /**\n     * @hidden\n     */\n    constructor(e, sender) {\n        super(sender);\n        this.axisRanges = e.axisRanges;\n        this.originalEvent = e.originalEvent;\n    }\n}\n/**\n * Arguments for the `legendItemHover` event.\n */\nclass LegendItemHoverEvent extends LegendEvent {\n    /**\n     * If called, the series highlight is not shown as a result of hovering over the legend item.\n     */\n    preventDefault() {\n        super.preventDefault();\n    }\n}\n/* tslint:disable:no-empty */\n/**\n * Arguments for the `legendItemLeave` event.\n */\nclass LegendItemLeaveEvent extends LegendEvent {\n    /**\n     * @hidden\n     */\n    preventDefault() {\n    }\n    /**\n     * @hidden\n     */\n    isDefaultPrevented() {\n        return false;\n    }\n}\n/**\n * @hidden\n */\nclass NoteEvent extends BaseEvent {\n    /**\n     * @hidden\n     */\n    constructor(e, sender) {\n        super(sender);\n        this.category = e.category;\n        this.dataItem = e.dataItem;\n        this.series = e.series;\n        this.value = e.value;\n        this.visual = e.visual;\n    }\n}\n/**\n * Arguments for the `noteClick` event.\n */\nclass NoteClickEvent extends NoteEvent {\n}\n/**\n * Arguments for the `noteHover` event.\n */\nclass NoteHoverEvent extends NoteEvent {\n}\n/**\n * Arguments for the `noteLeave` event.\n */\nclass NoteLeaveEvent extends NoteEvent {\n}\n/**\n * Arguments for the `paneRender` event.\n */\nclass PaneRenderEvent extends BaseEvent {\n    /**\n     * @hidden\n     */\n    constructor(args, sender) {\n        super(sender);\n        Object.assign(this, args);\n    }\n}\n/**\n * Arguments for the `plotAreaClick` event.\n */\nclass PlotAreaClickEvent extends BaseEvent {\n    /**\n     * @hidden\n     */\n    constructor(e, sender) {\n        super(sender);\n        this.category = e.category;\n        this.originalEvent = e.originalEvent;\n        this.value = e.value;\n        this.x = e.x;\n        this.y = e.y;\n    }\n}\n/**\n * Arguments for the `plotAreaHover` event.\n */\nclass PlotAreaHoverEvent extends BaseEvent {\n    /**\n     * @hidden\n     */\n    constructor(e, sender) {\n        super(sender);\n        this.category = e.category;\n        this.originalEvent = e.originalEvent;\n        this.value = e.value;\n        this.x = e.x;\n        this.y = e.y;\n    }\n}\nclass PlotAreaLeaveEvent extends BaseEvent {\n}\n/**\n * Arguments for the `render` event.\n */\nclass RenderEvent extends BaseEvent {\n    /**\n     * @hidden\n     */\n    constructor(_e, sender) {\n        super(sender);\n    }\n}\n/**\n * Arguments for the `select` event.\n */\nclass SelectEvent extends fesm2015_PreventableEvent {\n    /**\n     * @hidden\n     */\n    constructor(e, sender) {\n        super(sender);\n        this.axis = e.axis;\n        this.from = e.from;\n        this.to = e.to;\n    }\n}\n/**\n * Arguments for the `selectEnd` event.\n */\nclass SelectEndEvent extends BaseEvent {\n    /**\n     * @hidden\n     */\n    constructor(e, sender) {\n        super(sender);\n        this.axis = e.axis;\n        this.from = e.from;\n        this.to = e.to;\n    }\n}\n/**\n * Arguments for the `selectStart` event.\n */\nclass SelectStartEvent extends fesm2015_PreventableEvent {\n    /**\n     * @hidden\n     */\n    constructor(e, sender) {\n        super(sender);\n        this.axis = e.axis;\n        this.from = e.from;\n        this.to = e.to;\n    }\n}\n/**\n * Arguments for the `seriesClick` event.\n */\nclass SeriesClickEvent extends BaseEvent {\n    /**\n     * @hidden\n     */\n    constructor(e, sender) {\n        super(sender);\n        this.category = e.category;\n        this.dataItem = e.dataItem;\n        this.originalEvent = e.originalEvent;\n        this.percentage = e.percentage;\n        this.point = e.point;\n        this.series = e.series;\n        this.stackValue = e.stackValue;\n        this.value = e.value;\n    }\n}\n/**\n * @hidden\n */\nclass SeriesEvent extends fesm2015_PreventableEvent {\n    /**\n     * @hidden\n     */\n    constructor(e, sender) {\n        super(sender);\n        this.category = e.category;\n        this.dataItem = e.dataItem;\n        this.originalEvent = e.originalEvent;\n        this.percentage = e.percentage;\n        this.point = e.point;\n        this.series = e.series;\n        this.stackValue = e.stackValue;\n        this.value = e.value;\n    }\n}\n/**\n * Arguments for the `seriesHover` event.\n */\nclass SeriesHoverEvent extends SeriesEvent {\n}\n/**\n * Arguments for the `seriesOver` event.\n */\nclass SeriesOverEvent extends SeriesEvent {\n}\n/**\n * Arguments for the `seriesLeave` event.\n */\nclass SeriesLeaveEvent extends SeriesEvent {\n}\n/**\n * Arguments for the `zoom` event.\n */\nclass ZoomEvent extends fesm2015_PreventableEvent {\n    /**\n     * @hidden\n     */\n    constructor(e, sender) {\n        super(sender);\n        this.axisRanges = e.axisRanges;\n        this.delta = e.delta;\n        this.originalEvent = e.originalEvent;\n    }\n}\n/**\n * Arguments for the `zoomEnd` event.\n */\nclass ZoomEndEvent extends BaseEvent {\n    /**\n     * @hidden\n     */\n    constructor(e, sender) {\n        super(sender);\n        this.axisRanges = e.axisRanges;\n        this.originalEvent = e.originalEvent;\n    }\n}\n/**\n * Arguments for the `zoomStart` event.\n */\nclass ZoomStartEvent extends fesm2015_PreventableEvent {\n    /**\n     * @hidden\n     */\n    constructor(e, sender) {\n        super(sender);\n        this.axisRanges = e.axisRanges;\n        this.originalEvent = e.originalEvent;\n    }\n}\nconst EVENT_MAP = {\n    axisLabelClick: AxisLabelClickEvent,\n    drag: DragEvent,\n    dragEnd: DragEndEvent,\n    dragStart: DragStartEvent,\n    legendItemHover: LegendItemHoverEvent,\n    legendItemLeave: LegendItemLeaveEvent,\n    noteClick: NoteClickEvent,\n    noteHover: NoteHoverEvent,\n    noteLeave: NoteLeaveEvent,\n    paneRender: PaneRenderEvent,\n    plotAreaClick: PlotAreaClickEvent,\n    plotAreaHover: PlotAreaHoverEvent,\n    plotAreaLeave: PlotAreaLeaveEvent,\n    render: RenderEvent,\n    select: SelectEvent,\n    selectEnd: SelectEndEvent,\n    selectStart: SelectStartEvent,\n    seriesClick: SeriesClickEvent,\n    seriesHover: SeriesHoverEvent,\n    seriesOver: SeriesOverEvent,\n    seriesLeave: SeriesLeaveEvent,\n    zoom: ZoomEvent,\n    zoomEnd: ZoomEndEvent,\n    zoomStart: ZoomStartEvent\n};\nlet fesm2015_InstanceEventService = /*@__PURE__*/ (() => {\n    class InstanceEventService {\n        create(name, args, sender) {\n            if (EVENT_MAP[name]) {\n                return new EVENT_MAP[name](args, sender);\n            }\n        }\n    }\n    InstanceEventService.ɵfac = function InstanceEventService_Factory(t) { return new (t || InstanceEventService)(); };\n    InstanceEventService.ɵprov = core[\"Lb\" /* ɵɵdefineInjectable */]({ token: InstanceEventService, factory: InstanceEventService.ɵfac });\n    return InstanceEventService;\n})();\nlet fesm2015_DonutCenterTemplateDirective = /*@__PURE__*/ (() => {\n    /**\n     * A directive which selects a [template]({{ site.data.urls.angular['templatesyntax'] }})\n     * within the `<kendo-chart>` component for the\n     * [Donut center template]({% slug donut_seriestypes_charts %}).\n     *\n     * @example\n     * ```ts\n     * import { Component } from '@angular/core';\n     *\n     * _@Component({\n     *   selector: 'my-app',\n     *   template: `\n     *     <kendo-chart style=\"height: 450px;\">\n     *       <ng-template kendoChartDonutCenterTemplate>\n     *         <h3>22.5%</h3>\n     *         of which renewables\n     *       </ng-template>\n     *       <kendo-chart-series>\n     *         <kendo-chart-series-item\n     *             type=\"donut\" [data]=\"data\"\n     *             categoryField=\"kind\" field=\"share\">\n     *         </kendo-chart-series-item>\n     *       </kendo-chart-series>\n     *       <kendo-chart-legend [visible]=\"false\"></kendo-chart-legend>\n     *     </kendo-chart>\n     *   `\n     * })\n     * export class AppComponent {\n     *   public data: any[] = [{\n     *     kind: 'Hydroelectric', share: 0.175\n     *   }, {\n     *     kind: 'Nuclear', share: 0.238\n     *   }, {\n     *     kind: 'Coal', share: 0.118\n     *   }, {\n     *     kind: 'Solar', share: 0.052\n     *   }, {\n     *     kind: 'Wind', share: 0.225\n     *   }, {\n     *     kind: 'Other', share: 0.192\n     *   }];\n     * }\n     *\n     * ```\n     */\n    let DonutCenterTemplateDirective = class DonutCenterTemplateDirective {\n        constructor(templateRef) {\n            this.templateRef = templateRef;\n        }\n    };\n    DonutCenterTemplateDirective.ɵfac = function DonutCenterTemplateDirective_Factory(t) { return new (t || DonutCenterTemplateDirective)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"O\" /* TemplateRef */], 8)); };\n    DonutCenterTemplateDirective.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: DonutCenterTemplateDirective, selectors: [[\"\", \"kendoChartDonutCenterTemplate\", \"\"]] });\n    DonutCenterTemplateDirective = __decorate([__param(0, Object(core[\"C\" /* Optional */])()),\n        __metadata(\"design:paramtypes\", [core[\"O\" /* TemplateRef */]])\n    ], DonutCenterTemplateDirective);\n    return DonutCenterTemplateDirective;\n})();\n/**\n * @hidden\n */\nclass ItemChange {\n    constructor(sender, options) {\n        this.sender = sender;\n        this.options = options;\n    }\n}\nlet fesm2015_CollectionService = /*@__PURE__*/ (() => {\n    /**\n     * @hidden\n     */\n    let CollectionService = class CollectionService {\n        constructor() {\n            this.source = new Subject[\"a\" /* Subject */]();\n            this.onItemChange$ = this.source.asObservable();\n        }\n        notify(change) {\n            this.source.next(change);\n        }\n    };\n    CollectionService.ɵfac = function CollectionService_Factory(t) { return new (t || CollectionService)(); };\n    CollectionService.ɵprov = core[\"Lb\" /* ɵɵdefineInjectable */]({ token: CollectionService, factory: function (t) { return CollectionService.ɵfac(t); } });\n    CollectionService = __decorate([__metadata(\"design:paramtypes\", [])\n    ], CollectionService);\n    return CollectionService;\n})();\n/**\n * @hidden\n */\nfunction copyChanges(changes, options) {\n    for (const propertyName in changes) {\n        if (!changes.hasOwnProperty(propertyName)) {\n            continue;\n        }\n        const value = changes[propertyName].currentValue;\n        if (value === undefined) {\n            delete options[propertyName];\n        }\n        else {\n            options[propertyName] = value;\n        }\n    }\n}\n/**\n * @hidden\n */\nfunction toSimpleChanges(changes) {\n    const result = {};\n    for (const propertyName in changes) {\n        if (!changes.hasOwnProperty(propertyName)) {\n            continue;\n        }\n        result[propertyName] = new core[\"L\" /* SimpleChange */](null, changes[propertyName], false);\n    }\n    return result;\n}\nlet fesm2015_CollectionItemComponent = /*@__PURE__*/ (() => {\n    class CollectionItemComponent {\n        constructor(configurationService, collectionService) {\n            this.configurationService = configurationService;\n            this.collectionService = collectionService;\n            this.options = {};\n            this.subscription = configurationService.onFastChange$.subscribe(store => {\n                this.options = store;\n                this.notify();\n            });\n        }\n        ngOnChanges(changes) {\n            const store = this.configurationService.store;\n            copyChanges(changes, store);\n            this.configurationService.push(store);\n        }\n        /**\n         * Updates the component fields with the specified values and refreshes the Chart.\n         *\n         * Use this method when the configuration values cannot be set through the template.\n         *\n         * @example\n         * ```ts-no-run\n         * item.notifyChanges({ visible: true });\n         * ```\n         *\n         * @param changes An object containing the updated input fields.\n         */\n        notifyChanges(changes) {\n            this.ngOnChanges(toSimpleChanges(changes));\n        }\n        ngOnDestroy() {\n            this.subscription.unsubscribe();\n        }\n        notify() {\n            if (!this.collectionService) {\n                return;\n            }\n            this.collectionService.notify(new ItemChange(this, this.options));\n        }\n    }\n    CollectionItemComponent.ɵfac = function CollectionItemComponent_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    CollectionItemComponent.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: CollectionItemComponent, features: [core[\"Ab\" /* ɵɵNgOnChangesFeature */]] });\n    return CollectionItemComponent;\n})();\nlet fesm2015_SeriesItemComponentGenerated = /*@__PURE__*/ (() => {\n    class SeriesItemComponentGenerated extends fesm2015_CollectionItemComponent {\n        constructor(configurationService, collectionService) {\n            super(configurationService, collectionService);\n            this.configurationService = configurationService;\n            this.collectionService = collectionService;\n        }\n    }\n    SeriesItemComponentGenerated.ɵfac = function SeriesItemComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    SeriesItemComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: SeriesItemComponentGenerated, inputs: { aggregate: \"aggregate\", autoFit: \"autoFit\", axis: \"axis\", border: \"border\", categoryAxis: \"categoryAxis\", categoryField: \"categoryField\", closeField: \"closeField\", color: \"color\", colorField: \"colorField\", connectors: \"connectors\", currentField: \"currentField\", dashType: \"dashType\", data: \"data\", downColor: \"downColor\", downColorField: \"downColorField\", dynamicHeight: \"dynamicHeight\", dynamicSlope: \"dynamicSlope\", errorHighField: \"errorHighField\", errorLowField: \"errorLowField\", explodeField: \"explodeField\", field: \"field\", fromField: \"fromField\", gap: \"gap\", highField: \"highField\", holeSize: \"holeSize\", line: \"line\", lowField: \"lowField\", lowerField: \"lowerField\", margin: \"margin\", maxSize: \"maxSize\", mean: \"mean\", meanField: \"meanField\", median: \"median\", medianField: \"medianField\", minSize: \"minSize\", missingValues: \"missingValues\", name: \"name\", neckRatio: \"neckRatio\", negativeColor: \"negativeColor\", negativeValues: \"negativeValues\", noteTextField: \"noteTextField\", opacity: \"opacity\", openField: \"openField\", outliersField: \"outliersField\", overlay: \"overlay\", padding: \"padding\", q1Field: \"q1Field\", q3Field: \"q3Field\", segmentSpacing: \"segmentSpacing\", size: \"size\", sizeField: \"sizeField\", spacing: \"spacing\", stack: \"stack\", startAngle: \"startAngle\", style: \"style\", summaryField: \"summaryField\", target: \"target\", toField: \"toField\", type: \"type\", upperField: \"upperField\", visible: \"visible\", visibleInLegend: \"visibleInLegend\", visibleInLegendField: \"visibleInLegendField\", visual: \"visual\", width: \"width\", whiskers: \"whiskers\", xAxis: \"xAxis\", xErrorHighField: \"xErrorHighField\", xErrorLowField: \"xErrorLowField\", xField: \"xField\", yAxis: \"yAxis\", yErrorHighField: \"yErrorHighField\", yErrorLowField: \"yErrorLowField\", yField: \"yField\", zIndex: \"zIndex\", errorBars: \"errorBars\", extremes: \"extremes\", highlight: \"highlight\", labels: \"labels\", markers: \"markers\", notes: \"notes\", outliers: \"outliers\", tooltip: \"tooltip\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return SeriesItemComponentGenerated;\n})();\nlet fesm2015_SettingsComponent = /*@__PURE__*/ (() => {\n    class SettingsComponent {\n        constructor(configKey, configurationService) {\n            this.configKey = configKey;\n            this.configurationService = configurationService;\n            this.store = {};\n            if (configKey === undefined) {\n                throw new Error('Configuration key not set');\n            }\n        }\n        ngOnDestroy() {\n            this.store = undefined;\n            this.notify();\n        }\n        ngOnChanges(changes) {\n            copyChanges(changes, this.store);\n            this.notify();\n        }\n        /**\n         * Updates the component fields with the specified values and refreshes the Chart.\n         *\n         * Use this method when the configuration values cannot be set through the template.\n         *\n         * @example\n         * ```ts-no-run\n         * item.notifyChanges({ visible: true });\n         * ```\n         *\n         * @param changes An object containing the updated input fields.\n         */\n        notifyChanges(changes) {\n            this.ngOnChanges(toSimpleChanges(changes));\n        }\n        markAsVisible() {\n            this.store.visible = true;\n            this.notify();\n        }\n        notify() {\n            this.configurationService.notify(new Change(this.configKey, this.store));\n        }\n    }\n    SettingsComponent.ɵfac = function SettingsComponent_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    SettingsComponent.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: SettingsComponent, features: [core[\"Ab\" /* ɵɵNgOnChangesFeature */]] });\n    return SettingsComponent;\n})();\nlet fesm2015_SeriesTooltipComponentGenerated = /*@__PURE__*/ (() => {\n    class SeriesTooltipComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('tooltip', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    SeriesTooltipComponentGenerated.ɵfac = function SeriesTooltipComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    SeriesTooltipComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: SeriesTooltipComponentGenerated, inputs: { background: \"background\", border: \"border\", color: \"color\", font: \"font\", format: \"format\", padding: \"padding\", visible: \"visible\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return SeriesTooltipComponentGenerated;\n})();\nlet fesm2015_SeriesTooltipComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration options of the Chart series tooltip\n     * ([see example]({% slug tooltips_chart_charts %})).\n     */\n    let SeriesTooltipComponent = class SeriesTooltipComponent extends fesm2015_SeriesTooltipComponentGenerated {\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n            this.markAsVisible();\n        }\n        get seriesTooltipTemplateRef() {\n            return this.seriesTooltipTemplate;\n        }\n    };\n    SeriesTooltipComponent.ɵfac = function SeriesTooltipComponent_Factory(t) { return new (t || SeriesTooltipComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    SeriesTooltipComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: SeriesTooltipComponent, selectors: [[\"kendo-chart-series-item-tooltip\"]], contentQueries: function SeriesTooltipComponent_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                core[\"Ib\" /* ɵɵcontentQuery */](dirIndex, core[\"O\" /* TemplateRef */], true);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx.seriesTooltipTemplate = _t.first);\n            }\n        }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function SeriesTooltipComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    SeriesTooltipComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], SeriesTooltipComponent);\n    return SeriesTooltipComponent;\n})();\nconst fesm2015_toggle = (flag) => flag === undefined ? false : !flag;\nlet fesm2015_SeriesItemComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration component for a series item.\n     */\n    let SeriesItemComponent = class SeriesItemComponent extends fesm2015_SeriesItemComponentGenerated {\n        constructor(configurationService, collectionService) {\n            super(configurationService, collectionService);\n            this.configurationService = configurationService;\n            this.collectionService = collectionService;\n        }\n        /**\n         * Toggles the series visibility and updates the parent Chart\n         * without animated transitions.\n         */\n        toggleVisibility() {\n            this.options.visible = fesm2015_toggle(this.options.visible);\n            this.notify();\n        }\n        /**\n         * Toggles the visibility of a point with the given index.\n         * Applicable for the Pie, Donut, and Funnel series.\n         *\n         * @param pointIndex - The zero-based index of the point to toggle.\n         */\n        togglePointVisibility(pointIndex) {\n            const pv = this.options.pointVisibility = this.options.pointVisibility || {};\n            pv[pointIndex] = fesm2015_toggle(pv[pointIndex]);\n            this.notify();\n        }\n        get seriesTooltipTemplateRef() {\n            if (this.seriesTooltip) {\n                return this.seriesTooltip.seriesTooltipTemplateRef;\n            }\n        }\n    };\n    SeriesItemComponent.ɵfac = function SeriesItemComponent_Factory(t) { return new (t || SeriesItemComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_CollectionService)); };\n    SeriesItemComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: SeriesItemComponent, selectors: [[\"kendo-chart-series-item\"]], contentQueries: function SeriesItemComponent_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                core[\"Ib\" /* ɵɵcontentQuery */](dirIndex, fesm2015_SeriesTooltipComponent, true);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx.seriesTooltip = _t.first);\n            }\n        }, features: [core[\"Bb\" /* ɵɵProvidersFeature */]([fesm2015_ConfigurationService]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function SeriesItemComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    SeriesItemComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService,\n            fesm2015_CollectionService])\n    ], SeriesItemComponent);\n    return SeriesItemComponent;\n})();\n/**\n * Fallback theme in case the Theme Service fails\n * to read the variables from the main theme.\n *\n * @hidden\n */\nconst chartDefaultTheme = () => Object.assign({}, baseTheme(), {\n    axisDefaults: {\n        crosshair: {\n            color: 'rgba(0, 0, 0, 0.5)'\n        },\n        labels: {\n            color: 'rgb(101, 101, 101)',\n            font: '12px serif'\n        },\n        line: {\n            color: 'rgba(0, 0, 0, 0.08)'\n        },\n        majorGridLines: {\n            color: 'rgba(0, 0, 0, 0.08)'\n        },\n        minorGridLines: {\n            color: 'rgba(0, 0, 0, 0.04)'\n        },\n        notes: {\n            icon: {\n                background: 'rgba(0, 0, 0, 0.5)',\n                border: {\n                    color: 'rgba(0, 0, 0, 0.5)'\n                }\n            },\n            line: {\n                color: 'rgba(0, 0, 0, 0.5)'\n            },\n            label: {\n                font: '14px serif'\n            }\n        },\n        title: {\n            color: 'rgb(101, 101, 101)',\n            font: '14px serif'\n        }\n    },\n    chartArea: {\n        background: 'rgb(255, 255, 255)'\n    },\n    legend: {\n        inactiveItems: {\n            labels: {\n                color: 'rgba(102, 102, 102, 0.5)'\n            },\n            markers: {\n                color: 'rgba(102, 102, 102, 0.5)'\n            }\n        },\n        labels: {\n            color: 'rgb(101, 101, 101)',\n            font: '14px serif'\n        }\n    },\n    seriesDefaults: {\n        boxPlot: {\n            downColor: 'rgba(0, 0, 0, 0.08)',\n            mean: {\n                color: 'rgb(246, 246, 246)'\n            },\n            median: {\n                color: 'rgb(246, 246, 246)'\n            },\n            whiskers: {\n                color: 'rgb(255, 99, 88)'\n            }\n        },\n        bullet: {\n            target: {\n                color: 'rgb(101, 101, 101)'\n            }\n        },\n        candlestick: {\n            downColor: 'rgb(101, 101, 101)',\n            line: {\n                color: 'rgb(101, 101, 101)'\n            }\n        },\n        errorBars: {\n            color: 'rgba(0, 0, 0, 0.5)'\n        },\n        horizontalWaterfall: {\n            line: {\n                color: 'rgba(0, 0, 0, 0.08)'\n            }\n        },\n        icon: {\n            border: {\n                color: 'rgba(0, 0, 0, 0.08)'\n            }\n        },\n        labels: {\n            background: 'rgb(255, 255, 255)',\n            color: 'rgb(101, 101, 101)',\n            opacity: 0.8,\n            font: '12px serif'\n        },\n        notes: {\n            icon: {\n                background: 'rgba(0, 0, 0, 0.5)',\n                border: {\n                    color: 'rgba(0, 0, 0, 0.5)'\n                }\n            },\n            line: {\n                color: 'rgba(0, 0, 0, 0.5)'\n            },\n            label: {\n                font: '14px serif'\n            }\n        },\n        overlay: {\n            gradient: \"none\"\n        },\n        verticalBoxPlot: {\n            downColor: 'rgba(0, 0, 0, 0.08)',\n            mean: {\n                color: 'rgb(246, 246, 246)'\n            },\n            median: {\n                color: 'rgb(246, 246, 246)'\n            },\n            whiskers: {\n                color: 'rgb(255, 99, 88)'\n            }\n        },\n        verticalBullet: {\n            target: {\n                color: 'rgb(101, 101, 101)'\n            }\n        },\n        waterfall: {\n            line: {\n                color: 'rgba(0, 0, 0, 0.08)'\n            }\n        },\n        area: {\n            opacity: 0.8\n        }\n    },\n    title: {\n        color: 'rgb(101, 101, 101)',\n        font: '16px serif'\n    },\n    seriesColors: [\n        'rgb(255, 99, 88)',\n        'rgb(255, 210, 70)',\n        'rgb(120, 210, 55)',\n        'rgb(40, 180, 200)',\n        'rgb(45, 115, 245)',\n        'rgb(170, 70, 190)'\n    ]\n});\nconst font = (style) => `${style.fontWeight} ${style.fontSize} ${style.fontFamily}`;\nconst computedBackgroundColor = (element) => window.getComputedStyle(element).backgroundColor;\nconst letterPos = (letter) => letter.toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0);\nconst seriesPos = (name) => {\n    const alpha = name.match(/series-([a-z])$/);\n    if (alpha !== null) {\n        return letterPos(alpha[1]);\n    }\n    const num = name.split('--series-')[1];\n    return parseInt(num, 10) - 1;\n};\nconst SERIES_COLORS = 30;\nconst seriesTemplate = () => {\n    let template = `\n      <div class=\"k-var--series-a\"></div>\n      <div class=\"k-var--series-b\"></div>\n      <div class=\"k-var--series-c\"></div>\n      <div class=\"k-var--series-d\"></div>\n      <div class=\"k-var--series-e\"></div>\n      <div class=\"k-var--series-f\"></div>\n  `;\n    for (let i = 0; i < SERIES_COLORS; i++) {\n        template += `\n      <div class=\"k-var--series-${i + 1}\"></div>`;\n    }\n    return template;\n};\nconst fesm2015_template = () => `\n    <div class=\"k-var--accent\"></div>\n    <div class=\"k-var--accent-contrast\"></div>\n    <div class=\"k-var--base\"></div>\n    <div class=\"k-var--background\"></div>\n\n    <div class=\"k-var--normal-background\"></div>\n    <div class=\"k-var--normal-text-color\"></div>\n    <div class=\"k-var--hover-background\"></div>\n    <div class=\"k-var--hover-text-color\"></div>\n    <div class=\"k-var--selected-background\"></div>\n    <div class=\"k-var--selected-text-color\"></div>\n    <div class=\"k-var--chart-error-bars-background\"></div>\n    <div class=\"k-var--chart-notes-background\"></div>\n    <div class=\"k-var--chart-notes-border\"></div>\n    <div class=\"k-var--chart-notes-lines\"></div>\n    <div class=\"k-var--chart-crosshair-background\"></div>\n\n    <div class=\"k-var--chart-inactive\"></div>\n    <div class=\"k-var--chart-major-lines\"></div>\n    <div class=\"k-var--chart-minor-lines\"></div>\n    <div class=\"k-var--chart-area-opacity\"></div>\n    <div class=\"k-var--chart-area-inactive-opacity\"></div>\n    <div class=\"k-var--chart-line-inactive-opacity\"></div>\n\n    <div class=\"k-widget k-chart\">\n        <div class=\"k-var--chart-font\"></div>\n        <div class=\"k-var--chart-title-font\"></div>\n        <div class=\"k-var--chart-pane-title-font\"></div>\n        <div class=\"k-var--chart-label-font\"></div>\n    </div>\n\n    <div class=\"k-var--series-unset\"></div>\n    <div class=\"k-var--series\">\n      ${seriesTemplate()}\n    </div>\n`;\nlet fesm2015_ThemeService = /*@__PURE__*/ (() => {\n    /**\n     * @hidden\n     */\n    let ThemeService = class ThemeService extends fesm2015_ConfigurationService {\n        constructor(ngZone) {\n            super(ngZone);\n            this.loaded = false;\n        }\n        loadTheme() {\n            if (this.loaded || !isDocumentAvailable()) {\n                return;\n            }\n            if (!this.readTheme()) {\n                this.readDefaultTheme();\n            }\n            this.loaded = true;\n            this.next();\n        }\n        readTheme() {\n            this.createElement();\n            const available = this.queryColor('accent') !==\n                this.queryColor('accent-contrast');\n            try {\n                if (available) {\n                    this.push(baseTheme());\n                    this.setColors();\n                    this.setFonts();\n                    this.setSeriesColors();\n                }\n            }\n            finally {\n                this.destroyElement();\n            }\n            return available;\n        }\n        readDefaultTheme() {\n            this.push(chartDefaultTheme());\n        }\n        createElement() {\n            const container = this.element = document.createElement('div');\n            container.style.display = 'none';\n            container.innerHTML = fesm2015_template();\n            document.body.appendChild(container);\n        }\n        destroyElement() {\n            if (this.element) {\n                document.body.removeChild(this.element);\n                this.element = undefined;\n            }\n        }\n        setStyle(key, value) {\n            this.set(key, value);\n        }\n        setColors() {\n            this.mapColor('axisDefaults.crosshair.color', 'chart-crosshair-background');\n            this.mapColor('axisDefaults.labels.color', 'normal-text-color');\n            this.mapColor('axisDefaults.line.color', 'chart-major-lines');\n            this.mapColor('axisDefaults.majorGridLines.color', 'chart-major-lines');\n            this.mapColor('axisDefaults.minorGridLines.color', 'chart-minor-lines');\n            this.mapColor('axisDefaults.notes.icon.background', 'chart-notes-background');\n            this.mapColor('axisDefaults.notes.icon.border.color', 'chart-notes-border');\n            this.mapColor('axisDefaults.notes.line.color', 'chart-notes-lines');\n            this.mapColor('axisDefaults.title.color', 'normal-text-color');\n            this.mapColor('chartArea.background', 'background');\n            this.mapColor('legend.inactiveItems.labels.color', 'chart-inactive');\n            this.mapColor('legend.inactiveItems.markers.color', 'chart-inactive');\n            this.mapColor('legend.labels.color', 'normal-text-color');\n            this.mapColor('seriesDefaults.boxPlot.downColor', 'chart-major-lines');\n            this.mapColor('seriesDefaults.boxPlot.mean.color', 'base');\n            this.mapColor('seriesDefaults.boxPlot.median.color', 'base');\n            this.mapColor('seriesDefaults.boxPlot.whiskers.color', 'accent');\n            this.mapColor('seriesDefaults.bullet.target.color', 'normal-text-color');\n            this.mapColor('seriesDefaults.candlestick.downColor', 'normal-text-color');\n            this.mapColor('seriesDefaults.candlestick.line.color', 'normal-text-color');\n            this.mapColor('seriesDefaults.errorBars.color', 'chart-error-bars-background');\n            this.mapColor('seriesDefaults.horizontalWaterfall.line.color', 'chart-major-lines');\n            this.mapColor('seriesDefaults.icon.border.color', 'chart-major-lines');\n            this.mapColor('seriesDefaults.labels.background', 'background');\n            this.mapColor('seriesDefaults.labels.color', 'normal-text-color');\n            this.mapColor('seriesDefaults.notes.icon.background', 'chart-notes-background');\n            this.mapColor('seriesDefaults.notes.icon.border.color', 'chart-notes-border');\n            this.mapColor('seriesDefaults.notes.line.color', 'chart-notes-lines');\n            this.mapColor('seriesDefaults.verticalBoxPlot.downColor', 'chart-major-lines');\n            this.mapColor('seriesDefaults.verticalBoxPlot.mean.color', 'base');\n            this.mapColor('seriesDefaults.verticalBoxPlot.median.color', 'base');\n            this.mapColor('seriesDefaults.verticalBoxPlot.whiskers.color', 'accent');\n            this.mapColor('seriesDefaults.verticalBullet.target.color', 'normal-text-color');\n            this.mapColor('seriesDefaults.waterfall.line.color', 'chart-major-lines');\n            this.mapColor('title.color', 'normal-text-color');\n            const opacity = parseFloat(this.queryStyle('chart-area-opacity').opacity);\n            if (!isNaN(opacity)) {\n                this.setStyle('seriesDefaults.area.opacity', opacity);\n                this.setStyle('seriesDefaults.radarArea.opacity', opacity);\n                this.setStyle('seriesDefaults.verticalArea.opacity', opacity);\n                this.setStyle('seriesDefaults.labels.opacity', opacity);\n            }\n            this.setInactiveOpacity(['area', 'verticalArea'], 'chart-area-inactive-opacity');\n            this.setInactiveOpacity(['line', 'verticalLine'], 'chart-line-inactive-opacity');\n        }\n        setInactiveOpacity(seriesTypes, selector) {\n            const inactiveOpacity = parseFloat(this.queryStyle(selector).opacity);\n            if (!isNaN(inactiveOpacity) && inactiveOpacity < 1) {\n                seriesTypes.forEach(type => this.setStyle(`seriesDefaults.${type}.highlight.inactiveOpacity`, inactiveOpacity));\n            }\n        }\n        setFonts() {\n            const defaultFont = font(this.queryStyle('chart-font'));\n            const titleFont = font(this.queryStyle('chart-title-font'));\n            const paneTitleFont = font(this.queryStyle('chart-pane-title-font'));\n            const labelFont = font(this.queryStyle('chart-label-font'));\n            this.setStyle('axisDefaults.labels.font', labelFont);\n            this.setStyle('axisDefaults.notes.label.font', defaultFont);\n            this.setStyle('axisDefaults.title.font', defaultFont);\n            this.setStyle('legend.labels.font', defaultFont);\n            this.setStyle('seriesDefaults.labels.font', labelFont);\n            this.setStyle('seriesDefaults.notes.label.font', defaultFont);\n            this.setStyle('title.font', titleFont);\n            this.setStyle('paneDefaults.title.font', paneTitleFont);\n        }\n        setSeriesColors() {\n            const element = this.element;\n            const series = [].slice.call(element.querySelectorAll('.k-var--series div'));\n            const unsetColor = computedBackgroundColor(element.querySelector('.k-var--series-unset'));\n            const seriesColors = series.reduce((arr, el) => {\n                const pos = seriesPos(el.className);\n                const color = computedBackgroundColor(el);\n                if (color !== unsetColor) {\n                    arr[pos] = color;\n                }\n                return arr;\n            }, [] // Will populate the series colors in this array\n            );\n            this.setStyle('seriesColors', seriesColors);\n        }\n        mapColor(key, varName) {\n            this.setStyle(key, this.queryColor(varName));\n        }\n        queryColor(varName) {\n            return this.queryStyle(varName).backgroundColor;\n        }\n        queryStyle(varName) {\n            const element = this.element.querySelector(`.k-var--${varName}`);\n            return window.getComputedStyle(element);\n        }\n    };\n    ThemeService.ɵfac = function ThemeService_Factory(t) { return new (t || ThemeService)(core[\"cc\" /* ɵɵinject */](core[\"B\" /* NgZone */])); };\n    ThemeService.ɵprov = core[\"Lb\" /* ɵɵdefineInjectable */]({ token: ThemeService, factory: function (t) { return ThemeService.ɵfac(t); } });\n    ThemeService = __decorate([__metadata(\"design:paramtypes\", [core[\"B\" /* NgZone */]])\n    ], ThemeService);\n    return ThemeService;\n})();\n/**\n * @hidden\n */\nclass fesm2015_ChartInstanceObserver extends instance_observer {\n    constructor(instance) {\n        super(instance);\n        this.handlerMap = {\n            hideTooltip: 'onHideTooltip',\n            legendItemClick: 'onLegendItemClick',\n            render: 'onRender',\n            showTooltip: 'onShowTooltip',\n            init: 'onInit'\n        };\n    }\n}\nlet fesm2015_TooltipTemplateService = /*@__PURE__*/ (() => {\n    /**\n     * @hidden\n     */\n    let TooltipTemplateService = class TooltipTemplateService {\n        setTemplate(template) {\n            this.template = template;\n        }\n        getTemplate(seriesIndex) {\n            if (this.seriesTemplates && this.seriesTemplates[seriesIndex]) {\n                return this.seriesTemplates[seriesIndex];\n            }\n            return this.template;\n        }\n        setSeriesTemplates(seriesTemplates) {\n            this.seriesTemplates = seriesTemplates;\n        }\n        setSharedTemplate(sharedTemplate) {\n            this.sharedTemplate = sharedTemplate;\n        }\n        getSharedTemplate() {\n            return this.sharedTemplate;\n        }\n    };\n    TooltipTemplateService.ɵfac = function TooltipTemplateService_Factory(t) { return new (t || TooltipTemplateService)(); };\n    TooltipTemplateService.ɵprov = core[\"Lb\" /* ɵɵdefineInjectable */]({ token: TooltipTemplateService, factory: function (t) { return TooltipTemplateService.ɵfac(t); } });\n    return TooltipTemplateService;\n})();\nlet fesm2015_SeriesTooltipTemplateDirective = /*@__PURE__*/ (() => {\n    /**\n     * A directive that selects a [template]({{ site.data.urls.angular['templatesyntax'] }})\n     * within the `<kendo-chart-tooltip>` component for the\n     * [series tooltip]({% slug tooltips_chart_charts %}#toc-series-tooltip).\n     *\n     * @example\n     * ```ts\n     * import { Component } from '@angular/core';\n     *\n     * _@Component({\n     *   selector: 'my-app',\n     *   template: `\n     *     <kendo-chart>\n     *       <kendo-chart-tooltip>\n     *          <ng-template kendoChartSeriesTooltipTemplate let-value=\"value\">\n     *             Value is {{value}}\n     *           </ng-template>\n     *       </kendo-chart-tooltip>\n     *       <kendo-chart-series>\n     *         <kendo-chart-series-item [data]=\"[1, 2, 3]\">\n     *         </kendo-chart-series-item>\n     *       </kendo-chart-series>\n     *     </kendo-chart>\n     *   `\n     * })\n     * class AppComponent {\n     * }\n     *\n     * ```\n     */\n    let SeriesTooltipTemplateDirective = class SeriesTooltipTemplateDirective {\n        constructor(templateRef) {\n            this.templateRef = templateRef;\n        }\n    };\n    SeriesTooltipTemplateDirective.ɵfac = function SeriesTooltipTemplateDirective_Factory(t) { return new (t || SeriesTooltipTemplateDirective)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"O\" /* TemplateRef */], 8)); };\n    SeriesTooltipTemplateDirective.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: SeriesTooltipTemplateDirective, selectors: [[\"\", \"kendoChartSeriesTooltipTemplate\", \"\"]] });\n    SeriesTooltipTemplateDirective = __decorate([__param(0, Object(core[\"C\" /* Optional */])()),\n        __metadata(\"design:paramtypes\", [core[\"O\" /* TemplateRef */]])\n    ], SeriesTooltipTemplateDirective);\n    return SeriesTooltipTemplateDirective;\n})();\nlet fesm2015_SharedTooltipTemplateDirective = /*@__PURE__*/ (() => {\n    /**\n     * A directive that selects a [template]({{ site.data.urls.angular['templatesyntax'] }})\n     * within the `<kendo-chart-tooltip>` component for the\n     * [shared series tooltip]({% slug tooltips_chart_charts %}#toc-shared-tooltip).\n     *\n     * @example\n     * ```ts\n     * import { Component } from '@angular/core';\n     *\n     * _@Component({\n     *   selector: 'my-app',\n     *   template: `\n     *     <kendo-chart>\n     *       <kendo-chart-tooltip [shared]=\"true\">\n     *         <ng-template kendoChartSharedTooltipTemplate let-category=\"category\" let-points=\"points\">\n     *             <div> {{ category }} </div>\n     *             <div *ngFor=\"let point of points\">\n     *                 {{ point.series.name }} : {{ point.value }}\n     *             </div>\n     *         </ng-template>\n     *       </kendo-chart-tooltip>\n     *       <kendo-chart-category-axis>\n     *         <kendo-chart-category-axis-item [categories]=\"['A', 'B', 'C']\">\n     *         </kendo-chart-category-axis-item>\n     *       </kendo-chart-category-axis>\n     *       <kendo-chart-series>\n     *         <kendo-chart-series-item name=\"A\" [data]=\"[1, 2, 3]\">\n     *         </kendo-chart-series-item>\n     *         <kendo-chart-series-item name=\"B\" [data]=\"[1, 2, 3]\">\n     *         </kendo-chart-series-item>\n     *       </kendo-chart-series>\n     *     </kendo-chart>\n     *   `\n     * })\n     * class AppComponent {\n     * }\n     *\n     * ```\n     */\n    let SharedTooltipTemplateDirective = class SharedTooltipTemplateDirective {\n        constructor(templateRef) {\n            this.templateRef = templateRef;\n        }\n    };\n    SharedTooltipTemplateDirective.ɵfac = function SharedTooltipTemplateDirective_Factory(t) { return new (t || SharedTooltipTemplateDirective)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"O\" /* TemplateRef */], 8)); };\n    SharedTooltipTemplateDirective.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: SharedTooltipTemplateDirective, selectors: [[\"\", \"kendoChartSharedTooltipTemplate\", \"\"]] });\n    SharedTooltipTemplateDirective = __decorate([__param(0, Object(core[\"C\" /* Optional */])()),\n        __metadata(\"design:paramtypes\", [core[\"O\" /* TemplateRef */]])\n    ], SharedTooltipTemplateDirective);\n    return SharedTooltipTemplateDirective;\n})();\n/**\n * The point that is passed to the tooltip template.\n */\nclass TooltipTemplatePoint {\n    /**\n     * @hidden\n     */\n    constructor(point, format, template) {\n        this.value = point.value;\n        this.category = point.category;\n        this.categoryIndex = point.categoryIx;\n        this.series = point.series;\n        this.dataItem = point.dataItem;\n        this.percentage = point.percentage;\n        this.runningTotal = point.runningTotal;\n        this.total = point.total;\n        this.low = point.low;\n        this.high = point.high;\n        this.xLow = point.xLow;\n        this.xHigh = point.xHigh;\n        this.yLow = point.yLow;\n        this.yHigh = point.yHigh;\n        this.template = template;\n        this.point = point;\n        this.format = format;\n    }\n    /**\n     * @hidden\n     */\n    get formattedValue() {\n        return this.format ? this.point.formatValue(this.format) : String(this.value);\n    }\n}\n/* tslint:disable:align no-empty */\nconst POSITION_MODE = 'absolute';\nconst COLLISION = { horizontal: \"fit\", vertical: \"fit\" };\nlet fesm2015_BaseTooltip = /*@__PURE__*/ (() => {\n    class BaseTooltip {\n        constructor(popupService, localizationService) {\n            this.popupService = popupService;\n            this.localizationService = localizationService;\n            this.style = {};\n            this.popupRef = null;\n        }\n        get active() {\n            return this.popupRef !== null;\n        }\n        show(e) {\n            const align = e.anchor.align;\n            const offset = this.position(e.anchor.point);\n            this.style = e.style;\n            if (!this.popupRef) {\n                this.popupRef = this.popupService.open(Object.assign({\n                    offset: offset,\n                    popupAlign: align,\n                    animate: this.animate,\n                    content: this.templateRef,\n                    collision: COLLISION,\n                    positionMode: POSITION_MODE\n                }, this.popupSettings));\n                if (this.localizationService.rtl) {\n                    this.popupRef.popupElement.setAttribute('dir', 'rtl');\n                }\n                this.onInit();\n            }\n            else {\n                const popup = this.popupRef.popup.instance;\n                popup.offset = offset;\n                popup.popupAlign = align;\n            }\n        }\n        hide() {\n            if (this.popupRef) {\n                this.popupRef.close();\n                this.popupRef = null;\n            }\n        }\n        onInit() {\n        }\n        ngOnDestroy() {\n            this.hide();\n        }\n        position(offset) {\n            if (!this.popupSettings || !this.popupSettings.appendTo) {\n                return offset;\n            }\n            const appendTo = this.popupSettings.appendTo.element.nativeElement;\n            console.log('appendTo', appendTo);\n            const bbox = appendTo.getBoundingClientRect();\n            const { scrollLeft, scrollTop } = this.scrollOffset(appendTo);\n            return {\n                left: offset.left - bbox.left - scrollLeft,\n                top: offset.top - bbox.top - scrollTop\n            };\n        }\n        scrollOffset(element) {\n            if (!element) {\n                return null;\n            }\n            let scrollLeft = element.scrollLeft;\n            let scrollTop = element.scrollTop;\n            let parent = element.parentElement;\n            while (parent) {\n                scrollLeft += parent.scrollLeft;\n                scrollTop += parent.scrollTop;\n                parent = parent.parentElement;\n            }\n            return { scrollLeft, scrollTop };\n        }\n    }\n    BaseTooltip.ɵfac = function BaseTooltip_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    BaseTooltip.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: BaseTooltip });\n    return BaseTooltip;\n})();\n/**\n * @hidden\n */\nfunction hasParent(element, parent) {\n    let current = element;\n    while (current && current !== parent) {\n        current = current.parentNode;\n    }\n    return current ? true : false;\n}\n/**\n * @hidden\n */\nfunction bodyFactory() {\n    if (isDocumentAvailable()) {\n        return new core[\"l\" /* ElementRef */](document.body);\n    }\n}\nconst SHARED_TOOLTIP_CLASS = 'k-chart-shared-tooltip';\nconst TOOLTIP_CLASS = \"k-chart-tooltip\";\nconst ɵ0$2 = bodyFactory;\nlet fesm2015_TooltipPopupComponent = /*@__PURE__*/ (() => {\n    // Codelyzer 2.0.0-beta2 doesn't handle inherited members\n    /* tslint:disable:no-access-missing-member */\n    /**\n     * @hidden\n     */\n    let TooltipPopupComponent = class TooltipPopupComponent extends fesm2015_BaseTooltip {\n        constructor(popupService, templateService, localizationService, ngZone) {\n            super(popupService, localizationService);\n            this.popupService = popupService;\n            this.templateService = templateService;\n            this.localizationService = localizationService;\n            this.ngZone = ngZone;\n            this.seriesTooltipContext = {};\n            this.seriesSharedTooltipContext = {};\n            this.animate = true;\n            this.wrapperClass = 'k-chart-tooltip-wrapper';\n            this.leave = new core[\"o\" /* EventEmitter */]();\n            this.popupClasses = {};\n        }\n        show(e) {\n            this.shared = e.shared;\n            this.popupClasses = Object.assign({\n                [SHARED_TOOLTIP_CLASS]: e.shared,\n                [TOOLTIP_CLASS]: true,\n                [e.className]: !!e.className\n            }, this.classNames);\n            if (!e.shared) {\n                this.seriesTooltipContext = new TooltipTemplatePoint(e.point, e.format);\n                this.seriesTooltipTemplateRef = this.pointTemplateRef(e.point);\n            }\n            else {\n                this.seriesSharedTooltipTemplateRef = this.templateService.getSharedTemplate()\n                    || this.defaultSharedTooltipTemplate.templateRef;\n                this.seriesSharedTooltipContext = this.sharedTemplateContext(e);\n            }\n            super.show(e);\n        }\n        containsElement(element) {\n            if (this.popupRef) {\n                return hasParent(element, this.popupRef.popupElement);\n            }\n        }\n        sharedTemplateContext(e) {\n            const points = e.points;\n            const nameColumn = points.filter((point) => typeof point.series.name !== 'undefined').length > 0;\n            const colorMarker = e.series.length > 1;\n            let colspan = 1;\n            if (nameColumn) {\n                colspan++;\n            }\n            if (colorMarker) {\n                colspan++;\n            }\n            return {\n                category: e.category,\n                categoryText: e.categoryText,\n                colorMarker: colorMarker,\n                colspan: colspan,\n                nameColumn: nameColumn,\n                points: this.wrapPoints(e.points, e.format)\n            };\n        }\n        pointTemplateRef(point) {\n            return this.templateService.getTemplate(point.series.index) || this.defaultSeriesTooltipTemplate.templateRef;\n        }\n        wrapPoints(points, format) {\n            const result = [];\n            for (let idx = 0; idx < points.length; idx++) {\n                const point = points[idx];\n                const template = this.pointTemplateRef(point);\n                const pointFormat = ((point.options || {}).tooltip || {}).format || format;\n                result.push(new TooltipTemplatePoint(point, pointFormat, template));\n            }\n            return result;\n        }\n        onInit() {\n            this.ngZone.runOutsideAngular(() => {\n                this.mouseleaveSubscription = this.popupRef.popupElement.addEventListener('mouseleave', (args) => {\n                    this.leave.emit(args);\n                });\n            });\n            this.popupRef.popupElement.className += ` ${this.wrapperClass}`;\n        }\n        hide() {\n            if (this.mouseleaveSubscription) {\n                this.mouseleaveSubscription();\n                this.mouseleaveSubscription = null;\n            }\n            super.hide();\n        }\n    };\n    TooltipPopupComponent.ɵfac = function TooltipPopupComponent_Factory(t) { return new (t || TooltipPopupComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_PopupService), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_TooltipTemplateService), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_LocalizationService), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */])); };\n    TooltipPopupComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: TooltipPopupComponent, selectors: [[\"kendo-chart-tooltip-popup\"]], viewQuery: function TooltipPopupComponent_Query(rf, ctx) {\n            if (rf & 1) {\n                core[\"Rc\" /* ɵɵviewQuery */](fesm2015_SeriesTooltipTemplateDirective, true);\n                core[\"Rc\" /* ɵɵviewQuery */](fesm2015_SharedTooltipTemplateDirective, true);\n                core[\"Gc\" /* ɵɵstaticViewQuery */](fesm2015_c0, true);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx.defaultSeriesTooltipTemplate = _t.first);\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx.defaultSharedTooltipTemplate = _t.first);\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx.templateRef = _t.first);\n            }\n        }, inputs: { animate: \"animate\", wrapperClass: \"wrapperClass\", classNames: \"classNames\", popupSettings: \"popupSettings\" }, outputs: { leave: \"leave\" }, features: [core[\"Bb\" /* ɵɵProvidersFeature */]([fesm2015_PopupService, {\n                    provide: POPUP_CONTAINER,\n                    useFactory: ɵ0$2\n                }]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 4, vars: 0, consts: [[\"content\", \"\"], [\"kendoChartSeriesTooltipTemplate\", \"\"], [\"kendoChartSharedTooltipTemplate\", \"\"], [3, \"ngClass\", \"ngStyle\"], [4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [3, \"innerHTML\"], [4, \"ngFor\", \"ngForOf\"], [1, \"k-chart-shared-tooltip-marker\"]], template: function TooltipPopupComponent_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"Kc\" /* ɵɵtemplate */](0, TooltipPopupComponent_ng_template_0_Template, 3, 4, \"ng-template\", null, 0, core[\"Lc\" /* ɵɵtemplateRefExtractor */]);\n                core[\"Kc\" /* ɵɵtemplate */](2, TooltipPopupComponent_ng_template_2_Template, 1, 1, \"ng-template\", 1);\n                core[\"Kc\" /* ɵɵtemplate */](3, TooltipPopupComponent_ng_template_3_Template, 5, 3, \"ng-template\", 2);\n            }\n        }, directives: [fesm2015_SeriesTooltipTemplateDirective, fesm2015_SharedTooltipTemplateDirective, common[\"j\" /* NgClass */], common[\"m\" /* NgStyle */], common[\"l\" /* NgIf */], common[\"q\" /* NgTemplateOutlet */], common[\"k\" /* NgForOf */]], encapsulation: 2 });\n    TooltipPopupComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_PopupService,\n            fesm2015_TooltipTemplateService,\n            fesm2015_LocalizationService,\n            core[\"B\" /* NgZone */]])\n    ], TooltipPopupComponent);\n    return TooltipPopupComponent;\n})();\nconst ɵ0$3 = bodyFactory;\nlet fesm2015_CrosshairTooltipComponent = /*@__PURE__*/ (() => {\n    // Codelyzer 2.0.0-beta2 doesn't handle inherited members\n    /* tslint:disable:no-access-missing-member */\n    /**\n     * @hidden\n     */\n    let CrosshairTooltipComponent = class CrosshairTooltipComponent extends fesm2015_BaseTooltip {\n        constructor(popupService, localizationService) {\n            super(popupService, localizationService);\n            this.animate = false;\n        }\n        show(e) {\n            super.show(e);\n            this.value = e.value;\n            this.popupRef.popup.changeDetectorRef.detectChanges();\n        }\n    };\n    CrosshairTooltipComponent.ɵfac = function CrosshairTooltipComponent_Factory(t) { return new (t || CrosshairTooltipComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_PopupService), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_LocalizationService)); };\n    CrosshairTooltipComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: CrosshairTooltipComponent, selectors: [[\"kendo-chart-crosshair-tooltip\"]], viewQuery: function CrosshairTooltipComponent_Query(rf, ctx) {\n            if (rf & 1) {\n                core[\"Gc\" /* ɵɵstaticViewQuery */](fesm2015_c0, true);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx.templateRef = _t.first);\n            }\n        }, inputs: { key: \"key\", popupSettings: \"popupSettings\" }, features: [core[\"Bb\" /* ɵɵProvidersFeature */]([fesm2015_PopupService, {\n                    provide: POPUP_CONTAINER,\n                    useFactory: ɵ0$3\n                }]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 2, vars: 0, consts: [[\"content\", \"\"], [1, \"k-chart-tooltip\", \"k-chart-crosshair-tooltip\", 3, \"ngStyle\"]], template: function CrosshairTooltipComponent_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"Kc\" /* ɵɵtemplate */](0, CrosshairTooltipComponent_ng_template_0_Template, 2, 2, \"ng-template\", null, 0, core[\"Lc\" /* ɵɵtemplateRefExtractor */]);\n            }\n        }, directives: [common[\"m\" /* NgStyle */]], encapsulation: 2 });\n    CrosshairTooltipComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_PopupService, fesm2015_LocalizationService])\n    ], CrosshairTooltipComponent);\n    return CrosshairTooltipComponent;\n})();\nconst AXES = [\"categoryAxis\", \"valueAxis\", \"xAxis\", \"yAxis\"];\nlet fesm2015_CrosshairTooltipsContainerComponent = /*@__PURE__*/ (() => {\n    /**\n     * @hidden\n     */\n    let CrosshairTooltipsContainerComponent = class CrosshairTooltipsContainerComponent {\n        /**\n         * @hidden\n         */\n        constructor() {\n            this.tooltipKeys = [];\n            this.tooltipsMap = {};\n        }\n        show(e) {\n            const tooltipComponents = this.crossahirTooltipComponents.toArray();\n            const axisName = e.axisName;\n            const axisIndex = e.axisIndex;\n            for (let idx = 0; idx < tooltipComponents.length; idx++) {\n                if (tooltipComponents[idx].key === axisName + axisIndex) {\n                    tooltipComponents[idx].show(e);\n                    break;\n                }\n            }\n        }\n        hide() {\n            const tooltipComponents = this.crossahirTooltipComponents.toArray();\n            for (let idx = 0; idx < tooltipComponents.length; idx++) {\n                tooltipComponents[idx].hide();\n            }\n        }\n        get active() {\n            return this.tooltipKeys.length > 0;\n        }\n        createCrosshairTooltips(options) {\n            const newMap = this.mapTooltips(options);\n            const map = this.tooltipsMap;\n            for (let key in map) {\n                if (!newMap[key]) {\n                    this.removeTooltip(key);\n                    delete map[key];\n                }\n            }\n            for (let key in newMap) {\n                if (!map[key]) {\n                    map[key] = newMap[key];\n                    this.tooltipKeys.push(key);\n                }\n            }\n        }\n        removeTooltip(key) {\n            const keys = this.tooltipKeys;\n            for (let idx = 0; idx < keys.length; idx++) {\n                if (keys[idx] === key) {\n                    keys.splice(idx, 1);\n                    break;\n                }\n            }\n        }\n        mapTooltips(options) {\n            const map = {};\n            for (let idx = 0; idx < AXES.length; idx++) {\n                const tooltips = this.axesCrosshairTooltipOptions(options, AXES[idx]);\n                for (let tooltipIdx = 0; tooltipIdx < tooltips.length; tooltipIdx++) {\n                    const tooltip = tooltips[tooltipIdx];\n                    map[tooltip.name + tooltip.index] = tooltip;\n                }\n            }\n            return map;\n        }\n        axesCrosshairTooltipOptions(options, name) {\n            const result = [];\n            if (options[name]) {\n                const axes = [].concat(options[name]);\n                for (let idx = 0; idx < axes.length; idx++) {\n                    const tooltip = (axes[idx].crosshair || {}).tooltip;\n                    if (tooltip && tooltip.visible) {\n                        result.push({\n                            index: idx,\n                            name: name\n                        });\n                    }\n                }\n            }\n            return result;\n        }\n    };\n    CrosshairTooltipsContainerComponent.ɵfac = function CrosshairTooltipsContainerComponent_Factory(t) { return new (t || CrosshairTooltipsContainerComponent)(); };\n    CrosshairTooltipsContainerComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: CrosshairTooltipsContainerComponent, selectors: [[\"kendo-chart-crosshair-tooltips-container\"]], viewQuery: function CrosshairTooltipsContainerComponent_Query(rf, ctx) {\n            if (rf & 1) {\n                core[\"Rc\" /* ɵɵviewQuery */](fesm2015_CrosshairTooltipComponent, true);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx.crossahirTooltipComponents = _t);\n            }\n        }, inputs: { popupSettings: \"popupSettings\" }, decls: 1, vars: 1, consts: [[3, \"key\", \"popupSettings\", 4, \"ngFor\", \"ngForOf\"], [3, \"key\", \"popupSettings\"]], template: function CrosshairTooltipsContainerComponent_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"Kc\" /* ɵɵtemplate */](0, CrosshairTooltipsContainerComponent_kendo_chart_crosshair_tooltip_0_Template, 1, 2, \"kendo-chart-crosshair-tooltip\", 0);\n            }\n            if (rf & 2) {\n                core[\"pc\" /* ɵɵproperty */](\"ngForOf\", ctx.tooltipKeys);\n            }\n        }, directives: [common[\"k\" /* NgForOf */], fesm2015_CrosshairTooltipComponent], encapsulation: 2 });\n    return CrosshairTooltipsContainerComponent;\n})();\nconst getTouch = (domEvent) => {\n    return {\n        x: {\n            location: domEvent.pageX\n        },\n        y: {\n            location: domEvent.pageY\n        }\n    };\n};\nconst eventArgs = (e, previousArgs) => {\n    const pointers = e.pointers;\n    const pointer = pointers[0];\n    const xLocation = pointer.pageX;\n    const yLocation = pointer.pageY;\n    let distance = 0;\n    if (pointers.length > 1) {\n        const pointer1 = pointers[0];\n        const pointer2 = pointers[1];\n        distance = Math.sqrt(Math.pow(pointer1.pageX - pointer2.pageX, 2) + Math.pow(pointer1.pageY - pointer2.pageY, 2));\n    }\n    return {\n        distance: distance,\n        event: e.srcEvent,\n        preventDefault: function () {\n            e.preventDefault();\n        },\n        target: e.target,\n        touches: pointers.map(getTouch),\n        type: e.type,\n        x: {\n            delta: previousArgs ? xLocation - previousArgs.x.location : 0,\n            initialDelta: e.deltaX,\n            location: xLocation,\n            startLocation: xLocation - e.deltaX\n        },\n        y: {\n            delta: previousArgs ? yLocation - previousArgs.y.location : 0,\n            initialDelta: e.deltaY,\n            location: yLocation,\n            startLocation: yLocation - e.deltaY\n        }\n    };\n};\nfunction shouldBindGroup(groupNames, events) {\n    for (let idx = 0; idx < groupNames.length; idx++) {\n        if (events[groupNames[idx]]) {\n            return true;\n        }\n    }\n    return false;\n}\nconst eventGroups = [{\n        end: 'panend',\n        move: 'panmove',\n        start: 'panstart'\n    }, {\n        gesturechange: 'pinchmove',\n        gestureend: 'pinchend',\n        gesturestart: 'pinchstart'\n    }, {\n        press: 'press'\n    }, {\n        tap: 'tap'\n    }];\n/**\n * @hidden\n */\nclass DomEvents {\n    constructor(hammerInstance, events) {\n        this.hammerInstance = hammerInstance;\n        this.eventHandlers = {};\n        this.tap = this.tap.bind(this);\n        this.press = this.press.bind(this);\n        this.panstart = this.panstart.bind(this);\n        this.panmove = this.panmove.bind(this);\n        this.panend = this.panend.bind(this);\n        this.pinchstart = this.pinchstart.bind(this);\n        this.pinchmove = this.pinchmove.bind(this);\n        this.pinchend = this.pinchend.bind(this);\n        if (events) {\n            this.bind(events);\n        }\n    }\n    tap(e) {\n        this.trigger('tap', e);\n    }\n    press(e) {\n        this.trigger('press', e);\n    }\n    panstart(e) {\n        delete this.previous;\n        this.previous = this.trigger('start', e);\n    }\n    panmove(e) {\n        this.previous = this.trigger('move', e);\n    }\n    panend(e) {\n        this.trigger('end', e);\n        delete this.previous;\n    }\n    pinchstart(e) {\n        this.trigger('gesturestart', e);\n    }\n    pinchmove(e) {\n        this.trigger('gesturechange', e);\n    }\n    pinchend(e) {\n        this.trigger('gestureend', e);\n    }\n    trigger(name, e) {\n        const args = eventArgs(e, this.previous);\n        if (this.eventHandlers[name]) {\n            this.eventHandlers[name](args);\n        }\n        return args;\n    }\n    bind(events = {}) {\n        this.unbind();\n        this.eventHandlers = events;\n        for (let idx = 0; idx < eventGroups.length; idx++) {\n            const eventGroup = eventGroups[idx];\n            const groupNames = Object.keys(eventGroup);\n            if (shouldBindGroup(groupNames, events)) {\n                for (let nameIdx = 0; nameIdx < groupNames.length; nameIdx++) {\n                    const name = eventGroup[groupNames[nameIdx]];\n                    this.hammerInstance.on(name, this[name]);\n                }\n            }\n        }\n    }\n    unbind() {\n        if (this.hammerInstance) {\n            this.hammerInstance.off();\n        }\n        this.eventHandlers = {};\n    }\n    destroy() {\n        if (this.hammerInstance) {\n            this.hammerInstance.destroy();\n            delete this.hammerInstance;\n        }\n        delete this.eventHandlers;\n    }\n    toggleDrag(enable) {\n        this.toggle('pan', enable);\n    }\n    toggleZoom(enable) {\n        this.toggle('pinch', enable);\n    }\n    toggle(recognizer, enable) {\n        if (this.hammerInstance) {\n            const instanceRecognizer = this.hammerInstance.get(recognizer);\n            instanceRecognizer.set({\n                enable: enable\n            });\n        }\n    }\n}\nconst MISSING_HAMMER_MESSAGE = 'Hammerjs is not loaded.' +\n    'Solution: http://www.telerik.com/kendo-angular-ui/components/charts/troubleshooting/#toc-hammerjs-is-not-loaded';\n/**\n * @hidden\n */\nclass fesm2015_DomEventsBuilder$1 {\n    static create(element, events) {\n        if (typeof window !== 'undefined') {\n            const HAMMER = window.Hammer;\n            if (!HAMMER) {\n                if (Object(core[\"Y\" /* isDevMode */])()) {\n                    throw new Error(MISSING_HAMMER_MESSAGE);\n                }\n                return;\n            }\n            const hammerInstance = new HAMMER(element, {\n                recognizers: [\n                    [HAMMER.Tap],\n                    [HAMMER.Pan],\n                    [HAMMER.Pinch],\n                    [HAMMER.Press, { time: 0 }]\n                ]\n            });\n            return new DomEvents(hammerInstance, events);\n        }\n    }\n}\nconst dateCategoryAxisFormats = date_category_axis.prototype.options.labels.dateFormats;\nconst dateValueAxisFormats = date_value_axis.prototype.options.labels.dateFormats;\nconst dateFormats = {\n    milliseconds: \"HH:mm:ss.SSS\",\n    seconds: { time: 'medium' },\n    minutes: { time: 'short' },\n    hours: { time: 'short' },\n    days: { skeleton: 'Md' },\n    weeks: { skeleton: 'Md' },\n    months: { skeleton: 'yyMMM' },\n    years: { skeleton: 'y' }\n};\nObject.assign(dateCategoryAxisFormats, dateFormats);\nObject.assign(dateValueAxisFormats, dateFormats);\ndom_events_builder.register(fesm2015_DomEventsBuilder$1);\nfunction fesm2015_hasObservers(emitter) {\n    return emitter.observers.length > 0;\n}\nlet fesm2015_ChartComponent = /*@__PURE__*/ (() => {\n    /**\n     * The root Chart component.\n     *\n     * @example\n     * ```ts\n     * import { Component } from '@angular/core';\n     *\n     * _@Component({\n     *   selector: 'my-app',\n     *   template: `\n     *     <button (click)=\"toggleLegend()\">Toggle Legend</button>\n     *     <button (click)=\"toggleSeries()\">Toggle Series</button>\n     *     <kendo-chart>\n     *       <kendo-chart-legend [visible]=\"legendVisible\">\n     *       </kendo-chart-legend>\n     *       <kendo-chart-series>\n     *         <kendo-chart-series-item *ngIf=\"seriesVisible\" name=\"Series #1\"\n     *                                   type=\"line\" [data]=\"[1, 2, 3]\">\n     *         </kendo-chart-series-item>\n     *       </kendo-chart-series>\n     *     </kendo-chart>\n     *   `\n     * })\n     * class AppComponent {\n     *   public legendVisible: boolean = true;\n     *   public seriesVisible: boolean = true;\n     *\n     *   public toggleSeries(): void {\n     *     this.seriesVisible = !this.seriesVisible;\n     *   }\n     *\n     *   public toggleLegend(): void {\n     *     this.legendVisible = !this.legendVisible;\n     *   }\n     * }\n     *\n     * ```\n     */\n    let ChartComponent = class ChartComponent extends fesm2015_ChartComponentGenerated {\n        constructor(configurationService, themeService, element, intl, localizationService, ngZone, instanceEventService, changeDetector, renderer) {\n            super(configurationService);\n            this.configurationService = configurationService;\n            this.themeService = themeService;\n            this.element = element;\n            this.intl = intl;\n            this.localizationService = localizationService;\n            this.ngZone = ngZone;\n            this.instanceEventService = instanceEventService;\n            this.changeDetector = changeDetector;\n            this.renderer = renderer;\n            /**\n             * Fires when a legend item is clicked before the selected series visibility is toggled.\n             * Can be prevented.\n             */\n            this.legendItemClick = new core[\"o\" /* EventEmitter */]();\n            /**\n             * Limits the automatic resizing of the Chart. Sets the maximum number of times per second\n             * that the component redraws its content when the size of its container changes.\n             * Defaults to `10`. To disable the automatic resizing, set it to `0`.\n             *\n             * @example\n             * ```ts\n             * _@Component({\n             *     selector: 'my-app',\n             *     template: `\n             *         <kendo-chart [resizeRateLimit]=\"2\">\n             * <!--                 ^^^^^^^^^^^^^^^^^^^^^^\n             *       Will update the size of the Chart up to two times a second.\n             *       Resize the Plunkr pane or window to try it out.\n             * -->\n             *          <kendo-chart-series>\n             *            <kendo-chart-series-item [data]=\"seriesData\">\n             *           </kendo-chart-series-item>\n             *         </kendo-chart-series>\n             *       </kendo-chart>\n             *   `\n             * })\n             * export class AppComponent {\n             *    seriesData: number[] = [1, 2, 3, 5];\n             * }\n             * ```\n             */\n            this.resizeRateLimit = 10;\n            this.theme = null;\n            this.suppressTransitions = false;\n            this.rtl = false;\n            this.hostClasses = ['k-chart', 'k-widget'];\n            validatePackage(dist_fesm2015_packageMetadata);\n            this.themeService.loadTheme();\n            this.refreshWait();\n        }\n        ngOnInit() {\n            if (this.element) {\n                this.hostClasses.forEach(name => {\n                    this.renderer.addClass(this.element.nativeElement, name);\n                });\n                this.renderer.setStyle(this.element.nativeElement, 'position', 'relative');\n            }\n        }\n        ngAfterViewInit() {\n            if (this.canRender) {\n                this.ngZone.runOutsideAngular(() => {\n                    const chartMouseleave = this.renderer.listen(this.surfaceElement.nativeElement, 'mouseleave', this.chartMouseleave.bind(this));\n                    this.domSubscriptions = () => {\n                        chartMouseleave();\n                    };\n                });\n            }\n            this.setDirection();\n            this.subscriptions = this.intl.changes.subscribe(this.intlChange.bind(this));\n            this.subscriptions.add(this.localizationService.changes.subscribe(this.rtlChange.bind(this)));\n        }\n        ngAfterViewChecked() {\n            if (this.instance && this.autoResize) {\n                this.ngZone.runOutsideAngular(() => {\n                    clearTimeout(this.resizeTimeout);\n                    this.resizeTimeout = setTimeout(() => {\n                        this.resize();\n                    }, 0);\n                });\n            }\n        }\n        ngOnChanges(changes) {\n            const store = this.configurationService.store;\n            copyChanges(changes, store);\n            store.popupSettings = null;\n            this.configurationService.push(store);\n        }\n        /**\n         * Updates the component fields with the specified values and refreshes the Chart.\n         *\n         * Use this method when the configuration values cannot be set through the template.\n         *\n         * @example\n         * ```ts-no-run\n         * chart.notifyChanges({ title: { text: 'New Title' } });\n         * ```\n         *\n         * @param changes An object containing the updated input fields.\n         */\n        notifyChanges(changes) {\n            this.ngOnChanges(toSimpleChanges(changes));\n        }\n        ngOnDestroy() {\n            this.destroyed = true;\n            this.subscription.unsubscribe();\n            if (this.domSubscriptions) {\n                this.domSubscriptions();\n                this.domSubscriptions = null;\n            }\n            if (this.instance) {\n                this.instance.destroy();\n                this.instance = null;\n            }\n            if (this.subscriptions) {\n                this.subscriptions.unsubscribe();\n            }\n            clearTimeout(this.resizeTimeout);\n            clearTimeout(this.redrawTimeout);\n        }\n        createInstance(element, observer) {\n            this.instance = new chart_chart(element, this.options, this.theme, {\n                intlService: this.intl,\n                observer: observer,\n                rtl: this.rtl,\n                sender: this\n            });\n        }\n        /**\n         * Exports the Chart as an image. The export operation is asynchronous and returns a promise.\n         *\n         * @param {ImageExportOptions} options - The parameters for the exported image.\n         * @returns {Promise<string>} - A promise that will be resolved with a PNG image encoded as a Data URI.\n         */\n        exportImage(options = {}) {\n            return Object(export_image[\"a\" /* default */])(this.exportVisual(options), options);\n        }\n        /**\n         * Exports the Chart as an SVG document. The export operation is asynchronous and returns a promise.\n         *\n         * @param options - The parameters for the exported file.\n         * @returns - A promise that will be resolved with an SVG document that is encoded as a Data URI.\n         */\n        exportSVG(options = {}) {\n            return Object(export_svg[\"a\" /* default */])(this.exportVisual(options), options);\n        }\n        /**\n         * Exports the Chart as a Drawing `Scene`.\n         *\n         * @param options - The parameters for the export operation.\n         * @returns - The root Group of the scene.\n         */\n        exportVisual(options = {}) {\n            return this.instance.exportVisual(options);\n        }\n        /**\n         * Returns the axis with the specified name.\n         *\n         * @param {string} name - The axis name.\n         * @returns {ChartAxis} - The axis with a corresponding name.\n         */\n        findAxisByName(name) {\n            if (this.instance) {\n                return this.instance.findAxisByName(name);\n            }\n        }\n        /**\n         * Returns the pane at the specified index.\n         *\n         * @param {number} index - The pane index.\n         * @returns {ChartPane} - The pane at the specified index.\n         */\n        findPaneByIndex(index) {\n            if (this.instance) {\n                return this.instance.findPaneByIndex(index);\n            }\n        }\n        /**\n         * Returns the pane with the specified name.\n         *\n         * @param {string} name - The name of the pane.\n         * @returns {ChartPane} - The pane with the provided name.\n         */\n        findPaneByName(name) {\n            if (this.instance) {\n                return this.instance.findPaneByName(name);\n            }\n        }\n        /**\n         * Returns the plot area of the Chart.\n         * @returns {ChartPlotArea} - The plot area of the Chart.\n         */\n        getPlotArea() {\n            if (this.instance) {\n                return this.instance.plotArea();\n            }\n        }\n        /**\n         * Highlights the series points or the segments of a Pie, Donut, or Funnel charts.\n         *\n         * See [Series Highlight]({% slug serieshighlight_chart_charts %}) for more details.\n         *\n         * In the following example, the callback is evaluated for each data point.\n         * If the function returns `true`, the point is highlighted.\n         *\n         * {% meta height:500 %}\n         * {% embed_file elements/highlight/api/app.component.ts preview %}\n         * {% embed_file shared/app.module.ts hidden %}\n         * {% embed_file shared/main.ts hidden %}\n         * {% endmeta %}\n         *\n         * @param show - A Boolean value that indicates whether the highlight is shown or hidden.\n         * @param filter - A string that represents the series or category name, an object with the series and category name, or a function which will be called for each point. The function should return `true` for the points for which the highlight is toggled.\n         */\n        toggleHighlight(show, filter) {\n            if (this.instance) {\n                this.instance.toggleHighlight(show, filter);\n            }\n        }\n        /**\n         * Hides the tooltip of the Chart.\n         */\n        hideTooltip() {\n            if (this.instance) {\n                this.instance.hideTooltip();\n            }\n        }\n        /**\n         * Shows the Chart tooltip of a specific point or the shared tooltip of a specific category.\n         *\n         * @param filter - The category for a shared tooltip or a function which will be called for each point until the function returns `true`.\n         */\n        showTooltip(filter) {\n            if (this.instance) {\n                this.instance.showTooltip(filter);\n            }\n        }\n        init() {\n            if (!this.canRender) {\n                return;\n            }\n            const element = this.surfaceElement.nativeElement;\n            const instanceObserver = new fesm2015_ChartInstanceObserver(this);\n            this.createInstance(element, instanceObserver);\n        }\n        /**\n         * Detects the size of the container and redraws the Chart.\n         * Resizing is automatic unless you set the `resizeRateLimit` option to `0`.\n         */\n        resize() {\n            if (this.instance) {\n                this.instance.resize();\n            }\n        }\n        /**\n         * @hidden\n         */\n        onResize(_event) {\n            if (this.autoResize) {\n                this.resize();\n            }\n        }\n        onLegendItemClick(e) {\n            this.run(() => {\n                const args = new LegendItemClickEvent(e, this);\n                this.legendItemClick.emit(args);\n                if (!args.isDefaultPrevented()) {\n                    const series = this.seriesComponents.toArray()[e.series.index];\n                    if (!series) {\n                        return;\n                    }\n                    if (e.pointIndex === undefined) {\n                        series.toggleVisibility();\n                    }\n                    else {\n                        series.togglePointVisibility(e.pointIndex);\n                    }\n                    this.suppressTransitions = true;\n                }\n            }, fesm2015_hasObservers(this.legendItemClick), this.seriesComponents.length > 0);\n        }\n        onInit(e) {\n            this.instance = e.sender;\n        }\n        onRender(e) {\n            const donutCenterStyle = this.getDonutCenterStyle();\n            this.run(() => {\n                const args = new RenderEvent(e, this);\n                this.surface = e.sender.surface;\n                this.render.emit(args);\n                this.donutCenterStyle = donutCenterStyle;\n            }, fesm2015_hasObservers(this.render), this.donutCenterStyle !== donutCenterStyle);\n        }\n        onShowTooltip(e) {\n            this.run(() => {\n                if (!e.crosshair) {\n                    this.tooltipInstance.show(e);\n                }\n                else {\n                    this.crossahirTooltips.show(e);\n                }\n            }, !e.crosshair, true);\n        }\n        onHideTooltip(e) {\n            if (!e.crosshair) {\n                if (this.tooltipInstance.active) {\n                    this.tooltipInstance.hide();\n                    this.detectChanges();\n                }\n            }\n            else if (this.crossahirTooltips.active) {\n                this.crossahirTooltips.hide();\n                this.detectChanges();\n            }\n        }\n        trigger(name, e) {\n            if (name === 'resize') {\n                return;\n            }\n            const emitter = this.activeEmitter(name);\n            if (emitter) {\n                const args = this.instanceEventService.create(name, e, this);\n                this.run(() => {\n                    emitter.emit(args);\n                });\n                return args.isDefaultPrevented && args.isDefaultPrevented();\n            }\n        }\n        requiresHandlers(names) {\n            for (let idx = 0; idx < names.length; idx++) {\n                if (this.activeEmitter(names[idx])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        refresh() {\n            clearTimeout(this.redrawTimeout);\n            this.updateDirection();\n            this.crossahirTooltips.createCrosshairTooltips(this.options);\n            this.setChartAreaSize();\n            if (!this.instance) {\n                this.init();\n                return;\n            }\n            const transitions = this.options.transitions;\n            if (this.suppressTransitions) {\n                this.options.transitions = false;\n            }\n            this.updateOptions();\n            if (this.suppressTransitions) {\n                this.options.transitions = transitions;\n                this.suppressTransitions = false;\n            }\n        }\n        setChartAreaSize() {\n            if (!this.element) {\n                return;\n            }\n            const element = this.element.nativeElement;\n            const chartArea = this.options.chartArea || {};\n            if (chartArea.width) {\n                element.style.width = `${chartArea.width}px`;\n            }\n            if (chartArea.height) {\n                element.style.height = `${chartArea.height}px`;\n            }\n        }\n        updateOptions() {\n            this.instance.setOptions(this.options);\n        }\n        /**\n         * @hidden\n         */\n        tooltipMouseleave(e) {\n            const relatedTarget = e.relatedTarget;\n            const chartElement = this.element.nativeElement;\n            if (this.instance && (!relatedTarget || !hasParent(relatedTarget, chartElement))) {\n                this.instance.hideElements();\n            }\n        }\n        /**\n         * @hidden\n         */\n        chartMouseleave(e) {\n            const relatedTarget = e.relatedTarget;\n            const chartElement = this.element.nativeElement;\n            if (this.instance && (!relatedTarget || !(this.tooltipInstance.containsElement(relatedTarget) || hasParent(relatedTarget, chartElement))) &&\n                !this.instance.handlingTap) {\n                this.instance.hideElements();\n            }\n        }\n        get canRender() {\n            return isDocumentAvailable() && Boolean(this.surfaceElement);\n        }\n        get autoResize() {\n            return this.resizeRateLimit > 0;\n        }\n        activeEmitter(name) {\n            const emitter = this[name];\n            if (emitter && emitter.emit && fesm2015_hasObservers(emitter)) {\n                return emitter;\n            }\n        }\n        getDonutCenterStyle() {\n            if (!this.instance || !this.options || !this.options.series) {\n                return;\n            }\n            const firstSeries = this.options.series[0];\n            const charts = this.instance._plotArea.charts;\n            if (!firstSeries || firstSeries.type !== 'donut' || charts[0].points.length === 0) {\n                return;\n            }\n            const firstPoint = charts[0].points[0];\n            const center = firstPoint.box.center();\n            const radius = firstPoint.sector.innerRadius;\n            const top = center.y - radius;\n            const left = center.x - radius;\n            const size = radius * 2;\n            return {\n                height: size + 'px',\n                left: left + 'px',\n                top: top + 'px',\n                width: size + 'px'\n            };\n        }\n        refreshWait() {\n            this.ngZone.runOutsideAngular(() => {\n                this.subscription = Object(combineLatest[\"b\" /* combineLatest */])(this.configurationService.onChange$, this.themeService.onChange$).pipe(Object(tap[\"a\" /* tap */])((result) => {\n                    this.options = result[0];\n                    this.theme = result[1];\n                }), Object(auditTime[\"a\" /* auditTime */])(THROTTLE_MS))\n                    .subscribe(() => {\n                    this.refresh();\n                });\n            });\n        }\n        run(callback, inZone = true, detectChanges) {\n            if (inZone) {\n                if (detectChanges) {\n                    this.changeDetector.markForCheck();\n                }\n                this.ngZone.run(callback);\n            }\n            else {\n                callback();\n                if (detectChanges) {\n                    this.detectChanges();\n                }\n            }\n        }\n        detectChanges() {\n            if (!this.destroyed) {\n                this.changeDetector.detectChanges();\n            }\n        }\n        intlChange() {\n            if (this.instance) {\n                this.deferredRedraw();\n            }\n        }\n        rtlChange() {\n            if (this.instance && this.rtl !== this.isRTL) {\n                this.deferredRedraw();\n            }\n        }\n        deferredRedraw() {\n            this.ngZone.runOutsideAngular(() => {\n                clearTimeout(this.redrawTimeout);\n                this.redrawTimeout = setTimeout(() => {\n                    this.updateDirection();\n                    this.instance.noTransitionsRedraw();\n                }, 0);\n            });\n        }\n        updateDirection() {\n            const current = this.isRTL;\n            if (this.rtl !== current) {\n                this.setDirection();\n                if (this.instance) {\n                    this.instance.setDirection(current);\n                }\n            }\n        }\n        setDirection() {\n            this.rtl = this.isRTL;\n            if (this.element) {\n                this.renderer.setAttribute(this.element.nativeElement, 'dir', this.rtl ? 'rtl' : 'ltr');\n            }\n        }\n        get isRTL() {\n            return Boolean(this.localizationService.rtl);\n        }\n    };\n    ChartComponent.ɵfac = function ChartComponent_Factory(t) { return new (t || ChartComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ThemeService), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_IntlService), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_LocalizationService), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */]), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_InstanceEventService), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"h\" /* ChangeDetectorRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"G\" /* Renderer2 */])); };\n    ChartComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: ChartComponent, selectors: [[\"kendo-chart\"]], contentQueries: function ChartComponent_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                core[\"Ib\" /* ɵɵcontentQuery */](dirIndex, fesm2015_DonutCenterTemplateDirective, true);\n                core[\"Ib\" /* ɵɵcontentQuery */](dirIndex, fesm2015_SeriesItemComponent, true);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx.donutCenterTemplate = _t.first);\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx.seriesComponents = _t);\n            }\n        }, viewQuery: function ChartComponent_Query(rf, ctx) {\n            if (rf & 1) {\n                core[\"Gc\" /* ɵɵstaticViewQuery */](fesm2015_TooltipPopupComponent, true);\n                core[\"Gc\" /* ɵɵstaticViewQuery */](fesm2015_CrosshairTooltipsContainerComponent, true);\n                core[\"Gc\" /* ɵɵstaticViewQuery */](fesm2015_c1, true);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx.tooltipInstance = _t.first);\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx.crossahirTooltips = _t.first);\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx.surfaceElement = _t.first);\n            }\n        }, inputs: { resizeRateLimit: \"resizeRateLimit\", popupSettings: \"popupSettings\" }, outputs: { legendItemClick: \"legendItemClick\" }, exportAs: [\"kendoChart\"], features: [core[\"Bb\" /* ɵɵProvidersFeature */]([\n                fesm2015_ConfigurationService,\n                fesm2015_TooltipTemplateService,\n                fesm2015_InstanceEventService,\n                fesm2015_LocalizationService,\n                {\n                    provide: L10N_PREFIX,\n                    useValue: 'kendo.chart'\n                }\n            ]), core[\"zb\" /* ɵɵInheritDefinitionFeature */], core[\"Ab\" /* ɵɵNgOnChangesFeature */]], decls: 6, vars: 4, consts: [[1, \"k-chart-surface\"], [\"surface\", \"\"], [3, \"popupSettings\"], [3, \"popupSettings\", \"leave\"], [3, \"rateLimit\", \"resize\"], [\"class\", \"k-chart-donut-center\", 3, \"ngStyle\", 4, \"ngIf\"], [1, \"k-chart-donut-center\", 3, \"ngStyle\"], [3, \"ngTemplateOutlet\"]], template: function ChartComponent_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"Qb\" /* ɵɵelement */](0, \"div\", 0, 1);\n                core[\"Qb\" /* ɵɵelement */](2, \"kendo-chart-crosshair-tooltips-container\", 2);\n                core[\"Vb\" /* ɵɵelementStart */](3, \"kendo-chart-tooltip-popup\", 3);\n                core[\"gc\" /* ɵɵlistener */](\"leave\", function ChartComponent_Template_kendo_chart_tooltip_popup_leave_3_listener($event) { return ctx.tooltipMouseleave($event); });\n                core[\"Ub\" /* ɵɵelementEnd */]();\n                core[\"Vb\" /* ɵɵelementStart */](4, \"kendo-resize-sensor\", 4);\n                core[\"gc\" /* ɵɵlistener */](\"resize\", function ChartComponent_Template_kendo_resize_sensor_resize_4_listener($event) { return ctx.onResize($event); });\n                core[\"Ub\" /* ɵɵelementEnd */]();\n                core[\"Kc\" /* ɵɵtemplate */](5, ChartComponent_div_5_Template, 2, 2, \"div\", 5);\n            }\n            if (rf & 2) {\n                core[\"Cb\" /* ɵɵadvance */](2);\n                core[\"pc\" /* ɵɵproperty */](\"popupSettings\", ctx.popupSettings);\n                core[\"Cb\" /* ɵɵadvance */](1);\n                core[\"pc\" /* ɵɵproperty */](\"popupSettings\", ctx.popupSettings);\n                core[\"Cb\" /* ɵɵadvance */](1);\n                core[\"pc\" /* ɵɵproperty */](\"rateLimit\", ctx.resizeRateLimit);\n                core[\"Cb\" /* ɵɵadvance */](1);\n                core[\"pc\" /* ɵɵproperty */](\"ngIf\", ctx.donutCenterStyle && ctx.donutCenterTemplate);\n            }\n        }, directives: [fesm2015_CrosshairTooltipsContainerComponent, fesm2015_TooltipPopupComponent, fesm2015_ResizeSensorComponent, common[\"l\" /* NgIf */], common[\"m\" /* NgStyle */], common[\"q\" /* NgTemplateOutlet */]], encapsulation: 2, changeDetection: 0 });\n    ChartComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService,\n            fesm2015_ThemeService,\n            core[\"l\" /* ElementRef */],\n            fesm2015_IntlService,\n            fesm2015_LocalizationService,\n            core[\"B\" /* NgZone */],\n            fesm2015_InstanceEventService,\n            core[\"h\" /* ChangeDetectorRef */],\n            core[\"G\" /* Renderer2 */]])\n    ], ChartComponent);\n    return ChartComponent;\n})();\nlet fesm2015_AxisDefaultsComponentGenerated = /*@__PURE__*/ (() => {\n    class AxisDefaultsComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('axisDefaults', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    AxisDefaultsComponentGenerated.ɵfac = function AxisDefaultsComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    AxisDefaultsComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: AxisDefaultsComponentGenerated, inputs: { background: \"background\", color: \"color\", line: \"line\", majorGridLines: \"majorGridLines\", majorTicks: \"majorTicks\", minorGridLines: \"minorGridLines\", minorTicks: \"minorTicks\", narrowRange: \"narrowRange\", pane: \"pane\", plotBands: \"plotBands\", reverse: \"reverse\", startAngle: \"startAngle\", visible: \"visible\", crosshair: \"crosshair\", labels: \"labels\", title: \"title\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return AxisDefaultsComponentGenerated;\n})();\nlet fesm2015_AxisDefaultsComponent = /*@__PURE__*/ (() => {\n    /**\n     * The default options for all Chart axes.\n     * Accepts the options which are supported by [`categoryAxis`]({% slug api_charts_categoryaxisitemcomponent %}),\n     * [`valueAxis`]({% slug api_charts_valueaxisitemcomponent %}),\n     * [`xAxis`]({% slug api_charts_xaxisitemcomponent %}),\n     * and [`yAxis`]({% slug api_charts_yaxisitemcomponent %}).\n     *\n     * @example\n     * ```ts-preview\n     * import { Component } from '@angular/core';\n     *\n     * _@Component({\n     *   selector: 'my-app',\n     *   template: `\n     *  <div style=\"height: 600px;\">\n     *  <kendo-chart [categoryAxis]=\"{ categories: categories }\" [chartArea]=\"{height: 600}\" >\n     *    <kendo-chart-axis-defaults\n     *      [background]=\"background\"\n     *      [color]=\"color\"\n     *      [crosshair]=\"crosshair\"\n     *      [labels]=\"labels\"\n     *      [line]=\"line\"\n     *      [majorGridLines]=\"majorGridLines\"\n     *      [minorGridLines]=\"minorGridLines\"\n     *      [majorTicks]=\"majorTicks\"\n     *      [minorTicks]=\"minorTicks\"\n     *      [title]=\"title\"\n     *      ></kendo-chart-axis-defaults>\n     *    <kendo-chart-title text=\"Gross domestic product growth /GDP annual %/\"></kendo-chart-title>\n     *    <kendo-chart-legend position=\"bottom\" orientation=\"horizontal\"></kendo-chart-legend>\n     *    <kendo-chart-tooltip format=\"{0}%\"></kendo-chart-tooltip>\n     *    <kendo-chart-series>\n     *        <kendo-chart-series-item *ngFor=\"let item of series\"\n     *            type=\"line\" style=\"smooth\" [data]=\"item.data\" [name]=\"item.name\">\n     *        </kendo-chart-series-item>\n     *    </kendo-chart-series>\n     *  </kendo-chart>\n     *  </div>\n     * `\n     * })\n     * export class AppComponent {\n     * public series: any[] = [{\n     * name: \"India\",\n     * data: [4, 8, 8, 9, 9, 9, 3, 8, 9, 6]\n     * }, {\n     * name: \"Russian Federation\",\n     * data: [4, 7, 7, 6, 8, 8, 5, 8, 4, 4]\n     * }, {\n     * name: \"Germany\",\n     * data: [0, 0, 1, 1, 4, 3, 1, 5, 4, 3]\n     * },{\n     * name: \"World\",\n     * data: [2, 3, 4, 4, 4, 4, 1, 2, 4, 3]\n     * }];\n     *\n     * public  categories: number[] = [2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011];\n     *\n     * public background = 'white';\n     * // public color = 'cyan'; // will override the line.color option\n     * public crosshair = {\n     * visible: true\n     * };\n     * public labels = {\n     * font: 'bold 12px/30px Helvetica, Arial, sans-serif',\n     * color: '#4CAF50',\n     * padding: 5,\n     * rotation: 45,\n     * background: 'white',\n     * border: {\n     * color: '#4CAF50',\n     * width: 2\n     * },\n     * };\n     * public line = {\n     * color: 'black',\n     * width: 3\n     * };\n     *\n     * public majorGridLines = {\n     * color: 'black',\n     * visible: true\n     * }\n     *\n     * public minorGridLines = {\n     * color: 'lightgray',\n     * visible: true\n     * }\n     *\n     * public majorTicks = {\n     * color: 'black',\n     * size: 15\n     * }\n     *\n     * public minorTicks = {\n     * color: 'lightgray',\n     * size: 10\n     * }\n     *\n     * public title = {\n     * text: 'Default Axis Title',\n     * color: 'black',\n     * background: 'white',\n     * border: {\n     * color: 'black',\n     * width: 2\n     * },\n     * padding: 10\n     * }\n     * }\n     * ```\n     */\n    let AxisDefaultsComponent = class AxisDefaultsComponent extends fesm2015_AxisDefaultsComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    AxisDefaultsComponent.ɵfac = function AxisDefaultsComponent_Factory(t) { return new (t || AxisDefaultsComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    AxisDefaultsComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: AxisDefaultsComponent, selectors: [[\"kendo-chart-axis-defaults\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function AxisDefaultsComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    AxisDefaultsComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], AxisDefaultsComponent);\n    return AxisDefaultsComponent;\n})();\nlet fesm2015_AxisDefaultsCrosshairComponentGenerated = /*@__PURE__*/ (() => {\n    class AxisDefaultsCrosshairComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('axisDefaults.crosshair', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    AxisDefaultsCrosshairComponentGenerated.ɵfac = function AxisDefaultsCrosshairComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    AxisDefaultsCrosshairComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: AxisDefaultsCrosshairComponentGenerated, inputs: { color: \"color\", dashType: \"dashType\", opacity: \"opacity\", visible: \"visible\", width: \"width\", tooltip: \"tooltip\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return AxisDefaultsCrosshairComponentGenerated;\n})();\nlet fesm2015_AxisDefaultsCrosshairComponent = /*@__PURE__*/ (() => {\n    /**\n     * The crosshair configuration options ([see example]({% slug api_charts_axisdefaultscomponent %})).\n     */\n    let AxisDefaultsCrosshairComponent = class AxisDefaultsCrosshairComponent extends fesm2015_AxisDefaultsCrosshairComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n            this.markAsVisible();\n        }\n    };\n    AxisDefaultsCrosshairComponent.ɵfac = function AxisDefaultsCrosshairComponent_Factory(t) { return new (t || AxisDefaultsCrosshairComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    AxisDefaultsCrosshairComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: AxisDefaultsCrosshairComponent, selectors: [[\"kendo-chart-axis-defaults-crosshair\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function AxisDefaultsCrosshairComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    AxisDefaultsCrosshairComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], AxisDefaultsCrosshairComponent);\n    return AxisDefaultsCrosshairComponent;\n})();\nlet fesm2015_AxisDefaultsCrosshairTooltipComponentGenerated = /*@__PURE__*/ (() => {\n    class AxisDefaultsCrosshairTooltipComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('axisDefaults.crosshair.tooltip', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    AxisDefaultsCrosshairTooltipComponentGenerated.ɵfac = function AxisDefaultsCrosshairTooltipComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    AxisDefaultsCrosshairTooltipComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: AxisDefaultsCrosshairTooltipComponentGenerated, inputs: { background: \"background\", border: \"border\", color: \"color\", font: \"font\", format: \"format\", padding: \"padding\", visible: \"visible\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return AxisDefaultsCrosshairTooltipComponentGenerated;\n})();\nlet fesm2015_AxisDefaultsCrosshairTooltipComponent = /*@__PURE__*/ (() => {\n    /**\n     * The options of the crosshair tooltip ([see example]({% slug crosshairs_chart_charts %})).\n     * The crosshair tooltip is displayed when the [`axisDefaults.crosshair.tooltip.visible`]({% slug api_charts_axisdefaultscrosshairtooltipcomponent %}#toc-visible)\n     * option is set to `true`.\n     */\n    let AxisDefaultsCrosshairTooltipComponent = class AxisDefaultsCrosshairTooltipComponent extends fesm2015_AxisDefaultsCrosshairTooltipComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n            this.markAsVisible();\n        }\n    };\n    AxisDefaultsCrosshairTooltipComponent.ɵfac = function AxisDefaultsCrosshairTooltipComponent_Factory(t) { return new (t || AxisDefaultsCrosshairTooltipComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    AxisDefaultsCrosshairTooltipComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: AxisDefaultsCrosshairTooltipComponent, selectors: [[\"kendo-chart-axis-defaults-crosshair-tooltip\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function AxisDefaultsCrosshairTooltipComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    AxisDefaultsCrosshairTooltipComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], AxisDefaultsCrosshairTooltipComponent);\n    return AxisDefaultsCrosshairTooltipComponent;\n})();\nlet fesm2015_AxisDefaultsLabelsComponentGenerated = /*@__PURE__*/ (() => {\n    class AxisDefaultsLabelsComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('axisDefaults.labels', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    AxisDefaultsLabelsComponentGenerated.ɵfac = function AxisDefaultsLabelsComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    AxisDefaultsLabelsComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: AxisDefaultsLabelsComponentGenerated, inputs: { content: \"content\", font: \"font\", format: \"format\", margin: \"margin\", mirror: \"mirror\", padding: \"padding\", rotation: \"rotation\", skip: \"skip\", step: \"step\", visible: \"visible\", visual: \"visual\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return AxisDefaultsLabelsComponentGenerated;\n})();\nlet fesm2015_AxisDefaultsLabelsComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration of the axis labels ([see example]({% slug api_charts_axisdefaultscomponent %})).\n     */\n    let AxisDefaultsLabelsComponent = class AxisDefaultsLabelsComponent extends fesm2015_AxisDefaultsLabelsComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    AxisDefaultsLabelsComponent.ɵfac = function AxisDefaultsLabelsComponent_Factory(t) { return new (t || AxisDefaultsLabelsComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    AxisDefaultsLabelsComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: AxisDefaultsLabelsComponent, selectors: [[\"kendo-chart-axis-defaults-labels\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function AxisDefaultsLabelsComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    AxisDefaultsLabelsComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], AxisDefaultsLabelsComponent);\n    return AxisDefaultsLabelsComponent;\n})();\nlet fesm2015_AxisDefaultsTitleComponentGenerated = /*@__PURE__*/ (() => {\n    class AxisDefaultsTitleComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('axisDefaults.title', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    AxisDefaultsTitleComponentGenerated.ɵfac = function AxisDefaultsTitleComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    AxisDefaultsTitleComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: AxisDefaultsTitleComponentGenerated, inputs: { background: \"background\", border: \"border\", color: \"color\", font: \"font\", margin: \"margin\", padding: \"padding\", position: \"position\", rotation: \"rotation\", text: \"text\", visible: \"visible\", visual: \"visual\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return AxisDefaultsTitleComponentGenerated;\n})();\nlet fesm2015_AxisDefaultsTitleComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration of the axis title ([see example]({% slug api_charts_axisdefaultscomponent %})).\n     */\n    let AxisDefaultsTitleComponent = class AxisDefaultsTitleComponent extends fesm2015_AxisDefaultsTitleComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    AxisDefaultsTitleComponent.ɵfac = function AxisDefaultsTitleComponent_Factory(t) { return new (t || AxisDefaultsTitleComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    AxisDefaultsTitleComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: AxisDefaultsTitleComponent, selectors: [[\"kendo-chart-axis-defaults-title\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function AxisDefaultsTitleComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    AxisDefaultsTitleComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], AxisDefaultsTitleComponent);\n    return AxisDefaultsTitleComponent;\n})();\nlet fesm2015_CollectionComponent = /*@__PURE__*/ (() => {\n    class CollectionComponent {\n        constructor(configKey, configurationService, collectionService) {\n            this.configKey = configKey;\n            this.configurationService = configurationService;\n            this.collectionService = collectionService;\n            this.items = [];\n            this.subscription = collectionService.onItemChange$.subscribe(changes => this.processChanges(changes));\n        }\n        ngOnDestroy() {\n            this.subscription.unsubscribe();\n        }\n        ngAfterContentInit() {\n            this.readItems();\n            this.children.changes.subscribe(() => this.readItems());\n        }\n        processChanges(changes) {\n            if (!this.children) {\n                return;\n            }\n            const index = this.children.toArray().indexOf(changes.sender);\n            if (index < 0) {\n                return;\n            }\n            this.items[index] = changes.options;\n            this.change();\n        }\n        readItems() {\n            this.items = this.children.map(s => s.options);\n            this.change();\n        }\n        change() {\n            this.configurationService.notify(new Change(this.configKey, this.items));\n        }\n    }\n    CollectionComponent.ɵfac = function CollectionComponent_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    CollectionComponent.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: CollectionComponent });\n    return CollectionComponent;\n})();\n/**\n * Specifies the `weekStartDay` of a [CategoryAxisItemComponent]({% slug api_charts_categoryaxisitemcomponent %}).\n */\nvar WeekStartDay = /*@__PURE__*/ (function (WeekStartDay) {\n    /**\n     * Specifies Sunday as the first day of the week.\n     */\n    WeekStartDay[WeekStartDay[\"Sunday\"] = 0] = \"Sunday\";\n    /**\n     * Specifies Monday as the first day of the week.\n     */\n    WeekStartDay[WeekStartDay[\"Monday\"] = 1] = \"Monday\";\n    /**\n     * Specifies Tuesday as the first day of the week.\n     */\n    WeekStartDay[WeekStartDay[\"Tuesday\"] = 2] = \"Tuesday\";\n    /**\n     * Specifies Wednesday as the first day of the week.\n     */\n    WeekStartDay[WeekStartDay[\"Wednesday\"] = 3] = \"Wednesday\";\n    /**\n     * Specifies Thursday as the first day of the week.\n     */\n    WeekStartDay[WeekStartDay[\"Thursday\"] = 4] = \"Thursday\";\n    /**\n     * Specifies Friday as the first day of the week.\n     */\n    WeekStartDay[WeekStartDay[\"Friday\"] = 5] = \"Friday\";\n    /**\n     * Specifies Saturday as the first day of the week.\n     */\n    WeekStartDay[WeekStartDay[\"Saturday\"] = 6] = \"Saturday\";\n    return WeekStartDay;\n})({});\nlet fesm2015_CategoryAxisItemComponentGenerated = /*@__PURE__*/ (() => {\n    class CategoryAxisItemComponentGenerated extends fesm2015_CollectionItemComponent {\n        constructor(configurationService, collectionService, intl, localeId) {\n            super(configurationService, collectionService);\n            this.configurationService = configurationService;\n            this.collectionService = collectionService;\n            this.notifyChanges({ weekStartDay: intl.firstDay(localeId) });\n        }\n    }\n    CategoryAxisItemComponentGenerated.ɵfac = function CategoryAxisItemComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    CategoryAxisItemComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: CategoryAxisItemComponentGenerated, inputs: { autoBaseUnitSteps: \"autoBaseUnitSteps\", axisCrossingValue: \"axisCrossingValue\", background: \"background\", baseUnit: \"baseUnit\", baseUnitStep: \"baseUnitStep\", categories: \"categories\", color: \"color\", justified: \"justified\", line: \"line\", majorGridLines: \"majorGridLines\", majorTicks: \"majorTicks\", max: \"max\", maxDateGroups: \"maxDateGroups\", maxDivisions: \"maxDivisions\", min: \"min\", minorGridLines: \"minorGridLines\", minorTicks: \"minorTicks\", name: \"name\", pane: \"pane\", plotBands: \"plotBands\", reverse: \"reverse\", roundToBaseUnit: \"roundToBaseUnit\", startAngle: \"startAngle\", type: \"type\", visible: \"visible\", weekStartDay: \"weekStartDay\", crosshair: \"crosshair\", labels: \"labels\", notes: \"notes\", select: \"select\", title: \"title\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return CategoryAxisItemComponentGenerated;\n})();\nlet fesm2015_CategoryAxisItemComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration component for a category axis ([see example]({% slug axes_chart_charts %})).\n     */\n    let CategoryAxisItemComponent = class CategoryAxisItemComponent extends fesm2015_CategoryAxisItemComponentGenerated {\n        constructor(configurationService, collectionService, intl, localeId) {\n            super(configurationService, collectionService, intl, localeId);\n            this.configurationService = configurationService;\n            this.collectionService = collectionService;\n        }\n    };\n    CategoryAxisItemComponent.ɵfac = function CategoryAxisItemComponent_Factory(t) { return new (t || CategoryAxisItemComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_CollectionService), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_IntlService), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"w\" /* LOCALE_ID */])); };\n    CategoryAxisItemComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: CategoryAxisItemComponent, selectors: [[\"kendo-chart-category-axis-item\"]], inputs: { rangeLabels: \"rangeLabels\" }, features: [core[\"Bb\" /* ɵɵProvidersFeature */]([fesm2015_ConfigurationService]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function CategoryAxisItemComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    CategoryAxisItemComponent = __decorate([__param(3, Object(core[\"q\" /* Inject */])(core[\"w\" /* LOCALE_ID */])),\n        __metadata(\"design:paramtypes\", [fesm2015_ConfigurationService,\n            fesm2015_CollectionService,\n            fesm2015_IntlService, String])\n    ], CategoryAxisItemComponent);\n    return CategoryAxisItemComponent;\n})();\nlet fesm2015_CategoryAxisComponentGenerated = /*@__PURE__*/ (() => {\n    class CategoryAxisComponentGenerated extends fesm2015_CollectionComponent {\n        constructor(configurationService, collectionService) {\n            super('categoryAxis', configurationService, collectionService);\n            this.configurationService = configurationService;\n            this.collectionService = collectionService;\n        }\n    }\n    CategoryAxisComponentGenerated.ɵfac = function CategoryAxisComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    CategoryAxisComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: CategoryAxisComponentGenerated, contentQueries: function CategoryAxisComponentGenerated_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                core[\"Ib\" /* ɵɵcontentQuery */](dirIndex, fesm2015_CategoryAxisItemComponent, false);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx.children = _t);\n            }\n        }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return CategoryAxisComponentGenerated;\n})();\nlet fesm2015_CategoryAxisComponent = /*@__PURE__*/ (() => {\n    /**\n     * A collection of one or more category axis items.\n     *\n     * @example\n     * ```ts\n     * import { Component } from '@angular/core';\n     *\n     * _@Component({\n     *   selector: 'my-app',\n     *   template: `\n     *     <kendo-chart>\n     *       <kendo-chart-category-axis>\n     *         <kendo-chart-category-axis-item [categories]=\"[2015, 2016]\" color=\"#f00\">\n     *         </kendo-chart-category-axis-item>\n     *       </kendo-chart-category-axis>\n     *       <kendo-chart-series>\n     *         <kendo-chart-series-item type=\"line\" [data]=\"[1, 2, 3]\">\n     *         </kendo-chart-series-item>\n     *       </kendo-chart-series>\n     *     </kendo-chart>\n     *   `\n     * })\n     * class AppComponent {\n     * }\n     * ```\n     */\n    let CategoryAxisComponent = class CategoryAxisComponent extends fesm2015_CategoryAxisComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService, collectionService) {\n            super(configurationService, collectionService);\n            this.configurationService = configurationService;\n            this.collectionService = collectionService;\n        }\n    };\n    CategoryAxisComponent.ɵfac = function CategoryAxisComponent_Factory(t) { return new (t || CategoryAxisComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_CollectionService)); };\n    CategoryAxisComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: CategoryAxisComponent, selectors: [[\"kendo-chart-category-axis\"]], features: [core[\"Bb\" /* ɵɵProvidersFeature */]([fesm2015_CollectionService]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function CategoryAxisComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    CategoryAxisComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService,\n            fesm2015_CollectionService])\n    ], CategoryAxisComponent);\n    return CategoryAxisComponent;\n})();\nlet fesm2015_CategoryAxisCrosshairComponentGenerated = /*@__PURE__*/ (() => {\n    class CategoryAxisCrosshairComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('crosshair', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    CategoryAxisCrosshairComponentGenerated.ɵfac = function CategoryAxisCrosshairComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    CategoryAxisCrosshairComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: CategoryAxisCrosshairComponentGenerated, inputs: { color: \"color\", dashType: \"dashType\", opacity: \"opacity\", visible: \"visible\", width: \"width\", tooltip: \"tooltip\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return CategoryAxisCrosshairComponentGenerated;\n})();\nlet fesm2015_CategoryAxisCrosshairComponent = /*@__PURE__*/ (() => {\n    /**\n     * The crosshair configuration options ([see example]({% slug crosshairs_chart_charts %})).\n     */\n    let CategoryAxisCrosshairComponent = class CategoryAxisCrosshairComponent extends fesm2015_CategoryAxisCrosshairComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n            this.markAsVisible();\n        }\n    };\n    CategoryAxisCrosshairComponent.ɵfac = function CategoryAxisCrosshairComponent_Factory(t) { return new (t || CategoryAxisCrosshairComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    CategoryAxisCrosshairComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: CategoryAxisCrosshairComponent, selectors: [[\"kendo-chart-category-axis-item-crosshair\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function CategoryAxisCrosshairComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    CategoryAxisCrosshairComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], CategoryAxisCrosshairComponent);\n    return CategoryAxisCrosshairComponent;\n})();\nlet fesm2015_CategoryAxisCrosshairTooltipComponentGenerated = /*@__PURE__*/ (() => {\n    class CategoryAxisCrosshairTooltipComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('crosshair.tooltip', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    CategoryAxisCrosshairTooltipComponentGenerated.ɵfac = function CategoryAxisCrosshairTooltipComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    CategoryAxisCrosshairTooltipComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: CategoryAxisCrosshairTooltipComponentGenerated, inputs: { background: \"background\", border: \"border\", color: \"color\", font: \"font\", format: \"format\", padding: \"padding\", visible: \"visible\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return CategoryAxisCrosshairTooltipComponentGenerated;\n})();\nlet fesm2015_CategoryAxisCrosshairTooltipComponent = /*@__PURE__*/ (() => {\n    /**\n     * The options of the crosshair tooltip ([see example]({% slug crosshairs_chart_charts %})).\n     * The crosshair tooltip is displayed when the `visible` option is set to `true`.\n     */\n    let CategoryAxisCrosshairTooltipComponent = class CategoryAxisCrosshairTooltipComponent extends fesm2015_CategoryAxisCrosshairTooltipComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n            this.markAsVisible();\n        }\n    };\n    CategoryAxisCrosshairTooltipComponent.ɵfac = function CategoryAxisCrosshairTooltipComponent_Factory(t) { return new (t || CategoryAxisCrosshairTooltipComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    CategoryAxisCrosshairTooltipComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: CategoryAxisCrosshairTooltipComponent, selectors: [[\"kendo-chart-category-axis-item-crosshair-tooltip\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function CategoryAxisCrosshairTooltipComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    CategoryAxisCrosshairTooltipComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], CategoryAxisCrosshairTooltipComponent);\n    return CategoryAxisCrosshairTooltipComponent;\n})();\nlet fesm2015_CategoryAxisLabelsComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration of the axis labels ([see example]({% slug labels_chart_charts %})).\n     */\n    let CategoryAxisLabelsComponent = class CategoryAxisLabelsComponent extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('labels', configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    CategoryAxisLabelsComponent.ɵfac = function CategoryAxisLabelsComponent_Factory(t) { return new (t || CategoryAxisLabelsComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    CategoryAxisLabelsComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: CategoryAxisLabelsComponent, selectors: [[\"kendo-chart-category-axis-item-labels\"]], inputs: { background: \"background\", border: \"border\", color: \"color\", content: \"content\", culture: \"culture\", dateFormats: \"dateFormats\", font: \"font\", format: \"format\", margin: \"margin\", mirror: \"mirror\", padding: \"padding\", position: \"position\", rotation: \"rotation\", skip: \"skip\", step: \"step\", visible: \"visible\", visual: \"visual\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function CategoryAxisLabelsComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    CategoryAxisLabelsComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], CategoryAxisLabelsComponent);\n    return CategoryAxisLabelsComponent;\n})();\nlet fesm2015_CategoryAxisRangeLabelsComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration of the axis date range labels ([see example]({% slug labels_chart_charts %})).\n     */\n    let CategoryAxisRangeLabelsComponent = class CategoryAxisRangeLabelsComponent extends fesm2015_CategoryAxisLabelsComponent {\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n            this.configKey = 'rangeLabels';\n            this.markAsVisible();\n        }\n    };\n    CategoryAxisRangeLabelsComponent.ɵfac = function CategoryAxisRangeLabelsComponent_Factory(t) { return new (t || CategoryAxisRangeLabelsComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    CategoryAxisRangeLabelsComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: CategoryAxisRangeLabelsComponent, selectors: [[\"kendo-chart-category-axis-item-range-labels\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function CategoryAxisRangeLabelsComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    CategoryAxisRangeLabelsComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], CategoryAxisRangeLabelsComponent);\n    return CategoryAxisRangeLabelsComponent;\n})();\nlet fesm2015_CategoryAxisNotesComponentGenerated = /*@__PURE__*/ (() => {\n    class CategoryAxisNotesComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('notes', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    CategoryAxisNotesComponentGenerated.ɵfac = function CategoryAxisNotesComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    CategoryAxisNotesComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: CategoryAxisNotesComponentGenerated, inputs: { data: \"data\", line: \"line\", position: \"position\", visual: \"visual\", icon: \"icon\", label: \"label\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return CategoryAxisNotesComponentGenerated;\n})();\nlet fesm2015_CategoryAxisNotesComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration of the category axis notes ([see example]({% slug notes_chart_charts %}#toc-axis-notes)).\n     */\n    let CategoryAxisNotesComponent = class CategoryAxisNotesComponent extends fesm2015_CategoryAxisNotesComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    CategoryAxisNotesComponent.ɵfac = function CategoryAxisNotesComponent_Factory(t) { return new (t || CategoryAxisNotesComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    CategoryAxisNotesComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: CategoryAxisNotesComponent, selectors: [[\"kendo-chart-category-axis-item-notes\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function CategoryAxisNotesComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    CategoryAxisNotesComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], CategoryAxisNotesComponent);\n    return CategoryAxisNotesComponent;\n})();\nlet fesm2015_CategoryAxisNotesIconComponentGenerated = /*@__PURE__*/ (() => {\n    class CategoryAxisNotesIconComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('notes.icon', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    CategoryAxisNotesIconComponentGenerated.ɵfac = function CategoryAxisNotesIconComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    CategoryAxisNotesIconComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: CategoryAxisNotesIconComponentGenerated, inputs: { background: \"background\", border: \"border\", size: \"size\", type: \"type\", visible: \"visible\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return CategoryAxisNotesIconComponentGenerated;\n})();\nlet fesm2015_CategoryAxisNotesIconComponent = /*@__PURE__*/ (() => {\n    /**\n     * The icon of the notes.\n     */\n    let CategoryAxisNotesIconComponent = class CategoryAxisNotesIconComponent extends fesm2015_CategoryAxisNotesIconComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    CategoryAxisNotesIconComponent.ɵfac = function CategoryAxisNotesIconComponent_Factory(t) { return new (t || CategoryAxisNotesIconComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    CategoryAxisNotesIconComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: CategoryAxisNotesIconComponent, selectors: [[\"kendo-chart-category-axis-item-notes-icon\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function CategoryAxisNotesIconComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    CategoryAxisNotesIconComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], CategoryAxisNotesIconComponent);\n    return CategoryAxisNotesIconComponent;\n})();\nlet fesm2015_CategoryAxisNotesLabelComponentGenerated = /*@__PURE__*/ (() => {\n    class CategoryAxisNotesLabelComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('notes.label', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    CategoryAxisNotesLabelComponentGenerated.ɵfac = function CategoryAxisNotesLabelComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    CategoryAxisNotesLabelComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: CategoryAxisNotesLabelComponentGenerated, inputs: { background: \"background\", border: \"border\", color: \"color\", content: \"content\", font: \"font\", format: \"format\", position: \"position\", rotation: \"rotation\", visible: \"visible\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return CategoryAxisNotesLabelComponentGenerated;\n})();\nlet fesm2015_CategoryAxisNotesLabelComponent = /*@__PURE__*/ (() => {\n    /**\n     * The label of the notes.\n     */\n    let CategoryAxisNotesLabelComponent = class CategoryAxisNotesLabelComponent extends fesm2015_CategoryAxisNotesLabelComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    CategoryAxisNotesLabelComponent.ɵfac = function CategoryAxisNotesLabelComponent_Factory(t) { return new (t || CategoryAxisNotesLabelComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    CategoryAxisNotesLabelComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: CategoryAxisNotesLabelComponent, selectors: [[\"kendo-chart-category-axis-item-notes-label\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function CategoryAxisNotesLabelComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    CategoryAxisNotesLabelComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], CategoryAxisNotesLabelComponent);\n    return CategoryAxisNotesLabelComponent;\n})();\nlet fesm2015_CategoryAxisSelectComponentGenerated = /*@__PURE__*/ (() => {\n    class CategoryAxisSelectComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('select', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    CategoryAxisSelectComponentGenerated.ɵfac = function CategoryAxisSelectComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    CategoryAxisSelectComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: CategoryAxisSelectComponentGenerated, inputs: { from: \"from\", max: \"max\", min: \"min\", mousewheel: \"mousewheel\", to: \"to\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return CategoryAxisSelectComponentGenerated;\n})();\nlet fesm2015_CategoryAxisSelectComponent = /*@__PURE__*/ (() => {\n    /**\n     * The selected axis range. If set, the axis selection is enabled. The range is index-based and starts from zero.\n     * Categories with indexes in the\n     * ([`select.from`]({% slug api_charts_categoryaxisselectcomponent %}#toc-from)\n     * &mdash;[`select.to`]({% slug api_charts_categoryaxisselectcomponent %}#toc-to)) range will be selected.\n     * This means that the last category in the range will not be included in the selection.\n     * If the categories are dates, the range has to be also specified with date values.\n     */\n    let CategoryAxisSelectComponent = class CategoryAxisSelectComponent extends fesm2015_CategoryAxisSelectComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    CategoryAxisSelectComponent.ɵfac = function CategoryAxisSelectComponent_Factory(t) { return new (t || CategoryAxisSelectComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    CategoryAxisSelectComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: CategoryAxisSelectComponent, selectors: [[\"kendo-chart-category-axis-item-select\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function CategoryAxisSelectComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    CategoryAxisSelectComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], CategoryAxisSelectComponent);\n    return CategoryAxisSelectComponent;\n})();\nlet fesm2015_CategoryAxisTitleComponentGenerated = /*@__PURE__*/ (() => {\n    class CategoryAxisTitleComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('title', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    CategoryAxisTitleComponentGenerated.ɵfac = function CategoryAxisTitleComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    CategoryAxisTitleComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: CategoryAxisTitleComponentGenerated, inputs: { background: \"background\", border: \"border\", color: \"color\", font: \"font\", margin: \"margin\", padding: \"padding\", position: \"position\", rotation: \"rotation\", text: \"text\", visible: \"visible\", visual: \"visual\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return CategoryAxisTitleComponentGenerated;\n})();\nlet fesm2015_CategoryAxisTitleComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration of the category axis title.\n     */\n    let CategoryAxisTitleComponent = class CategoryAxisTitleComponent extends fesm2015_CategoryAxisTitleComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    CategoryAxisTitleComponent.ɵfac = function CategoryAxisTitleComponent_Factory(t) { return new (t || CategoryAxisTitleComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    CategoryAxisTitleComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: CategoryAxisTitleComponent, selectors: [[\"kendo-chart-category-axis-item-title\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function CategoryAxisTitleComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    CategoryAxisTitleComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], CategoryAxisTitleComponent);\n    return CategoryAxisTitleComponent;\n})();\nlet fesm2015_ChartAreaComponentGenerated = /*@__PURE__*/ (() => {\n    class ChartAreaComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('chartArea', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    ChartAreaComponentGenerated.ɵfac = function ChartAreaComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    ChartAreaComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: ChartAreaComponentGenerated, inputs: { background: \"background\", border: \"border\", height: \"height\", margin: \"margin\", opacity: \"opacity\", width: \"width\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return ChartAreaComponentGenerated;\n})();\nlet fesm2015_ChartAreaComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration options of the Chart area.\n     * Represents the entire visible area of the Chart\n     * ([see example]({% slug chartarea_chart_charts %})).\n     */\n    let ChartAreaComponent = class ChartAreaComponent extends fesm2015_ChartAreaComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    ChartAreaComponent.ɵfac = function ChartAreaComponent_Factory(t) { return new (t || ChartAreaComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    ChartAreaComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: ChartAreaComponent, selectors: [[\"kendo-chart-area\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function ChartAreaComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    ChartAreaComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], ChartAreaComponent);\n    return ChartAreaComponent;\n})();\nlet fesm2015_LegendComponentGenerated = /*@__PURE__*/ (() => {\n    class LegendComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('legend', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    LegendComponentGenerated.ɵfac = function LegendComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    LegendComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: LegendComponentGenerated, inputs: { align: \"align\", background: \"background\", border: \"border\", height: \"height\", labels: \"labels\", margin: \"margin\", offsetX: \"offsetX\", offsetY: \"offsetY\", orientation: \"orientation\", padding: \"padding\", position: \"position\", reverse: \"reverse\", visible: \"visible\", width: \"width\", markers: \"markers\", spacing: \"spacing\", inactiveItems: \"inactiveItems\", item: \"item\", title: \"title\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return LegendComponentGenerated;\n})();\nlet fesm2015_LegendComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration options of the Chart legend\n     * ([see example]({% slug legend_chart_charts %})).\n     */\n    let LegendComponent = class LegendComponent extends fesm2015_LegendComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n            this.markAsVisible();\n        }\n    };\n    LegendComponent.ɵfac = function LegendComponent_Factory(t) { return new (t || LegendComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    LegendComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: LegendComponent, selectors: [[\"kendo-chart-legend\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function LegendComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    LegendComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], LegendComponent);\n    return LegendComponent;\n})();\nlet fesm2015_LegendInactiveItemsComponentGenerated = /*@__PURE__*/ (() => {\n    class LegendInactiveItemsComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('legend.inactiveItems', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    LegendInactiveItemsComponentGenerated.ɵfac = function LegendInactiveItemsComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    LegendInactiveItemsComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: LegendInactiveItemsComponentGenerated, inputs: { labels: \"labels\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return LegendInactiveItemsComponentGenerated;\n})();\nlet fesm2015_LegendInactiveItemsComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration of the inactive Chart legend items.\n     *\n     * @example\n     *\n     * ```html-no-run\n     * <kendo-chart>\n     *   <kendo-chart-legend>\n     *      <kendo-chart-legend-inactive-items [labels]=\"{color: 'pink'}\"></kendo-chart-legend-inactive-items>\n     *   </kendo-chart-legend>\n     * </kendo-chart>\n     * ```\n     */\n    let LegendInactiveItemsComponent = class LegendInactiveItemsComponent extends fesm2015_LegendInactiveItemsComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    LegendInactiveItemsComponent.ɵfac = function LegendInactiveItemsComponent_Factory(t) { return new (t || LegendInactiveItemsComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    LegendInactiveItemsComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: LegendInactiveItemsComponent, selectors: [[\"kendo-chart-legend-inactive-items\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function LegendInactiveItemsComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    LegendInactiveItemsComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], LegendInactiveItemsComponent);\n    return LegendInactiveItemsComponent;\n})();\nlet fesm2015_LegendItemComponentGenerated = /*@__PURE__*/ (() => {\n    class LegendItemComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('legend.item', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    LegendItemComponentGenerated.ɵfac = function LegendItemComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    LegendItemComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: LegendItemComponentGenerated, inputs: { cursor: \"cursor\", visual: \"visual\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return LegendItemComponentGenerated;\n})();\nlet fesm2015_LegendItemComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration of the Chart legend item.\n     *\n     * @example\n     *\n     * ```html-no-run\n     * <kendo-chart>\n     *   <kendo-chart-legend>\n     *      <kendo-chart-legend-item cursor=\"crosshair\"></kendo-chart-legend-item>\n     *   </kendo-chart-legend>\n     * </kendo-chart>\n     * ```\n     */\n    let LegendItemComponent = class LegendItemComponent extends fesm2015_LegendItemComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    LegendItemComponent.ɵfac = function LegendItemComponent_Factory(t) { return new (t || LegendItemComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    LegendItemComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: LegendItemComponent, selectors: [[\"kendo-chart-legend-item\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function LegendItemComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    LegendItemComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], LegendItemComponent);\n    return LegendItemComponent;\n})();\nlet fesm2015_PaneComponentGenerated = /*@__PURE__*/ (() => {\n    class PaneComponentGenerated extends fesm2015_CollectionItemComponent {\n        constructor(configurationService, collectionService) {\n            super(configurationService, collectionService);\n            this.configurationService = configurationService;\n            this.collectionService = collectionService;\n        }\n    }\n    PaneComponentGenerated.ɵfac = function PaneComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    PaneComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: PaneComponentGenerated, inputs: { background: \"background\", border: \"border\", clip: \"clip\", height: \"height\", margin: \"margin\", name: \"name\", padding: \"padding\", title: \"title\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return PaneComponentGenerated;\n})();\nlet fesm2015_PaneComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration component for a Chart pane.\n     *\n     * @example\n     * ```ts\n     * import { Component } from '@angular/core';\n     *\n     * _@Component({\n     *   selector: 'my-app',\n     *   template: `\n     *       <kendo-chart>\n     *         <kendo-chart-panes>\n     *             <kendo-chart-pane name=\"top\" background=\"pink\" [border]=\"{ color: 'black', dashtype: 'dash', width: 2 }\">\n     *               <!--            ^^^^^^^^^^\n     *                   Unique ID for the pane.\n     *               -->\n     *             </kendo-chart-pane>\n     *             <kendo-chart-pane name=\"bottom\" [height]=\"150\" title=\"Bottom pane\">\n     *               <!--                          ^^^^^^^^^^^^^^\n     *                   Note that the binding is required,\n     *                   otherwise the property will be\n     *                   bound to a '100' string.\n     *               -->\n     *             </kendo-chart-pane>\n     *         </kendo-chart-panes>\n     *\n     *         <kendo-chart-value-axis>\n     *             <kendo-chart-value-axis-item name=\"top\">\n     *               <!--                       ^^^^^^^^^^\n     *                   Unique ID for the axis.\n     *                   No need to set a pane as it will use the first,\n     *                   'top' pane by default.\n     *               -->\n     *             </kendo-chart-value-axis-item>\n     *             <kendo-chart-value-axis-item name=\"bottom\"\n     *                                          pane=\"bottom\">\n     *               <!--                       ^^^^^^^^^^^^^\n     *                   Move the axis to the bottom pane.\n     *               -->\n     *             </kendo-chart-value-axis-item>\n     *         </kendo-chart-value-axis>\n     *         <kendo-chart-series>\n     *           <kendo-chart-series-item [data]=\"seriesData[0]\">\n     *               <!-- Will use the first, 'top' value axis by default. -->\n     *           </kendo-chart-series-item>\n     *           <kendo-chart-series-item type=\"line\" [data]=\"seriesData[1]\" axis=\"bottom\">\n     *               <!-- Plot this series to the 'bottom' axis.              ^^^^^^^^^^^^^ -->\n     *           </kendo-chart-series-item>\n     *         </kendo-chart-series>\n     *       </kendo-chart>\n     *   `\n     * })\n     * export class AppComponent {\n     *   public seriesData: number[][] = [[1, 2, 3, 5], [0, 1, 0, 1]];\n     * }\n     * ```\n     */\n    let PaneComponent = class PaneComponent extends fesm2015_PaneComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService, collectionService) {\n            super(configurationService, collectionService);\n            this.configurationService = configurationService;\n            this.collectionService = collectionService;\n        }\n    };\n    PaneComponent.ɵfac = function PaneComponent_Factory(t) { return new (t || PaneComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_CollectionService)); };\n    PaneComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: PaneComponent, selectors: [[\"kendo-chart-pane\"], [\"kendo-chart-panes-item\"]], features: [core[\"Bb\" /* ɵɵProvidersFeature */]([fesm2015_ConfigurationService]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function PaneComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    PaneComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService,\n            fesm2015_CollectionService])\n    ], PaneComponent);\n    return PaneComponent;\n})();\nlet fesm2015_PaneDefaultsComponent = /*@__PURE__*/ (() => {\n    /**\n     * The default options for all chart panes,\n     * ([see example]({% slug panes_chart_charts %}#toc-default-panes-configuration)).\n     */\n    let PaneDefaultsComponent = class PaneDefaultsComponent extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('paneDefaults', configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    PaneDefaultsComponent.ɵfac = function PaneDefaultsComponent_Factory(t) { return new (t || PaneDefaultsComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    PaneDefaultsComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: PaneDefaultsComponent, selectors: [[\"kendo-chart-pane-defaults\"]], inputs: { background: \"background\", border: \"border\", clip: \"clip\", height: \"height\", margin: \"margin\", padding: \"padding\", title: \"title\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function PaneDefaultsComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    PaneDefaultsComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], PaneDefaultsComponent);\n    return PaneDefaultsComponent;\n})();\nlet fesm2015_PaneDefaultsTitleComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration of the pane default title.\n     */\n    let PaneDefaultsTitleComponent = class PaneDefaultsTitleComponent extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('paneDefaults.title', configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    PaneDefaultsTitleComponent.ɵfac = function PaneDefaultsTitleComponent_Factory(t) { return new (t || PaneDefaultsTitleComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    PaneDefaultsTitleComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: PaneDefaultsTitleComponent, selectors: [[\"kendo-chart-pane-defaults-title\"]], inputs: { background: \"background\", border: \"border\", color: \"color\", font: \"font\", margin: \"margin\", position: \"position\", visible: \"visible\", visual: \"visual\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function PaneDefaultsTitleComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    PaneDefaultsTitleComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], PaneDefaultsTitleComponent);\n    return PaneDefaultsTitleComponent;\n})();\nlet fesm2015_PanesComponentGenerated = /*@__PURE__*/ (() => {\n    class PanesComponentGenerated extends fesm2015_CollectionComponent {\n        constructor(configurationService, collectionService) {\n            super('panes', configurationService, collectionService);\n            this.configurationService = configurationService;\n            this.collectionService = collectionService;\n        }\n    }\n    PanesComponentGenerated.ɵfac = function PanesComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    PanesComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: PanesComponentGenerated, contentQueries: function PanesComponentGenerated_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                core[\"Ib\" /* ɵɵcontentQuery */](dirIndex, fesm2015_PaneComponent, false);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx.children = _t);\n            }\n        }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return PanesComponentGenerated;\n})();\nlet fesm2015_PanesComponent = /*@__PURE__*/ (() => {\n    /**\n     * A collection of one or more pane configuration components.\n     *\n     * @example\n     * ```ts\n     * import { Component } from '@angular/core';\n     *\n     * _@Component({\n     *   selector: 'my-app',\n     *   template: `\n     *     <kendo-chart>\n     *       <kendo-chart-panes>\n     *         <kendo-chart-pane name=\"topPane\">\n     *         </kendo-chart-pane>\n     *         <kendo-chart-pane name=\"bottomPane\">\n     *         </kendo-chart-pane>\n     *       </kendo-chart-panes>\n     *       <kendo-chart-value-axis>\n     *         <kendo-chart-value-axis-item pane=\"topPane\">\n     *         </kendo-chart-value-axis-item>\n     *         <kendo-chart-value-axis-item name=\"bottomAxis\" pane=\"bottomPane\">\n     *         </kendo-chart-value-axis-item>\n     *       </kendo-chart-value-axis>\n     *       <kendo-chart-series>\n     *         <kendo-chart-series-item type=\"line\" [data]=\"[1, 2, 3]\">\n     *         </kendo-chart-series-item>\n     *         <kendo-chart-series-item type=\"line\" [data]=\"[1, 2, 3, 4]\"\n     *                                  axis=\"bottomAxis\">\n     *         </kendo-chart-series-item>\n     *       </kendo-chart-series>\n     *     </kendo-chart>\n     *   `\n     * })\n     * class AppComponent {\n     * }\n     *\n     * ```\n     */\n    let PanesComponent = class PanesComponent extends fesm2015_PanesComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService, collectionService) {\n            super(configurationService, collectionService);\n            this.configurationService = configurationService;\n            this.collectionService = collectionService;\n        }\n    };\n    PanesComponent.ɵfac = function PanesComponent_Factory(t) { return new (t || PanesComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_CollectionService)); };\n    PanesComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: PanesComponent, selectors: [[\"kendo-chart-panes\"]], features: [core[\"Bb\" /* ɵɵProvidersFeature */]([fesm2015_CollectionService]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function PanesComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    PanesComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService,\n            fesm2015_CollectionService])\n    ], PanesComponent);\n    return PanesComponent;\n})();\nlet fesm2015_PanesTitleComponentGenerated = /*@__PURE__*/ (() => {\n    class PanesTitleComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('title', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    PanesTitleComponentGenerated.ɵfac = function PanesTitleComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    PanesTitleComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: PanesTitleComponentGenerated, inputs: { background: \"background\", border: \"border\", color: \"color\", font: \"font\", margin: \"margin\", position: \"position\", text: \"text\", visible: \"visible\", visual: \"visual\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return PanesTitleComponentGenerated;\n})();\nlet fesm2015_PanesTitleComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration of the Chart pane title.\n     */\n    let PanesTitleComponent = class PanesTitleComponent extends fesm2015_PanesTitleComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    PanesTitleComponent.ɵfac = function PanesTitleComponent_Factory(t) { return new (t || PanesTitleComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    PanesTitleComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: PanesTitleComponent, selectors: [[\"kendo-chart-pane-title\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function PanesTitleComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    PanesTitleComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], PanesTitleComponent);\n    return PanesTitleComponent;\n})();\nlet fesm2015_PlotAreaComponentGenerated = /*@__PURE__*/ (() => {\n    class PlotAreaComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('plotArea', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    PlotAreaComponentGenerated.ɵfac = function PlotAreaComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    PlotAreaComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: PlotAreaComponentGenerated, inputs: { background: \"background\", border: \"border\", margin: \"margin\", opacity: \"opacity\", padding: \"padding\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return PlotAreaComponentGenerated;\n})();\nlet fesm2015_PlotAreaComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration options of the plot area\n     * ([see example]({% slug plotarea_chart_charts %})).\n     * The plot area is the area which displays the series.\n     */\n    let PlotAreaComponent = class PlotAreaComponent extends fesm2015_PlotAreaComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    PlotAreaComponent.ɵfac = function PlotAreaComponent_Factory(t) { return new (t || PlotAreaComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    PlotAreaComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: PlotAreaComponent, selectors: [[\"kendo-chart-plot-area\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function PlotAreaComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    PlotAreaComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], PlotAreaComponent);\n    return PlotAreaComponent;\n})();\nlet fesm2015_SeriesComponentGenerated = /*@__PURE__*/ (() => {\n    class SeriesComponentGenerated extends fesm2015_CollectionComponent {\n        constructor(configurationService, collectionService) {\n            super('series', configurationService, collectionService);\n            this.configurationService = configurationService;\n            this.collectionService = collectionService;\n        }\n    }\n    SeriesComponentGenerated.ɵfac = function SeriesComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    SeriesComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: SeriesComponentGenerated, contentQueries: function SeriesComponentGenerated_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                core[\"Ib\" /* ɵɵcontentQuery */](dirIndex, fesm2015_SeriesItemComponent, false);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx.children = _t);\n            }\n        }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return SeriesComponentGenerated;\n})();\nlet fesm2015_SeriesComponent = /*@__PURE__*/ (() => {\n    /**\n     * A collection of one or more series items.\n     *\n     * @example\n     * ```ts\n     * import { Component } from '@angular/core';\n     *\n     * _@Component({\n     *   selector: 'my-app',\n     *   template: `\n     *     <kendo-chart>\n     *       <kendo-chart-series>\n     *         <kendo-chart-series-item type=\"line\" [data]=\"[1, 2, 3]\">\n     *         </kendo-chart-series-item>\n     *       </kendo-chart-series>\n     *     </kendo-chart>\n     *   `\n     * })\n     * class AppComponent {\n     * }\n     *\n     * ```\n     */\n    let SeriesComponent = class SeriesComponent extends fesm2015_SeriesComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService, collectionService, tooltipTemplateService) {\n            super(configurationService, collectionService);\n            this.configurationService = configurationService;\n            this.collectionService = collectionService;\n            this.tooltipTemplateService = tooltipTemplateService;\n        }\n        ngAfterContentChecked() {\n            this.readTooltipTemplates();\n        }\n        readTooltipTemplates() {\n            const templates = this.children.map((item) => item.seriesTooltipTemplateRef);\n            this.tooltipTemplateService.setSeriesTemplates(templates);\n        }\n    };\n    SeriesComponent.ɵfac = function SeriesComponent_Factory(t) { return new (t || SeriesComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_CollectionService), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_TooltipTemplateService)); };\n    SeriesComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: SeriesComponent, selectors: [[\"kendo-chart-series\"]], features: [core[\"Bb\" /* ɵɵProvidersFeature */]([fesm2015_CollectionService]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function SeriesComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    SeriesComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService,\n            fesm2015_CollectionService,\n            fesm2015_TooltipTemplateService])\n    ], SeriesComponent);\n    return SeriesComponent;\n})();\nlet fesm2015_SeriesDefaultsComponentGenerated = /*@__PURE__*/ (() => {\n    class SeriesDefaultsComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('seriesDefaults', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    SeriesDefaultsComponentGenerated.ɵfac = function SeriesDefaultsComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    SeriesDefaultsComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: SeriesDefaultsComponentGenerated, inputs: { border: \"border\", gap: \"gap\", highlight: \"highlight\", overlay: \"overlay\", spacing: \"spacing\", stack: \"stack\", type: \"type\", visual: \"visual\", labels: \"labels\", notes: \"notes\", tooltip: \"tooltip\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return SeriesDefaultsComponentGenerated;\n})();\nlet fesm2015_SeriesDefaultsComponent = /*@__PURE__*/ (() => {\n    /**\n     * The default options for all series\n     * ([see example]({% slug series_chart_charts %}#toc-default-series-configuration)).\n     */\n    let SeriesDefaultsComponent = class SeriesDefaultsComponent extends fesm2015_SeriesDefaultsComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    SeriesDefaultsComponent.ɵfac = function SeriesDefaultsComponent_Factory(t) { return new (t || SeriesDefaultsComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    SeriesDefaultsComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: SeriesDefaultsComponent, selectors: [[\"kendo-chart-series-defaults\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function SeriesDefaultsComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    SeriesDefaultsComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], SeriesDefaultsComponent);\n    return SeriesDefaultsComponent;\n})();\nlet fesm2015_SeriesDefaultsLabelsComponentGenerated = /*@__PURE__*/ (() => {\n    class SeriesDefaultsLabelsComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('seriesDefaults.labels', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    SeriesDefaultsLabelsComponentGenerated.ɵfac = function SeriesDefaultsLabelsComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    SeriesDefaultsLabelsComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: SeriesDefaultsLabelsComponentGenerated, inputs: { background: \"background\", border: \"border\", color: \"color\", content: \"content\", font: \"font\", format: \"format\", margin: \"margin\", padding: \"padding\", visible: \"visible\", visual: \"visual\", from: \"from\", to: \"to\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return SeriesDefaultsLabelsComponentGenerated;\n})();\nlet fesm2015_SeriesDefaultsLabelsComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration of the Chart series label.\n     */\n    let SeriesDefaultsLabelsComponent = class SeriesDefaultsLabelsComponent extends fesm2015_SeriesDefaultsLabelsComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n            this.markAsVisible();\n        }\n    };\n    SeriesDefaultsLabelsComponent.ɵfac = function SeriesDefaultsLabelsComponent_Factory(t) { return new (t || SeriesDefaultsLabelsComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    SeriesDefaultsLabelsComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: SeriesDefaultsLabelsComponent, selectors: [[\"kendo-chart-series-defaults-labels\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function SeriesDefaultsLabelsComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    SeriesDefaultsLabelsComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], SeriesDefaultsLabelsComponent);\n    return SeriesDefaultsLabelsComponent;\n})();\nlet fesm2015_SeriesDefaultsLabelsFromComponentGenerated = /*@__PURE__*/ (() => {\n    class SeriesDefaultsLabelsFromComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('seriesDefaults.labels.from', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    SeriesDefaultsLabelsFromComponentGenerated.ɵfac = function SeriesDefaultsLabelsFromComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    SeriesDefaultsLabelsFromComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: SeriesDefaultsLabelsFromComponentGenerated, inputs: { background: \"background\", border: \"border\", color: \"color\", content: \"content\", font: \"font\", format: \"format\", margin: \"margin\", padding: \"padding\", visible: \"visible\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return SeriesDefaultsLabelsFromComponentGenerated;\n})();\nlet fesm2015_SeriesDefaultsLabelsFromComponent = /*@__PURE__*/ (() => {\n    /**\n     * The `from` label configuration of the Chart series.\n     */\n    let SeriesDefaultsLabelsFromComponent = class SeriesDefaultsLabelsFromComponent extends fesm2015_SeriesDefaultsLabelsFromComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n            this.markAsVisible();\n        }\n    };\n    SeriesDefaultsLabelsFromComponent.ɵfac = function SeriesDefaultsLabelsFromComponent_Factory(t) { return new (t || SeriesDefaultsLabelsFromComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    SeriesDefaultsLabelsFromComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: SeriesDefaultsLabelsFromComponent, selectors: [[\"kendo-chart-series-defaults-labels-from\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function SeriesDefaultsLabelsFromComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    SeriesDefaultsLabelsFromComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], SeriesDefaultsLabelsFromComponent);\n    return SeriesDefaultsLabelsFromComponent;\n})();\nlet fesm2015_SeriesDefaultsLabelsToComponentGenerated = /*@__PURE__*/ (() => {\n    class SeriesDefaultsLabelsToComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('seriesDefaults.labels.to', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    SeriesDefaultsLabelsToComponentGenerated.ɵfac = function SeriesDefaultsLabelsToComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    SeriesDefaultsLabelsToComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: SeriesDefaultsLabelsToComponentGenerated, inputs: { background: \"background\", border: \"border\", color: \"color\", content: \"content\", font: \"font\", format: \"format\", margin: \"margin\", padding: \"padding\", visible: \"visible\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return SeriesDefaultsLabelsToComponentGenerated;\n})();\nlet fesm2015_SeriesDefaultsLabelsToComponent = /*@__PURE__*/ (() => {\n    /**\n     * The `to` label configuration of the Chart series.\n     */\n    let SeriesDefaultsLabelsToComponent = class SeriesDefaultsLabelsToComponent extends fesm2015_SeriesDefaultsLabelsToComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n            this.markAsVisible();\n        }\n    };\n    SeriesDefaultsLabelsToComponent.ɵfac = function SeriesDefaultsLabelsToComponent_Factory(t) { return new (t || SeriesDefaultsLabelsToComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    SeriesDefaultsLabelsToComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: SeriesDefaultsLabelsToComponent, selectors: [[\"kendo-chart-series-defaults-labels-to\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function SeriesDefaultsLabelsToComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    SeriesDefaultsLabelsToComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], SeriesDefaultsLabelsToComponent);\n    return SeriesDefaultsLabelsToComponent;\n})();\nlet fesm2015_SeriesDefaultsNotesComponentGenerated = /*@__PURE__*/ (() => {\n    class SeriesDefaultsNotesComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('seriesDefaults.notes', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    SeriesDefaultsNotesComponentGenerated.ɵfac = function SeriesDefaultsNotesComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    SeriesDefaultsNotesComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: SeriesDefaultsNotesComponentGenerated, inputs: { line: \"line\", visual: \"visual\", icon: \"icon\", label: \"label\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return SeriesDefaultsNotesComponentGenerated;\n})();\nlet fesm2015_SeriesDefaultsNotesComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration of the [`seriesDefaults`]({% slug api_charts_seriesdefaultscomponent %}) notes.\n     */\n    let SeriesDefaultsNotesComponent = class SeriesDefaultsNotesComponent extends fesm2015_SeriesDefaultsNotesComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    SeriesDefaultsNotesComponent.ɵfac = function SeriesDefaultsNotesComponent_Factory(t) { return new (t || SeriesDefaultsNotesComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    SeriesDefaultsNotesComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: SeriesDefaultsNotesComponent, selectors: [[\"kendo-chart-series-defaults-notes\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function SeriesDefaultsNotesComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    SeriesDefaultsNotesComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], SeriesDefaultsNotesComponent);\n    return SeriesDefaultsNotesComponent;\n})();\nlet fesm2015_SeriesDefaultsNotesIconComponentGenerated = /*@__PURE__*/ (() => {\n    class SeriesDefaultsNotesIconComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('seriesDefaults.notes.icon', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    SeriesDefaultsNotesIconComponentGenerated.ɵfac = function SeriesDefaultsNotesIconComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    SeriesDefaultsNotesIconComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: SeriesDefaultsNotesIconComponentGenerated, inputs: { background: \"background\", border: \"border\", size: \"size\", type: \"type\", visible: \"visible\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return SeriesDefaultsNotesIconComponentGenerated;\n})();\nlet fesm2015_SeriesDefaultsNotesIconComponent = /*@__PURE__*/ (() => {\n    /**\n     * The icon of the notes.\n     */\n    let SeriesDefaultsNotesIconComponent = class SeriesDefaultsNotesIconComponent extends fesm2015_SeriesDefaultsNotesIconComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    SeriesDefaultsNotesIconComponent.ɵfac = function SeriesDefaultsNotesIconComponent_Factory(t) { return new (t || SeriesDefaultsNotesIconComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    SeriesDefaultsNotesIconComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: SeriesDefaultsNotesIconComponent, selectors: [[\"kendo-chart-series-defaults-notes-icon\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function SeriesDefaultsNotesIconComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    SeriesDefaultsNotesIconComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], SeriesDefaultsNotesIconComponent);\n    return SeriesDefaultsNotesIconComponent;\n})();\nlet fesm2015_SeriesDefaultsNotesLabelComponentGenerated = /*@__PURE__*/ (() => {\n    class SeriesDefaultsNotesLabelComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('seriesDefaults.notes.label', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    SeriesDefaultsNotesLabelComponentGenerated.ɵfac = function SeriesDefaultsNotesLabelComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    SeriesDefaultsNotesLabelComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: SeriesDefaultsNotesLabelComponentGenerated, inputs: { background: \"background\", border: \"border\", color: \"color\", content: \"content\", font: \"font\", format: \"format\", position: \"position\", rotation: \"rotation\", visible: \"visible\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return SeriesDefaultsNotesLabelComponentGenerated;\n})();\nlet fesm2015_SeriesDefaultsNotesLabelComponent = /*@__PURE__*/ (() => {\n    /**\n     * The label of the notes.\n     */\n    let SeriesDefaultsNotesLabelComponent = class SeriesDefaultsNotesLabelComponent extends fesm2015_SeriesDefaultsNotesLabelComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    SeriesDefaultsNotesLabelComponent.ɵfac = function SeriesDefaultsNotesLabelComponent_Factory(t) { return new (t || SeriesDefaultsNotesLabelComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    SeriesDefaultsNotesLabelComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: SeriesDefaultsNotesLabelComponent, selectors: [[\"kendo-chart-series-defaults-notes-label\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function SeriesDefaultsNotesLabelComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    SeriesDefaultsNotesLabelComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], SeriesDefaultsNotesLabelComponent);\n    return SeriesDefaultsNotesLabelComponent;\n})();\nlet fesm2015_SeriesDefaultsTooltipComponentGenerated = /*@__PURE__*/ (() => {\n    class SeriesDefaultsTooltipComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('seriesDefaults.tooltip', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    SeriesDefaultsTooltipComponentGenerated.ɵfac = function SeriesDefaultsTooltipComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    SeriesDefaultsTooltipComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: SeriesDefaultsTooltipComponentGenerated, inputs: { background: \"background\", border: \"border\", color: \"color\", font: \"font\", format: \"format\", padding: \"padding\", visible: \"visible\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return SeriesDefaultsTooltipComponentGenerated;\n})();\nlet fesm2015_SeriesDefaultsTooltipComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration options of the Chart series tooltip.\n     */\n    let SeriesDefaultsTooltipComponent = class SeriesDefaultsTooltipComponent extends fesm2015_SeriesDefaultsTooltipComponentGenerated {\n        // Place custom properties here.\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n            this.markAsVisible();\n        }\n    };\n    SeriesDefaultsTooltipComponent.ɵfac = function SeriesDefaultsTooltipComponent_Factory(t) { return new (t || SeriesDefaultsTooltipComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    SeriesDefaultsTooltipComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: SeriesDefaultsTooltipComponent, selectors: [[\"kendo-chart-series-defaults-tooltip\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function SeriesDefaultsTooltipComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    SeriesDefaultsTooltipComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], SeriesDefaultsTooltipComponent);\n    return SeriesDefaultsTooltipComponent;\n})();\nlet fesm2015_SeriesErrorBarsComponentGenerated = /*@__PURE__*/ (() => {\n    class SeriesErrorBarsComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('errorBars', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    SeriesErrorBarsComponentGenerated.ɵfac = function SeriesErrorBarsComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    SeriesErrorBarsComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: SeriesErrorBarsComponentGenerated, inputs: { color: \"color\", endCaps: \"endCaps\", line: \"line\", value: \"value\", visual: \"visual\", xValue: \"xValue\", yValue: \"yValue\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return SeriesErrorBarsComponentGenerated;\n})();\nlet fesm2015_SeriesErrorBarsComponent = /*@__PURE__*/ (() => {\n    /**\n     * The error bars of the Chart series\n     * ([see example]({% slug errorbars_chart_charts %})).\n     */\n    let SeriesErrorBarsComponent = class SeriesErrorBarsComponent extends fesm2015_SeriesErrorBarsComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    SeriesErrorBarsComponent.ɵfac = function SeriesErrorBarsComponent_Factory(t) { return new (t || SeriesErrorBarsComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    SeriesErrorBarsComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: SeriesErrorBarsComponent, selectors: [[\"kendo-chart-series-item-error-bars\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function SeriesErrorBarsComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    SeriesErrorBarsComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], SeriesErrorBarsComponent);\n    return SeriesErrorBarsComponent;\n})();\nlet fesm2015_SeriesExtremesComponentGenerated = /*@__PURE__*/ (() => {\n    class SeriesExtremesComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('extremes', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    SeriesExtremesComponentGenerated.ɵfac = function SeriesExtremesComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    SeriesExtremesComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: SeriesExtremesComponentGenerated, inputs: { background: \"background\", border: \"border\", rotation: \"rotation\", size: \"size\", type: \"type\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return SeriesExtremesComponentGenerated;\n})();\nlet fesm2015_SeriesExtremesComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration of the Chart series extremes.\n     * Applies to extreme outliers.\n     * For more information, refer to [`series.outliers`]({% slug api_charts_seriesitemcomponent %}#toc-outliers).\n     */\n    let SeriesExtremesComponent = class SeriesExtremesComponent extends fesm2015_SeriesExtremesComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    SeriesExtremesComponent.ɵfac = function SeriesExtremesComponent_Factory(t) { return new (t || SeriesExtremesComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    SeriesExtremesComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: SeriesExtremesComponent, selectors: [[\"kendo-chart-series-item-extremes\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function SeriesExtremesComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    SeriesExtremesComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], SeriesExtremesComponent);\n    return SeriesExtremesComponent;\n})();\nlet fesm2015_SeriesHighlightComponentGenerated = /*@__PURE__*/ (() => {\n    class SeriesHighlightComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('highlight', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    SeriesHighlightComponentGenerated.ɵfac = function SeriesHighlightComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    SeriesHighlightComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: SeriesHighlightComponentGenerated, inputs: { border: \"border\", color: \"color\", line: \"line\", markers: \"markers\", opacity: \"opacity\", toggle: \"toggle\", visible: \"visible\", visual: \"visual\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return SeriesHighlightComponentGenerated;\n})();\nlet fesm2015_SeriesHighlightComponent = /*@__PURE__*/ (() => {\n    /**\n     * The Chart series highlighting configuration options.\n     */\n    let SeriesHighlightComponent = class SeriesHighlightComponent extends fesm2015_SeriesHighlightComponentGenerated {\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    SeriesHighlightComponent.ɵfac = function SeriesHighlightComponent_Factory(t) { return new (t || SeriesHighlightComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    SeriesHighlightComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: SeriesHighlightComponent, selectors: [[\"kendo-chart-series-item-highlight\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function SeriesHighlightComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    SeriesHighlightComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], SeriesHighlightComponent);\n    return SeriesHighlightComponent;\n})();\nlet fesm2015_SeriesLabelsComponentGenerated = /*@__PURE__*/ (() => {\n    class SeriesLabelsComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('labels', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    SeriesLabelsComponentGenerated.ɵfac = function SeriesLabelsComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    SeriesLabelsComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: SeriesLabelsComponentGenerated, inputs: { align: \"align\", background: \"background\", border: \"border\", color: \"color\", content: \"content\", distance: \"distance\", font: \"font\", format: \"format\", margin: \"margin\", padding: \"padding\", position: \"position\", rotation: \"rotation\", visible: \"visible\", visual: \"visual\", from: \"from\", to: \"to\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return SeriesLabelsComponentGenerated;\n})();\nlet fesm2015_SeriesLabelsComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration of the Chart series label\n     * ([see example]({% slug labels_chart_charts %})).\n     */\n    let SeriesLabelsComponent = class SeriesLabelsComponent extends fesm2015_SeriesLabelsComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n            this.markAsVisible();\n        }\n    };\n    SeriesLabelsComponent.ɵfac = function SeriesLabelsComponent_Factory(t) { return new (t || SeriesLabelsComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    SeriesLabelsComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: SeriesLabelsComponent, selectors: [[\"kendo-chart-series-item-labels\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function SeriesLabelsComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    SeriesLabelsComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], SeriesLabelsComponent);\n    return SeriesLabelsComponent;\n})();\nlet fesm2015_SeriesLabelsFromComponentGenerated = /*@__PURE__*/ (() => {\n    class SeriesLabelsFromComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('labels.from', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    SeriesLabelsFromComponentGenerated.ɵfac = function SeriesLabelsFromComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    SeriesLabelsFromComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: SeriesLabelsFromComponentGenerated, inputs: { background: \"background\", border: \"border\", color: \"color\", content: \"content\", font: \"font\", format: \"format\", margin: \"margin\", padding: \"padding\", position: \"position\", visible: \"visible\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return SeriesLabelsFromComponentGenerated;\n})();\nlet fesm2015_SeriesLabelsFromComponent = /*@__PURE__*/ (() => {\n    /**\n     * The `from` label configuration of the Chart series.\n     */\n    let SeriesLabelsFromComponent = class SeriesLabelsFromComponent extends fesm2015_SeriesLabelsFromComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n            this.markAsVisible();\n        }\n    };\n    SeriesLabelsFromComponent.ɵfac = function SeriesLabelsFromComponent_Factory(t) { return new (t || SeriesLabelsFromComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    SeriesLabelsFromComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: SeriesLabelsFromComponent, selectors: [[\"kendo-chart-series-item-labels-from\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function SeriesLabelsFromComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    SeriesLabelsFromComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], SeriesLabelsFromComponent);\n    return SeriesLabelsFromComponent;\n})();\nlet fesm2015_SeriesLabelsToComponentGenerated = /*@__PURE__*/ (() => {\n    class SeriesLabelsToComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('labels.to', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    SeriesLabelsToComponentGenerated.ɵfac = function SeriesLabelsToComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    SeriesLabelsToComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: SeriesLabelsToComponentGenerated, inputs: { background: \"background\", border: \"border\", color: \"color\", content: \"content\", font: \"font\", format: \"format\", margin: \"margin\", padding: \"padding\", position: \"position\", visible: \"visible\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return SeriesLabelsToComponentGenerated;\n})();\nlet fesm2015_SeriesLabelsToComponent = /*@__PURE__*/ (() => {\n    /**\n     * The `to` label configuration of the Chart series.\n     */\n    let SeriesLabelsToComponent = class SeriesLabelsToComponent extends fesm2015_SeriesLabelsToComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n            this.markAsVisible();\n        }\n    };\n    SeriesLabelsToComponent.ɵfac = function SeriesLabelsToComponent_Factory(t) { return new (t || SeriesLabelsToComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    SeriesLabelsToComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: SeriesLabelsToComponent, selectors: [[\"kendo-chart-series-item-labels-to\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function SeriesLabelsToComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    SeriesLabelsToComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], SeriesLabelsToComponent);\n    return SeriesLabelsToComponent;\n})();\nlet fesm2015_SeriesMarkersComponentGenerated = /*@__PURE__*/ (() => {\n    class SeriesMarkersComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('markers', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    SeriesMarkersComponentGenerated.ɵfac = function SeriesMarkersComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    SeriesMarkersComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: SeriesMarkersComponentGenerated, inputs: { background: \"background\", border: \"border\", rotation: \"rotation\", size: \"size\", type: \"type\", visible: \"visible\", visual: \"visual\", from: \"from\", to: \"to\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return SeriesMarkersComponentGenerated;\n})();\nlet fesm2015_SeriesMarkersComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration of the Chart series marker.\n     *\n     * @example\n     * ```ts\n     * import { Component } from '@angular/core';\n     *\n     * _@Component({\n     *       selector: 'my-app',\n     *   template: `\n     *       <kendo-chart [categoryAxis]=\"{ categories: categories }\">\n     *           <kendo-chart-title text=\"Gross domestic product growth /GDP annual %/\"></kendo-chart-title>\n     *           <kendo-chart-legend position=\"bottom\" orientation=\"horizontal\"></kendo-chart-legend>\n     *           <kendo-chart-tooltip format=\"{0}%\"></kendo-chart-tooltip>\n     *           <kendo-chart-series>\n     *               <kendo-chart-series-item *ngFor=\"let item of series\"\n     *                   type=\"line\"\n     *                   style=\"smooth\"\n     *                   [data]=\"item.data\"\n     *                   [name]=\"item.name\"\n     *                   [markers]=\"item.markers\">\n     *               </kendo-chart-series-item>\n     *           </kendo-chart-series>\n     *       </kendo-chart>\n     *   `\n     * })\n     * export class AppComponent {\n     * public series: any[] = [{\n     *   name: \"India\",\n     *   data: [3.907, 7.943, 7.848, 9.284, 9.263, 9.801, 3.890, 8.238, 9.552, 6.855],\n     *   markers: {\n     *     background: 'red',\n     *     size: 20,\n     *     type: 'circle'\n     *   }\n     * }, {\n     *   name: \"Russian Federation\",\n     *   data: [4.743, 7.295, 7.175, 6.376, 8.153, 8.535, 5.247, -7.832, 4.3, 4.3],\n     *   markers: {\n     *     background: 'yellow',\n     *     size: 10,\n     *     type: 'square',\n     *     rotation: 45\n     *   }\n     * }, {\n     *   name: \"Germany\",\n     *   data: [0.010, -0.375, 1.161, 0.684, 3.7, 3.269, 1.083, -5.127, 3.690, 2.995],\n     *   markers: {\n     *     background: 'green',\n     *     size: 20,\n     *     type: 'triangle'\n     *   }\n     * },{\n     *   name: \"World\",\n     *   data: [1.988, 2.733, 3.994, 3.464, 4.001, 3.939, 1.333, -2.245, 4.339, 2.727],\n     *   markers: {\n     *     background: 'blue',\n     *     size: 10,\n     *     type: 'cross'\n     *   }\n     * }];\n     * public categories: number[] = [2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011];\n     * }\n     * ```\n     */\n    let SeriesMarkersComponent = class SeriesMarkersComponent extends fesm2015_SeriesMarkersComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    SeriesMarkersComponent.ɵfac = function SeriesMarkersComponent_Factory(t) { return new (t || SeriesMarkersComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    SeriesMarkersComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: SeriesMarkersComponent, selectors: [[\"kendo-chart-series-item-markers\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function SeriesMarkersComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    SeriesMarkersComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], SeriesMarkersComponent);\n    return SeriesMarkersComponent;\n})();\nlet fesm2015_SeriesNotesComponentGenerated = /*@__PURE__*/ (() => {\n    class SeriesNotesComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('notes', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    SeriesNotesComponentGenerated.ɵfac = function SeriesNotesComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    SeriesNotesComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: SeriesNotesComponentGenerated, inputs: { line: \"line\", position: \"position\", visual: \"visual\", icon: \"icon\", label: \"label\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return SeriesNotesComponentGenerated;\n})();\nlet fesm2015_SeriesNotesComponent = /*@__PURE__*/ (() => {\n    /**\n     * The series notes configuration\n     * ([see example]({% slug notes_chart_charts %})).\n     */\n    let SeriesNotesComponent = class SeriesNotesComponent extends fesm2015_SeriesNotesComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    SeriesNotesComponent.ɵfac = function SeriesNotesComponent_Factory(t) { return new (t || SeriesNotesComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    SeriesNotesComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: SeriesNotesComponent, selectors: [[\"kendo-chart-series-item-notes\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function SeriesNotesComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    SeriesNotesComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], SeriesNotesComponent);\n    return SeriesNotesComponent;\n})();\nlet fesm2015_SeriesNotesIconComponentGenerated = /*@__PURE__*/ (() => {\n    class SeriesNotesIconComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('notes.icon', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    SeriesNotesIconComponentGenerated.ɵfac = function SeriesNotesIconComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    SeriesNotesIconComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: SeriesNotesIconComponentGenerated, inputs: { background: \"background\", border: \"border\", size: \"size\", type: \"type\", visible: \"visible\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return SeriesNotesIconComponentGenerated;\n})();\nlet fesm2015_SeriesNotesIconComponent = /*@__PURE__*/ (() => {\n    /**\n     * The icon of the notes.\n     */\n    let SeriesNotesIconComponent = class SeriesNotesIconComponent extends fesm2015_SeriesNotesIconComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    SeriesNotesIconComponent.ɵfac = function SeriesNotesIconComponent_Factory(t) { return new (t || SeriesNotesIconComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    SeriesNotesIconComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: SeriesNotesIconComponent, selectors: [[\"kendo-chart-series-item-notes-icon\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function SeriesNotesIconComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    SeriesNotesIconComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], SeriesNotesIconComponent);\n    return SeriesNotesIconComponent;\n})();\nlet fesm2015_SeriesNotesLabelComponentGenerated = /*@__PURE__*/ (() => {\n    class SeriesNotesLabelComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('notes.label', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    SeriesNotesLabelComponentGenerated.ɵfac = function SeriesNotesLabelComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    SeriesNotesLabelComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: SeriesNotesLabelComponentGenerated, inputs: { background: \"background\", border: \"border\", color: \"color\", content: \"content\", font: \"font\", format: \"format\", position: \"position\", rotation: \"rotation\", visible: \"visible\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return SeriesNotesLabelComponentGenerated;\n})();\nlet fesm2015_SeriesNotesLabelComponent = /*@__PURE__*/ (() => {\n    /**\n     * The label of the notes.\n     */\n    let SeriesNotesLabelComponent = class SeriesNotesLabelComponent extends fesm2015_SeriesNotesLabelComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    SeriesNotesLabelComponent.ɵfac = function SeriesNotesLabelComponent_Factory(t) { return new (t || SeriesNotesLabelComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    SeriesNotesLabelComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: SeriesNotesLabelComponent, selectors: [[\"kendo-chart-series-item-notes-label\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function SeriesNotesLabelComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    SeriesNotesLabelComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], SeriesNotesLabelComponent);\n    return SeriesNotesLabelComponent;\n})();\nlet fesm2015_SeriesOutliersComponentGenerated = /*@__PURE__*/ (() => {\n    class SeriesOutliersComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('outliers', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    SeriesOutliersComponentGenerated.ɵfac = function SeriesOutliersComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    SeriesOutliersComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: SeriesOutliersComponentGenerated, inputs: { background: \"background\", border: \"border\", rotation: \"rotation\", size: \"size\", type: \"type\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return SeriesOutliersComponentGenerated;\n})();\nlet fesm2015_SeriesOutliersComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration of the Chart series outliers.\n     * Applies to mild outliers.\n     * For more information, refer to the [`series.extremes`]({% slug api_charts_seriesitemcomponent %}#toc-extremes) option.\n     */\n    let SeriesOutliersComponent = class SeriesOutliersComponent extends fesm2015_SeriesOutliersComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    SeriesOutliersComponent.ɵfac = function SeriesOutliersComponent_Factory(t) { return new (t || SeriesOutliersComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    SeriesOutliersComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: SeriesOutliersComponent, selectors: [[\"kendo-chart-series-item-outliers\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function SeriesOutliersComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    SeriesOutliersComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], SeriesOutliersComponent);\n    return SeriesOutliersComponent;\n})();\nlet fesm2015_TitleComponentGenerated = /*@__PURE__*/ (() => {\n    class TitleComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('title', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    TitleComponentGenerated.ɵfac = function TitleComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    TitleComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: TitleComponentGenerated, inputs: { align: \"align\", background: \"background\", border: \"border\", color: \"color\", font: \"font\", margin: \"margin\", padding: \"padding\", position: \"position\", text: \"text\", visible: \"visible\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return TitleComponentGenerated;\n})();\nlet fesm2015_TitleComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration options of the Chart title or text\n     * ([see example]({% slug title_chart_charts %})).\n     *\n     * @example\n     * ```ts-preview\n     * import { Component } from '@angular/core';\n     *\n     * _@Component({\n     *    selector: 'my-app',\n     *    template: `\n     *        <kendo-chart [categoryAxis]=\"{ categories: categories }\">\n     *            <kendo-chart-title text=\"Gross domestic product growth /GDP annual %/\"></kendo-chart-title>\n     *            <kendo-chart-legend\n     *              position=\"bottom\"\n     *              orientation=\"horizontal\"\n     *              align=\"end\"\n     *              background=\"rgba(255, 0, 0, 0.1)\"\n     *              [border]=\"borderOptions\"\n     *              [margin]=\"10\"\n     *              [padding]=\"10\"\n     *              [width]=\"150\"\n     *              [offsetX]=\"11\"\n     *              [offsetY]=\"-103\"\n     *              [reverse]=\"true\"\n     *              [visible]=\"isVisible\"\n     *              ></kendo-chart-legend>\n     *            <kendo-chart-tooltip format=\"{0}%\"></kendo-chart-tooltip>\n     *            <kendo-chart-series>\n     *                <kendo-chart-series-item *ngFor=\"let item of series\"\n     *                    type=\"line\" style=\"smooth\" [data]=\"item.data\" [name]=\"item.name\">\n     *                </kendo-chart-series-item>\n     *            </kendo-chart-series>\n     *        </kendo-chart>\n     *        <br /><br />\n     *        <button class=\"k-button\" (click)=\"isVisible=!isVisible\">Toggle Legend</button>\n     *    `\n     * })\n     * export class AppComponent {\n     *  public isVisible = true;\n     *  public borderOptions = {\n     *    color: \"rgba(255, 0, 0, 0.8)\",\n     *    dashType: 'dash',\n     *    width: 2\n     *  };\n     *\n     * public series: any[] = [{\n     *   name: \"India\",\n     *   data: [3.907, 7.943, 7.848, 9.284, 9.263, 9.801, 3.890, 8.238, 9.552, 6.855]\n     * }, {\n     *   name: \"Russian Federation\",\n     *   data: [4.743, 7.295, 7.175, 6.376, 8.153, 8.535, 5.247, -7.832, 4.3, 4.3]\n     * }, {\n     *   name: \"Germany\",\n     *   data: [0.010, -0.375, 1.161, 0.684, 3.7, 3.269, 1.083, -5.127, 3.690, 2.995]\n     * },{\n     *   name: \"World\",\n     *   data: [1.988, 2.733, 3.994, 3.464, 4.001, 3.939, 1.333, -2.245, 4.339, 2.727]\n     * }];\n     *  public categories: number[] = [2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011];\n     * }\n     * ```\n     */\n    let TitleComponent = class TitleComponent extends fesm2015_TitleComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    TitleComponent.ɵfac = function TitleComponent_Factory(t) { return new (t || TitleComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    TitleComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: TitleComponent, selectors: [[\"kendo-chart-title\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function TitleComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    TitleComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], TitleComponent);\n    return TitleComponent;\n})();\nlet fesm2015_TooltipComponentGenerated = /*@__PURE__*/ (() => {\n    class TooltipComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('tooltip', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    TooltipComponentGenerated.ɵfac = function TooltipComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    TooltipComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: TooltipComponentGenerated, inputs: { background: \"background\", border: \"border\", color: \"color\", font: \"font\", format: \"format\", opacity: \"opacity\", padding: \"padding\", shared: \"shared\", visible: \"visible\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return TooltipComponentGenerated;\n})();\nlet fesm2015_TooltipComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration options of the Chart series tooltip\n     * ([see example]({% slug tooltips_chart_charts %})).\n     */\n    let TooltipComponent = class TooltipComponent extends fesm2015_TooltipComponentGenerated {\n        constructor(configurationService, templateService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n            this.templateService = templateService;\n            this.markAsVisible();\n        }\n        ngAfterContentChecked() {\n            this.templateService.setTemplate(this.seriesTooltipTemplate ? this.seriesTooltipTemplate.templateRef : null);\n            this.templateService.setSharedTemplate(this.sharedTooltipTemplate ? this.sharedTooltipTemplate.templateRef : null);\n        }\n    };\n    TooltipComponent.ɵfac = function TooltipComponent_Factory(t) { return new (t || TooltipComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_TooltipTemplateService)); };\n    TooltipComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: TooltipComponent, selectors: [[\"kendo-chart-tooltip\"]], contentQueries: function TooltipComponent_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                core[\"Ib\" /* ɵɵcontentQuery */](dirIndex, fesm2015_SeriesTooltipTemplateDirective, true);\n                core[\"Ib\" /* ɵɵcontentQuery */](dirIndex, fesm2015_SharedTooltipTemplateDirective, true);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx.seriesTooltipTemplate = _t.first);\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx.sharedTooltipTemplate = _t.first);\n            }\n        }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function TooltipComponent_Template(rf, ctx) { }, encapsulation: 2 });\n    TooltipComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService,\n            fesm2015_TooltipTemplateService])\n    ], TooltipComponent);\n    return TooltipComponent;\n})();\nlet fesm2015_ValueAxisItemComponentGenerated = /*@__PURE__*/ (() => {\n    class ValueAxisItemComponentGenerated extends fesm2015_CollectionItemComponent {\n        constructor(configurationService, collectionService) {\n            super(configurationService, collectionService);\n            this.configurationService = configurationService;\n            this.collectionService = collectionService;\n        }\n    }\n    ValueAxisItemComponentGenerated.ɵfac = function ValueAxisItemComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    ValueAxisItemComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: ValueAxisItemComponentGenerated, inputs: { axisCrossingValue: \"axisCrossingValue\", background: \"background\", color: \"color\", line: \"line\", majorGridLines: \"majorGridLines\", majorTicks: \"majorTicks\", majorUnit: \"majorUnit\", max: \"max\", min: \"min\", minorGridLines: \"minorGridLines\", minorTicks: \"minorTicks\", minorUnit: \"minorUnit\", name: \"name\", narrowRange: \"narrowRange\", pane: \"pane\", plotBands: \"plotBands\", reverse: \"reverse\", type: \"type\", visible: \"visible\", crosshair: \"crosshair\", labels: \"labels\", notes: \"notes\", title: \"title\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return ValueAxisItemComponentGenerated;\n})();\nlet fesm2015_ValueAxisItemComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration component for a value axis.\n     */\n    let ValueAxisItemComponent = class ValueAxisItemComponent extends fesm2015_ValueAxisItemComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService, collectionService) {\n            super(configurationService, collectionService);\n            this.configurationService = configurationService;\n            this.collectionService = collectionService;\n        }\n    };\n    ValueAxisItemComponent.ɵfac = function ValueAxisItemComponent_Factory(t) { return new (t || ValueAxisItemComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_CollectionService)); };\n    ValueAxisItemComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: ValueAxisItemComponent, selectors: [[\"kendo-chart-value-axis-item\"]], features: [core[\"Bb\" /* ɵɵProvidersFeature */]([fesm2015_ConfigurationService]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function ValueAxisItemComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    ValueAxisItemComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService,\n            fesm2015_CollectionService])\n    ], ValueAxisItemComponent);\n    return ValueAxisItemComponent;\n})();\nlet fesm2015_ValueAxisComponentGenerated = /*@__PURE__*/ (() => {\n    class ValueAxisComponentGenerated extends fesm2015_CollectionComponent {\n        constructor(configurationService, collectionService) {\n            super('valueAxis', configurationService, collectionService);\n            this.configurationService = configurationService;\n            this.collectionService = collectionService;\n        }\n    }\n    ValueAxisComponentGenerated.ɵfac = function ValueAxisComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    ValueAxisComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: ValueAxisComponentGenerated, contentQueries: function ValueAxisComponentGenerated_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                core[\"Ib\" /* ɵɵcontentQuery */](dirIndex, fesm2015_ValueAxisItemComponent, false);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx.children = _t);\n            }\n        }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return ValueAxisComponentGenerated;\n})();\nlet fesm2015_ValueAxisComponent = /*@__PURE__*/ (() => {\n    /**\n     * A collection of one or more value axis configuration components.\n     *\n     * @example\n     * ```ts\n     * import { Component } from '@angular/core';\n     *\n     * _@Component({\n     *   selector: 'my-app',\n     *   template: `\n     *     <kendo-chart>\n     *       <kendo-chart-value-axis>\n     *         <kendo-chart-value-axis-item>\n     *         </kendo-chart-value-axis-item>\n     *         <kendo-chart-value-axis-item name=\"secondAxis\">\n     *         </kendo-chart-value-axis-item>\n     *       </kendo-chart-value-axis>\n     *       <kendo-chart-series>\n     *         <kendo-chart-series-item type=\"line\" [data]=\"[1, 2, 3]\">\n     *         </kendo-chart-series-item>\n     *         <kendo-chart-series-item type=\"line\" [data]=\"[0.1, 0.2, 0.3]\"\n     *                                  axis=\"secondAxis\">\n     *         </kendo-chart-series-item>\n     *       </kendo-chart-series>\n     *     </kendo-chart>\n     *   `\n     * })\n     * class AppComponent {\n     * }\n     *\n     * ```\n     */\n    let ValueAxisComponent = class ValueAxisComponent extends fesm2015_ValueAxisComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService, collectionService) {\n            super(configurationService, collectionService);\n            this.configurationService = configurationService;\n            this.collectionService = collectionService;\n        }\n    };\n    ValueAxisComponent.ɵfac = function ValueAxisComponent_Factory(t) { return new (t || ValueAxisComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_CollectionService)); };\n    ValueAxisComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: ValueAxisComponent, selectors: [[\"kendo-chart-value-axis\"]], features: [core[\"Bb\" /* ɵɵProvidersFeature */]([fesm2015_CollectionService]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function ValueAxisComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    ValueAxisComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService,\n            fesm2015_CollectionService])\n    ], ValueAxisComponent);\n    return ValueAxisComponent;\n})();\nlet fesm2015_ValueAxisCrosshairComponentGenerated = /*@__PURE__*/ (() => {\n    class ValueAxisCrosshairComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('crosshair', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    ValueAxisCrosshairComponentGenerated.ɵfac = function ValueAxisCrosshairComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    ValueAxisCrosshairComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: ValueAxisCrosshairComponentGenerated, inputs: { color: \"color\", opacity: \"opacity\", visible: \"visible\", width: \"width\", tooltip: \"tooltip\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return ValueAxisCrosshairComponentGenerated;\n})();\nlet fesm2015_ValueAxisCrosshairComponent = /*@__PURE__*/ (() => {\n    /**\n     * The crosshair configuration options ([see example]({% slug crosshairs_chart_charts %})).\n     */\n    let ValueAxisCrosshairComponent = class ValueAxisCrosshairComponent extends fesm2015_ValueAxisCrosshairComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n            this.markAsVisible();\n        }\n    };\n    ValueAxisCrosshairComponent.ɵfac = function ValueAxisCrosshairComponent_Factory(t) { return new (t || ValueAxisCrosshairComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    ValueAxisCrosshairComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: ValueAxisCrosshairComponent, selectors: [[\"kendo-chart-value-axis-item-crosshair\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function ValueAxisCrosshairComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    ValueAxisCrosshairComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], ValueAxisCrosshairComponent);\n    return ValueAxisCrosshairComponent;\n})();\nlet fesm2015_ValueAxisCrosshairTooltipComponentGenerated = /*@__PURE__*/ (() => {\n    class ValueAxisCrosshairTooltipComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('crosshair.tooltip', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    ValueAxisCrosshairTooltipComponentGenerated.ɵfac = function ValueAxisCrosshairTooltipComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    ValueAxisCrosshairTooltipComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: ValueAxisCrosshairTooltipComponentGenerated, inputs: { background: \"background\", border: \"border\", color: \"color\", font: \"font\", format: \"format\", padding: \"padding\", visible: \"visible\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return ValueAxisCrosshairTooltipComponentGenerated;\n})();\nlet fesm2015_ValueAxisCrosshairTooltipComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration options of the crosshair tooltip ([see example]({% slug crosshairs_chart_charts %})).\n     * The crosshair tooltip is displayed when the `visible` option is set to `true`.\n     */\n    let ValueAxisCrosshairTooltipComponent = class ValueAxisCrosshairTooltipComponent extends fesm2015_ValueAxisCrosshairTooltipComponentGenerated {\n        // Place custom properties here.\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n            this.markAsVisible();\n        }\n    };\n    ValueAxisCrosshairTooltipComponent.ɵfac = function ValueAxisCrosshairTooltipComponent_Factory(t) { return new (t || ValueAxisCrosshairTooltipComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    ValueAxisCrosshairTooltipComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: ValueAxisCrosshairTooltipComponent, selectors: [[\"kendo-chart-value-axis-item-crosshair-tooltip\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function ValueAxisCrosshairTooltipComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    ValueAxisCrosshairTooltipComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], ValueAxisCrosshairTooltipComponent);\n    return ValueAxisCrosshairTooltipComponent;\n})();\nlet fesm2015_ValueAxisLabelsComponentGenerated = /*@__PURE__*/ (() => {\n    class ValueAxisLabelsComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('labels', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    ValueAxisLabelsComponentGenerated.ɵfac = function ValueAxisLabelsComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    ValueAxisLabelsComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: ValueAxisLabelsComponentGenerated, inputs: { background: \"background\", border: \"border\", color: \"color\", content: \"content\", font: \"font\", format: \"format\", margin: \"margin\", mirror: \"mirror\", padding: \"padding\", position: \"position\", rotation: \"rotation\", skip: \"skip\", step: \"step\", visible: \"visible\", visual: \"visual\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return ValueAxisLabelsComponentGenerated;\n})();\nlet fesm2015_ValueAxisLabelsComponent = /*@__PURE__*/ (() => {\n    /**\n     * The axis labels configuration.\n     */\n    let ValueAxisLabelsComponent = class ValueAxisLabelsComponent extends fesm2015_ValueAxisLabelsComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    ValueAxisLabelsComponent.ɵfac = function ValueAxisLabelsComponent_Factory(t) { return new (t || ValueAxisLabelsComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    ValueAxisLabelsComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: ValueAxisLabelsComponent, selectors: [[\"kendo-chart-value-axis-item-labels\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function ValueAxisLabelsComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    ValueAxisLabelsComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], ValueAxisLabelsComponent);\n    return ValueAxisLabelsComponent;\n})();\nlet fesm2015_ValueAxisNotesComponentGenerated = /*@__PURE__*/ (() => {\n    class ValueAxisNotesComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('notes', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    ValueAxisNotesComponentGenerated.ɵfac = function ValueAxisNotesComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    ValueAxisNotesComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: ValueAxisNotesComponentGenerated, inputs: { data: \"data\", line: \"line\", position: \"position\", visual: \"visual\", icon: \"icon\", label: \"label\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return ValueAxisNotesComponentGenerated;\n})();\nlet fesm2015_ValueAxisNotesComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration of the value axis notes ([see example]({% slug notes_chart_charts %}#toc-axis-notes)).\n     */\n    let ValueAxisNotesComponent = class ValueAxisNotesComponent extends fesm2015_ValueAxisNotesComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    ValueAxisNotesComponent.ɵfac = function ValueAxisNotesComponent_Factory(t) { return new (t || ValueAxisNotesComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    ValueAxisNotesComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: ValueAxisNotesComponent, selectors: [[\"kendo-chart-value-axis-item-notes\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function ValueAxisNotesComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    ValueAxisNotesComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], ValueAxisNotesComponent);\n    return ValueAxisNotesComponent;\n})();\nlet fesm2015_ValueAxisNotesIconComponentGenerated = /*@__PURE__*/ (() => {\n    class ValueAxisNotesIconComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('notes.icon', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    ValueAxisNotesIconComponentGenerated.ɵfac = function ValueAxisNotesIconComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    ValueAxisNotesIconComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: ValueAxisNotesIconComponentGenerated, inputs: { background: \"background\", border: \"border\", size: \"size\", type: \"type\", visible: \"visible\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return ValueAxisNotesIconComponentGenerated;\n})();\nlet fesm2015_ValueAxisNotesIconComponent = /*@__PURE__*/ (() => {\n    /**\n     * The icon of the notes.\n     */\n    let ValueAxisNotesIconComponent = class ValueAxisNotesIconComponent extends fesm2015_ValueAxisNotesIconComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    ValueAxisNotesIconComponent.ɵfac = function ValueAxisNotesIconComponent_Factory(t) { return new (t || ValueAxisNotesIconComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    ValueAxisNotesIconComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: ValueAxisNotesIconComponent, selectors: [[\"kendo-chart-value-axis-item-notes-icon\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function ValueAxisNotesIconComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    ValueAxisNotesIconComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], ValueAxisNotesIconComponent);\n    return ValueAxisNotesIconComponent;\n})();\nlet fesm2015_ValueAxisNotesLabelComponentGenerated = /*@__PURE__*/ (() => {\n    class ValueAxisNotesLabelComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('notes.label', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    ValueAxisNotesLabelComponentGenerated.ɵfac = function ValueAxisNotesLabelComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    ValueAxisNotesLabelComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: ValueAxisNotesLabelComponentGenerated, inputs: { background: \"background\", border: \"border\", color: \"color\", content: \"content\", font: \"font\", format: \"format\", position: \"position\", rotation: \"rotation\", visible: \"visible\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return ValueAxisNotesLabelComponentGenerated;\n})();\nlet fesm2015_ValueAxisNotesLabelComponent = /*@__PURE__*/ (() => {\n    /**\n     * The label of the notes.\n     */\n    let ValueAxisNotesLabelComponent = class ValueAxisNotesLabelComponent extends fesm2015_ValueAxisNotesLabelComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    ValueAxisNotesLabelComponent.ɵfac = function ValueAxisNotesLabelComponent_Factory(t) { return new (t || ValueAxisNotesLabelComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    ValueAxisNotesLabelComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: ValueAxisNotesLabelComponent, selectors: [[\"kendo-chart-value-axis-item-notes-label\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function ValueAxisNotesLabelComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    ValueAxisNotesLabelComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], ValueAxisNotesLabelComponent);\n    return ValueAxisNotesLabelComponent;\n})();\nlet fesm2015_ValueAxisTitleComponentGenerated = /*@__PURE__*/ (() => {\n    class ValueAxisTitleComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('title', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    ValueAxisTitleComponentGenerated.ɵfac = function ValueAxisTitleComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    ValueAxisTitleComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: ValueAxisTitleComponentGenerated, inputs: { background: \"background\", border: \"border\", color: \"color\", font: \"font\", margin: \"margin\", padding: \"padding\", position: \"position\", rotation: \"rotation\", text: \"text\", visible: \"visible\", visual: \"visual\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return ValueAxisTitleComponentGenerated;\n})();\nlet fesm2015_ValueAxisTitleComponent = /*@__PURE__*/ (() => {\n    /**\n     * The title configuration of the value axis.\n     */\n    let ValueAxisTitleComponent = class ValueAxisTitleComponent extends fesm2015_ValueAxisTitleComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    ValueAxisTitleComponent.ɵfac = function ValueAxisTitleComponent_Factory(t) { return new (t || ValueAxisTitleComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    ValueAxisTitleComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: ValueAxisTitleComponent, selectors: [[\"kendo-chart-value-axis-item-title\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function ValueAxisTitleComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    ValueAxisTitleComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], ValueAxisTitleComponent);\n    return ValueAxisTitleComponent;\n})();\nlet fesm2015_XAxisItemComponentGenerated = /*@__PURE__*/ (() => {\n    class XAxisItemComponentGenerated extends fesm2015_CollectionItemComponent {\n        constructor(configurationService, collectionService, intl, localeId) {\n            super(configurationService, collectionService);\n            this.configurationService = configurationService;\n            this.collectionService = collectionService;\n            this.notifyChanges({ weekStartDay: intl.firstDay(localeId) });\n        }\n    }\n    XAxisItemComponentGenerated.ɵfac = function XAxisItemComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    XAxisItemComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: XAxisItemComponentGenerated, inputs: { axisCrossingValue: \"axisCrossingValue\", background: \"background\", baseUnit: \"baseUnit\", color: \"color\", line: \"line\", majorGridLines: \"majorGridLines\", majorTicks: \"majorTicks\", majorUnit: \"majorUnit\", max: \"max\", min: \"min\", minorGridLines: \"minorGridLines\", minorTicks: \"minorTicks\", minorUnit: \"minorUnit\", name: \"name\", narrowRange: \"narrowRange\", pane: \"pane\", plotBands: \"plotBands\", reverse: \"reverse\", startAngle: \"startAngle\", type: \"type\", visible: \"visible\", weekStartDay: \"weekStartDay\", crosshair: \"crosshair\", labels: \"labels\", notes: \"notes\", title: \"title\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return XAxisItemComponentGenerated;\n})();\nlet fesm2015_XAxisItemComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration component for an X axis\n     * ([see example]({% slug api_charts_xaxiscomponent %})).\n     */\n    let XAxisItemComponent = class XAxisItemComponent extends fesm2015_XAxisItemComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService, collectionService, intl, localeId) {\n            super(configurationService, collectionService, intl, localeId);\n            this.configurationService = configurationService;\n            this.collectionService = collectionService;\n            this.intl = intl;\n        }\n    };\n    XAxisItemComponent.ɵfac = function XAxisItemComponent_Factory(t) { return new (t || XAxisItemComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_CollectionService), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_IntlService), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"w\" /* LOCALE_ID */])); };\n    XAxisItemComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: XAxisItemComponent, selectors: [[\"kendo-chart-x-axis-item\"]], features: [core[\"Bb\" /* ɵɵProvidersFeature */]([fesm2015_ConfigurationService]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function XAxisItemComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    XAxisItemComponent = __decorate([__param(3, Object(core[\"q\" /* Inject */])(core[\"w\" /* LOCALE_ID */])),\n        __metadata(\"design:paramtypes\", [fesm2015_ConfigurationService,\n            fesm2015_CollectionService,\n            fesm2015_IntlService, String])\n    ], XAxisItemComponent);\n    return XAxisItemComponent;\n})();\nlet fesm2015_XAxisComponentGenerated = /*@__PURE__*/ (() => {\n    class XAxisComponentGenerated extends fesm2015_CollectionComponent {\n        constructor(configurationService, collectionService) {\n            super('xAxis', configurationService, collectionService);\n            this.configurationService = configurationService;\n            this.collectionService = collectionService;\n        }\n    }\n    XAxisComponentGenerated.ɵfac = function XAxisComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    XAxisComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: XAxisComponentGenerated, contentQueries: function XAxisComponentGenerated_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                core[\"Ib\" /* ɵɵcontentQuery */](dirIndex, fesm2015_XAxisItemComponent, false);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx.children = _t);\n            }\n        }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return XAxisComponentGenerated;\n})();\nlet fesm2015_XAxisComponent = /*@__PURE__*/ (() => {\n    /**\n     * A collection of one or more X-axis configuration components.\n     *\n     * @example\n     * ```ts\n     * import { Component } from '@angular/core';\n     *\n     * _@Component({\n     *  selector: 'my-app',\n     * template: `\n     *   <kendo-chart>\n     *     <kendo-chart-x-axis>\n     *       <kendo-chart-x-axis-item\n     *         [background]=\"'rgba(100, 100, 100, 0.2)'\"\n     *         [color]=\"'red'\"\n     *         [notes]=\"notesConfig\"\n     *         [crosshair]=\"crosshairConfig\">\n     *       </kendo-chart-x-axis-item>\n     *       <kendo-chart-x-axis-item name=\"secondAxis\">\n     *       </kendo-chart-x-axis-item>\n     *     </kendo-chart-x-axis>\n     *     <kendo-chart-series>\n     *       <kendo-chart-series-item type=\"scatter\" [data]=\"[[1, 2]]\">\n     *       </kendo-chart-series-item>\n     *       <kendo-chart-series-item type=\"scatter\" [data]=\"[[0.1, 0.2]]\"\n     *                                xAxis=\"secondAxis\">\n     *       </kendo-chart-series-item>\n     *     </kendo-chart-series>\n     *   </kendo-chart>\n     * `\n     * })\n     * export class AppComponent {\n     * public notesConfig = {\n     *   data: [{\n     *       value: 0.2,\n     *       text: \"foo\"\n     *     }, {\n     *       value: 0.8,\n     *       text: \"bar\"\n     *     }],\n     *   label: {\n     *     content: (args: any) => args.dataItem.text,\n     *     background: 'red',\n     *     color: 'white'\n     *   },\n     *   line: {\n     *     color: 'blue',\n     *     dashType: 'dash',\n     *     length: 150,\n     *     width: 2\n     *   },\n     *   position: 'top'\n     * };\n     *\n     * public crosshairConfig = {\n     *   color: 'green',\n     *   opacity: 0.8,\n     *   visible: true,\n     *   width: 3\n     * };\n     * }\n     *\n     * ```\n     */\n    let XAxisComponent = class XAxisComponent extends fesm2015_XAxisComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService, collectionService) {\n            super(configurationService, collectionService);\n            this.configurationService = configurationService;\n            this.collectionService = collectionService;\n        }\n    };\n    XAxisComponent.ɵfac = function XAxisComponent_Factory(t) { return new (t || XAxisComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_CollectionService)); };\n    XAxisComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: XAxisComponent, selectors: [[\"kendo-chart-x-axis\"]], features: [core[\"Bb\" /* ɵɵProvidersFeature */]([fesm2015_CollectionService]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function XAxisComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    XAxisComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService,\n            fesm2015_CollectionService])\n    ], XAxisComponent);\n    return XAxisComponent;\n})();\nlet fesm2015_XAxisCrosshairComponentGenerated = /*@__PURE__*/ (() => {\n    class XAxisCrosshairComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('crosshair', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    XAxisCrosshairComponentGenerated.ɵfac = function XAxisCrosshairComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    XAxisCrosshairComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: XAxisCrosshairComponentGenerated, inputs: { color: \"color\", opacity: \"opacity\", visible: \"visible\", width: \"width\", tooltip: \"tooltip\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return XAxisCrosshairComponentGenerated;\n})();\nlet fesm2015_XAxisCrosshairComponent = /*@__PURE__*/ (() => {\n    /**\n     * The crosshair configuration options\n     * ([see example]({% slug api_charts_xaxiscomponent %})).\n     */\n    let XAxisCrosshairComponent = class XAxisCrosshairComponent extends fesm2015_XAxisCrosshairComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n            this.markAsVisible();\n        }\n    };\n    XAxisCrosshairComponent.ɵfac = function XAxisCrosshairComponent_Factory(t) { return new (t || XAxisCrosshairComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    XAxisCrosshairComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: XAxisCrosshairComponent, selectors: [[\"kendo-chart-x-axis-item-crosshair\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function XAxisCrosshairComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    XAxisCrosshairComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], XAxisCrosshairComponent);\n    return XAxisCrosshairComponent;\n})();\nlet fesm2015_XAxisCrosshairTooltipComponentGenerated = /*@__PURE__*/ (() => {\n    class XAxisCrosshairTooltipComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('crosshair.tooltip', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    XAxisCrosshairTooltipComponentGenerated.ɵfac = function XAxisCrosshairTooltipComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    XAxisCrosshairTooltipComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: XAxisCrosshairTooltipComponentGenerated, inputs: { background: \"background\", border: \"border\", color: \"color\", font: \"font\", format: \"format\", padding: \"padding\", visible: \"visible\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return XAxisCrosshairTooltipComponentGenerated;\n})();\nlet fesm2015_XAxisCrosshairTooltipComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration options of the crosshair tooltip.\n     * The crosshair tooltip is displayed when the `visible` option is set to `true`.\n     */\n    let XAxisCrosshairTooltipComponent = class XAxisCrosshairTooltipComponent extends fesm2015_XAxisCrosshairTooltipComponentGenerated {\n        // Place custom properties here.\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n            this.markAsVisible();\n        }\n    };\n    XAxisCrosshairTooltipComponent.ɵfac = function XAxisCrosshairTooltipComponent_Factory(t) { return new (t || XAxisCrosshairTooltipComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    XAxisCrosshairTooltipComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: XAxisCrosshairTooltipComponent, selectors: [[\"kendo-chart-x-axis-item-crosshair-tooltip\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function XAxisCrosshairTooltipComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    XAxisCrosshairTooltipComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], XAxisCrosshairTooltipComponent);\n    return XAxisCrosshairTooltipComponent;\n})();\nlet fesm2015_XAxisLabelsComponentGenerated = /*@__PURE__*/ (() => {\n    class XAxisLabelsComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('labels', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    XAxisLabelsComponentGenerated.ɵfac = function XAxisLabelsComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    XAxisLabelsComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: XAxisLabelsComponentGenerated, inputs: { background: \"background\", border: \"border\", color: \"color\", content: \"content\", culture: \"culture\", dateFormats: \"dateFormats\", font: \"font\", format: \"format\", margin: \"margin\", mirror: \"mirror\", padding: \"padding\", position: \"position\", rotation: \"rotation\", skip: \"skip\", step: \"step\", visible: \"visible\", visual: \"visual\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return XAxisLabelsComponentGenerated;\n})();\nlet fesm2015_XAxisLabelsComponent = /*@__PURE__*/ (() => {\n    /**\n     * The axis labels configuration.\n     */\n    let XAxisLabelsComponent = class XAxisLabelsComponent extends fesm2015_XAxisLabelsComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    XAxisLabelsComponent.ɵfac = function XAxisLabelsComponent_Factory(t) { return new (t || XAxisLabelsComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    XAxisLabelsComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: XAxisLabelsComponent, selectors: [[\"kendo-chart-x-axis-item-labels\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function XAxisLabelsComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    XAxisLabelsComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], XAxisLabelsComponent);\n    return XAxisLabelsComponent;\n})();\nlet fesm2015_XAxisNotesComponentGenerated = /*@__PURE__*/ (() => {\n    class XAxisNotesComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('notes', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    XAxisNotesComponentGenerated.ɵfac = function XAxisNotesComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    XAxisNotesComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: XAxisNotesComponentGenerated, inputs: { data: \"data\", line: \"line\", position: \"position\", visual: \"visual\", icon: \"icon\", label: \"label\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return XAxisNotesComponentGenerated;\n})();\nlet fesm2015_XAxisNotesComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration of the X-axis notes.\n     * For an example on the basic usage of the XAxisNotesComponent,\n     * refer to the [demo on the XAxisComponent]({% slug api_charts_xaxiscomponent %})\n     * or to the documentation about the\n     * [axis notes]({% slug notes_chart_charts %}#toc-axis-notes).\n     */\n    let XAxisNotesComponent = class XAxisNotesComponent extends fesm2015_XAxisNotesComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    XAxisNotesComponent.ɵfac = function XAxisNotesComponent_Factory(t) { return new (t || XAxisNotesComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    XAxisNotesComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: XAxisNotesComponent, selectors: [[\"kendo-chart-x-axis-item-notes\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function XAxisNotesComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    XAxisNotesComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], XAxisNotesComponent);\n    return XAxisNotesComponent;\n})();\nlet fesm2015_XAxisNotesIconComponentGenerated = /*@__PURE__*/ (() => {\n    class XAxisNotesIconComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('notes.icon', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    XAxisNotesIconComponentGenerated.ɵfac = function XAxisNotesIconComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    XAxisNotesIconComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: XAxisNotesIconComponentGenerated, inputs: { background: \"background\", border: \"border\", size: \"size\", type: \"type\", visible: \"visible\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return XAxisNotesIconComponentGenerated;\n})();\nlet fesm2015_XAxisNotesIconComponent = /*@__PURE__*/ (() => {\n    /**\n     * The icon of the notes.\n     */\n    let XAxisNotesIconComponent = class XAxisNotesIconComponent extends fesm2015_XAxisNotesIconComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    XAxisNotesIconComponent.ɵfac = function XAxisNotesIconComponent_Factory(t) { return new (t || XAxisNotesIconComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    XAxisNotesIconComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: XAxisNotesIconComponent, selectors: [[\"kendo-chart-x-axis-item-notes-icon\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function XAxisNotesIconComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    XAxisNotesIconComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], XAxisNotesIconComponent);\n    return XAxisNotesIconComponent;\n})();\nlet fesm2015_XAxisNotesLabelComponentGenerated = /*@__PURE__*/ (() => {\n    class XAxisNotesLabelComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('notes.label', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    XAxisNotesLabelComponentGenerated.ɵfac = function XAxisNotesLabelComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    XAxisNotesLabelComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: XAxisNotesLabelComponentGenerated, inputs: { background: \"background\", border: \"border\", color: \"color\", content: \"content\", font: \"font\", format: \"format\", position: \"position\", rotation: \"rotation\", visible: \"visible\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return XAxisNotesLabelComponentGenerated;\n})();\nlet fesm2015_XAxisNotesLabelComponent = /*@__PURE__*/ (() => {\n    /**\n     * The label of the notes.\n     */\n    let XAxisNotesLabelComponent = class XAxisNotesLabelComponent extends fesm2015_XAxisNotesLabelComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    XAxisNotesLabelComponent.ɵfac = function XAxisNotesLabelComponent_Factory(t) { return new (t || XAxisNotesLabelComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    XAxisNotesLabelComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: XAxisNotesLabelComponent, selectors: [[\"kendo-chart-x-axis-item-notes-label\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function XAxisNotesLabelComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    XAxisNotesLabelComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], XAxisNotesLabelComponent);\n    return XAxisNotesLabelComponent;\n})();\nlet fesm2015_XAxisTitleComponentGenerated = /*@__PURE__*/ (() => {\n    class XAxisTitleComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('title', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    XAxisTitleComponentGenerated.ɵfac = function XAxisTitleComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    XAxisTitleComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: XAxisTitleComponentGenerated, inputs: { background: \"background\", border: \"border\", color: \"color\", font: \"font\", margin: \"margin\", padding: \"padding\", position: \"position\", rotation: \"rotation\", text: \"text\", visible: \"visible\", visual: \"visual\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return XAxisTitleComponentGenerated;\n})();\nlet fesm2015_XAxisTitleComponent = /*@__PURE__*/ (() => {\n    /**\n     * The title configuration of the Scatter Chart X axis.\n     */\n    let XAxisTitleComponent = class XAxisTitleComponent extends fesm2015_XAxisTitleComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    XAxisTitleComponent.ɵfac = function XAxisTitleComponent_Factory(t) { return new (t || XAxisTitleComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    XAxisTitleComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: XAxisTitleComponent, selectors: [[\"kendo-chart-x-axis-item-title\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function XAxisTitleComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    XAxisTitleComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], XAxisTitleComponent);\n    return XAxisTitleComponent;\n})();\nlet fesm2015_YAxisItemComponentGenerated = /*@__PURE__*/ (() => {\n    class YAxisItemComponentGenerated extends fesm2015_CollectionItemComponent {\n        constructor(configurationService, collectionService) {\n            super(configurationService, collectionService);\n            this.configurationService = configurationService;\n            this.collectionService = collectionService;\n        }\n    }\n    YAxisItemComponentGenerated.ɵfac = function YAxisItemComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    YAxisItemComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: YAxisItemComponentGenerated, inputs: { axisCrossingValue: \"axisCrossingValue\", background: \"background\", baseUnit: \"baseUnit\", color: \"color\", line: \"line\", majorGridLines: \"majorGridLines\", majorTicks: \"majorTicks\", majorUnit: \"majorUnit\", max: \"max\", min: \"min\", minorGridLines: \"minorGridLines\", minorTicks: \"minorTicks\", minorUnit: \"minorUnit\", name: \"name\", narrowRange: \"narrowRange\", pane: \"pane\", plotBands: \"plotBands\", reverse: \"reverse\", type: \"type\", visible: \"visible\", crosshair: \"crosshair\", labels: \"labels\", notes: \"notes\", title: \"title\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return YAxisItemComponentGenerated;\n})();\nlet fesm2015_YAxisItemComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration component for the Y axis\n     * ([see example]({% slug api_charts_yaxiscomponent %})).\n     */\n    let YAxisItemComponent = class YAxisItemComponent extends fesm2015_YAxisItemComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService, collectionService) {\n            super(configurationService, collectionService);\n            this.configurationService = configurationService;\n            this.collectionService = collectionService;\n        }\n    };\n    YAxisItemComponent.ɵfac = function YAxisItemComponent_Factory(t) { return new (t || YAxisItemComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_CollectionService)); };\n    YAxisItemComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: YAxisItemComponent, selectors: [[\"kendo-chart-y-axis-item\"]], features: [core[\"Bb\" /* ɵɵProvidersFeature */]([fesm2015_ConfigurationService]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function YAxisItemComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    YAxisItemComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService,\n            fesm2015_CollectionService])\n    ], YAxisItemComponent);\n    return YAxisItemComponent;\n})();\nlet fesm2015_YAxisComponentGenerated = /*@__PURE__*/ (() => {\n    class YAxisComponentGenerated extends fesm2015_CollectionComponent {\n        constructor(configurationService, collectionService) {\n            super('yAxis', configurationService, collectionService);\n            this.configurationService = configurationService;\n            this.collectionService = collectionService;\n        }\n    }\n    YAxisComponentGenerated.ɵfac = function YAxisComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    YAxisComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: YAxisComponentGenerated, contentQueries: function YAxisComponentGenerated_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                core[\"Ib\" /* ɵɵcontentQuery */](dirIndex, fesm2015_YAxisItemComponent, false);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx.children = _t);\n            }\n        }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return YAxisComponentGenerated;\n})();\nlet fesm2015_YAxisComponent = /*@__PURE__*/ (() => {\n    /**\n     * A collection of one or more Y-axis configuration components.\n     *\n     * @example\n     * ```ts\n     * import { Component } from '@angular/core';\n     *\n     * _@Component({\n     *  selector: 'my-app',\n     *  template: `\n     *    <kendo-chart>\n     *     <kendo-chart-y-axis>\n     *       <kendo-chart-y-axis-item\n     *         [background]=\"'rgba(100, 100, 100, 0.2)'\"\n     *         [color]=\"'red'\"\n     *         [notes]=\"notesConfig\"\n     *         [crosshair]=\"crosshairConfig\">\n     *       </kendo-chart-y-axis-item>\n     *       <kendo-chart-y-axis-item name=\"secondAxis\">\n     *       </kendo-chart-y-axis-item>\n     *     </kendo-chart-y-axis>\n     *     <kendo-chart-series>\n     *       <kendo-chart-series-item type=\"scatter\" [data]=\"[[1, 2]]\">\n     *       </kendo-chart-series-item>\n     *       <kendo-chart-series-item type=\"scatter\" [data]=\"[[0.1, 0.2]]\"\n     *                                yAxis=\"secondAxis\">\n     *       </kendo-chart-series-item>\n     *     </kendo-chart-series>\n     *   </kendo-chart>\n     * `\n     * })\n     * export class AppComponent {\n     * public notesConfig = {\n     *   data: [{\n     *       value: 0.2,\n     *       text: \"foo\"\n     *     }, {\n     *       value: 0.8,\n     *       text: \"bar\"\n     *     }],\n     *    label: {\n     *     content: (args: any) => args.dataItem.text,\n     *     background: 'red',\n     *     color: 'white'\n     *   },\n     *   line: {\n     *     color: 'blue',\n     *     dashType: 'dash',\n     *     length: 150,\n     *     width: 2\n     *   },\n     *   position: 'top'\n     * };\n     *\n     * public crosshairConfig = {\n     *   color: 'green',\n     *   opacity: 0.8,\n     *   visible: true,\n     *   width: 3\n     * };\n     * }\n     *\n     * ```\n     */\n    let YAxisComponent = class YAxisComponent extends fesm2015_YAxisComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService, collectionService) {\n            super(configurationService, collectionService);\n            this.configurationService = configurationService;\n            this.collectionService = collectionService;\n        }\n    };\n    YAxisComponent.ɵfac = function YAxisComponent_Factory(t) { return new (t || YAxisComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_CollectionService)); };\n    YAxisComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: YAxisComponent, selectors: [[\"kendo-chart-y-axis\"]], features: [core[\"Bb\" /* ɵɵProvidersFeature */]([fesm2015_CollectionService]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function YAxisComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    YAxisComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService,\n            fesm2015_CollectionService])\n    ], YAxisComponent);\n    return YAxisComponent;\n})();\nlet fesm2015_YAxisCrosshairComponentGenerated = /*@__PURE__*/ (() => {\n    class YAxisCrosshairComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('crosshair', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    YAxisCrosshairComponentGenerated.ɵfac = function YAxisCrosshairComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    YAxisCrosshairComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: YAxisCrosshairComponentGenerated, inputs: { color: \"color\", opacity: \"opacity\", visible: \"visible\", width: \"width\", tooltip: \"tooltip\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return YAxisCrosshairComponentGenerated;\n})();\nlet fesm2015_YAxisCrosshairComponent = /*@__PURE__*/ (() => {\n    /**\n     * The crosshair configuration options\n     * ([see example]({% slug api_charts_yaxiscomponent %})).\n     */\n    let YAxisCrosshairComponent = class YAxisCrosshairComponent extends fesm2015_YAxisCrosshairComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n            this.markAsVisible();\n        }\n    };\n    YAxisCrosshairComponent.ɵfac = function YAxisCrosshairComponent_Factory(t) { return new (t || YAxisCrosshairComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    YAxisCrosshairComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: YAxisCrosshairComponent, selectors: [[\"kendo-chart-y-axis-item-crosshair\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function YAxisCrosshairComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    YAxisCrosshairComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], YAxisCrosshairComponent);\n    return YAxisCrosshairComponent;\n})();\nlet fesm2015_YAxisCrosshairTooltipComponentGenerated = /*@__PURE__*/ (() => {\n    class YAxisCrosshairTooltipComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('crosshair.tooltip', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    YAxisCrosshairTooltipComponentGenerated.ɵfac = function YAxisCrosshairTooltipComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    YAxisCrosshairTooltipComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: YAxisCrosshairTooltipComponentGenerated, inputs: { background: \"background\", border: \"border\", color: \"color\", font: \"font\", format: \"format\", padding: \"padding\", visible: \"visible\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return YAxisCrosshairTooltipComponentGenerated;\n})();\nlet fesm2015_YAxisCrosshairTooltipComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration options of the crosshair tooltip.\n     * The crosshair tooltip is displayed when the `visible` option is set to `true`.\n     */\n    let YAxisCrosshairTooltipComponent = class YAxisCrosshairTooltipComponent extends fesm2015_YAxisCrosshairTooltipComponentGenerated {\n        // Place custom properties here.\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n            this.markAsVisible();\n        }\n    };\n    YAxisCrosshairTooltipComponent.ɵfac = function YAxisCrosshairTooltipComponent_Factory(t) { return new (t || YAxisCrosshairTooltipComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    YAxisCrosshairTooltipComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: YAxisCrosshairTooltipComponent, selectors: [[\"kendo-chart-y-axis-item-crosshair-tooltip\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function YAxisCrosshairTooltipComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    YAxisCrosshairTooltipComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], YAxisCrosshairTooltipComponent);\n    return YAxisCrosshairTooltipComponent;\n})();\nlet fesm2015_YAxisLabelsComponentGenerated = /*@__PURE__*/ (() => {\n    class YAxisLabelsComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('labels', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    YAxisLabelsComponentGenerated.ɵfac = function YAxisLabelsComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    YAxisLabelsComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: YAxisLabelsComponentGenerated, inputs: { background: \"background\", border: \"border\", color: \"color\", content: \"content\", culture: \"culture\", dateFormats: \"dateFormats\", font: \"font\", format: \"format\", margin: \"margin\", mirror: \"mirror\", padding: \"padding\", position: \"position\", rotation: \"rotation\", skip: \"skip\", step: \"step\", visible: \"visible\", visual: \"visual\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return YAxisLabelsComponentGenerated;\n})();\nlet fesm2015_YAxisLabelsComponent = /*@__PURE__*/ (() => {\n    /**\n     * The axis labels configuration.\n     */\n    let YAxisLabelsComponent = class YAxisLabelsComponent extends fesm2015_YAxisLabelsComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    YAxisLabelsComponent.ɵfac = function YAxisLabelsComponent_Factory(t) { return new (t || YAxisLabelsComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    YAxisLabelsComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: YAxisLabelsComponent, selectors: [[\"kendo-chart-y-axis-item-labels\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function YAxisLabelsComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    YAxisLabelsComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], YAxisLabelsComponent);\n    return YAxisLabelsComponent;\n})();\nlet fesm2015_YAxisNotesComponentGenerated = /*@__PURE__*/ (() => {\n    class YAxisNotesComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('notes', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    YAxisNotesComponentGenerated.ɵfac = function YAxisNotesComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    YAxisNotesComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: YAxisNotesComponentGenerated, inputs: { data: \"data\", line: \"line\", position: \"position\", visual: \"visual\", icon: \"icon\", label: \"label\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return YAxisNotesComponentGenerated;\n})();\nlet fesm2015_YAxisNotesComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration of the Y axis notes\n     * ([see example]({% slug api_charts_yaxiscomponent %})).\n     */\n    let YAxisNotesComponent = class YAxisNotesComponent extends fesm2015_YAxisNotesComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    YAxisNotesComponent.ɵfac = function YAxisNotesComponent_Factory(t) { return new (t || YAxisNotesComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    YAxisNotesComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: YAxisNotesComponent, selectors: [[\"kendo-chart-y-axis-item-notes\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function YAxisNotesComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    YAxisNotesComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], YAxisNotesComponent);\n    return YAxisNotesComponent;\n})();\nlet fesm2015_YAxisNotesIconComponentGenerated = /*@__PURE__*/ (() => {\n    class YAxisNotesIconComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('notes.icon', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    YAxisNotesIconComponentGenerated.ɵfac = function YAxisNotesIconComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    YAxisNotesIconComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: YAxisNotesIconComponentGenerated, inputs: { background: \"background\", border: \"border\", size: \"size\", type: \"type\", visible: \"visible\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return YAxisNotesIconComponentGenerated;\n})();\nlet fesm2015_YAxisNotesIconComponent = /*@__PURE__*/ (() => {\n    /**\n     * The icon of the notes.\n     */\n    let YAxisNotesIconComponent = class YAxisNotesIconComponent extends fesm2015_YAxisNotesIconComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    YAxisNotesIconComponent.ɵfac = function YAxisNotesIconComponent_Factory(t) { return new (t || YAxisNotesIconComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    YAxisNotesIconComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: YAxisNotesIconComponent, selectors: [[\"kendo-chart-y-axis-item-notes-icon\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function YAxisNotesIconComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    YAxisNotesIconComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], YAxisNotesIconComponent);\n    return YAxisNotesIconComponent;\n})();\nlet fesm2015_YAxisNotesLabelComponentGenerated = /*@__PURE__*/ (() => {\n    class YAxisNotesLabelComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('notes.label', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    YAxisNotesLabelComponentGenerated.ɵfac = function YAxisNotesLabelComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    YAxisNotesLabelComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: YAxisNotesLabelComponentGenerated, inputs: { background: \"background\", border: \"border\", color: \"color\", content: \"content\", font: \"font\", format: \"format\", position: \"position\", rotation: \"rotation\", visible: \"visible\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return YAxisNotesLabelComponentGenerated;\n})();\nlet fesm2015_YAxisNotesLabelComponent = /*@__PURE__*/ (() => {\n    /**\n     * The label of the notes.\n     */\n    let YAxisNotesLabelComponent = class YAxisNotesLabelComponent extends fesm2015_YAxisNotesLabelComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    YAxisNotesLabelComponent.ɵfac = function YAxisNotesLabelComponent_Factory(t) { return new (t || YAxisNotesLabelComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    YAxisNotesLabelComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: YAxisNotesLabelComponent, selectors: [[\"kendo-chart-y-axis-item-notes-label\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function YAxisNotesLabelComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    YAxisNotesLabelComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], YAxisNotesLabelComponent);\n    return YAxisNotesLabelComponent;\n})();\nlet fesm2015_YAxisTitleComponentGenerated = /*@__PURE__*/ (() => {\n    class YAxisTitleComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('title', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    YAxisTitleComponentGenerated.ɵfac = function YAxisTitleComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    YAxisTitleComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: YAxisTitleComponentGenerated, inputs: { background: \"background\", border: \"border\", color: \"color\", font: \"font\", margin: \"margin\", padding: \"padding\", position: \"position\", rotation: \"rotation\", text: \"text\", visible: \"visible\", visual: \"visual\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return YAxisTitleComponentGenerated;\n})();\nlet fesm2015_YAxisTitleComponent = /*@__PURE__*/ (() => {\n    /**\n     * The title configuration of the Scatter Chart Y axis.\n     */\n    let YAxisTitleComponent = class YAxisTitleComponent extends fesm2015_YAxisTitleComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    YAxisTitleComponent.ɵfac = function YAxisTitleComponent_Factory(t) { return new (t || YAxisTitleComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    YAxisTitleComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: YAxisTitleComponent, selectors: [[\"kendo-chart-y-axis-item-title\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function YAxisTitleComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    YAxisTitleComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], YAxisTitleComponent);\n    return YAxisTitleComponent;\n})();\nlet fesm2015_ZoomableComponentGenerated = /*@__PURE__*/ (() => {\n    class ZoomableComponentGenerated extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('zoomable', configurationService);\n            this.configurationService = configurationService;\n        }\n    }\n    ZoomableComponentGenerated.ɵfac = function ZoomableComponentGenerated_Factory(t) { core[\"fc\" /* ɵɵinvalidFactory */](); };\n    ZoomableComponentGenerated.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: ZoomableComponentGenerated, inputs: { mousewheel: \"mousewheel\", selection: \"selection\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]] });\n    return ZoomableComponentGenerated;\n})();\nlet fesm2015_ZoomableComponent = /*@__PURE__*/ (() => {\n    /**\n     * Specifies if the Chart can be zoomed.\n     *\n     * @example\n     *\n     * ```html-no-run\n     * <kendo-chart>\n     *   <kendo-chart-zoomable [mousewheel]=\"false\"></kendo-chart-zoomable>\n     * </kendo-chart>\n     * ```\n     */\n    let ZoomableComponent = class ZoomableComponent extends fesm2015_ZoomableComponentGenerated {\n        // Place custom properties here\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    ZoomableComponent.ɵfac = function ZoomableComponent_Factory(t) { return new (t || ZoomableComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    ZoomableComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: ZoomableComponent, selectors: [[\"kendo-chart-zoomable\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function ZoomableComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    ZoomableComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], ZoomableComponent);\n    return ZoomableComponent;\n})();\n/**\n * @hidden\n */\nconst CHART_DIRECTIVES = [\n    fesm2015_ChartComponent,\n    fesm2015_TooltipPopupComponent,\n    fesm2015_SeriesTooltipTemplateDirective,\n    fesm2015_SharedTooltipTemplateDirective,\n    fesm2015_CrosshairTooltipsContainerComponent,\n    fesm2015_CrosshairTooltipComponent,\n    fesm2015_DonutCenterTemplateDirective,\n    fesm2015_AxisDefaultsComponent,\n    fesm2015_AxisDefaultsCrosshairComponent,\n    fesm2015_AxisDefaultsCrosshairTooltipComponent,\n    fesm2015_AxisDefaultsLabelsComponent,\n    fesm2015_AxisDefaultsTitleComponent,\n    fesm2015_CategoryAxisComponent,\n    fesm2015_CategoryAxisCrosshairComponent,\n    fesm2015_CategoryAxisCrosshairTooltipComponent,\n    fesm2015_CategoryAxisItemComponent,\n    fesm2015_CategoryAxisLabelsComponent,\n    fesm2015_CategoryAxisRangeLabelsComponent,\n    fesm2015_CategoryAxisNotesComponent,\n    fesm2015_CategoryAxisNotesIconComponent,\n    fesm2015_CategoryAxisNotesLabelComponent,\n    fesm2015_CategoryAxisSelectComponent,\n    fesm2015_CategoryAxisTitleComponent,\n    fesm2015_ChartAreaComponent,\n    fesm2015_LegendComponent,\n    fesm2015_LegendInactiveItemsComponent,\n    fesm2015_LegendItemComponent,\n    fesm2015_PaneComponent,\n    fesm2015_PaneDefaultsComponent,\n    fesm2015_PaneDefaultsTitleComponent,\n    fesm2015_PanesComponent,\n    fesm2015_PanesTitleComponent,\n    fesm2015_PlotAreaComponent,\n    fesm2015_SeriesComponent,\n    fesm2015_SeriesDefaultsComponent,\n    fesm2015_SeriesDefaultsLabelsComponent,\n    fesm2015_SeriesDefaultsLabelsFromComponent,\n    fesm2015_SeriesDefaultsLabelsToComponent,\n    fesm2015_SeriesDefaultsNotesComponent,\n    fesm2015_SeriesDefaultsNotesIconComponent,\n    fesm2015_SeriesDefaultsNotesLabelComponent,\n    fesm2015_SeriesDefaultsTooltipComponent,\n    fesm2015_SeriesErrorBarsComponent,\n    fesm2015_SeriesExtremesComponent,\n    fesm2015_SeriesHighlightComponent,\n    fesm2015_SeriesItemComponent,\n    fesm2015_SeriesLabelsComponent,\n    fesm2015_SeriesLabelsFromComponent,\n    fesm2015_SeriesLabelsToComponent,\n    fesm2015_SeriesMarkersComponent,\n    fesm2015_SeriesNotesComponent,\n    fesm2015_SeriesNotesIconComponent,\n    fesm2015_SeriesNotesLabelComponent,\n    fesm2015_SeriesOutliersComponent,\n    fesm2015_SeriesTooltipComponent,\n    fesm2015_TitleComponent,\n    fesm2015_TooltipComponent,\n    fesm2015_ValueAxisComponent,\n    fesm2015_ValueAxisCrosshairComponent,\n    fesm2015_ValueAxisCrosshairTooltipComponent,\n    fesm2015_ValueAxisItemComponent,\n    fesm2015_ValueAxisLabelsComponent,\n    fesm2015_ValueAxisNotesComponent,\n    fesm2015_ValueAxisNotesIconComponent,\n    fesm2015_ValueAxisNotesLabelComponent,\n    fesm2015_ValueAxisTitleComponent,\n    fesm2015_XAxisComponent,\n    fesm2015_XAxisCrosshairComponent,\n    fesm2015_XAxisCrosshairTooltipComponent,\n    fesm2015_XAxisItemComponent,\n    fesm2015_XAxisLabelsComponent,\n    fesm2015_XAxisNotesComponent,\n    fesm2015_XAxisNotesIconComponent,\n    fesm2015_XAxisNotesLabelComponent,\n    fesm2015_XAxisTitleComponent,\n    fesm2015_YAxisComponent,\n    fesm2015_YAxisCrosshairComponent,\n    fesm2015_YAxisCrosshairTooltipComponent,\n    fesm2015_YAxisItemComponent,\n    fesm2015_YAxisLabelsComponent,\n    fesm2015_YAxisNotesComponent,\n    fesm2015_YAxisNotesIconComponent,\n    fesm2015_YAxisNotesLabelComponent,\n    fesm2015_YAxisTitleComponent,\n    fesm2015_ZoomableComponent\n];\n// Re-export event types\n/**\n * The arguments for the `navigatorFilter` event.\n */\nclass NavigatorFilterEvent extends BaseEvent {\n    /**\n     * Constructs the event arguments from a raw object.\n     */\n    constructor(e, sender) {\n        super(sender);\n        this.from = e.from;\n        this.to = e.to;\n    }\n}\nlet fesm2015_RootConfigurationService = /*@__PURE__*/ (() => {\n    // Re-export event types\n    /**\n     * @hidden\n     */\n    let RootConfigurationService = class RootConfigurationService extends fesm2015_ConfigurationService {\n    };\n    RootConfigurationService.ɵfac = function RootConfigurationService_Factory(t) { return ɵRootConfigurationService_BaseFactory(t || RootConfigurationService); };\n    RootConfigurationService.ɵprov = core[\"Lb\" /* ɵɵdefineInjectable */]({ token: RootConfigurationService, factory: function (t) { return RootConfigurationService.ɵfac(t); } });\n    return RootConfigurationService;\n})();\nconst EVENT_MAP$1 = {\n    navigatorFilter: NavigatorFilterEvent\n};\nlet fesm2015_StockInstanceEventService = /*@__PURE__*/ (() => {\n    class StockInstanceEventService extends fesm2015_InstanceEventService {\n        create(name, args, sender) {\n            if (EVENT_MAP$1[name]) {\n                return new EVENT_MAP$1[name](args, sender);\n            }\n            return super.create(name, args, sender);\n        }\n    }\n    StockInstanceEventService.ɵfac = function StockInstanceEventService_Factory(t) { return ɵStockInstanceEventService_BaseFactory(t || StockInstanceEventService); };\n    StockInstanceEventService.ɵprov = core[\"Lb\" /* ɵɵdefineInjectable */]({ token: StockInstanceEventService, factory: StockInstanceEventService.ɵfac });\n    return StockInstanceEventService;\n})();\nconst NAVIGATOR_DEFAULTS = {\n    autoBindElements: true,\n    liveDrag: false,\n    partialRedraw: true\n};\nlet fesm2015_StockChartComponent = /*@__PURE__*/ (() => {\n    /* tslint:disable:no-access-missing-member */\n    /**\n     * The root StockChart component.\n     *\n     * @example\n     * ```ts\n     * import { Component } from '@angular/core';\n     *\n     * _@Component({\n     *   selector: 'my-app',\n     *   template: `\n     *     <kendo-stockchart>\n     *         <kendo-chart-series>\n     *             <kendo-chart-series-item type=\"line\" [data]=\"data\" field=\"value\" categoryField=\"date\">\n     *             </kendo-chart-series-item>\n     *         </kendo-chart-series>\n     *         <kendo-chart-navigator>\n     *             <kendo-chart-navigator-select to=\"2017/02/01\">\n     *             </kendo-chart-navigator-select>\n     *             <kendo-chart-navigator-series>\n     *                 <kendo-chart-navigator-series-item type=\"area\" [data]=\"data\" field=\"value\" categoryField=\"date\">\n     *                 </kendo-chart-navigator-series-item>\n     *             </kendo-chart-navigator-series>\n     *         </kendo-chart-navigator>\n     *     </kendo-stockchart>\n     *   `\n     * })\n     * class AppComponent {\n     *   public data: any[] = [];\n     *\n     *   constructor() {\n     *      for (let idx = 0; idx < 100; idx++) {\n     *          this.data.push({\n     *              date: new Date(2017, 0, idx),\n     *              value: Math.random() * 100\n     *          });\n     *      }\n     *   }\n     * }\n     *\n     * ```\n     */\n    let StockChartComponent = class StockChartComponent extends fesm2015_ChartComponent {\n        constructor(configurationService, themeService, element, intl, localizationService, ngZone, instanceEventService, changeDetector, renderer) {\n            super(configurationService, themeService, element, intl, localizationService, ngZone, instanceEventService, changeDetector, renderer);\n            this.configurationService = configurationService;\n            this.themeService = themeService;\n            this.element = element;\n            this.intl = intl;\n            this.localizationService = localizationService;\n            this.ngZone = ngZone;\n            this.instanceEventService = instanceEventService;\n            this.changeDetector = changeDetector;\n            this.renderer = renderer;\n            /**\n             * Fires when the navigator range is changed.\n             */\n            this.navigatorFilter = new core[\"o\" /* EventEmitter */]();\n            this.redrawSlaves = false;\n            this.hostClasses = ['k-chart', 'k-stockchart'];\n            validatePackage(dist_fesm2015_packageMetadata);\n        }\n        /**\n         * If called, the navigator pane is not redrawn the next time the StockChart options are updated.\n         * The method is useful if you need to update only the main series data for the selected period.\n         */\n        skipNavigatorRedraw() {\n            this.redrawSlaves = true;\n        }\n        createInstance(element, observer) {\n            this.applyNavigatorDefaults();\n            if (this.isDevMode() && (this.options.zoomable || this.options.pannable)) {\n                throw new Error('The pannable and zoomable options are not supported by the StockChart component.');\n            }\n            this.instance = new stock_chart(element, this.options, this.theme, {\n                intlService: this.intl,\n                observer: observer,\n                rtl: this.rtl,\n                sender: this\n            });\n        }\n        updateOptions() {\n            this.applyNavigatorDefaults();\n            if (this.redrawSlaves) {\n                this.instance.applyOptions(this.options);\n                this.instance.bindCategories();\n                this.instance.navigator.redrawSlaves();\n            }\n            else {\n                this.instance.setOptions(this.options);\n            }\n            this.redrawSlaves = false;\n        }\n        applyNavigatorDefaults() {\n            this.options.navigator = Object.assign({}, this.options.navigator, NAVIGATOR_DEFAULTS);\n        }\n        isDevMode() {\n            return Object(core[\"Y\" /* isDevMode */])();\n        }\n    };\n    StockChartComponent.ɵfac = function StockChartComponent_Factory(t) { return new (t || StockChartComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ThemeService), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_IntlService), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_LocalizationService), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */]), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_StockInstanceEventService), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"h\" /* ChangeDetectorRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"G\" /* Renderer2 */])); };\n    StockChartComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: StockChartComponent, selectors: [[\"kendo-stockchart\"]], inputs: { navigator: \"navigator\", pannable: \"pannable\", zoomable: \"zoomable\" }, outputs: { navigatorFilter: \"navigatorFilter\" }, exportAs: [\"kendoStockChart\"], features: [core[\"Bb\" /* ɵɵProvidersFeature */]([\n                fesm2015_ConfigurationService,\n                fesm2015_TooltipTemplateService,\n                { provide: fesm2015_RootConfigurationService, useExisting: fesm2015_ConfigurationService },\n                fesm2015_StockInstanceEventService,\n                fesm2015_LocalizationService,\n                {\n                    provide: L10N_PREFIX,\n                    useValue: 'kendo.chart'\n                }\n            ]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 5, vars: 2, consts: [[1, \"k-chart-surface\"], [\"surface\", \"\"], [3, \"popupSettings\"], [3, \"popupSettings\", \"leave\"], [3, \"resize\"]], template: function StockChartComponent_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"Qb\" /* ɵɵelement */](0, \"div\", 0, 1);\n                core[\"Qb\" /* ɵɵelement */](2, \"kendo-chart-crosshair-tooltips-container\", 2);\n                core[\"Vb\" /* ɵɵelementStart */](3, \"kendo-chart-tooltip-popup\", 3);\n                core[\"gc\" /* ɵɵlistener */](\"leave\", function StockChartComponent_Template_kendo_chart_tooltip_popup_leave_3_listener($event) { return ctx.tooltipMouseleave($event); });\n                core[\"Ub\" /* ɵɵelementEnd */]();\n                core[\"Vb\" /* ɵɵelementStart */](4, \"kendo-resize-sensor\", 4);\n                core[\"gc\" /* ɵɵlistener */](\"resize\", function StockChartComponent_Template_kendo_resize_sensor_resize_4_listener($event) { return ctx.onResize($event); });\n                core[\"Ub\" /* ɵɵelementEnd */]();\n            }\n            if (rf & 2) {\n                core[\"Cb\" /* ɵɵadvance */](2);\n                core[\"pc\" /* ɵɵproperty */](\"popupSettings\", ctx.popupSettings);\n                core[\"Cb\" /* ɵɵadvance */](1);\n                core[\"pc\" /* ɵɵproperty */](\"popupSettings\", ctx.popupSettings);\n            }\n        }, directives: [fesm2015_CrosshairTooltipsContainerComponent, fesm2015_TooltipPopupComponent, fesm2015_ResizeSensorComponent], encapsulation: 2, changeDetection: 0 });\n    StockChartComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService,\n            fesm2015_ThemeService,\n            core[\"l\" /* ElementRef */],\n            fesm2015_IntlService,\n            fesm2015_LocalizationService,\n            core[\"B\" /* NgZone */],\n            fesm2015_StockInstanceEventService,\n            core[\"h\" /* ChangeDetectorRef */],\n            core[\"G\" /* Renderer2 */]])\n    ], StockChartComponent);\n    return StockChartComponent;\n})();\n/**\n * @hidden\n */\nconst PREFIX = new core[\"s\" /* InjectionToken */]('configuration prefix');\nlet fesm2015_PrefixConfigurationService = /*@__PURE__*/ (() => {\n    /**\n     * @hidden\n     */\n    let PrefixConfigurationService = class PrefixConfigurationService extends fesm2015_ConfigurationService {\n        constructor(rootService, prefix, ngZone) {\n            super(ngZone);\n            this.rootService = rootService;\n            this.prefix = prefix;\n        }\n        push(store) {\n            this.rootService.notify(new Change(this.prefix, store));\n        }\n        notify(change) {\n            change.key = this.prefix + (change.key ? `.${change.key}` : '');\n            this.rootService.notify(change);\n        }\n    };\n    PrefixConfigurationService.ɵfac = function PrefixConfigurationService_Factory(t) { return new (t || PrefixConfigurationService)(core[\"cc\" /* ɵɵinject */](fesm2015_RootConfigurationService), core[\"cc\" /* ɵɵinject */](PREFIX), core[\"cc\" /* ɵɵinject */](core[\"B\" /* NgZone */])); };\n    PrefixConfigurationService.ɵprov = core[\"Lb\" /* ɵɵdefineInjectable */]({ token: PrefixConfigurationService, factory: function (t) { return PrefixConfigurationService.ɵfac(t); } });\n    PrefixConfigurationService = __decorate([__param(0, Object(core[\"q\" /* Inject */])(fesm2015_RootConfigurationService)),\n        __param(1, Object(core[\"q\" /* Inject */])(PREFIX)),\n        __metadata(\"design:paramtypes\", [fesm2015_RootConfigurationService, String, core[\"B\" /* NgZone */]])\n    ], PrefixConfigurationService);\n    return PrefixConfigurationService;\n})();\nlet fesm2015_NavigatorComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration options of the navigator\n     * ([see runnable example]({% slug overview_stockchart_charts %}#toc-navigator)).\n     *\n     * @example\n     * ```ts-no-run\n     * _@Component({\n     *     selector: 'my-app',\n     *       template: `\n     *         <kendo-stockchart (navigatorFilter)=\"onNavigatorFilter($event)\">\n     *             <kendo-chart-series>\n     *                <kendo-chart-series-item\n     *                type=\"candlestick\"\n     *                 [data]=\"seriesData\"\n     *                 openField=\"Open\"\n     *                 closeField=\"Close\"\n     *                 lowField=\"Low\"\n     *                 highField=\"High\"\n     *                 categoryField=\"Date\">\n     *             </kendo-chart-series-item>\n     *          </kendo-chart-series>\n     *          <kendo-chart-navigator\n     *            [categoryAxis]=\"categoryAxisOptions\"\n     *            [hint]=\"hintOptions\"\n     *            [pane]=\"paneOptions\"\n     *            [visible]=\"isVisible\">\n     *            <kendo-chart-navigator-select [from]=\"from\" [to]=\"to\">\n     *            </kendo-chart-navigator-select>\n     *            <kendo-chart-navigator-series>\n     *              <kendo-chart-navigator-series-item type=\"area\" [data]=\"navigatorData\" field=\"Close\" categoryField=\"Date\">\n     *              </kendo-chart-navigator-series-item>\n     *           </kendo-chart-navigator-series>\n     *          </kendo-chart-navigator>\n     *        </kendo-stockchart>\n     *        <br /><br />\n     *        <button class=\"k-button\" (click)=\"isVisible = !isVisible\">Toggle Navigator</button>\n     *    `\n     * })\n     * ```\n     */\n    let NavigatorComponent = class NavigatorComponent extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('', configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    NavigatorComponent.ɵfac = function NavigatorComponent_Factory(t) { return new (t || NavigatorComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    NavigatorComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: NavigatorComponent, selectors: [[\"kendo-chart-navigator\"]], inputs: { visible: \"visible\", categoryAxis: \"categoryAxis\", hint: \"hint\", pane: \"pane\", select: \"select\", series: \"series\" }, features: [core[\"Bb\" /* ɵɵProvidersFeature */]([{ provide: PREFIX, useValue: 'navigator' }, { provide: fesm2015_ConfigurationService, useClass: fesm2015_PrefixConfigurationService }]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function NavigatorComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    NavigatorComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], NavigatorComponent);\n    return NavigatorComponent;\n})();\nlet fesm2015_NavigatorCategoryAxisComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration component of the navigator category axis.\n     *\n     * @example\n     *\n     * ```html-no-run\n     * <kendo-stockchart>\n     *   <kendo-chart-navigator>\n     *     <kendo-chart-navigator-category-axis\n     *       color=\"maroon\"\n     *       [labels]=\"{color: 'green'}\">\n     *     </kendo-chart-navigator-category-axis>\n     *   </kendo-chart-navigator>\n     * </kendo-stockchart>\n     * ```\n     */\n    let NavigatorCategoryAxisComponent = class NavigatorCategoryAxisComponent extends fesm2015_CategoryAxisItemComponent {\n        constructor(configurationService, intl, localeId) {\n            super(configurationService, null, intl, localeId);\n            this.configurationService = configurationService;\n        }\n    };\n    NavigatorCategoryAxisComponent.ɵfac = function NavigatorCategoryAxisComponent_Factory(t) { return new (t || NavigatorCategoryAxisComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_IntlService), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"w\" /* LOCALE_ID */])); };\n    NavigatorCategoryAxisComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: NavigatorCategoryAxisComponent, selectors: [[\"kendo-chart-navigator-category-axis\"]], features: [core[\"Bb\" /* ɵɵProvidersFeature */]([{\n                    provide: PREFIX,\n                    useValue: 'navigator.categoryAxis'\n                }, {\n                    provide: fesm2015_ConfigurationService,\n                    useClass: fesm2015_PrefixConfigurationService\n                }]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function NavigatorCategoryAxisComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    NavigatorCategoryAxisComponent = __decorate([__param(2, Object(core[\"q\" /* Inject */])(core[\"w\" /* LOCALE_ID */])),\n        __metadata(\"design:paramtypes\", [fesm2015_ConfigurationService,\n            fesm2015_IntlService, String])\n    ], NavigatorCategoryAxisComponent);\n    return NavigatorCategoryAxisComponent;\n})();\nlet fesm2015_NavigatorCategoryAxisCrosshairComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration options of the crosshair.\n     */\n    let NavigatorCategoryAxisCrosshairComponent = class NavigatorCategoryAxisCrosshairComponent extends fesm2015_CategoryAxisCrosshairComponent {\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    NavigatorCategoryAxisCrosshairComponent.ɵfac = function NavigatorCategoryAxisCrosshairComponent_Factory(t) { return new (t || NavigatorCategoryAxisCrosshairComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    NavigatorCategoryAxisCrosshairComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: NavigatorCategoryAxisCrosshairComponent, selectors: [[\"kendo-chart-navigator-category-axis-crosshair\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function NavigatorCategoryAxisCrosshairComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    NavigatorCategoryAxisCrosshairComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], NavigatorCategoryAxisCrosshairComponent);\n    return NavigatorCategoryAxisCrosshairComponent;\n})();\nlet fesm2015_NavigatorCategoryAxisCrosshairTooltipComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration options of the crosshair tooltip.\n     * The crosshair tooltip is displayed when the `visible` option is set to `true`.\n     */\n    let NavigatorCategoryAxisCrosshairTooltipComponent = class NavigatorCategoryAxisCrosshairTooltipComponent extends fesm2015_CategoryAxisCrosshairTooltipComponent {\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    NavigatorCategoryAxisCrosshairTooltipComponent.ɵfac = function NavigatorCategoryAxisCrosshairTooltipComponent_Factory(t) { return new (t || NavigatorCategoryAxisCrosshairTooltipComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    NavigatorCategoryAxisCrosshairTooltipComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: NavigatorCategoryAxisCrosshairTooltipComponent, selectors: [[\"kendo-chart-navigator-category-axis-crosshair-tooltip\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function NavigatorCategoryAxisCrosshairTooltipComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    NavigatorCategoryAxisCrosshairTooltipComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], NavigatorCategoryAxisCrosshairTooltipComponent);\n    return NavigatorCategoryAxisCrosshairTooltipComponent;\n})();\nlet fesm2015_NavigatorCategoryAxisLabelsComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration of the axis labels.\n     */\n    let NavigatorCategoryAxisLabelsComponent = class NavigatorCategoryAxisLabelsComponent extends fesm2015_CategoryAxisLabelsComponent {\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    NavigatorCategoryAxisLabelsComponent.ɵfac = function NavigatorCategoryAxisLabelsComponent_Factory(t) { return new (t || NavigatorCategoryAxisLabelsComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    NavigatorCategoryAxisLabelsComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: NavigatorCategoryAxisLabelsComponent, selectors: [[\"kendo-chart-navigator-category-axis-labels\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function NavigatorCategoryAxisLabelsComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    NavigatorCategoryAxisLabelsComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], NavigatorCategoryAxisLabelsComponent);\n    return NavigatorCategoryAxisLabelsComponent;\n})();\nlet fesm2015_NavigatorCategoryAxisNotesComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration of the category axis notes.\n     */\n    let NavigatorCategoryAxisNotesComponent = class NavigatorCategoryAxisNotesComponent extends fesm2015_CategoryAxisNotesComponent {\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    NavigatorCategoryAxisNotesComponent.ɵfac = function NavigatorCategoryAxisNotesComponent_Factory(t) { return new (t || NavigatorCategoryAxisNotesComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    NavigatorCategoryAxisNotesComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: NavigatorCategoryAxisNotesComponent, selectors: [[\"kendo-chart-navigator-category-axis-notes\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function NavigatorCategoryAxisNotesComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    NavigatorCategoryAxisNotesComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], NavigatorCategoryAxisNotesComponent);\n    return NavigatorCategoryAxisNotesComponent;\n})();\nlet fesm2015_NavigatorCategoryAxisNotesIconComponent = /*@__PURE__*/ (() => {\n    /**\n     * The icon of the notes.\n     */\n    let NavigatorCategoryAxisNotesIconComponent = class NavigatorCategoryAxisNotesIconComponent extends fesm2015_CategoryAxisNotesIconComponent {\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    NavigatorCategoryAxisNotesIconComponent.ɵfac = function NavigatorCategoryAxisNotesIconComponent_Factory(t) { return new (t || NavigatorCategoryAxisNotesIconComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    NavigatorCategoryAxisNotesIconComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: NavigatorCategoryAxisNotesIconComponent, selectors: [[\"kendo-chart-navigator-category-axis-notes-icon\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function NavigatorCategoryAxisNotesIconComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    NavigatorCategoryAxisNotesIconComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], NavigatorCategoryAxisNotesIconComponent);\n    return NavigatorCategoryAxisNotesIconComponent;\n})();\nlet fesm2015_NavigatorCategoryAxisNotesLabelComponent = /*@__PURE__*/ (() => {\n    /**\n     * The label of the notes.\n     */\n    let NavigatorCategoryAxisNotesLabelComponent = class NavigatorCategoryAxisNotesLabelComponent extends fesm2015_CategoryAxisNotesLabelComponent {\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    NavigatorCategoryAxisNotesLabelComponent.ɵfac = function NavigatorCategoryAxisNotesLabelComponent_Factory(t) { return new (t || NavigatorCategoryAxisNotesLabelComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    NavigatorCategoryAxisNotesLabelComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: NavigatorCategoryAxisNotesLabelComponent, selectors: [[\"kendo-chart-navigator-category-axis-notes-label\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function NavigatorCategoryAxisNotesLabelComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    NavigatorCategoryAxisNotesLabelComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], NavigatorCategoryAxisNotesLabelComponent);\n    return NavigatorCategoryAxisNotesLabelComponent;\n})();\nlet fesm2015_NavigatorCategoryAxisSelectComponent = /*@__PURE__*/ (() => {\n    /**\n     * The selected axis range. If set, the axis selection is enabled. The range is index-based and starts from zero.\n     * Categories with indexes in the range (`select.from`, `select.to`) will be selected.\n     * This means that the last category in the range will not be included in the selection.\n     * If the categories are dates, the range has also to be specified with date values.\n     */\n    let NavigatorCategoryAxisSelectComponent = class NavigatorCategoryAxisSelectComponent extends fesm2015_CategoryAxisSelectComponent {\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    NavigatorCategoryAxisSelectComponent.ɵfac = function NavigatorCategoryAxisSelectComponent_Factory(t) { return new (t || NavigatorCategoryAxisSelectComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    NavigatorCategoryAxisSelectComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: NavigatorCategoryAxisSelectComponent, selectors: [[\"kendo-chart-navigator-category-axis-select\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function NavigatorCategoryAxisSelectComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    NavigatorCategoryAxisSelectComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], NavigatorCategoryAxisSelectComponent);\n    return NavigatorCategoryAxisSelectComponent;\n})();\nlet fesm2015_NavigatorCategoryAxisTitleComponent = /*@__PURE__*/ (() => {\n    /**\n     * The title configuration of the navigator category axis.\n     */\n    let NavigatorCategoryAxisTitleComponent = class NavigatorCategoryAxisTitleComponent extends fesm2015_CategoryAxisTitleComponent {\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    NavigatorCategoryAxisTitleComponent.ɵfac = function NavigatorCategoryAxisTitleComponent_Factory(t) { return new (t || NavigatorCategoryAxisTitleComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    NavigatorCategoryAxisTitleComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: NavigatorCategoryAxisTitleComponent, selectors: [[\"kendo-chart-navigator-category-axis-title\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function NavigatorCategoryAxisTitleComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    NavigatorCategoryAxisTitleComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], NavigatorCategoryAxisTitleComponent);\n    return NavigatorCategoryAxisTitleComponent;\n})();\nlet fesm2015_NavigatorHintComponent = /*@__PURE__*/ (() => {\n    /**\n     * The default options of the navigator hint\n     * ([see example]({% slug overview_stockchart_charts %}#toc-navigator)).\n     */\n    let NavigatorHintComponent = class NavigatorHintComponent extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('hint', configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    NavigatorHintComponent.ɵfac = function NavigatorHintComponent_Factory(t) { return new (t || NavigatorHintComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    NavigatorHintComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: NavigatorHintComponent, selectors: [[\"kendo-chart-navigator-hint\"]], inputs: { content: \"content\", format: \"format\", visible: \"visible\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function NavigatorHintComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    NavigatorHintComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], NavigatorHintComponent);\n    return NavigatorHintComponent;\n})();\nlet fesm2015_NavigatorPaneComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration component of the navigator pane\n     * ([see example]({% slug overview_stockchart_charts %}#toc-navigator)).\n     */\n    let NavigatorPaneComponent = class NavigatorPaneComponent extends fesm2015_PaneComponentGenerated {\n        constructor(configurationService) {\n            super(configurationService, null);\n            this.configurationService = configurationService;\n        }\n    };\n    NavigatorPaneComponent.ɵfac = function NavigatorPaneComponent_Factory(t) { return new (t || NavigatorPaneComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    NavigatorPaneComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: NavigatorPaneComponent, selectors: [[\"kendo-chart-navigator-pane\"]], features: [core[\"Bb\" /* ɵɵProvidersFeature */]([{ provide: PREFIX, useValue: 'navigator.pane' }, { provide: fesm2015_ConfigurationService, useClass: fesm2015_PrefixConfigurationService }]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function NavigatorPaneComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    NavigatorPaneComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], NavigatorPaneComponent);\n    return NavigatorPaneComponent;\n})();\nlet fesm2015_NavigatorPaneTitleComponent = /*@__PURE__*/ (() => {\n    /**\n     * The title configuration of the StockChart navigator pane.\n     */\n    let NavigatorPaneTitleComponent = class NavigatorPaneTitleComponent extends fesm2015_PanesTitleComponent {\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    NavigatorPaneTitleComponent.ɵfac = function NavigatorPaneTitleComponent_Factory(t) { return new (t || NavigatorPaneTitleComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    NavigatorPaneTitleComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: NavigatorPaneTitleComponent, selectors: [[\"kendo-chart-navigator-pane-title\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function NavigatorPaneTitleComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    NavigatorPaneTitleComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], NavigatorPaneTitleComponent);\n    return NavigatorPaneTitleComponent;\n})();\nlet fesm2015_NavigatorSelectComponent = /*@__PURE__*/ (() => {\n    /**\n     * Specifies the initially selected range.\n     * If no range is specified, the full range of values is rendered.\n     */\n    let NavigatorSelectComponent = class NavigatorSelectComponent extends fesm2015_SettingsComponent {\n        constructor(configurationService) {\n            super('select', configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    NavigatorSelectComponent.ɵfac = function NavigatorSelectComponent_Factory(t) { return new (t || NavigatorSelectComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    NavigatorSelectComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: NavigatorSelectComponent, selectors: [[\"kendo-chart-navigator-select\"]], inputs: { from: \"from\", to: \"to\", mousewheel: \"mousewheel\" }, features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function NavigatorSelectComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    NavigatorSelectComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], NavigatorSelectComponent);\n    return NavigatorSelectComponent;\n})();\nlet fesm2015_NavigatorSeriesItemComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration component of a navigator series item\n     * ([see example]({% slug navigator_stockchart_charts %})).\n     */\n    let NavigatorSeriesItemComponent = class NavigatorSeriesItemComponent extends fesm2015_SeriesItemComponent {\n        constructor(configurationService, collectionService) {\n            super(configurationService, collectionService);\n            this.configurationService = configurationService;\n            this.collectionService = collectionService;\n        }\n    };\n    NavigatorSeriesItemComponent.ɵfac = function NavigatorSeriesItemComponent_Factory(t) { return new (t || NavigatorSeriesItemComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_CollectionService)); };\n    NavigatorSeriesItemComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: NavigatorSeriesItemComponent, selectors: [[\"kendo-chart-navigator-series-item\"]], features: [core[\"Bb\" /* ɵɵProvidersFeature */]([fesm2015_ConfigurationService]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function NavigatorSeriesItemComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    NavigatorSeriesItemComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService,\n            fesm2015_CollectionService])\n    ], NavigatorSeriesItemComponent);\n    return NavigatorSeriesItemComponent;\n})();\nlet fesm2015_NavigatorSeriesComponent = /*@__PURE__*/ (() => {\n    /**\n     * A collection of one or more navigator series items.\n     *\n     * @example\n     * ```ts\n     * import { Component } from '@angular/core';\n     *\n     * _@Component({\n     *   selector: 'my-app',\n     *   template: `\n     *     <kendo-stockchart>\n     *         <kendo-chart-navigator>\n     *             <kendo-chart-navigator-series>\n     *                 <kendo-chart-navigator-series-item type=\"area\" [data]=\"data\" field=\"value\" categoryField=\"date\">\n     *                 </kendo-chart-navigator-series-item>\n     *             </kendo-chart-navigator-series>\n     *         </kendo-chart-navigator>\n     *     </kendo-stockchart>\n     *   `\n     * })\n     * class AppComponent {\n     *   public data: any[] = [];\n     *\n     *   constructor() {\n     *      for (let idx = 0; idx < 100; idx++) {\n     *          this.data.push({\n     *              date: new Date(2017, 0, idx),\n     *              value: Math.random() * 100\n     *          });\n     *      }\n     *   }\n     * }\n     *\n     * ```\n     */\n    let NavigatorSeriesComponent = class NavigatorSeriesComponent extends fesm2015_SeriesComponent {\n        constructor(configurationService, collectionService, tooltipTemplateService) {\n            super(configurationService, collectionService, tooltipTemplateService);\n            this.configurationService = configurationService;\n            this.collectionService = collectionService;\n            this.tooltipTemplateService = tooltipTemplateService;\n        }\n        readTooltipTemplates() {\n        }\n    };\n    NavigatorSeriesComponent.ɵfac = function NavigatorSeriesComponent_Factory(t) { return new (t || NavigatorSeriesComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_CollectionService), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_TooltipTemplateService)); };\n    NavigatorSeriesComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: NavigatorSeriesComponent, selectors: [[\"kendo-chart-navigator-series\"]], contentQueries: function NavigatorSeriesComponent_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                core[\"Ib\" /* ɵɵcontentQuery */](dirIndex, fesm2015_NavigatorSeriesItemComponent, false);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx.children = _t);\n            }\n        }, features: [core[\"Bb\" /* ɵɵProvidersFeature */]([fesm2015_CollectionService]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function NavigatorSeriesComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    NavigatorSeriesComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService,\n            fesm2015_CollectionService,\n            fesm2015_TooltipTemplateService])\n    ], NavigatorSeriesComponent);\n    return NavigatorSeriesComponent;\n})();\nlet fesm2015_NavigatorSeriesErrorBarsComponent = /*@__PURE__*/ (() => {\n    /**\n     * The error bars of the StockChart navigator series.\n     */\n    let NavigatorSeriesErrorBarsComponent = class NavigatorSeriesErrorBarsComponent extends fesm2015_SeriesErrorBarsComponent {\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    NavigatorSeriesErrorBarsComponent.ɵfac = function NavigatorSeriesErrorBarsComponent_Factory(t) { return new (t || NavigatorSeriesErrorBarsComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    NavigatorSeriesErrorBarsComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: NavigatorSeriesErrorBarsComponent, selectors: [[\"kendo-chart-navigator-series-item-error-bars\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function NavigatorSeriesErrorBarsComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    NavigatorSeriesErrorBarsComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], NavigatorSeriesErrorBarsComponent);\n    return NavigatorSeriesErrorBarsComponent;\n})();\nlet fesm2015_NavigatorSeriesExtremesComponent = /*@__PURE__*/ (() => {\n    /**\n     * The extremes configuration of the StockChart navigator series. Applies to extreme outliers.\n     */\n    let NavigatorSeriesExtremesComponent = class NavigatorSeriesExtremesComponent extends fesm2015_SeriesExtremesComponent {\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    NavigatorSeriesExtremesComponent.ɵfac = function NavigatorSeriesExtremesComponent_Factory(t) { return new (t || NavigatorSeriesExtremesComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    NavigatorSeriesExtremesComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: NavigatorSeriesExtremesComponent, selectors: [[\"kendo-chart-navigator-series-item-extremes\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function NavigatorSeriesExtremesComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    NavigatorSeriesExtremesComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], NavigatorSeriesExtremesComponent);\n    return NavigatorSeriesExtremesComponent;\n})();\nlet fesm2015_NavigatorSeriesHighlightComponent = /*@__PURE__*/ (() => {\n    /**\n     * The configuration options of the StockChart series highlight.\n     */\n    let NavigatorSeriesHighlightComponent = class NavigatorSeriesHighlightComponent extends fesm2015_SeriesHighlightComponent {\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    NavigatorSeriesHighlightComponent.ɵfac = function NavigatorSeriesHighlightComponent_Factory(t) { return new (t || NavigatorSeriesHighlightComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    NavigatorSeriesHighlightComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: NavigatorSeriesHighlightComponent, selectors: [[\"kendo-chart-navigator-series-item-highlight\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function NavigatorSeriesHighlightComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    NavigatorSeriesHighlightComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], NavigatorSeriesHighlightComponent);\n    return NavigatorSeriesHighlightComponent;\n})();\nlet fesm2015_NavigatorSeriesLabelsComponent = /*@__PURE__*/ (() => {\n    /**\n     * The label configuration of the StockChart navigator series.\n     */\n    let NavigatorSeriesLabelsComponent = class NavigatorSeriesLabelsComponent extends fesm2015_SeriesLabelsComponent {\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n            this.markAsVisible();\n        }\n    };\n    NavigatorSeriesLabelsComponent.ɵfac = function NavigatorSeriesLabelsComponent_Factory(t) { return new (t || NavigatorSeriesLabelsComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    NavigatorSeriesLabelsComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: NavigatorSeriesLabelsComponent, selectors: [[\"kendo-chart-navigator-series-item-labels\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function NavigatorSeriesLabelsComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    NavigatorSeriesLabelsComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], NavigatorSeriesLabelsComponent);\n    return NavigatorSeriesLabelsComponent;\n})();\nlet fesm2015_NavigatorSeriesLabelsFromComponent = /*@__PURE__*/ (() => {\n    /**\n     * The `from` label configuration of the StockChart navigator series.\n     */\n    let NavigatorSeriesLabelsFromComponent = class NavigatorSeriesLabelsFromComponent extends fesm2015_SeriesLabelsFromComponent {\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n            this.markAsVisible();\n        }\n    };\n    NavigatorSeriesLabelsFromComponent.ɵfac = function NavigatorSeriesLabelsFromComponent_Factory(t) { return new (t || NavigatorSeriesLabelsFromComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    NavigatorSeriesLabelsFromComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: NavigatorSeriesLabelsFromComponent, selectors: [[\"kendo-chart-navigator-series-item-labels-from\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function NavigatorSeriesLabelsFromComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    NavigatorSeriesLabelsFromComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], NavigatorSeriesLabelsFromComponent);\n    return NavigatorSeriesLabelsFromComponent;\n})();\nlet fesm2015_NavigatorSeriesLabelsToComponent = /*@__PURE__*/ (() => {\n    /**\n     * The `to` label configuration of the StockChart navigator series.\n     */\n    let NavigatorSeriesLabelsToComponent = class NavigatorSeriesLabelsToComponent extends fesm2015_SeriesLabelsToComponent {\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n            this.markAsVisible();\n        }\n    };\n    NavigatorSeriesLabelsToComponent.ɵfac = function NavigatorSeriesLabelsToComponent_Factory(t) { return new (t || NavigatorSeriesLabelsToComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    NavigatorSeriesLabelsToComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: NavigatorSeriesLabelsToComponent, selectors: [[\"kendo-chart-navigator-series-item-labels-to\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function NavigatorSeriesLabelsToComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    NavigatorSeriesLabelsToComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], NavigatorSeriesLabelsToComponent);\n    return NavigatorSeriesLabelsToComponent;\n})();\nlet fesm2015_NavigatorSeriesMarkersComponent = /*@__PURE__*/ (() => {\n    /**\n     * The marker configuration of the StockChart navigator series.\n     */\n    let NavigatorSeriesMarkersComponent = class NavigatorSeriesMarkersComponent extends fesm2015_SeriesMarkersComponent {\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    NavigatorSeriesMarkersComponent.ɵfac = function NavigatorSeriesMarkersComponent_Factory(t) { return new (t || NavigatorSeriesMarkersComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    NavigatorSeriesMarkersComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: NavigatorSeriesMarkersComponent, selectors: [[\"kendo-chart-navigator-series-item-markers\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function NavigatorSeriesMarkersComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    NavigatorSeriesMarkersComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], NavigatorSeriesMarkersComponent);\n    return NavigatorSeriesMarkersComponent;\n})();\nlet fesm2015_NavigatorSeriesNotesComponent = /*@__PURE__*/ (() => {\n    /**\n     * The notes configuration of the StockChart navigator series.\n     */\n    let NavigatorSeriesNotesComponent = class NavigatorSeriesNotesComponent extends fesm2015_SeriesNotesComponent {\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    NavigatorSeriesNotesComponent.ɵfac = function NavigatorSeriesNotesComponent_Factory(t) { return new (t || NavigatorSeriesNotesComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    NavigatorSeriesNotesComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: NavigatorSeriesNotesComponent, selectors: [[\"kendo-chart-navigator-series-item-notes\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function NavigatorSeriesNotesComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    NavigatorSeriesNotesComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], NavigatorSeriesNotesComponent);\n    return NavigatorSeriesNotesComponent;\n})();\nlet fesm2015_NavigatorSeriesNotesIconComponent = /*@__PURE__*/ (() => {\n    /**\n     * The icon of the notes.\n     */\n    let NavigatorSeriesNotesIconComponent = class NavigatorSeriesNotesIconComponent extends fesm2015_SeriesNotesIconComponent {\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    NavigatorSeriesNotesIconComponent.ɵfac = function NavigatorSeriesNotesIconComponent_Factory(t) { return new (t || NavigatorSeriesNotesIconComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    NavigatorSeriesNotesIconComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: NavigatorSeriesNotesIconComponent, selectors: [[\"kendo-chart-navigator-series-item-notes-icon\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function NavigatorSeriesNotesIconComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    NavigatorSeriesNotesIconComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], NavigatorSeriesNotesIconComponent);\n    return NavigatorSeriesNotesIconComponent;\n})();\nlet fesm2015_NavigatorSeriesNotesLabelComponent = /*@__PURE__*/ (() => {\n    /**\n     * The label of the notes.\n     */\n    let NavigatorSeriesNotesLabelComponent = class NavigatorSeriesNotesLabelComponent extends fesm2015_SeriesNotesLabelComponent {\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    NavigatorSeriesNotesLabelComponent.ɵfac = function NavigatorSeriesNotesLabelComponent_Factory(t) { return new (t || NavigatorSeriesNotesLabelComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    NavigatorSeriesNotesLabelComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: NavigatorSeriesNotesLabelComponent, selectors: [[\"kendo-chart-navigator-series-item-notes-label\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function NavigatorSeriesNotesLabelComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    NavigatorSeriesNotesLabelComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], NavigatorSeriesNotesLabelComponent);\n    return NavigatorSeriesNotesLabelComponent;\n})();\nlet fesm2015_NavigatorSeriesOutliersComponent = /*@__PURE__*/ (() => {\n    /**\n     * The outliers configuration of the StockChart navigator series. Applies to mild outliers.\n     */\n    let NavigatorSeriesOutliersComponent = class NavigatorSeriesOutliersComponent extends fesm2015_SeriesOutliersComponent {\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    NavigatorSeriesOutliersComponent.ɵfac = function NavigatorSeriesOutliersComponent_Factory(t) { return new (t || NavigatorSeriesOutliersComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    NavigatorSeriesOutliersComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: NavigatorSeriesOutliersComponent, selectors: [[\"kendo-chart-navigator-series-item-outliers\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function NavigatorSeriesOutliersComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    NavigatorSeriesOutliersComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], NavigatorSeriesOutliersComponent);\n    return NavigatorSeriesOutliersComponent;\n})();\nlet fesm2015_NavigatorSeriesTooltipComponent = /*@__PURE__*/ (() => {\n    /**\n     * The tooltip configuration of the StockChart navigator series.\n     * The StockChart navigator series tooltip is displayed when the `navigator.series.tooltip.visible` option is set to `true`.\n     */\n    let NavigatorSeriesTooltipComponent = class NavigatorSeriesTooltipComponent extends fesm2015_SeriesTooltipComponent {\n        constructor(configurationService) {\n            super(configurationService);\n            this.configurationService = configurationService;\n        }\n    };\n    NavigatorSeriesTooltipComponent.ɵfac = function NavigatorSeriesTooltipComponent_Factory(t) { return new (t || NavigatorSeriesTooltipComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService)); };\n    NavigatorSeriesTooltipComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: NavigatorSeriesTooltipComponent, selectors: [[\"kendo-chart-navigator-series-item-tooltip\"]], features: [core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 0, vars: 0, template: function NavigatorSeriesTooltipComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });\n    NavigatorSeriesTooltipComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService])\n    ], NavigatorSeriesTooltipComponent);\n    return NavigatorSeriesTooltipComponent;\n})();\n/**\n * @hidden\n */\nconst STOCK_CHART_DIRECTIVES = [\n    fesm2015_StockChartComponent,\n    fesm2015_NavigatorComponent,\n    fesm2015_NavigatorCategoryAxisComponent,\n    fesm2015_NavigatorCategoryAxisCrosshairComponent,\n    fesm2015_NavigatorCategoryAxisCrosshairTooltipComponent,\n    fesm2015_NavigatorCategoryAxisLabelsComponent,\n    fesm2015_NavigatorCategoryAxisNotesComponent,\n    fesm2015_NavigatorCategoryAxisNotesIconComponent,\n    fesm2015_NavigatorCategoryAxisNotesLabelComponent,\n    fesm2015_NavigatorCategoryAxisSelectComponent,\n    fesm2015_NavigatorCategoryAxisTitleComponent,\n    fesm2015_NavigatorHintComponent,\n    fesm2015_NavigatorPaneComponent,\n    fesm2015_NavigatorPaneTitleComponent,\n    fesm2015_NavigatorSelectComponent,\n    fesm2015_NavigatorSeriesComponent,\n    fesm2015_NavigatorSeriesItemComponent,\n    fesm2015_NavigatorSeriesErrorBarsComponent,\n    fesm2015_NavigatorSeriesExtremesComponent,\n    fesm2015_NavigatorSeriesHighlightComponent,\n    fesm2015_NavigatorSeriesLabelsComponent,\n    fesm2015_NavigatorSeriesLabelsFromComponent,\n    fesm2015_NavigatorSeriesLabelsToComponent,\n    fesm2015_NavigatorSeriesMarkersComponent,\n    fesm2015_NavigatorSeriesNotesComponent,\n    fesm2015_NavigatorSeriesNotesIconComponent,\n    fesm2015_NavigatorSeriesNotesLabelComponent,\n    fesm2015_NavigatorSeriesOutliersComponent,\n    fesm2015_NavigatorSeriesTooltipComponent\n];\nlet fesm2015_SparklineComponent = /*@__PURE__*/ (() => {\n    /* tslint:disable:no-access-missing-member */\n    /**\n     * The root Chart component.\n     *\n     * @example\n     * ```ts\n     * import { Component } from '@angular/core';\n     *\n     * _@Component({\n     *   selector: 'my-app',\n     *   template: `\n     *     <kendo-sparkline [data]=\"data\" type=\"column\">\n     *     </kendo-sparkline>\n     *   `\n     * })\n     * class AppComponent {\n     *   public data: any[] = [\n     *     936, 968, 1025, 999, 998, 1014, 1017, 1010, 1010, 1007,\n     *     1004, 988, 990, 988, 987, 995, 946, 954, 991, 984,\n     *     974, 956, 986, 936, 955, 1021, 1013, 1005, 958, 953,\n     *     952, 940, 937, 980, 966, 965, 928, 916, 910, 980\n     *   ];\n     * }\n     *\n     * ```\n     */\n    let SparklineComponent = class SparklineComponent extends fesm2015_ChartComponent {\n        constructor(configurationService, themeService, element, intl, localizationService, ngZone, instanceEventService, changeDetector, renderer) {\n            super(configurationService, themeService, element, intl, localizationService, ngZone, instanceEventService, changeDetector, renderer);\n            this.configurationService = configurationService;\n            this.themeService = themeService;\n            this.element = element;\n            this.intl = intl;\n            this.localizationService = localizationService;\n            this.ngZone = ngZone;\n            this.instanceEventService = instanceEventService;\n            this.changeDetector = changeDetector;\n            this.renderer = renderer;\n            /**\n             * @hidden\n             */\n            this.tooltipWrapperClass = 'k-sparkline-tooltip-wrapper';\n            /**\n             * @hidden\n             */\n            this.tooltipContentClasses = {\n                'k-sparkline-tooltip': true\n            };\n            this.hostClasses = ['k-sparkline', 'k-widget'];\n            validatePackage(dist_fesm2015_packageMetadata);\n        }\n        createInstance(element, observer) {\n            this.instance = new sparkline(element, sparkline.normalizeOptions(this.options), this.theme, {\n                intlService: this.intl,\n                observer: observer,\n                rtl: this.rtl,\n                sender: this\n            });\n        }\n        updateOptions() {\n            this.instance.setOptions(sparkline.normalizeOptions(this.options));\n        }\n    };\n    SparklineComponent.ɵfac = function SparklineComponent_Factory(t) { return new (t || SparklineComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ConfigurationService), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_ThemeService), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_IntlService), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_LocalizationService), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */]), core[\"Pb\" /* ɵɵdirectiveInject */](fesm2015_InstanceEventService), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"h\" /* ChangeDetectorRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"G\" /* Renderer2 */])); };\n    SparklineComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: SparklineComponent, selectors: [[\"kendo-sparkline\"]], inputs: { type: \"type\", data: \"data\" }, exportAs: [\"kendoSparkline\"], features: [core[\"Bb\" /* ɵɵProvidersFeature */]([\n                fesm2015_ConfigurationService,\n                fesm2015_TooltipTemplateService,\n                fesm2015_InstanceEventService,\n                fesm2015_LocalizationService,\n                {\n                    provide: L10N_PREFIX,\n                    useValue: 'kendo.chart'\n                }\n            ]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]], decls: 5, vars: 5, consts: [[1, \"k-chart-surface\"], [\"surface\", \"\"], [3, \"popupSettings\"], [3, \"animate\", \"wrapperClass\", \"classNames\", \"popupSettings\", \"leave\"], [3, \"resize\"]], template: function SparklineComponent_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"Qb\" /* ɵɵelement */](0, \"span\", 0, 1);\n                core[\"Qb\" /* ɵɵelement */](2, \"kendo-chart-crosshair-tooltips-container\", 2);\n                core[\"Vb\" /* ɵɵelementStart */](3, \"kendo-chart-tooltip-popup\", 3);\n                core[\"gc\" /* ɵɵlistener */](\"leave\", function SparklineComponent_Template_kendo_chart_tooltip_popup_leave_3_listener($event) { return ctx.tooltipMouseleave($event); });\n                core[\"Ub\" /* ɵɵelementEnd */]();\n                core[\"Vb\" /* ɵɵelementStart */](4, \"kendo-resize-sensor\", 4);\n                core[\"gc\" /* ɵɵlistener */](\"resize\", function SparklineComponent_Template_kendo_resize_sensor_resize_4_listener($event) { return ctx.onResize($event); });\n                core[\"Ub\" /* ɵɵelementEnd */]();\n            }\n            if (rf & 2) {\n                core[\"Cb\" /* ɵɵadvance */](2);\n                core[\"pc\" /* ɵɵproperty */](\"popupSettings\", ctx.popupSettings);\n                core[\"Cb\" /* ɵɵadvance */](1);\n                core[\"pc\" /* ɵɵproperty */](\"animate\", false)(\"wrapperClass\", ctx.tooltipWrapperClass)(\"classNames\", ctx.tooltipContentClasses)(\"popupSettings\", ctx.popupSettings);\n            }\n        }, directives: [fesm2015_CrosshairTooltipsContainerComponent, fesm2015_TooltipPopupComponent, fesm2015_ResizeSensorComponent], encapsulation: 2, changeDetection: 0 });\n    SparklineComponent = __decorate([__metadata(\"design:paramtypes\", [fesm2015_ConfigurationService,\n            fesm2015_ThemeService,\n            core[\"l\" /* ElementRef */],\n            fesm2015_IntlService,\n            fesm2015_LocalizationService,\n            core[\"B\" /* NgZone */],\n            fesm2015_InstanceEventService,\n            core[\"h\" /* ChangeDetectorRef */],\n            core[\"G\" /* Renderer2 */]])\n    ], SparklineComponent);\n    return SparklineComponent;\n})();\n/**\n * @hidden\n */\nconst SPARKLINE_DIRECTIVES = [\n    fesm2015_SparklineComponent\n];\nlet fesm2015_ChartModule = /*@__PURE__*/ (() => {\n    /**\n     * A [module]({{ site.data.urls.angular['ngmoduleapi'] }}) that includes the Chart component and directives.\n     *\n     * Imports the ChartModule into your application\n     * [root module]({{ site.data.url.angular['ngmodules'] }}#angular-modularity) or any other sub-module\n     * that will use the Chart component.\n     *\n     * @example\n     * ```ts-no-run\n     * import { NgModule } from '@angular/core';\n     * import { BrowserModule } from '@angular/platform-browser';\n     * import { ChartModule } from '@progress/kendo-angular-charts';\n     * import { AppComponent } from './app.component';\n     *\n     * _@NgModule({\n     *     bootstrap:    [AppComponent],\n     *     declarations: [AppComponent],\n     *     imports:      [BrowserModule, ChartModule]\n     * })\n     * export class AppModule {\n     * }\n     * ```\n     */\n    let ChartModule = class ChartModule {\n    };\n    ChartModule.ɵmod = core[\"Nb\" /* ɵɵdefineNgModule */]({ type: ChartModule });\n    ChartModule.ɵinj = core[\"Mb\" /* ɵɵdefineInjector */]({ factory: function ChartModule_Factory(t) { return new (t || ChartModule)(); }, providers: [\n            fesm2015_ThemeService\n        ], imports: [[common[\"c\" /* CommonModule */], fesm2015_PopupModule, fesm2015_ResizeSensorModule]] });\n    return ChartModule;\n})();\nlet fesm2015_StockChartModule = /*@__PURE__*/ (() => {\n    /**\n     * A [module]({{ site.data.urls.angular['ngmoduleapi'] }}) that includes the StockChart component and directives.\n     *\n     * Imports the StockChartModule into your application\n     * [root module]({{ site.data.urls.angular['ngmodules'] }}#angular-modularity) or any other sub-module\n     * that will use the StockChart component.\n     *\n     * @example\n     * ```ts-no-run\n     * import { NgModule } from '@angular/core';\n     * import { BrowserModule } from '@angular/platform-browser';\n     * import { StockChartModule } from '@progress/kendo-angular-charts';\n     * import { AppComponent } from './app.component';\n     *\n     * _@NgModule({\n     *     bootstrap:    [AppComponent],\n     *     declarations: [AppComponent],\n     *     imports:      [BrowserModule, StockChartModule]\n     * })\n     * export class AppModule {\n     * }\n     * ```\n     */\n    let StockChartModule = class StockChartModule {\n    };\n    StockChartModule.ɵmod = core[\"Nb\" /* ɵɵdefineNgModule */]({ type: StockChartModule });\n    StockChartModule.ɵinj = core[\"Mb\" /* ɵɵdefineInjector */]({ factory: function StockChartModule_Factory(t) { return new (t || StockChartModule)(); }, imports: [[fesm2015_ChartModule, common[\"c\" /* CommonModule */], fesm2015_PopupModule, fesm2015_ResizeSensorModule], fesm2015_ChartModule] });\n    return StockChartModule;\n})();\nlet fesm2015_SparklineModule = /*@__PURE__*/ (() => {\n    /**\n     * A [module]({{ site.data.urls.angular['ngmoduleapi'] }}) that includes the Sparkline component and directives.\n     *\n     * Imports the SparklineModule into your application\n     * [root module]({{ site.data.urls.angular['ngmodules'] }}#angular-modularity) or any other sub-module\n     * that will use the Sparkline component.\n     *\n     * @example\n     * ```ts-no-run\n     * import { NgModule } from '@angular/core';\n     * import { BrowserModule } from '@angular/platform-browser';\n     * import { SparklineModule } from '@progress/kendo-angular-charts';\n     * import { AppComponent } from './app.component';\n     *\n     * _@NgModule({\n     *     bootstrap:    [AppComponent],\n     *     declarations: [AppComponent],\n     *     imports:      [BrowserModule, SparklineModule]\n     * })\n     * export class AppModule {\n     * }\n     * ```\n     */\n    let SparklineModule = class SparklineModule {\n    };\n    SparklineModule.ɵmod = core[\"Nb\" /* ɵɵdefineNgModule */]({ type: SparklineModule });\n    SparklineModule.ɵinj = core[\"Mb\" /* ɵɵdefineInjector */]({ factory: function SparklineModule_Factory(t) { return new (t || SparklineModule)(); }, imports: [[fesm2015_ChartModule, common[\"c\" /* CommonModule */], fesm2015_PopupModule, fesm2015_ResizeSensorModule], fesm2015_ChartModule] });\n    return SparklineModule;\n})();\nlet fesm2015_ChartsModule = /*@__PURE__*/ (() => {\n    /**\n     * A [module]({{ site.data.urls.angular['ngmoduleapi'] }}) that includes all Chart components and directives.\n     *\n     * Imports the ChartsModule into your application\n     * [root module]({{ site.data.urls.angular['ngmodules'] }}#angular-modularity) or any other sub-module\n     * that will use the Charts components.\n     *\n     * @example\n     * ```ts-no-run\n     * import { NgModule } from '@angular/core';\n     * import { BrowserModule } from '@angular/platform-browser';\n     * import { ChartsModule } from '@progress/kendo-angular-charts';\n     * import { AppComponent } from './app.component';\n     *\n     * _@NgModule({\n     *     bootstrap:    [AppComponent],\n     *     declarations: [AppComponent],\n     *     imports:      [BrowserModule, ChartsModule]\n     * })\n     * export class AppModule {\n     * }\n     * ```\n     */\n    let ChartsModule = class ChartsModule {\n    };\n    ChartsModule.ɵmod = core[\"Nb\" /* ɵɵdefineNgModule */]({ type: ChartsModule });\n    ChartsModule.ɵinj = core[\"Mb\" /* ɵɵdefineInjector */]({ factory: function ChartsModule_Factory(t) { return new (t || ChartsModule)(); }, imports: [fesm2015_ChartModule, fesm2015_SparklineModule, fesm2015_StockChartModule] });\n    return ChartsModule;\n})();\nconst ɵRootConfigurationService_BaseFactory = /*@__PURE__*/ core[\"Xb\" /* ɵɵgetInheritedFactory */](fesm2015_RootConfigurationService);\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ec\" /* ɵɵsetNgModuleScope */](fesm2015_ChartModule, { declarations: function () { return [fesm2015_ChartComponent, fesm2015_TooltipPopupComponent, fesm2015_SeriesTooltipTemplateDirective, fesm2015_SharedTooltipTemplateDirective, fesm2015_CrosshairTooltipsContainerComponent, fesm2015_CrosshairTooltipComponent, fesm2015_DonutCenterTemplateDirective, fesm2015_AxisDefaultsComponent, fesm2015_AxisDefaultsCrosshairComponent, fesm2015_AxisDefaultsCrosshairTooltipComponent, fesm2015_AxisDefaultsLabelsComponent, fesm2015_AxisDefaultsTitleComponent, fesm2015_CategoryAxisComponent, fesm2015_CategoryAxisCrosshairComponent, fesm2015_CategoryAxisCrosshairTooltipComponent, fesm2015_CategoryAxisItemComponent, fesm2015_CategoryAxisLabelsComponent, fesm2015_CategoryAxisRangeLabelsComponent, fesm2015_CategoryAxisNotesComponent, fesm2015_CategoryAxisNotesIconComponent, fesm2015_CategoryAxisNotesLabelComponent, fesm2015_CategoryAxisSelectComponent, fesm2015_CategoryAxisTitleComponent, fesm2015_ChartAreaComponent, fesm2015_LegendComponent, fesm2015_LegendInactiveItemsComponent, fesm2015_LegendItemComponent, fesm2015_PaneComponent, fesm2015_PaneDefaultsComponent, fesm2015_PaneDefaultsTitleComponent, fesm2015_PanesComponent, fesm2015_PanesTitleComponent, fesm2015_PlotAreaComponent, fesm2015_SeriesComponent, fesm2015_SeriesDefaultsComponent, fesm2015_SeriesDefaultsLabelsComponent, fesm2015_SeriesDefaultsLabelsFromComponent, fesm2015_SeriesDefaultsLabelsToComponent, fesm2015_SeriesDefaultsNotesComponent, fesm2015_SeriesDefaultsNotesIconComponent, fesm2015_SeriesDefaultsNotesLabelComponent, fesm2015_SeriesDefaultsTooltipComponent, fesm2015_SeriesErrorBarsComponent, fesm2015_SeriesExtremesComponent, fesm2015_SeriesHighlightComponent, fesm2015_SeriesItemComponent, fesm2015_SeriesLabelsComponent, fesm2015_SeriesLabelsFromComponent, fesm2015_SeriesLabelsToComponent, fesm2015_SeriesMarkersComponent, fesm2015_SeriesNotesComponent, fesm2015_SeriesNotesIconComponent, fesm2015_SeriesNotesLabelComponent, fesm2015_SeriesOutliersComponent, fesm2015_SeriesTooltipComponent, fesm2015_TitleComponent, fesm2015_TooltipComponent, fesm2015_ValueAxisComponent, fesm2015_ValueAxisCrosshairComponent, fesm2015_ValueAxisCrosshairTooltipComponent, fesm2015_ValueAxisItemComponent, fesm2015_ValueAxisLabelsComponent, fesm2015_ValueAxisNotesComponent, fesm2015_ValueAxisNotesIconComponent, fesm2015_ValueAxisNotesLabelComponent, fesm2015_ValueAxisTitleComponent, fesm2015_XAxisComponent, fesm2015_XAxisCrosshairComponent, fesm2015_XAxisCrosshairTooltipComponent, fesm2015_XAxisItemComponent, fesm2015_XAxisLabelsComponent, fesm2015_XAxisNotesComponent, fesm2015_XAxisNotesIconComponent, fesm2015_XAxisNotesLabelComponent, fesm2015_XAxisTitleComponent, fesm2015_YAxisComponent, fesm2015_YAxisCrosshairComponent, fesm2015_YAxisCrosshairTooltipComponent, fesm2015_YAxisItemComponent, fesm2015_YAxisLabelsComponent, fesm2015_YAxisNotesComponent, fesm2015_YAxisNotesIconComponent, fesm2015_YAxisNotesLabelComponent, fesm2015_YAxisTitleComponent, fesm2015_ZoomableComponent]; }, imports: function () { return [common[\"c\" /* CommonModule */], fesm2015_PopupModule, fesm2015_ResizeSensorModule]; }, exports: function () { return [fesm2015_ChartComponent, fesm2015_TooltipPopupComponent, fesm2015_SeriesTooltipTemplateDirective, fesm2015_SharedTooltipTemplateDirective, fesm2015_CrosshairTooltipsContainerComponent, fesm2015_CrosshairTooltipComponent, fesm2015_DonutCenterTemplateDirective, fesm2015_AxisDefaultsComponent, fesm2015_AxisDefaultsCrosshairComponent, fesm2015_AxisDefaultsCrosshairTooltipComponent, fesm2015_AxisDefaultsLabelsComponent, fesm2015_AxisDefaultsTitleComponent, fesm2015_CategoryAxisComponent, fesm2015_CategoryAxisCrosshairComponent, fesm2015_CategoryAxisCrosshairTooltipComponent, fesm2015_CategoryAxisItemComponent, fesm2015_CategoryAxisLabelsComponent, fesm2015_CategoryAxisRangeLabelsComponent, fesm2015_CategoryAxisNotesComponent, fesm2015_CategoryAxisNotesIconComponent, fesm2015_CategoryAxisNotesLabelComponent, fesm2015_CategoryAxisSelectComponent, fesm2015_CategoryAxisTitleComponent, fesm2015_ChartAreaComponent, fesm2015_LegendComponent, fesm2015_LegendInactiveItemsComponent, fesm2015_LegendItemComponent, fesm2015_PaneComponent, fesm2015_PaneDefaultsComponent, fesm2015_PaneDefaultsTitleComponent, fesm2015_PanesComponent, fesm2015_PanesTitleComponent, fesm2015_PlotAreaComponent, fesm2015_SeriesComponent, fesm2015_SeriesDefaultsComponent, fesm2015_SeriesDefaultsLabelsComponent, fesm2015_SeriesDefaultsLabelsFromComponent, fesm2015_SeriesDefaultsLabelsToComponent, fesm2015_SeriesDefaultsNotesComponent, fesm2015_SeriesDefaultsNotesIconComponent, fesm2015_SeriesDefaultsNotesLabelComponent, fesm2015_SeriesDefaultsTooltipComponent, fesm2015_SeriesErrorBarsComponent, fesm2015_SeriesExtremesComponent, fesm2015_SeriesHighlightComponent, fesm2015_SeriesItemComponent, fesm2015_SeriesLabelsComponent, fesm2015_SeriesLabelsFromComponent, fesm2015_SeriesLabelsToComponent, fesm2015_SeriesMarkersComponent, fesm2015_SeriesNotesComponent, fesm2015_SeriesNotesIconComponent, fesm2015_SeriesNotesLabelComponent, fesm2015_SeriesOutliersComponent, fesm2015_SeriesTooltipComponent, fesm2015_TitleComponent, fesm2015_TooltipComponent, fesm2015_ValueAxisComponent, fesm2015_ValueAxisCrosshairComponent, fesm2015_ValueAxisCrosshairTooltipComponent, fesm2015_ValueAxisItemComponent, fesm2015_ValueAxisLabelsComponent, fesm2015_ValueAxisNotesComponent, fesm2015_ValueAxisNotesIconComponent, fesm2015_ValueAxisNotesLabelComponent, fesm2015_ValueAxisTitleComponent, fesm2015_XAxisComponent, fesm2015_XAxisCrosshairComponent, fesm2015_XAxisCrosshairTooltipComponent, fesm2015_XAxisItemComponent, fesm2015_XAxisLabelsComponent, fesm2015_XAxisNotesComponent, fesm2015_XAxisNotesIconComponent, fesm2015_XAxisNotesLabelComponent, fesm2015_XAxisTitleComponent, fesm2015_YAxisComponent, fesm2015_YAxisCrosshairComponent, fesm2015_YAxisCrosshairTooltipComponent, fesm2015_YAxisItemComponent, fesm2015_YAxisLabelsComponent, fesm2015_YAxisNotesComponent, fesm2015_YAxisNotesIconComponent, fesm2015_YAxisNotesLabelComponent, fesm2015_YAxisTitleComponent, fesm2015_ZoomableComponent]; } }); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ec\" /* ɵɵsetNgModuleScope */](fesm2015_StockChartModule, { declarations: function () { return [fesm2015_StockChartComponent, fesm2015_NavigatorComponent, fesm2015_NavigatorCategoryAxisComponent, fesm2015_NavigatorCategoryAxisCrosshairComponent, fesm2015_NavigatorCategoryAxisCrosshairTooltipComponent, fesm2015_NavigatorCategoryAxisLabelsComponent, fesm2015_NavigatorCategoryAxisNotesComponent, fesm2015_NavigatorCategoryAxisNotesIconComponent, fesm2015_NavigatorCategoryAxisNotesLabelComponent, fesm2015_NavigatorCategoryAxisSelectComponent, fesm2015_NavigatorCategoryAxisTitleComponent, fesm2015_NavigatorHintComponent, fesm2015_NavigatorPaneComponent, fesm2015_NavigatorPaneTitleComponent, fesm2015_NavigatorSelectComponent, fesm2015_NavigatorSeriesComponent, fesm2015_NavigatorSeriesItemComponent, fesm2015_NavigatorSeriesErrorBarsComponent, fesm2015_NavigatorSeriesExtremesComponent, fesm2015_NavigatorSeriesHighlightComponent, fesm2015_NavigatorSeriesLabelsComponent, fesm2015_NavigatorSeriesLabelsFromComponent, fesm2015_NavigatorSeriesLabelsToComponent, fesm2015_NavigatorSeriesMarkersComponent, fesm2015_NavigatorSeriesNotesComponent, fesm2015_NavigatorSeriesNotesIconComponent, fesm2015_NavigatorSeriesNotesLabelComponent, fesm2015_NavigatorSeriesOutliersComponent, fesm2015_NavigatorSeriesTooltipComponent]; }, imports: function () { return [fesm2015_ChartModule, common[\"c\" /* CommonModule */], fesm2015_PopupModule, fesm2015_ResizeSensorModule]; }, exports: function () { return [fesm2015_StockChartComponent, fesm2015_NavigatorComponent, fesm2015_NavigatorCategoryAxisComponent, fesm2015_NavigatorCategoryAxisCrosshairComponent, fesm2015_NavigatorCategoryAxisCrosshairTooltipComponent, fesm2015_NavigatorCategoryAxisLabelsComponent, fesm2015_NavigatorCategoryAxisNotesComponent, fesm2015_NavigatorCategoryAxisNotesIconComponent, fesm2015_NavigatorCategoryAxisNotesLabelComponent, fesm2015_NavigatorCategoryAxisSelectComponent, fesm2015_NavigatorCategoryAxisTitleComponent, fesm2015_NavigatorHintComponent, fesm2015_NavigatorPaneComponent, fesm2015_NavigatorPaneTitleComponent, fesm2015_NavigatorSelectComponent, fesm2015_NavigatorSeriesComponent, fesm2015_NavigatorSeriesItemComponent, fesm2015_NavigatorSeriesErrorBarsComponent, fesm2015_NavigatorSeriesExtremesComponent, fesm2015_NavigatorSeriesHighlightComponent, fesm2015_NavigatorSeriesLabelsComponent, fesm2015_NavigatorSeriesLabelsFromComponent, fesm2015_NavigatorSeriesLabelsToComponent, fesm2015_NavigatorSeriesMarkersComponent, fesm2015_NavigatorSeriesNotesComponent, fesm2015_NavigatorSeriesNotesIconComponent, fesm2015_NavigatorSeriesNotesLabelComponent, fesm2015_NavigatorSeriesOutliersComponent, fesm2015_NavigatorSeriesTooltipComponent, fesm2015_ChartModule]; } }); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ec\" /* ɵɵsetNgModuleScope */](fesm2015_SparklineModule, { declarations: function () { return [fesm2015_SparklineComponent]; }, imports: function () { return [fesm2015_ChartModule, common[\"c\" /* CommonModule */], fesm2015_PopupModule, fesm2015_ResizeSensorModule]; }, exports: function () { return [fesm2015_SparklineComponent, fesm2015_ChartModule]; } }); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ec\" /* ɵɵsetNgModuleScope */](fesm2015_ChartsModule, { exports: [fesm2015_ChartModule, fesm2015_SparklineModule, fesm2015_StockChartModule] }); })();\nconst ɵStockInstanceEventService_BaseFactory = /*@__PURE__*/ core[\"Xb\" /* ɵɵgetInheritedFactory */](fesm2015_StockInstanceEventService);\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Z3BDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7d0pBQUU7QUFDRixtQ0FFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NEhBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzZKQUFFO0FBQ0YsMkNBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OytJQUFFO0FBQ0YsZ0NBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztvSUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzRqRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt3SEFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzswU0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O29MQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O29PQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FPRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Z0lBQUU7QUFDRiwyQkFFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzhKQUcyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O21LQUFFO0FBQ0YsNkNBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzttS0FBRTtBQUNGLDZDQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7bUVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lNQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQXlDRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7MkRBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FlRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7c0ZBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQVN3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsrTUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkEyQkc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7a2hCQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzsyU0FBRTtBQUNGLG9DQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7d1NBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2dWQUFFO0FBQ0YsNkNBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt3VUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NldBQUU7QUFDRixvREFNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O29YQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O29VQUFFO0FBQ0YsMENBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs4WEFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztnVUFBRTtBQUNGLHlDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzttRkFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzA0QkFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7dVpBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQU9HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OzBEQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzsyVkFBRTtBQUNGLG9DQU9HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt3U0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7cVZBQUU7QUFDRiw2Q0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3dVQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7a1hBQUU7QUFDRixvREFNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzJwQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs4VkFBRTtBQUNGLCtDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Z1JBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztxVUFBRTtBQUNGLHlDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7a1JBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7c1ZBQUU7QUFDRiw2Q0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3dXQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7MFZBQUU7QUFDRiw4Q0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzBQQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt5VUFBRTtBQUNGLDBDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OFhBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7cVVBQUU7QUFDRix5Q0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2tSQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3lSQUFFO0FBQ0YsaUNBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztzaEJBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztrUkFBRTtBQUNGLDhCQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7b01BQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7d1VBQUU7QUFDRiwyQ0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O29NQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7bVNBQUU7QUFDRixrQ0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7b1NBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt5VkFBRTtBQUNGLDRCQU9HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3liQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O29lQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OzBEQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs4VEFBRTtBQUNGLDZCQU9HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztzVUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2tTQUFFO0FBQ0Ysa0NBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztrUUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7MlJBQUU7QUFDRixnQ0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OzswREFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2tVQUFFO0FBQ0YsOEJBT0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NFdBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzttVEFBRTtBQUNGLHNDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7d1lBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzRVQUFFO0FBQ0YsNENBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztzV0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NlZBQUU7QUFDRixnREFNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2tXQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztxVkFBRTtBQUNGLDhDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Z1BBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3dVQUFFO0FBQ0YsMkNBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztzUkFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt5VkFBRTtBQUNGLCtDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NFdBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs2VkFBRTtBQUNGLGdEQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7MFRBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Z1ZBQUU7QUFDRiw2Q0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2tTQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzZUQUFFO0FBQ0YsdUNBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztzUUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7d1RBQUU7QUFDRixzQ0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzBUQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs0VEFBRTtBQUNGLHVDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7MGNBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztnVEFBRTtBQUNGLG9DQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NFdBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7aVVBQUU7QUFDRix3Q0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3dXQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3lUQUFFO0FBQ0Ysc0NBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztrVUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztvVEFBRTtBQUNGLHFDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7c1BBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs0U0FBRTtBQUNGLG1DQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7c1FBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NlRBQUU7QUFDRix1Q0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzRWQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7aVVBQUU7QUFDRix3Q0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3NRQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt3VEFBRTtBQUNGLHNDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OFVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzhRQUFFO0FBQ0YsNkJBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztvVUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OzswSkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFLRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztzcEJBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzttV0FBRTtBQUNGLHFDQU9HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7MERBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OytVQUFFO0FBQ0YsaUNBT0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzRRQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7eVVBQUU7QUFDRiwwQ0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2tVQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7c1dBQUU7QUFDRixpREFNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2djQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NlRBQUU7QUFDRix1Q0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzBRQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7eVRBQUU7QUFDRixzQ0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzRRQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzBVQUFFO0FBQ0YsMENBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztrV0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzhVQUFFO0FBQ0YsMkNBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt3WEFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt5VEFBRTtBQUNGLHNDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzR0QkFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzttVkFBRTtBQUNGLGlDQU9HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OzBEQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7K1RBQUU7QUFDRiw2QkFPRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7b1FBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3lUQUFFO0FBQ0Ysc0NBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzswVEFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3NWQUFFO0FBQ0YsNkNBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt3ZUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs2U0FBRTtBQUNGLG1DQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7a1FBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3lTQUFFO0FBQ0Ysa0NBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztvUUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzswVEFBRTtBQUNGLHNDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7MFZBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs4VEFBRTtBQUNGLHVDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Z1hBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7eVNBQUU7QUFDRixrQ0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7b3FCQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O21WQUFFO0FBQ0YsaUNBT0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OzswREFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OytUQUFFO0FBQ0YsNkJBT0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O29RQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt5VEFBRTtBQUNGLHNDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7MFRBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztzVkFBRTtBQUNGLDZDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7d2VBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NlNBQUU7QUFDRixtQ0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2tRQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt5U0FBRTtBQUNGLGtDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7b1FBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7MFRBQUU7QUFDRixzQ0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzBWQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OFRBQUU7QUFDRix1Q0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2dYQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3lTQUFFO0FBQ0Ysa0NBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs4TUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7MFJBQUU7QUFDRixnQ0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O29LQUc2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzJJQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3lKQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0F5Qkc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7MEtBQUU7QUFDRix5Q0FFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzhpQkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQU9HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozt5TEFBRTtBQUNGLDZDQWFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3FYQUFFO0FBQ0Ysc0RBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2taQUFFO0FBQ0YsNkRBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt5V0FBRTtBQUNGLG1EQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7cVdBQUU7QUFDRixrREFNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3NYQUFFO0FBQ0Ysc0RBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzswWEFBRTtBQUNGLHVEQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7eVdBQUU7QUFDRixtREFNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3FXQUFFO0FBQ0Ysa0RBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3FYQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3NjQUFFO0FBQ0YscUNBT0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztvVUFBRTtBQUNGLDBDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztxWEFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzJYQUFFO0FBQ0YsMkNBT0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7c09BQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQU9HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2tXQUFFO0FBQ0YsZ0RBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs2VkFBRTtBQUNGLCtDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7aVdBQUU7QUFDRixnREFNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7cVZBQUU7QUFDRiw2Q0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7c1dBQUU7QUFDRixpREFNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OFZBQUU7QUFDRiwrQ0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3lWQUFFO0FBQ0YsOENBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztpVkFBRTtBQUNGLDRDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7a1dBQUU7QUFDRixnREFNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3NXQUFFO0FBQ0YsaURBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs2VkFBRTtBQUNGLCtDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt5VkFBRTtBQUNGLDhDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUpBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBeUJHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O3FFQVVnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzttT0FPcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Z09BT29CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3FIQUtpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiBDb3B5cmlnaHQgwqkgMjAyMCBQcm9ncmVzcyBTb2Z0d2FyZSBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiogTGljZW5zZWQgdW5kZXIgY29tbWVyY2lhbCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBpbiB0aGUgcHJvamVjdCByb290IGZvciBtb3JlIGluZm9ybWF0aW9uXG4qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBfX2RlY29yYXRlLCBfX21ldGFkYXRhLCBfX3BhcmFtIH0gZnJvbSAndHNsaWInO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0LCBJbmplY3RhYmxlLCBOZ1pvbmUsIERpcmVjdGl2ZSwgT3B0aW9uYWwsIFRlbXBsYXRlUmVmLCBTaW1wbGVDaGFuZ2UsIENvbnRlbnRDaGlsZCwgQ29tcG9uZW50LCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgRWxlbWVudFJlZiwgVmlld0NoaWxkLCBWaWV3Q2hpbGRyZW4sIFF1ZXJ5TGlzdCwgaXNEZXZNb2RlLCBDb250ZW50Q2hpbGRyZW4sIENoYW5nZURldGVjdG9yUmVmLCBSZW5kZXJlcjIsIEluamVjdCwgTE9DQUxFX0lELCBJbmplY3Rpb25Ub2tlbiwgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgU3ViamVjdCwgY29tYmluZUxhdGVzdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgYXVkaXRUaW1lLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyB2YWxpZGF0ZVBhY2thZ2UgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tbGljZW5zaW5nJztcbmltcG9ydCB7IGNoYXJ0QmFzZVRoZW1lLCBJbnN0YW5jZU9ic2VydmVyLCBEYXRlQ2F0ZWdvcnlBeGlzLCBEYXRlVmFsdWVBeGlzLCBEb21FdmVudHNCdWlsZGVyLCBDaGFydCwgU3RvY2tDaGFydCwgU3BhcmtsaW5lIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWNoYXJ0cyc7XG5pbXBvcnQgeyBpc0RvY3VtZW50QXZhaWxhYmxlLCBSZXNpemVTZW5zb3JNb2R1bGUgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1jb21tb24nO1xuZXhwb3J0IHsgUmVzaXplU2Vuc29yQ29tcG9uZW50IH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItY29tbW9uJztcbmltcG9ydCB7IFBvcHVwU2VydmljZSwgUE9QVVBfQ09OVEFJTkVSLCBQb3B1cE1vZHVsZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLXBvcHVwJztcbmV4cG9ydCB7IFBvcHVwQ29tcG9uZW50IH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItcG9wdXAnO1xuaW1wb3J0IHsgTG9jYWxpemF0aW9uU2VydmljZSwgTDEwTl9QUkVGSVggfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1sMTBuJztcbmltcG9ydCB7IEludGxTZXJ2aWNlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItaW50bCc7XG5pbXBvcnQgeyBleHBvcnRJbWFnZSwgZXhwb3J0U1ZHIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWRyYXdpbmcnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IHBhY2thZ2VNZXRhZGF0YSA9IHtcbiAgICBuYW1lOiAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItY2hhcnRzJyxcbiAgICBwcm9kdWN0TmFtZTogJ0tlbmRvIFVJIGZvciBBbmd1bGFyJyxcbiAgICBwcm9kdWN0Q29kZXM6IFsnS0VORE9VSUFOR1VMQVInLCAnS0VORE9VSUNPTVBMRVRFJ10sXG4gICAgcHVibGlzaERhdGU6IDE2MjAyMTMwOTksXG4gICAgdmVyc2lvbjogJycsXG4gICAgbGljZW5zaW5nRG9jc1VybDogJ2h0dHBzOi8vd3d3LnRlbGVyaWsuY29tL2tlbmRvLWFuZ3VsYXItdWkvbXktbGljZW5zZS8/dXRtX21lZGl1bT1wcm9kdWN0JnV0bV9zb3VyY2U9a2VuZG9hbmd1bGFyJnV0bV9jYW1wYWlnbj1rZW5kby11aS1hbmd1bGFyLXB1cmNoYXNlLWxpY2Vuc2Uta2V5cy13YXJuaW5nJ1xufTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIENoYXJ0Q29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBhbiBheGlzIGxhYmVsIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgb3ZlcnZpZXdfY2hhcnRfY2hhcnRzICV9I3RvYy1ldmVudHMpKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXhpc0xhYmVsQ2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBhcyBsb25nIGFzIHRoZSB1c2VyIGlzIGRyYWdnaW5nIHRoZSBDaGFydCB3aXRoIHRoZSBtb3VzZSBvciB0aHJvdWdoIHN3aXBlIGdlc3R1cmVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcmFnID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBzdG9wcyBkcmFnZ2luZyB0aGUgQ2hhcnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRyYWdFbmQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgQ2hhcnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRyYWdTdGFydCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgaG92ZXJzIG92ZXIgYSBsZWdlbmQgaXRlbSAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIG92ZXJ2aWV3X2NoYXJ0X2NoYXJ0cyAlfSN0b2MtZXZlbnRzKSkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxlZ2VuZEl0ZW1Ib3ZlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGN1cnNvciBsZWF2ZXMgYSBsZWdlbmQgaXRlbS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGVnZW5kSXRlbUxlYXZlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBjbGlja3MgYSBub3RlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ub3RlQ2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIGhvdmVycyBvdmVyIGEgbm90ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubm90ZUhvdmVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgY3Vyc29yIGxlYXZlcyBhIG5vdGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vdGVMZWF2ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gYSBwYW5lIGlzIHJlbmRlcmVkIGJlY2F1c2UgdGhlIENoYXJ0OlxuICAgICAgICAgKiAqIElzIHJlbmRlcmVkLlxuICAgICAgICAgKiAqIFBlcmZvcm1zIHBhbm5pbmcgb3Igem9vbWluZy5cbiAgICAgICAgICogKiBJcyBleHBvcnRlZCB3aXRoIGRpZmZlcmVudCBvcHRpb25zLlxuICAgICAgICAgKiBUaGUgZXZlbnQgaXMgdXNlZCB0byByZW5kZXIgY3VzdG9tIHZpc3VhbHMgaW4gdGhlIHBhbmVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYW5lUmVuZGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlIHBsb3QgYXJlYSAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIG92ZXJ2aWV3X2NoYXJ0X2NoYXJ0cyAlfSN0b2MtZXZlbnRzKSkuXG4gICAgICAgICAqIFRoZSBgY2xpY2tgIGV2ZW50IGlzIHRyaWdnZXJlZCBieSB0aGUgYHRhcGAgYW5kIGBjb250ZXh0bWVudWAgZXZlbnRzLlxuICAgICAgICAgKiBUbyBkaXN0aW5ndWlzaCBiZXR3ZWVuIHRoZSBvcmlnaW5hbCBldmVudHMsIGluc3BlY3QgdGhlIGBlLm9yaWdpbmFsRXZlbnQudHlwZWAgZmllbGQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBsb3RBcmVhQ2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIGhvdmVycyB0aGUgcGxvdCBhcmVhIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgb3ZlcnZpZXdfY2hhcnRfY2hhcnRzICV9I3RvYy1ldmVudHMpKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGxvdEFyZWFIb3ZlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGN1cnNvciBsZWF2ZXMgdGhlIHBsb3QgYXJlYS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGxvdEFyZWFMZWF2ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIENoYXJ0IGlzIHJlYWR5IHRvIHJlbmRlciBvbiBzY3JlZW4gKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBvdmVydmlld19jaGFydF9jaGFydHMgJX0jdG9jLWV2ZW50cykpLlxuICAgICAgICAgKiBGb3IgZXhhbXBsZSwgeW91IGNhbiB1c2UgaXQgdG8gcmVtb3ZlIGxvYWRpbmcgaW5kaWNhdG9ycy5cbiAgICAgICAgICogQW55IGNoYW5nZXMgbWFkZSB0byB0aGUgb3B0aW9ucyBhcmUgaWdub3JlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVuZGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBtb2RpZmllcyB0aGUgc2VsZWN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgcmFuZ2UgdW5pdHMgYXJlOlxuICAgICAgICAgKiAtIEdlbmVyaWMgYXhpcyZtZGFzaDtDYXRlZ29yeSBpbmRleCAoMC1iYXNlZCkuXG4gICAgICAgICAqIC0gRGF0ZSBheGlzJm1kYXNoO0RhdGUgaW5zdGFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgY29tcGxldGVzIHRoZSBtb2RpZmljYXRpb24gb2YgdGhlIHNlbGVjdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHJhbmdlIHVuaXRzIGFyZTpcbiAgICAgICAgICogLSBHZW5lcmljIGF4aXMmbWRhc2g7Q2F0ZWdvcnkgaW5kZXggKDAtYmFzZWQpLlxuICAgICAgICAgKiAtIERhdGUgYXhpcyZtZGFzaDtEYXRlIGluc3RhbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3RFbmQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBtb2RpZnlpbmcgdGhlIGF4aXMgc2VsZWN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgcmFuZ2UgdW5pdHMgYXJlOlxuICAgICAgICAgKiAtIEdlbmVyaWMgYXhpcyZtZGFzaDtDYXRlZ29yeSBpbmRleCAoMC1iYXNlZCkuXG4gICAgICAgICAqIC0gRGF0ZSBheGlzJm1kYXNoO0RhdGUgaW5zdGFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdFN0YXJ0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlIENoYXJ0IHNlcmllcy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGBjbGlja2AgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQgYnkgdGhlIGB0YXBgIGFuZCBgY29udGV4dG1lbnVgIGV2ZW50cyAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIG92ZXJ2aWV3X2NoYXJ0X2NoYXJ0cyAlfSN0b2MtZXZlbnRzKSkuXG4gICAgICAgICAqIFRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gdGhlIG9yaWdpbmFsIGV2ZW50cywgaW5zcGVjdCB0aGUgYGUub3JpZ2luYWxFdmVudC50eXBlYCBmaWVsZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VyaWVzQ2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIGhvdmVycyB0aGUgQ2hhcnQgc2VyaWVzIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgb3ZlcnZpZXdfY2hhcnRfY2hhcnRzICV9I3RvYy1ldmVudHMpKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VyaWVzSG92ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBjdXJzb3IgZW50ZXJzIGEgc2VyaWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXJpZXNPdmVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgY3Vyc29yIGxlYXZlcyBhIHNlcmllcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VyaWVzTGVhdmUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBhcyBsb25nIGFzIHRoZSB1c2VyIGlzIHpvb21pbmcgdGhlIENoYXJ0IGJ5IHVzaW5nIHRoZSBtb3VzZXdoZWVsIG9wZXJhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuem9vbSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgc3RvcHMgem9vbWluZyB0aGUgQ2hhcnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnpvb21FbmQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIHVzZXMgdGhlIG1vdXNld2hlZWwgdG8gem9vbSB0aGUgQ2hhcnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnpvb21TdGFydCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDaGFydENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicGFubmFibGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENoYXJ0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJyZW5kZXJBc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBDaGFydENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwic2VyaWVzQ29sb3JzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDaGFydENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidGl0bGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDaGFydENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidHJhbnNpdGlvbnNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENoYXJ0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ6b29tYWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2hhcnRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImF4aXNEZWZhdWx0c1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2hhcnRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNhdGVnb3J5QXhpc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2hhcnRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNoYXJ0QXJlYVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2hhcnRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImxlZ2VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBDaGFydENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicGFuZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENoYXJ0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwYW5lRGVmYXVsdHNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENoYXJ0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwbG90QXJlYVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBDaGFydENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwic2VyaWVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDaGFydENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwic2VyaWVzRGVmYXVsdHNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENoYXJ0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0b29sdGlwXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDaGFydENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmFsdWVBeGlzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDaGFydENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwieEF4aXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENoYXJ0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ5QXhpc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIENoYXJ0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJheGlzTGFiZWxDbGlja1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIENoYXJ0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJkcmFnXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgQ2hhcnRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImRyYWdFbmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBDaGFydENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZHJhZ1N0YXJ0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgQ2hhcnRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImxlZ2VuZEl0ZW1Ib3ZlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIENoYXJ0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJsZWdlbmRJdGVtTGVhdmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBDaGFydENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibm90ZUNsaWNrXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgQ2hhcnRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm5vdGVIb3ZlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIENoYXJ0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJub3RlTGVhdmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBDaGFydENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicGFuZVJlbmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIENoYXJ0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwbG90QXJlYUNsaWNrXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgQ2hhcnRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBsb3RBcmVhSG92ZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBDaGFydENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicGxvdEFyZWFMZWF2ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIENoYXJ0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJyZW5kZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBDaGFydENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgQ2hhcnRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInNlbGVjdEVuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIENoYXJ0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJzZWxlY3RTdGFydFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIENoYXJ0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJzZXJpZXNDbGlja1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIENoYXJ0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJzZXJpZXNIb3ZlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIENoYXJ0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJzZXJpZXNPdmVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgQ2hhcnRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInNlcmllc0xlYXZlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgQ2hhcnRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInpvb21cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBDaGFydENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiem9vbUVuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIENoYXJ0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ6b29tU3RhcnRcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IFRIUk9UVExFX01TID0gMTAwMCAvIDYwO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIENoYW5nZSB7XG4gICAgY29uc3RydWN0b3Ioa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgQ29uZmlndXJhdGlvblNlcnZpY2UgPSBjbGFzcyBDb25maWd1cmF0aW9uU2VydmljZSB7XG4gICAgY29uc3RydWN0b3Iobmdab25lKSB7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLnN0b3JlID0ge307XG4gICAgICAgIHRoaXMuc291cmNlID0gbmV3IEJlaGF2aW9yU3ViamVjdCh7fSk7XG4gICAgICAgIHRoaXMuaW5pdFNvdXJjZSgpO1xuICAgIH1cbiAgICBpbml0U291cmNlKCkge1xuICAgICAgICB0aGlzLm9uRmFzdENoYW5nZSQgPSB0aGlzLnNvdXJjZS5hc09ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSQgPSB0aGlzLm9uRmFzdENoYW5nZSQucGlwZShhdWRpdFRpbWUoVEhST1RUTEVfTVMpKTtcbiAgICB9XG4gICAgcHVzaChzdG9yZSkge1xuICAgICAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cbiAgICBub3RpZnkoY2hhbmdlKSB7XG4gICAgICAgIHRoaXMuc2V0KGNoYW5nZS5rZXksIGNoYW5nZS52YWx1ZSk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cbiAgICBzZXQoZmllbGQsIHZhbHVlKSB7XG4gICAgICAgIGxldCBzdG9yZSA9IHRoaXMuc3RvcmU7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gZmllbGQuc3BsaXQoJy4nKTtcbiAgICAgICAgbGV0IGtleSA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgICAgIHdoaWxlIChwYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzdG9yZSA9IHN0b3JlW2tleV0gPSBzdG9yZVtrZXldIHx8IHt9O1xuICAgICAgICAgICAga2V5ID0gcGFydHMuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICBzdG9yZVtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlLm5leHQodGhpcy5zdG9yZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5Db25maWd1cmF0aW9uU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05nWm9uZV0pXG5dLCBDb25maWd1cmF0aW9uU2VydmljZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBCYXNlRXZlbnQge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzZW5kZXIpIHtcbiAgICAgICAgdGhpcy5zZW5kZXIgPSBzZW5kZXI7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgUHJldmVudGFibGVFdmVudCBleHRlbmRzIEJhc2VFdmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucHJldmVudGVkID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXZlbnRzIHRoZSBkZWZhdWx0IGFjdGlvbiBmb3IgYSBzcGVjaWZpZWQgZXZlbnQuXG4gICAgICogSW4gdGhpcyB3YXksIHRoZSBzb3VyY2UgY29tcG9uZW50IHN1cHByZXNzZXNcbiAgICAgKiB0aGUgYnVpbHQtaW4gYmVoYXZpb3IgdGhhdCBmb2xsb3dzIHRoZSBldmVudC5cbiAgICAgKi9cbiAgICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICAgICAgdGhpcy5wcmV2ZW50ZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZXZlbnQgd2FzIHByZXZlbnRlZFxuICAgICAqIGJ5IGFueSBvZiBpdHMgc3Vic2NyaWJlcnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGRlZmF1bHQgYWN0aW9uIHdhcyBwcmV2ZW50ZWQuXG4gICAgICogT3RoZXJ3aXNlLCByZXR1cm5zIGBmYWxzZWAuXG4gICAgICovXG4gICAgaXNEZWZhdWx0UHJldmVudGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmV2ZW50ZWQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgTGVnZW5kRXZlbnQgZXh0ZW5kcyBQcmV2ZW50YWJsZUV2ZW50IHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZSwgc2VuZGVyKSB7XG4gICAgICAgIHN1cGVyKHNlbmRlcik7XG4gICAgICAgIHRoaXMuc2VyaWVzID0gZS5zZXJpZXM7XG4gICAgICAgIHRoaXMuc2VyaWVzSW5kZXggPSBlLnNlcmllc0luZGV4O1xuICAgICAgICB0aGlzLnBvaW50SW5kZXggPSBlLnBvaW50SW5kZXg7XG4gICAgICAgIHRoaXMudGV4dCA9IGUudGV4dDtcbiAgICB9XG59XG5cbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgYGxlZ2VuZEl0ZW1DbGlja2AgZXZlbnQuXG4gKi9cbmNsYXNzIExlZ2VuZEl0ZW1DbGlja0V2ZW50IGV4dGVuZHMgTGVnZW5kRXZlbnQge1xuICAgIC8qKlxuICAgICAqIElmIGNhbGxlZCwgdGhlIHNlcmllcyB2aXNpYmlsaXR5IGlzIG5vdCB0b2dnbGVkIGFzIGEgcmVzdWx0IG9mIGNsaWNraW5nIHRoZSBsZWdlbmQgaXRlbS5cbiAgICAgKi9cbiAgICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICAgICAgc3VwZXIucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgYGF4aXNMYWJlbENsaWNrYCBldmVudC5cbiAqL1xuY2xhc3MgQXhpc0xhYmVsQ2xpY2tFdmVudCBleHRlbmRzIEJhc2VFdmVudCB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGUsIHNlbmRlcikge1xuICAgICAgICBzdXBlcihzZW5kZXIpO1xuICAgICAgICB0aGlzLmF4aXMgPSBlLmF4aXM7XG4gICAgICAgIHRoaXMuZGF0YUl0ZW0gPSBlLmRhdGFJdGVtO1xuICAgICAgICB0aGlzLmluZGV4ID0gZS5pbmRleDtcbiAgICAgICAgdGhpcy50ZXh0ID0gZS50ZXh0O1xuICAgICAgICB0aGlzLnZhbHVlID0gZS52YWx1ZTtcbiAgICB9XG59XG5cbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgYGRyYWdgIGV2ZW50LlxuICovXG5jbGFzcyBEcmFnRXZlbnQgZXh0ZW5kcyBQcmV2ZW50YWJsZUV2ZW50IHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZSwgc2VuZGVyKSB7XG4gICAgICAgIHN1cGVyKHNlbmRlcik7XG4gICAgICAgIHRoaXMuYXhpc1JhbmdlcyA9IGUuYXhpc1JhbmdlcztcbiAgICAgICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gZS5vcmlnaW5hbEV2ZW50O1xuICAgIH1cbn1cblxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBgZHJhZ0VuZGAgZXZlbnQuXG4gKi9cbmNsYXNzIERyYWdFbmRFdmVudCBleHRlbmRzIEJhc2VFdmVudCB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGUsIHNlbmRlcikge1xuICAgICAgICBzdXBlcihzZW5kZXIpO1xuICAgICAgICB0aGlzLmF4aXNSYW5nZXMgPSBlLmF4aXNSYW5nZXM7XG4gICAgICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IGUub3JpZ2luYWxFdmVudDtcbiAgICB9XG59XG5cbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgYGRyYWdTdGFydGAgZXZlbnQuXG4gKi9cbmNsYXNzIERyYWdTdGFydEV2ZW50IGV4dGVuZHMgUHJldmVudGFibGVFdmVudCB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGUsIHNlbmRlcikge1xuICAgICAgICBzdXBlcihzZW5kZXIpO1xuICAgICAgICB0aGlzLmF4aXNSYW5nZXMgPSBlLmF4aXNSYW5nZXM7XG4gICAgICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IGUub3JpZ2luYWxFdmVudDtcbiAgICB9XG59XG5cbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgYGxlZ2VuZEl0ZW1Ib3ZlcmAgZXZlbnQuXG4gKi9cbmNsYXNzIExlZ2VuZEl0ZW1Ib3ZlckV2ZW50IGV4dGVuZHMgTGVnZW5kRXZlbnQge1xuICAgIC8qKlxuICAgICAqIElmIGNhbGxlZCwgdGhlIHNlcmllcyBoaWdobGlnaHQgaXMgbm90IHNob3duIGFzIGEgcmVzdWx0IG9mIGhvdmVyaW5nIG92ZXIgdGhlIGxlZ2VuZCBpdGVtLlxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICBzdXBlci5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn1cblxuLyogdHNsaW50OmRpc2FibGU6bm8tZW1wdHkgKi9cbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgYGxlZ2VuZEl0ZW1MZWF2ZWAgZXZlbnQuXG4gKi9cbmNsYXNzIExlZ2VuZEl0ZW1MZWF2ZUV2ZW50IGV4dGVuZHMgTGVnZW5kRXZlbnQge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGlzRGVmYXVsdFByZXZlbnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIE5vdGVFdmVudCBleHRlbmRzIEJhc2VFdmVudCB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGUsIHNlbmRlcikge1xuICAgICAgICBzdXBlcihzZW5kZXIpO1xuICAgICAgICB0aGlzLmNhdGVnb3J5ID0gZS5jYXRlZ29yeTtcbiAgICAgICAgdGhpcy5kYXRhSXRlbSA9IGUuZGF0YUl0ZW07XG4gICAgICAgIHRoaXMuc2VyaWVzID0gZS5zZXJpZXM7XG4gICAgICAgIHRoaXMudmFsdWUgPSBlLnZhbHVlO1xuICAgICAgICB0aGlzLnZpc3VhbCA9IGUudmlzdWFsO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBgbm90ZUNsaWNrYCBldmVudC5cbiAqL1xuY2xhc3MgTm90ZUNsaWNrRXZlbnQgZXh0ZW5kcyBOb3RlRXZlbnQge1xufVxuXG4vKipcbiAqIEFyZ3VtZW50cyBmb3IgdGhlIGBub3RlSG92ZXJgIGV2ZW50LlxuICovXG5jbGFzcyBOb3RlSG92ZXJFdmVudCBleHRlbmRzIE5vdGVFdmVudCB7XG59XG5cbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgYG5vdGVMZWF2ZWAgZXZlbnQuXG4gKi9cbmNsYXNzIE5vdGVMZWF2ZUV2ZW50IGV4dGVuZHMgTm90ZUV2ZW50IHtcbn1cblxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBgcGFuZVJlbmRlcmAgZXZlbnQuXG4gKi9cbmNsYXNzIFBhbmVSZW5kZXJFdmVudCBleHRlbmRzIEJhc2VFdmVudCB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFyZ3MsIHNlbmRlcikge1xuICAgICAgICBzdXBlcihzZW5kZXIpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGFyZ3MpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBgcGxvdEFyZWFDbGlja2AgZXZlbnQuXG4gKi9cbmNsYXNzIFBsb3RBcmVhQ2xpY2tFdmVudCBleHRlbmRzIEJhc2VFdmVudCB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGUsIHNlbmRlcikge1xuICAgICAgICBzdXBlcihzZW5kZXIpO1xuICAgICAgICB0aGlzLmNhdGVnb3J5ID0gZS5jYXRlZ29yeTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gZS5vcmlnaW5hbEV2ZW50O1xuICAgICAgICB0aGlzLnZhbHVlID0gZS52YWx1ZTtcbiAgICAgICAgdGhpcy54ID0gZS54O1xuICAgICAgICB0aGlzLnkgPSBlLnk7XG4gICAgfVxufVxuXG4vKipcbiAqIEFyZ3VtZW50cyBmb3IgdGhlIGBwbG90QXJlYUhvdmVyYCBldmVudC5cbiAqL1xuY2xhc3MgUGxvdEFyZWFIb3ZlckV2ZW50IGV4dGVuZHMgQmFzZUV2ZW50IHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZSwgc2VuZGVyKSB7XG4gICAgICAgIHN1cGVyKHNlbmRlcik7XG4gICAgICAgIHRoaXMuY2F0ZWdvcnkgPSBlLmNhdGVnb3J5O1xuICAgICAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSBlLm9yaWdpbmFsRXZlbnQ7XG4gICAgICAgIHRoaXMudmFsdWUgPSBlLnZhbHVlO1xuICAgICAgICB0aGlzLnggPSBlLng7XG4gICAgICAgIHRoaXMueSA9IGUueTtcbiAgICB9XG59XG5cbmNsYXNzIFBsb3RBcmVhTGVhdmVFdmVudCBleHRlbmRzIEJhc2VFdmVudCB7XG59XG5cbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgYHJlbmRlcmAgZXZlbnQuXG4gKi9cbmNsYXNzIFJlbmRlckV2ZW50IGV4dGVuZHMgQmFzZUV2ZW50IHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX2UsIHNlbmRlcikge1xuICAgICAgICBzdXBlcihzZW5kZXIpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBgc2VsZWN0YCBldmVudC5cbiAqL1xuY2xhc3MgU2VsZWN0RXZlbnQgZXh0ZW5kcyBQcmV2ZW50YWJsZUV2ZW50IHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZSwgc2VuZGVyKSB7XG4gICAgICAgIHN1cGVyKHNlbmRlcik7XG4gICAgICAgIHRoaXMuYXhpcyA9IGUuYXhpcztcbiAgICAgICAgdGhpcy5mcm9tID0gZS5mcm9tO1xuICAgICAgICB0aGlzLnRvID0gZS50bztcbiAgICB9XG59XG5cbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgYHNlbGVjdEVuZGAgZXZlbnQuXG4gKi9cbmNsYXNzIFNlbGVjdEVuZEV2ZW50IGV4dGVuZHMgQmFzZUV2ZW50IHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZSwgc2VuZGVyKSB7XG4gICAgICAgIHN1cGVyKHNlbmRlcik7XG4gICAgICAgIHRoaXMuYXhpcyA9IGUuYXhpcztcbiAgICAgICAgdGhpcy5mcm9tID0gZS5mcm9tO1xuICAgICAgICB0aGlzLnRvID0gZS50bztcbiAgICB9XG59XG5cbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgYHNlbGVjdFN0YXJ0YCBldmVudC5cbiAqL1xuY2xhc3MgU2VsZWN0U3RhcnRFdmVudCBleHRlbmRzIFByZXZlbnRhYmxlRXZlbnQge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlLCBzZW5kZXIpIHtcbiAgICAgICAgc3VwZXIoc2VuZGVyKTtcbiAgICAgICAgdGhpcy5heGlzID0gZS5heGlzO1xuICAgICAgICB0aGlzLmZyb20gPSBlLmZyb207XG4gICAgICAgIHRoaXMudG8gPSBlLnRvO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBgc2VyaWVzQ2xpY2tgIGV2ZW50LlxuICovXG5jbGFzcyBTZXJpZXNDbGlja0V2ZW50IGV4dGVuZHMgQmFzZUV2ZW50IHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZSwgc2VuZGVyKSB7XG4gICAgICAgIHN1cGVyKHNlbmRlcik7XG4gICAgICAgIHRoaXMuY2F0ZWdvcnkgPSBlLmNhdGVnb3J5O1xuICAgICAgICB0aGlzLmRhdGFJdGVtID0gZS5kYXRhSXRlbTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gZS5vcmlnaW5hbEV2ZW50O1xuICAgICAgICB0aGlzLnBlcmNlbnRhZ2UgPSBlLnBlcmNlbnRhZ2U7XG4gICAgICAgIHRoaXMucG9pbnQgPSBlLnBvaW50O1xuICAgICAgICB0aGlzLnNlcmllcyA9IGUuc2VyaWVzO1xuICAgICAgICB0aGlzLnN0YWNrVmFsdWUgPSBlLnN0YWNrVmFsdWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSBlLnZhbHVlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFNlcmllc0V2ZW50IGV4dGVuZHMgUHJldmVudGFibGVFdmVudCB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGUsIHNlbmRlcikge1xuICAgICAgICBzdXBlcihzZW5kZXIpO1xuICAgICAgICB0aGlzLmNhdGVnb3J5ID0gZS5jYXRlZ29yeTtcbiAgICAgICAgdGhpcy5kYXRhSXRlbSA9IGUuZGF0YUl0ZW07XG4gICAgICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IGUub3JpZ2luYWxFdmVudDtcbiAgICAgICAgdGhpcy5wZXJjZW50YWdlID0gZS5wZXJjZW50YWdlO1xuICAgICAgICB0aGlzLnBvaW50ID0gZS5wb2ludDtcbiAgICAgICAgdGhpcy5zZXJpZXMgPSBlLnNlcmllcztcbiAgICAgICAgdGhpcy5zdGFja1ZhbHVlID0gZS5zdGFja1ZhbHVlO1xuICAgICAgICB0aGlzLnZhbHVlID0gZS52YWx1ZTtcbiAgICB9XG59XG5cbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgYHNlcmllc0hvdmVyYCBldmVudC5cbiAqL1xuY2xhc3MgU2VyaWVzSG92ZXJFdmVudCBleHRlbmRzIFNlcmllc0V2ZW50IHtcbn1cblxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBgc2VyaWVzT3ZlcmAgZXZlbnQuXG4gKi9cbmNsYXNzIFNlcmllc092ZXJFdmVudCBleHRlbmRzIFNlcmllc0V2ZW50IHtcbn1cblxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBgc2VyaWVzTGVhdmVgIGV2ZW50LlxuICovXG5jbGFzcyBTZXJpZXNMZWF2ZUV2ZW50IGV4dGVuZHMgU2VyaWVzRXZlbnQge1xufVxuXG4vKipcbiAqIEFyZ3VtZW50cyBmb3IgdGhlIGB6b29tYCBldmVudC5cbiAqL1xuY2xhc3MgWm9vbUV2ZW50IGV4dGVuZHMgUHJldmVudGFibGVFdmVudCB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGUsIHNlbmRlcikge1xuICAgICAgICBzdXBlcihzZW5kZXIpO1xuICAgICAgICB0aGlzLmF4aXNSYW5nZXMgPSBlLmF4aXNSYW5nZXM7XG4gICAgICAgIHRoaXMuZGVsdGEgPSBlLmRlbHRhO1xuICAgICAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSBlLm9yaWdpbmFsRXZlbnQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEFyZ3VtZW50cyBmb3IgdGhlIGB6b29tRW5kYCBldmVudC5cbiAqL1xuY2xhc3MgWm9vbUVuZEV2ZW50IGV4dGVuZHMgQmFzZUV2ZW50IHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZSwgc2VuZGVyKSB7XG4gICAgICAgIHN1cGVyKHNlbmRlcik7XG4gICAgICAgIHRoaXMuYXhpc1JhbmdlcyA9IGUuYXhpc1JhbmdlcztcbiAgICAgICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gZS5vcmlnaW5hbEV2ZW50O1xuICAgIH1cbn1cblxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBgem9vbVN0YXJ0YCBldmVudC5cbiAqL1xuY2xhc3MgWm9vbVN0YXJ0RXZlbnQgZXh0ZW5kcyBQcmV2ZW50YWJsZUV2ZW50IHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZSwgc2VuZGVyKSB7XG4gICAgICAgIHN1cGVyKHNlbmRlcik7XG4gICAgICAgIHRoaXMuYXhpc1JhbmdlcyA9IGUuYXhpc1JhbmdlcztcbiAgICAgICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gZS5vcmlnaW5hbEV2ZW50O1xuICAgIH1cbn1cblxuY29uc3QgRVZFTlRfTUFQID0ge1xuICAgIGF4aXNMYWJlbENsaWNrOiBBeGlzTGFiZWxDbGlja0V2ZW50LFxuICAgIGRyYWc6IERyYWdFdmVudCxcbiAgICBkcmFnRW5kOiBEcmFnRW5kRXZlbnQsXG4gICAgZHJhZ1N0YXJ0OiBEcmFnU3RhcnRFdmVudCxcbiAgICBsZWdlbmRJdGVtSG92ZXI6IExlZ2VuZEl0ZW1Ib3ZlckV2ZW50LFxuICAgIGxlZ2VuZEl0ZW1MZWF2ZTogTGVnZW5kSXRlbUxlYXZlRXZlbnQsXG4gICAgbm90ZUNsaWNrOiBOb3RlQ2xpY2tFdmVudCxcbiAgICBub3RlSG92ZXI6IE5vdGVIb3ZlckV2ZW50LFxuICAgIG5vdGVMZWF2ZTogTm90ZUxlYXZlRXZlbnQsXG4gICAgcGFuZVJlbmRlcjogUGFuZVJlbmRlckV2ZW50LFxuICAgIHBsb3RBcmVhQ2xpY2s6IFBsb3RBcmVhQ2xpY2tFdmVudCxcbiAgICBwbG90QXJlYUhvdmVyOiBQbG90QXJlYUhvdmVyRXZlbnQsXG4gICAgcGxvdEFyZWFMZWF2ZTogUGxvdEFyZWFMZWF2ZUV2ZW50LFxuICAgIHJlbmRlcjogUmVuZGVyRXZlbnQsXG4gICAgc2VsZWN0OiBTZWxlY3RFdmVudCxcbiAgICBzZWxlY3RFbmQ6IFNlbGVjdEVuZEV2ZW50LFxuICAgIHNlbGVjdFN0YXJ0OiBTZWxlY3RTdGFydEV2ZW50LFxuICAgIHNlcmllc0NsaWNrOiBTZXJpZXNDbGlja0V2ZW50LFxuICAgIHNlcmllc0hvdmVyOiBTZXJpZXNIb3ZlckV2ZW50LFxuICAgIHNlcmllc092ZXI6IFNlcmllc092ZXJFdmVudCxcbiAgICBzZXJpZXNMZWF2ZTogU2VyaWVzTGVhdmVFdmVudCxcbiAgICB6b29tOiBab29tRXZlbnQsXG4gICAgem9vbUVuZDogWm9vbUVuZEV2ZW50LFxuICAgIHpvb21TdGFydDogWm9vbVN0YXJ0RXZlbnRcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgSW5zdGFuY2VFdmVudFNlcnZpY2Uge1xuICAgIGNyZWF0ZShuYW1lLCBhcmdzLCBzZW5kZXIpIHtcbiAgICAgICAgaWYgKEVWRU5UX01BUFtuYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFVkVOVF9NQVBbbmFtZV0oYXJncywgc2VuZGVyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBBIGRpcmVjdGl2ZSB3aGljaCBzZWxlY3RzIGEgW3RlbXBsYXRlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyd0ZW1wbGF0ZXN5bnRheCddIH19KVxuICogd2l0aGluIHRoZSBgPGtlbmRvLWNoYXJ0PmAgY29tcG9uZW50IGZvciB0aGVcbiAqIFtEb251dCBjZW50ZXIgdGVtcGxhdGVdKHslIHNsdWcgZG9udXRfc2VyaWVzdHlwZXNfY2hhcnRzICV9KS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICpcbiAqIF9AQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICB0ZW1wbGF0ZTogYFxuICogICAgIDxrZW5kby1jaGFydCBzdHlsZT1cImhlaWdodDogNDUwcHg7XCI+XG4gKiAgICAgICA8bmctdGVtcGxhdGUga2VuZG9DaGFydERvbnV0Q2VudGVyVGVtcGxhdGU+XG4gKiAgICAgICAgIDxoMz4yMi41JTwvaDM+XG4gKiAgICAgICAgIG9mIHdoaWNoIHJlbmV3YWJsZXNcbiAqICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICA8a2VuZG8tY2hhcnQtc2VyaWVzPlxuICogICAgICAgICA8a2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW1cbiAqICAgICAgICAgICAgIHR5cGU9XCJkb251dFwiIFtkYXRhXT1cImRhdGFcIlxuICogICAgICAgICAgICAgY2F0ZWdvcnlGaWVsZD1cImtpbmRcIiBmaWVsZD1cInNoYXJlXCI+XG4gKiAgICAgICAgIDwva2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0+XG4gKiAgICAgICA8L2tlbmRvLWNoYXJ0LXNlcmllcz5cbiAqICAgICAgIDxrZW5kby1jaGFydC1sZWdlbmQgW3Zpc2libGVdPVwiZmFsc2VcIj48L2tlbmRvLWNoYXJ0LWxlZ2VuZD5cbiAqICAgICA8L2tlbmRvLWNoYXJ0PlxuICogICBgXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiAgIHB1YmxpYyBkYXRhOiBhbnlbXSA9IFt7XG4gKiAgICAga2luZDogJ0h5ZHJvZWxlY3RyaWMnLCBzaGFyZTogMC4xNzVcbiAqICAgfSwge1xuICogICAgIGtpbmQ6ICdOdWNsZWFyJywgc2hhcmU6IDAuMjM4XG4gKiAgIH0sIHtcbiAqICAgICBraW5kOiAnQ29hbCcsIHNoYXJlOiAwLjExOFxuICogICB9LCB7XG4gKiAgICAga2luZDogJ1NvbGFyJywgc2hhcmU6IDAuMDUyXG4gKiAgIH0sIHtcbiAqICAgICBraW5kOiAnV2luZCcsIHNoYXJlOiAwLjIyNVxuICogICB9LCB7XG4gKiAgICAga2luZDogJ090aGVyJywgc2hhcmU6IDAuMTkyXG4gKiAgIH1dO1xuICogfVxuICpcbiAqIGBgYFxuICovXG5sZXQgRG9udXRDZW50ZXJUZW1wbGF0ZURpcmVjdGl2ZSA9IGNsYXNzIERvbnV0Q2VudGVyVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59O1xuRG9udXRDZW50ZXJUZW1wbGF0ZURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvQ2hhcnREb251dENlbnRlclRlbXBsYXRlXSdcbiAgICB9KSxcbiAgICBfX3BhcmFtKDAsIE9wdGlvbmFsKCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbVGVtcGxhdGVSZWZdKVxuXSwgRG9udXRDZW50ZXJUZW1wbGF0ZURpcmVjdGl2ZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBJdGVtQ2hhbmdlIHtcbiAgICBjb25zdHJ1Y3RvcihzZW5kZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zZW5kZXIgPSBzZW5kZXI7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBDb2xsZWN0aW9uU2VydmljZSA9IGNsYXNzIENvbGxlY3Rpb25TZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLm9uSXRlbUNoYW5nZSQgPSB0aGlzLnNvdXJjZS5hc09ic2VydmFibGUoKTtcbiAgICB9XG4gICAgbm90aWZ5KGNoYW5nZSkge1xuICAgICAgICB0aGlzLnNvdXJjZS5uZXh0KGNoYW5nZSk7XG4gICAgfVxufTtcbkNvbGxlY3Rpb25TZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIENvbGxlY3Rpb25TZXJ2aWNlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGNvcHlDaGFuZ2VzKGNoYW5nZXMsIG9wdGlvbnMpIHtcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5TmFtZSBpbiBjaGFuZ2VzKSB7XG4gICAgICAgIGlmICghY2hhbmdlcy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IGNoYW5nZXNbcHJvcGVydHlOYW1lXS5jdXJyZW50VmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkZWxldGUgb3B0aW9uc1twcm9wZXJ0eU5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9uc1twcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiB0b1NpbXBsZUNoYW5nZXMoY2hhbmdlcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgcHJvcGVydHlOYW1lIGluIGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKCFjaGFuZ2VzLmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtwcm9wZXJ0eU5hbWVdID0gbmV3IFNpbXBsZUNoYW5nZShudWxsLCBjaGFuZ2VzW3Byb3BlcnR5TmFtZV0sIGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIENvbGxlY3Rpb25JdGVtQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25TZXJ2aWNlID0gY29sbGVjdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlLm9uRmFzdENoYW5nZSQuc3Vic2NyaWJlKHN0b3JlID0+IHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IHN0b3JlO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnkoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlLnN0b3JlO1xuICAgICAgICBjb3B5Q2hhbmdlcyhjaGFuZ2VzLCBzdG9yZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UucHVzaChzdG9yZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGNvbXBvbmVudCBmaWVsZHMgd2l0aCB0aGUgc3BlY2lmaWVkIHZhbHVlcyBhbmQgcmVmcmVzaGVzIHRoZSBDaGFydC5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCB3aGVuIHRoZSBjb25maWd1cmF0aW9uIHZhbHVlcyBjYW5ub3QgYmUgc2V0IHRocm91Z2ggdGhlIHRlbXBsYXRlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0cy1uby1ydW5cbiAgICAgKiBpdGVtLm5vdGlmeUNoYW5nZXMoeyB2aXNpYmxlOiB0cnVlIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYW5nZXMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHVwZGF0ZWQgaW5wdXQgZmllbGRzLlxuICAgICAqL1xuICAgIG5vdGlmeUNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICB0aGlzLm5nT25DaGFuZ2VzKHRvU2ltcGxlQ2hhbmdlcyhjaGFuZ2VzKSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBub3RpZnkoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb2xsZWN0aW9uU2VydmljZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sbGVjdGlvblNlcnZpY2Uubm90aWZ5KG5ldyBJdGVtQ2hhbmdlKHRoaXMsIHRoaXMub3B0aW9ucykpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBDb2xsZWN0aW9uSXRlbUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uU2VydmljZSA9IGNvbGxlY3Rpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImFnZ3JlZ2F0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImF1dG9GaXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImF4aXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY2F0ZWdvcnlBeGlzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjYXRlZ29yeUZpZWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjbG9zZUZpZWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29sb3JGaWVsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29ubmVjdG9yc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY3VycmVudEZpZWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJkYXNoVHlwZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJkb3duQ29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImRvd25Db2xvckZpZWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZHluYW1pY0hlaWdodFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImR5bmFtaWNTbG9wZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZXJyb3JIaWdoRmllbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImVycm9yTG93RmllbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImV4cGxvZGVGaWVsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZmllbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZyb21GaWVsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZ2FwXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJoaWdoRmllbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImhvbGVTaXplXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJsaW5lXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJsb3dGaWVsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibG93ZXJGaWVsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWFyZ2luXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtYXhTaXplXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtZWFuXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtZWFuRmllbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1lZGlhblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWVkaWFuRmllbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1pblNpemVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1pc3NpbmdWYWx1ZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm5hbWVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm5lY2tSYXRpb1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibmVnYXRpdmVDb2xvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibmVnYXRpdmVWYWx1ZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm5vdGVUZXh0RmllbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm9wYWNpdHlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm9wZW5GaWVsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwib3V0bGllcnNGaWVsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwib3ZlcmxheVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicTFGaWVsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicTNGaWVsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwic2VnbWVudFNwYWNpbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInNpemVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInNpemVGaWVsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwic3BhY2luZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwic3RhY2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInN0YXJ0QW5nbGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInN0eWxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJzdW1tYXJ5RmllbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInRhcmdldFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidG9GaWVsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidHlwZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidXBwZXJGaWVsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc2libGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXNpYmxlSW5MZWdlbmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc2libGVJbkxlZ2VuZEZpZWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc3VhbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwid2lkdGhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIndoaXNrZXJzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ4QXhpc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwieEVycm9ySGlnaEZpZWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ4RXJyb3JMb3dGaWVsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwieEZpZWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ5QXhpc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwieUVycm9ySGlnaEZpZWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ5RXJyb3JMb3dGaWVsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwieUZpZWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ6SW5kZXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImVycm9yQmFyc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZXh0cmVtZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImhpZ2hsaWdodFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibGFiZWxzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtYXJrZXJzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJub3Rlc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwib3V0bGllcnNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInRvb2x0aXBcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWdLZXksIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuY29uZmlnS2V5ID0gY29uZmlnS2V5O1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuc3RvcmUgPSB7fTtcbiAgICAgICAgaWYgKGNvbmZpZ0tleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbmZpZ3VyYXRpb24ga2V5IG5vdCBzZXQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zdG9yZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5ub3RpZnkoKTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBjb3B5Q2hhbmdlcyhjaGFuZ2VzLCB0aGlzLnN0b3JlKTtcbiAgICAgICAgdGhpcy5ub3RpZnkoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY29tcG9uZW50IGZpZWxkcyB3aXRoIHRoZSBzcGVjaWZpZWQgdmFsdWVzIGFuZCByZWZyZXNoZXMgdGhlIENoYXJ0LlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHdoZW4gdGhlIGNvbmZpZ3VyYXRpb24gdmFsdWVzIGNhbm5vdCBiZSBzZXQgdGhyb3VnaCB0aGUgdGVtcGxhdGUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzLW5vLXJ1blxuICAgICAqIGl0ZW0ubm90aWZ5Q2hhbmdlcyh7IHZpc2libGU6IHRydWUgfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbmdlcyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgdXBkYXRlZCBpbnB1dCBmaWVsZHMuXG4gICAgICovXG4gICAgbm90aWZ5Q2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMubmdPbkNoYW5nZXModG9TaW1wbGVDaGFuZ2VzKGNoYW5nZXMpKTtcbiAgICB9XG4gICAgbWFya0FzVmlzaWJsZSgpIHtcbiAgICAgICAgdGhpcy5zdG9yZS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ub3RpZnkoKTtcbiAgICB9XG4gICAgbm90aWZ5KCkge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlLm5vdGlmeShuZXcgQ2hhbmdlKHRoaXMuY29uZmlnS2V5LCB0aGlzLnN0b3JlKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU2VyaWVzVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcigndG9vbHRpcCcsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc1Rvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc1Rvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc1Rvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc1Rvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvcm1hdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFNlcmllc1Rvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc2libGVcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIG9mIHRoZSBDaGFydCBzZXJpZXMgdG9vbHRpcFxuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyB0b29sdGlwc19jaGFydF9jaGFydHMgJX0pKS5cbiAqL1xubGV0IFNlcmllc1Rvb2x0aXBDb21wb25lbnQgPSBjbGFzcyBTZXJpZXNUb29sdGlwQ29tcG9uZW50IGV4dGVuZHMgU2VyaWVzVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMubWFya0FzVmlzaWJsZSgpO1xuICAgIH1cbiAgICBnZXQgc2VyaWVzVG9vbHRpcFRlbXBsYXRlUmVmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJpZXNUb29sdGlwVGVtcGxhdGU7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChUZW1wbGF0ZVJlZiwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBUZW1wbGF0ZVJlZilcbl0sIFNlcmllc1Rvb2x0aXBDb21wb25lbnQucHJvdG90eXBlLCBcInNlcmllc1Rvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xuU2VyaWVzVG9vbHRpcENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXNlcmllcy1pdGVtLXRvb2x0aXAnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIFNlcmllc1Rvb2x0aXBDb21wb25lbnQpO1xuXG5jb25zdCB0b2dnbGUgPSAoZmxhZykgPT4gZmxhZyA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiAhZmxhZztcbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gY29tcG9uZW50IGZvciBhIHNlcmllcyBpdGVtLlxuICovXG5sZXQgU2VyaWVzSXRlbUNvbXBvbmVudCA9IGNsYXNzIFNlcmllc0l0ZW1Db21wb25lbnQgZXh0ZW5kcyBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25TZXJ2aWNlID0gY29sbGVjdGlvblNlcnZpY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIHNlcmllcyB2aXNpYmlsaXR5IGFuZCB1cGRhdGVzIHRoZSBwYXJlbnQgQ2hhcnRcbiAgICAgKiB3aXRob3V0IGFuaW1hdGVkIHRyYW5zaXRpb25zLlxuICAgICAqL1xuICAgIHRvZ2dsZVZpc2liaWxpdHkoKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy52aXNpYmxlID0gdG9nZ2xlKHRoaXMub3B0aW9ucy52aXNpYmxlKTtcbiAgICAgICAgdGhpcy5ub3RpZnkoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgdmlzaWJpbGl0eSBvZiBhIHBvaW50IHdpdGggdGhlIGdpdmVuIGluZGV4LlxuICAgICAqIEFwcGxpY2FibGUgZm9yIHRoZSBQaWUsIERvbnV0LCBhbmQgRnVubmVsIHNlcmllcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwb2ludEluZGV4IC0gVGhlIHplcm8tYmFzZWQgaW5kZXggb2YgdGhlIHBvaW50IHRvIHRvZ2dsZS5cbiAgICAgKi9cbiAgICB0b2dnbGVQb2ludFZpc2liaWxpdHkocG9pbnRJbmRleCkge1xuICAgICAgICBjb25zdCBwdiA9IHRoaXMub3B0aW9ucy5wb2ludFZpc2liaWxpdHkgPSB0aGlzLm9wdGlvbnMucG9pbnRWaXNpYmlsaXR5IHx8IHt9O1xuICAgICAgICBwdltwb2ludEluZGV4XSA9IHRvZ2dsZShwdltwb2ludEluZGV4XSk7XG4gICAgICAgIHRoaXMubm90aWZ5KCk7XG4gICAgfVxuICAgIGdldCBzZXJpZXNUb29sdGlwVGVtcGxhdGVSZWYoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlcmllc1Rvb2x0aXApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcmllc1Rvb2x0aXAuc2VyaWVzVG9vbHRpcFRlbXBsYXRlUmVmO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChTZXJpZXNUb29sdGlwQ29tcG9uZW50LCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFNlcmllc1Rvb2x0aXBDb21wb25lbnQpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZXJpZXNUb29sdGlwXCIsIHZvaWQgMCk7XG5TZXJpZXNJdGVtQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHByb3ZpZGVyczogW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1zZXJpZXMtaXRlbScsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2UsXG4gICAgICAgIENvbGxlY3Rpb25TZXJ2aWNlXSlcbl0sIFNlcmllc0l0ZW1Db21wb25lbnQpO1xuXG4vKipcbiAqIEZhbGxiYWNrIHRoZW1lIGluIGNhc2UgdGhlIFRoZW1lIFNlcnZpY2UgZmFpbHNcbiAqIHRvIHJlYWQgdGhlIHZhcmlhYmxlcyBmcm9tIHRoZSBtYWluIHRoZW1lLlxuICpcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgY2hhcnREZWZhdWx0VGhlbWUgPSAoKSA9PiBPYmplY3QuYXNzaWduKHt9LCBjaGFydEJhc2VUaGVtZSgpLCB7XG4gICAgYXhpc0RlZmF1bHRzOiB7XG4gICAgICAgIGNyb3NzaGFpcjoge1xuICAgICAgICAgICAgY29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuNSknXG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsczoge1xuICAgICAgICAgICAgY29sb3I6ICdyZ2IoMTAxLCAxMDEsIDEwMSknLFxuICAgICAgICAgICAgZm9udDogJzEycHggc2VyaWYnXG4gICAgICAgIH0sXG4gICAgICAgIGxpbmU6IHtcbiAgICAgICAgICAgIGNvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjA4KSdcbiAgICAgICAgfSxcbiAgICAgICAgbWFqb3JHcmlkTGluZXM6IHtcbiAgICAgICAgICAgIGNvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjA4KSdcbiAgICAgICAgfSxcbiAgICAgICAgbWlub3JHcmlkTGluZXM6IHtcbiAgICAgICAgICAgIGNvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjA0KSdcbiAgICAgICAgfSxcbiAgICAgICAgbm90ZXM6IHtcbiAgICAgICAgICAgIGljb246IHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAncmdiYSgwLCAwLCAwLCAwLjUpJyxcbiAgICAgICAgICAgICAgICBib3JkZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuNSknXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbmU6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC41KSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgICAgIGZvbnQ6ICcxNHB4IHNlcmlmJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgY29sb3I6ICdyZ2IoMTAxLCAxMDEsIDEwMSknLFxuICAgICAgICAgICAgZm9udDogJzE0cHggc2VyaWYnXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNoYXJ0QXJlYToge1xuICAgICAgICBiYWNrZ3JvdW5kOiAncmdiKDI1NSwgMjU1LCAyNTUpJ1xuICAgIH0sXG4gICAgbGVnZW5kOiB7XG4gICAgICAgIGluYWN0aXZlSXRlbXM6IHtcbiAgICAgICAgICAgIGxhYmVsczoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAncmdiYSgxMDIsIDEwMiwgMTAyLCAwLjUpJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1hcmtlcnM6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJ3JnYmEoMTAyLCAxMDIsIDEwMiwgMC41KSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgICBjb2xvcjogJ3JnYigxMDEsIDEwMSwgMTAxKScsXG4gICAgICAgICAgICBmb250OiAnMTRweCBzZXJpZidcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2VyaWVzRGVmYXVsdHM6IHtcbiAgICAgICAgYm94UGxvdDoge1xuICAgICAgICAgICAgZG93bkNvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjA4KScsXG4gICAgICAgICAgICBtZWFuOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICdyZ2IoMjQ2LCAyNDYsIDI0NiknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWVkaWFuOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICdyZ2IoMjQ2LCAyNDYsIDI0NiknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd2hpc2tlcnM6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJ3JnYigyNTUsIDk5LCA4OCknXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGJ1bGxldDoge1xuICAgICAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICdyZ2IoMTAxLCAxMDEsIDEwMSknXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNhbmRsZXN0aWNrOiB7XG4gICAgICAgICAgICBkb3duQ29sb3I6ICdyZ2IoMTAxLCAxMDEsIDEwMSknLFxuICAgICAgICAgICAgbGluZToge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAncmdiKDEwMSwgMTAxLCAxMDEpJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlcnJvckJhcnM6IHtcbiAgICAgICAgICAgIGNvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjUpJ1xuICAgICAgICB9LFxuICAgICAgICBob3Jpem9udGFsV2F0ZXJmYWxsOiB7XG4gICAgICAgICAgICBsaW5lOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuMDgpJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpY29uOiB7XG4gICAgICAgICAgICBib3JkZXI6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC4wOCknXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsczoge1xuICAgICAgICAgICAgYmFja2dyb3VuZDogJ3JnYigyNTUsIDI1NSwgMjU1KScsXG4gICAgICAgICAgICBjb2xvcjogJ3JnYigxMDEsIDEwMSwgMTAxKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjgsXG4gICAgICAgICAgICBmb250OiAnMTJweCBzZXJpZidcbiAgICAgICAgfSxcbiAgICAgICAgbm90ZXM6IHtcbiAgICAgICAgICAgIGljb246IHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAncmdiYSgwLCAwLCAwLCAwLjUpJyxcbiAgICAgICAgICAgICAgICBib3JkZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuNSknXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbmU6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC41KSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgICAgIGZvbnQ6ICcxNHB4IHNlcmlmJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvdmVybGF5OiB7XG4gICAgICAgICAgICBncmFkaWVudDogXCJub25lXCJcbiAgICAgICAgfSxcbiAgICAgICAgdmVydGljYWxCb3hQbG90OiB7XG4gICAgICAgICAgICBkb3duQ29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuMDgpJyxcbiAgICAgICAgICAgIG1lYW46IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJ3JnYigyNDYsIDI0NiwgMjQ2KSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZWRpYW46IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJ3JnYigyNDYsIDI0NiwgMjQ2KSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3aGlza2Vyczoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAncmdiKDI1NSwgOTksIDg4KSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdmVydGljYWxCdWxsZXQ6IHtcbiAgICAgICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAncmdiKDEwMSwgMTAxLCAxMDEpJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB3YXRlcmZhbGw6IHtcbiAgICAgICAgICAgIGxpbmU6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC4wOCknXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFyZWE6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuOFxuICAgICAgICB9XG4gICAgfSxcbiAgICB0aXRsZToge1xuICAgICAgICBjb2xvcjogJ3JnYigxMDEsIDEwMSwgMTAxKScsXG4gICAgICAgIGZvbnQ6ICcxNnB4IHNlcmlmJ1xuICAgIH0sXG4gICAgc2VyaWVzQ29sb3JzOiBbXG4gICAgICAgICdyZ2IoMjU1LCA5OSwgODgpJyxcbiAgICAgICAgJ3JnYigyNTUsIDIxMCwgNzApJyxcbiAgICAgICAgJ3JnYigxMjAsIDIxMCwgNTUpJyxcbiAgICAgICAgJ3JnYig0MCwgMTgwLCAyMDApJyxcbiAgICAgICAgJ3JnYig0NSwgMTE1LCAyNDUpJyxcbiAgICAgICAgJ3JnYigxNzAsIDcwLCAxOTApJ1xuICAgIF1cbn0pO1xuXG5jb25zdCBmb250ID0gKHN0eWxlKSA9PiBgJHtzdHlsZS5mb250V2VpZ2h0fSAke3N0eWxlLmZvbnRTaXplfSAke3N0eWxlLmZvbnRGYW1pbHl9YDtcbmNvbnN0IGNvbXB1dGVkQmFja2dyb3VuZENvbG9yID0gKGVsZW1lbnQpID0+IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmJhY2tncm91bmRDb2xvcjtcbmNvbnN0IGxldHRlclBvcyA9IChsZXR0ZXIpID0+IGxldHRlci50b0xvd2VyQ2FzZSgpLmNoYXJDb2RlQXQoMCkgLSAnYScuY2hhckNvZGVBdCgwKTtcbmNvbnN0IHNlcmllc1BvcyA9IChuYW1lKSA9PiB7XG4gICAgY29uc3QgYWxwaGEgPSBuYW1lLm1hdGNoKC9zZXJpZXMtKFthLXpdKSQvKTtcbiAgICBpZiAoYWxwaGEgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGxldHRlclBvcyhhbHBoYVsxXSk7XG4gICAgfVxuICAgIGNvbnN0IG51bSA9IG5hbWUuc3BsaXQoJy0tc2VyaWVzLScpWzFdO1xuICAgIHJldHVybiBwYXJzZUludChudW0sIDEwKSAtIDE7XG59O1xuY29uc3QgU0VSSUVTX0NPTE9SUyA9IDMwO1xuY29uc3Qgc2VyaWVzVGVtcGxhdGUgPSAoKSA9PiB7XG4gICAgbGV0IHRlbXBsYXRlID0gYFxuICAgICAgPGRpdiBjbGFzcz1cImstdmFyLS1zZXJpZXMtYVwiPjwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cImstdmFyLS1zZXJpZXMtYlwiPjwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cImstdmFyLS1zZXJpZXMtY1wiPjwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cImstdmFyLS1zZXJpZXMtZFwiPjwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cImstdmFyLS1zZXJpZXMtZVwiPjwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cImstdmFyLS1zZXJpZXMtZlwiPjwvZGl2PlxuICBgO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgU0VSSUVTX0NPTE9SUzsgaSsrKSB7XG4gICAgICAgIHRlbXBsYXRlICs9IGBcbiAgICAgIDxkaXYgY2xhc3M9XCJrLXZhci0tc2VyaWVzLSR7aSArIDF9XCI+PC9kaXY+YDtcbiAgICB9XG4gICAgcmV0dXJuIHRlbXBsYXRlO1xufTtcbmNvbnN0IHRlbXBsYXRlID0gKCkgPT4gYFxuICAgIDxkaXYgY2xhc3M9XCJrLXZhci0tYWNjZW50XCI+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImstdmFyLS1hY2NlbnQtY29udHJhc3RcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiay12YXItLWJhc2VcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiay12YXItLWJhY2tncm91bmRcIj48L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJrLXZhci0tbm9ybWFsLWJhY2tncm91bmRcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiay12YXItLW5vcm1hbC10ZXh0LWNvbG9yXCI+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImstdmFyLS1ob3Zlci1iYWNrZ3JvdW5kXCI+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImstdmFyLS1ob3Zlci10ZXh0LWNvbG9yXCI+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImstdmFyLS1zZWxlY3RlZC1iYWNrZ3JvdW5kXCI+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImstdmFyLS1zZWxlY3RlZC10ZXh0LWNvbG9yXCI+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImstdmFyLS1jaGFydC1lcnJvci1iYXJzLWJhY2tncm91bmRcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiay12YXItLWNoYXJ0LW5vdGVzLWJhY2tncm91bmRcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiay12YXItLWNoYXJ0LW5vdGVzLWJvcmRlclwiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJrLXZhci0tY2hhcnQtbm90ZXMtbGluZXNcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiay12YXItLWNoYXJ0LWNyb3NzaGFpci1iYWNrZ3JvdW5kXCI+PC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiay12YXItLWNoYXJ0LWluYWN0aXZlXCI+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImstdmFyLS1jaGFydC1tYWpvci1saW5lc1wiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJrLXZhci0tY2hhcnQtbWlub3ItbGluZXNcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiay12YXItLWNoYXJ0LWFyZWEtb3BhY2l0eVwiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJrLXZhci0tY2hhcnQtYXJlYS1pbmFjdGl2ZS1vcGFjaXR5XCI+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImstdmFyLS1jaGFydC1saW5lLWluYWN0aXZlLW9wYWNpdHlcIj48L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJrLXdpZGdldCBrLWNoYXJ0XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJrLXZhci0tY2hhcnQtZm9udFwiPjwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiay12YXItLWNoYXJ0LXRpdGxlLWZvbnRcIj48L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImstdmFyLS1jaGFydC1wYW5lLXRpdGxlLWZvbnRcIj48L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImstdmFyLS1jaGFydC1sYWJlbC1mb250XCI+PC9kaXY+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiay12YXItLXNlcmllcy11bnNldFwiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJrLXZhci0tc2VyaWVzXCI+XG4gICAgICAke3Nlcmllc1RlbXBsYXRlKCl9XG4gICAgPC9kaXY+XG5gO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBUaGVtZVNlcnZpY2UgPSBjbGFzcyBUaGVtZVNlcnZpY2UgZXh0ZW5kcyBDb25maWd1cmF0aW9uU2VydmljZSB7XG4gICAgY29uc3RydWN0b3Iobmdab25lKSB7XG4gICAgICAgIHN1cGVyKG5nWm9uZSk7XG4gICAgICAgIHRoaXMubG9hZGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGxvYWRUaGVtZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubG9hZGVkIHx8ICFpc0RvY3VtZW50QXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucmVhZFRoZW1lKCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZERlZmF1bHRUaGVtZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIHJlYWRUaGVtZSgpIHtcbiAgICAgICAgdGhpcy5jcmVhdGVFbGVtZW50KCk7XG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZSA9IHRoaXMucXVlcnlDb2xvcignYWNjZW50JykgIT09XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5Q29sb3IoJ2FjY2VudC1jb250cmFzdCcpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGF2YWlsYWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaChjaGFydEJhc2VUaGVtZSgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldENvbG9ycygpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Rm9udHMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFNlcmllc0NvbG9ycygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95RWxlbWVudCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdmFpbGFibGU7XG4gICAgfVxuICAgIHJlYWREZWZhdWx0VGhlbWUoKSB7XG4gICAgICAgIHRoaXMucHVzaChjaGFydERlZmF1bHRUaGVtZSgpKTtcbiAgICB9XG4gICAgY3JlYXRlRWxlbWVudCgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gdGVtcGxhdGUoKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgIH1cbiAgICBkZXN0cm95RWxlbWVudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudCkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFN0eWxlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIHNldENvbG9ycygpIHtcbiAgICAgICAgdGhpcy5tYXBDb2xvcignYXhpc0RlZmF1bHRzLmNyb3NzaGFpci5jb2xvcicsICdjaGFydC1jcm9zc2hhaXItYmFja2dyb3VuZCcpO1xuICAgICAgICB0aGlzLm1hcENvbG9yKCdheGlzRGVmYXVsdHMubGFiZWxzLmNvbG9yJywgJ25vcm1hbC10ZXh0LWNvbG9yJyk7XG4gICAgICAgIHRoaXMubWFwQ29sb3IoJ2F4aXNEZWZhdWx0cy5saW5lLmNvbG9yJywgJ2NoYXJ0LW1ham9yLWxpbmVzJyk7XG4gICAgICAgIHRoaXMubWFwQ29sb3IoJ2F4aXNEZWZhdWx0cy5tYWpvckdyaWRMaW5lcy5jb2xvcicsICdjaGFydC1tYWpvci1saW5lcycpO1xuICAgICAgICB0aGlzLm1hcENvbG9yKCdheGlzRGVmYXVsdHMubWlub3JHcmlkTGluZXMuY29sb3InLCAnY2hhcnQtbWlub3ItbGluZXMnKTtcbiAgICAgICAgdGhpcy5tYXBDb2xvcignYXhpc0RlZmF1bHRzLm5vdGVzLmljb24uYmFja2dyb3VuZCcsICdjaGFydC1ub3Rlcy1iYWNrZ3JvdW5kJyk7XG4gICAgICAgIHRoaXMubWFwQ29sb3IoJ2F4aXNEZWZhdWx0cy5ub3Rlcy5pY29uLmJvcmRlci5jb2xvcicsICdjaGFydC1ub3Rlcy1ib3JkZXInKTtcbiAgICAgICAgdGhpcy5tYXBDb2xvcignYXhpc0RlZmF1bHRzLm5vdGVzLmxpbmUuY29sb3InLCAnY2hhcnQtbm90ZXMtbGluZXMnKTtcbiAgICAgICAgdGhpcy5tYXBDb2xvcignYXhpc0RlZmF1bHRzLnRpdGxlLmNvbG9yJywgJ25vcm1hbC10ZXh0LWNvbG9yJyk7XG4gICAgICAgIHRoaXMubWFwQ29sb3IoJ2NoYXJ0QXJlYS5iYWNrZ3JvdW5kJywgJ2JhY2tncm91bmQnKTtcbiAgICAgICAgdGhpcy5tYXBDb2xvcignbGVnZW5kLmluYWN0aXZlSXRlbXMubGFiZWxzLmNvbG9yJywgJ2NoYXJ0LWluYWN0aXZlJyk7XG4gICAgICAgIHRoaXMubWFwQ29sb3IoJ2xlZ2VuZC5pbmFjdGl2ZUl0ZW1zLm1hcmtlcnMuY29sb3InLCAnY2hhcnQtaW5hY3RpdmUnKTtcbiAgICAgICAgdGhpcy5tYXBDb2xvcignbGVnZW5kLmxhYmVscy5jb2xvcicsICdub3JtYWwtdGV4dC1jb2xvcicpO1xuICAgICAgICB0aGlzLm1hcENvbG9yKCdzZXJpZXNEZWZhdWx0cy5ib3hQbG90LmRvd25Db2xvcicsICdjaGFydC1tYWpvci1saW5lcycpO1xuICAgICAgICB0aGlzLm1hcENvbG9yKCdzZXJpZXNEZWZhdWx0cy5ib3hQbG90Lm1lYW4uY29sb3InLCAnYmFzZScpO1xuICAgICAgICB0aGlzLm1hcENvbG9yKCdzZXJpZXNEZWZhdWx0cy5ib3hQbG90Lm1lZGlhbi5jb2xvcicsICdiYXNlJyk7XG4gICAgICAgIHRoaXMubWFwQ29sb3IoJ3Nlcmllc0RlZmF1bHRzLmJveFBsb3Qud2hpc2tlcnMuY29sb3InLCAnYWNjZW50Jyk7XG4gICAgICAgIHRoaXMubWFwQ29sb3IoJ3Nlcmllc0RlZmF1bHRzLmJ1bGxldC50YXJnZXQuY29sb3InLCAnbm9ybWFsLXRleHQtY29sb3InKTtcbiAgICAgICAgdGhpcy5tYXBDb2xvcignc2VyaWVzRGVmYXVsdHMuY2FuZGxlc3RpY2suZG93bkNvbG9yJywgJ25vcm1hbC10ZXh0LWNvbG9yJyk7XG4gICAgICAgIHRoaXMubWFwQ29sb3IoJ3Nlcmllc0RlZmF1bHRzLmNhbmRsZXN0aWNrLmxpbmUuY29sb3InLCAnbm9ybWFsLXRleHQtY29sb3InKTtcbiAgICAgICAgdGhpcy5tYXBDb2xvcignc2VyaWVzRGVmYXVsdHMuZXJyb3JCYXJzLmNvbG9yJywgJ2NoYXJ0LWVycm9yLWJhcnMtYmFja2dyb3VuZCcpO1xuICAgICAgICB0aGlzLm1hcENvbG9yKCdzZXJpZXNEZWZhdWx0cy5ob3Jpem9udGFsV2F0ZXJmYWxsLmxpbmUuY29sb3InLCAnY2hhcnQtbWFqb3ItbGluZXMnKTtcbiAgICAgICAgdGhpcy5tYXBDb2xvcignc2VyaWVzRGVmYXVsdHMuaWNvbi5ib3JkZXIuY29sb3InLCAnY2hhcnQtbWFqb3ItbGluZXMnKTtcbiAgICAgICAgdGhpcy5tYXBDb2xvcignc2VyaWVzRGVmYXVsdHMubGFiZWxzLmJhY2tncm91bmQnLCAnYmFja2dyb3VuZCcpO1xuICAgICAgICB0aGlzLm1hcENvbG9yKCdzZXJpZXNEZWZhdWx0cy5sYWJlbHMuY29sb3InLCAnbm9ybWFsLXRleHQtY29sb3InKTtcbiAgICAgICAgdGhpcy5tYXBDb2xvcignc2VyaWVzRGVmYXVsdHMubm90ZXMuaWNvbi5iYWNrZ3JvdW5kJywgJ2NoYXJ0LW5vdGVzLWJhY2tncm91bmQnKTtcbiAgICAgICAgdGhpcy5tYXBDb2xvcignc2VyaWVzRGVmYXVsdHMubm90ZXMuaWNvbi5ib3JkZXIuY29sb3InLCAnY2hhcnQtbm90ZXMtYm9yZGVyJyk7XG4gICAgICAgIHRoaXMubWFwQ29sb3IoJ3Nlcmllc0RlZmF1bHRzLm5vdGVzLmxpbmUuY29sb3InLCAnY2hhcnQtbm90ZXMtbGluZXMnKTtcbiAgICAgICAgdGhpcy5tYXBDb2xvcignc2VyaWVzRGVmYXVsdHMudmVydGljYWxCb3hQbG90LmRvd25Db2xvcicsICdjaGFydC1tYWpvci1saW5lcycpO1xuICAgICAgICB0aGlzLm1hcENvbG9yKCdzZXJpZXNEZWZhdWx0cy52ZXJ0aWNhbEJveFBsb3QubWVhbi5jb2xvcicsICdiYXNlJyk7XG4gICAgICAgIHRoaXMubWFwQ29sb3IoJ3Nlcmllc0RlZmF1bHRzLnZlcnRpY2FsQm94UGxvdC5tZWRpYW4uY29sb3InLCAnYmFzZScpO1xuICAgICAgICB0aGlzLm1hcENvbG9yKCdzZXJpZXNEZWZhdWx0cy52ZXJ0aWNhbEJveFBsb3Qud2hpc2tlcnMuY29sb3InLCAnYWNjZW50Jyk7XG4gICAgICAgIHRoaXMubWFwQ29sb3IoJ3Nlcmllc0RlZmF1bHRzLnZlcnRpY2FsQnVsbGV0LnRhcmdldC5jb2xvcicsICdub3JtYWwtdGV4dC1jb2xvcicpO1xuICAgICAgICB0aGlzLm1hcENvbG9yKCdzZXJpZXNEZWZhdWx0cy53YXRlcmZhbGwubGluZS5jb2xvcicsICdjaGFydC1tYWpvci1saW5lcycpO1xuICAgICAgICB0aGlzLm1hcENvbG9yKCd0aXRsZS5jb2xvcicsICdub3JtYWwtdGV4dC1jb2xvcicpO1xuICAgICAgICBjb25zdCBvcGFjaXR5ID0gcGFyc2VGbG9hdCh0aGlzLnF1ZXJ5U3R5bGUoJ2NoYXJ0LWFyZWEtb3BhY2l0eScpLm9wYWNpdHkpO1xuICAgICAgICBpZiAoIWlzTmFOKG9wYWNpdHkpKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0eWxlKCdzZXJpZXNEZWZhdWx0cy5hcmVhLm9wYWNpdHknLCBvcGFjaXR5KTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3R5bGUoJ3Nlcmllc0RlZmF1bHRzLnJhZGFyQXJlYS5vcGFjaXR5Jywgb3BhY2l0eSk7XG4gICAgICAgICAgICB0aGlzLnNldFN0eWxlKCdzZXJpZXNEZWZhdWx0cy52ZXJ0aWNhbEFyZWEub3BhY2l0eScsIG9wYWNpdHkpO1xuICAgICAgICAgICAgdGhpcy5zZXRTdHlsZSgnc2VyaWVzRGVmYXVsdHMubGFiZWxzLm9wYWNpdHknLCBvcGFjaXR5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEluYWN0aXZlT3BhY2l0eShbJ2FyZWEnLCAndmVydGljYWxBcmVhJ10sICdjaGFydC1hcmVhLWluYWN0aXZlLW9wYWNpdHknKTtcbiAgICAgICAgdGhpcy5zZXRJbmFjdGl2ZU9wYWNpdHkoWydsaW5lJywgJ3ZlcnRpY2FsTGluZSddLCAnY2hhcnQtbGluZS1pbmFjdGl2ZS1vcGFjaXR5Jyk7XG4gICAgfVxuICAgIHNldEluYWN0aXZlT3BhY2l0eShzZXJpZXNUeXBlcywgc2VsZWN0b3IpIHtcbiAgICAgICAgY29uc3QgaW5hY3RpdmVPcGFjaXR5ID0gcGFyc2VGbG9hdCh0aGlzLnF1ZXJ5U3R5bGUoc2VsZWN0b3IpLm9wYWNpdHkpO1xuICAgICAgICBpZiAoIWlzTmFOKGluYWN0aXZlT3BhY2l0eSkgJiYgaW5hY3RpdmVPcGFjaXR5IDwgMSkge1xuICAgICAgICAgICAgc2VyaWVzVHlwZXMuZm9yRWFjaCh0eXBlID0+IHRoaXMuc2V0U3R5bGUoYHNlcmllc0RlZmF1bHRzLiR7dHlwZX0uaGlnaGxpZ2h0LmluYWN0aXZlT3BhY2l0eWAsIGluYWN0aXZlT3BhY2l0eSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEZvbnRzKCkge1xuICAgICAgICBjb25zdCBkZWZhdWx0Rm9udCA9IGZvbnQodGhpcy5xdWVyeVN0eWxlKCdjaGFydC1mb250JykpO1xuICAgICAgICBjb25zdCB0aXRsZUZvbnQgPSBmb250KHRoaXMucXVlcnlTdHlsZSgnY2hhcnQtdGl0bGUtZm9udCcpKTtcbiAgICAgICAgY29uc3QgcGFuZVRpdGxlRm9udCA9IGZvbnQodGhpcy5xdWVyeVN0eWxlKCdjaGFydC1wYW5lLXRpdGxlLWZvbnQnKSk7XG4gICAgICAgIGNvbnN0IGxhYmVsRm9udCA9IGZvbnQodGhpcy5xdWVyeVN0eWxlKCdjaGFydC1sYWJlbC1mb250JykpO1xuICAgICAgICB0aGlzLnNldFN0eWxlKCdheGlzRGVmYXVsdHMubGFiZWxzLmZvbnQnLCBsYWJlbEZvbnQpO1xuICAgICAgICB0aGlzLnNldFN0eWxlKCdheGlzRGVmYXVsdHMubm90ZXMubGFiZWwuZm9udCcsIGRlZmF1bHRGb250KTtcbiAgICAgICAgdGhpcy5zZXRTdHlsZSgnYXhpc0RlZmF1bHRzLnRpdGxlLmZvbnQnLCBkZWZhdWx0Rm9udCk7XG4gICAgICAgIHRoaXMuc2V0U3R5bGUoJ2xlZ2VuZC5sYWJlbHMuZm9udCcsIGRlZmF1bHRGb250KTtcbiAgICAgICAgdGhpcy5zZXRTdHlsZSgnc2VyaWVzRGVmYXVsdHMubGFiZWxzLmZvbnQnLCBsYWJlbEZvbnQpO1xuICAgICAgICB0aGlzLnNldFN0eWxlKCdzZXJpZXNEZWZhdWx0cy5ub3Rlcy5sYWJlbC5mb250JywgZGVmYXVsdEZvbnQpO1xuICAgICAgICB0aGlzLnNldFN0eWxlKCd0aXRsZS5mb250JywgdGl0bGVGb250KTtcbiAgICAgICAgdGhpcy5zZXRTdHlsZSgncGFuZURlZmF1bHRzLnRpdGxlLmZvbnQnLCBwYW5lVGl0bGVGb250KTtcbiAgICB9XG4gICAgc2V0U2VyaWVzQ29sb3JzKCkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgICAgICBjb25zdCBzZXJpZXMgPSBbXS5zbGljZS5jYWxsKGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmstdmFyLS1zZXJpZXMgZGl2JykpO1xuICAgICAgICBjb25zdCB1bnNldENvbG9yID0gY29tcHV0ZWRCYWNrZ3JvdW5kQ29sb3IoZWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuay12YXItLXNlcmllcy11bnNldCcpKTtcbiAgICAgICAgY29uc3Qgc2VyaWVzQ29sb3JzID0gc2VyaWVzLnJlZHVjZSgoYXJyLCBlbCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcG9zID0gc2VyaWVzUG9zKGVsLmNsYXNzTmFtZSk7XG4gICAgICAgICAgICBjb25zdCBjb2xvciA9IGNvbXB1dGVkQmFja2dyb3VuZENvbG9yKGVsKTtcbiAgICAgICAgICAgIGlmIChjb2xvciAhPT0gdW5zZXRDb2xvcikge1xuICAgICAgICAgICAgICAgIGFycltwb3NdID0gY29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgICB9LCBbXSAvLyBXaWxsIHBvcHVsYXRlIHRoZSBzZXJpZXMgY29sb3JzIGluIHRoaXMgYXJyYXlcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5zZXRTdHlsZSgnc2VyaWVzQ29sb3JzJywgc2VyaWVzQ29sb3JzKTtcbiAgICB9XG4gICAgbWFwQ29sb3Ioa2V5LCB2YXJOYW1lKSB7XG4gICAgICAgIHRoaXMuc2V0U3R5bGUoa2V5LCB0aGlzLnF1ZXJ5Q29sb3IodmFyTmFtZSkpO1xuICAgIH1cbiAgICBxdWVyeUNvbG9yKHZhck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlTdHlsZSh2YXJOYW1lKS5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgfVxuICAgIHF1ZXJ5U3R5bGUodmFyTmFtZSkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoYC5rLXZhci0tJHt2YXJOYW1lfWApO1xuICAgICAgICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgfVxufTtcblRoZW1lU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05nWm9uZV0pXG5dLCBUaGVtZVNlcnZpY2UpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgQ2hhcnRJbnN0YW5jZU9ic2VydmVyIGV4dGVuZHMgSW5zdGFuY2VPYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3IoaW5zdGFuY2UpIHtcbiAgICAgICAgc3VwZXIoaW5zdGFuY2UpO1xuICAgICAgICB0aGlzLmhhbmRsZXJNYXAgPSB7XG4gICAgICAgICAgICBoaWRlVG9vbHRpcDogJ29uSGlkZVRvb2x0aXAnLFxuICAgICAgICAgICAgbGVnZW5kSXRlbUNsaWNrOiAnb25MZWdlbmRJdGVtQ2xpY2snLFxuICAgICAgICAgICAgcmVuZGVyOiAnb25SZW5kZXInLFxuICAgICAgICAgICAgc2hvd1Rvb2x0aXA6ICdvblNob3dUb29sdGlwJyxcbiAgICAgICAgICAgIGluaXQ6ICdvbkluaXQnXG4gICAgICAgIH07XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IFRvb2x0aXBUZW1wbGF0ZVNlcnZpY2UgPSBjbGFzcyBUb29sdGlwVGVtcGxhdGVTZXJ2aWNlIHtcbiAgICBzZXRUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgfVxuICAgIGdldFRlbXBsYXRlKHNlcmllc0luZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLnNlcmllc1RlbXBsYXRlcyAmJiB0aGlzLnNlcmllc1RlbXBsYXRlc1tzZXJpZXNJbmRleF0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcmllc1RlbXBsYXRlc1tzZXJpZXNJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudGVtcGxhdGU7XG4gICAgfVxuICAgIHNldFNlcmllc1RlbXBsYXRlcyhzZXJpZXNUZW1wbGF0ZXMpIHtcbiAgICAgICAgdGhpcy5zZXJpZXNUZW1wbGF0ZXMgPSBzZXJpZXNUZW1wbGF0ZXM7XG4gICAgfVxuICAgIHNldFNoYXJlZFRlbXBsYXRlKHNoYXJlZFRlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMuc2hhcmVkVGVtcGxhdGUgPSBzaGFyZWRUZW1wbGF0ZTtcbiAgICB9XG4gICAgZ2V0U2hhcmVkVGVtcGxhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoYXJlZFRlbXBsYXRlO1xuICAgIH1cbn07XG5Ub29sdGlwVGVtcGxhdGVTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpXG5dLCBUb29sdGlwVGVtcGxhdGVTZXJ2aWNlKTtcblxuLyoqXG4gKiBBIGRpcmVjdGl2ZSB0aGF0IHNlbGVjdHMgYSBbdGVtcGxhdGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ3RlbXBsYXRlc3ludGF4J10gfX0pXG4gKiB3aXRoaW4gdGhlIGA8a2VuZG8tY2hhcnQtdG9vbHRpcD5gIGNvbXBvbmVudCBmb3IgdGhlXG4gKiBbc2VyaWVzIHRvb2x0aXBdKHslIHNsdWcgdG9vbHRpcHNfY2hhcnRfY2hhcnRzICV9I3RvYy1zZXJpZXMtdG9vbHRpcCkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiBfQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgdGVtcGxhdGU6IGBcbiAqICAgICA8a2VuZG8tY2hhcnQ+XG4gKiAgICAgICA8a2VuZG8tY2hhcnQtdG9vbHRpcD5cbiAqICAgICAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb0NoYXJ0U2VyaWVzVG9vbHRpcFRlbXBsYXRlIGxldC12YWx1ZT1cInZhbHVlXCI+XG4gKiAgICAgICAgICAgICBWYWx1ZSBpcyB7e3ZhbHVlfX1cbiAqICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICogICAgICAgPC9rZW5kby1jaGFydC10b29sdGlwPlxuICogICAgICAgPGtlbmRvLWNoYXJ0LXNlcmllcz5cbiAqICAgICAgICAgPGtlbmRvLWNoYXJ0LXNlcmllcy1pdGVtIFtkYXRhXT1cIlsxLCAyLCAzXVwiPlxuICogICAgICAgICA8L2tlbmRvLWNoYXJ0LXNlcmllcy1pdGVtPlxuICogICAgICAgPC9rZW5kby1jaGFydC1zZXJpZXM+XG4gKiAgICAgPC9rZW5kby1jaGFydD5cbiAqICAgYFxuICogfSlcbiAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiB9XG4gKlxuICogYGBgXG4gKi9cbmxldCBTZXJpZXNUb29sdGlwVGVtcGxhdGVEaXJlY3RpdmUgPSBjbGFzcyBTZXJpZXNUb29sdGlwVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlUmVmKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVSZWYgPSB0ZW1wbGF0ZVJlZjtcbiAgICB9XG59O1xuU2VyaWVzVG9vbHRpcFRlbXBsYXRlRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9DaGFydFNlcmllc1Rvb2x0aXBUZW1wbGF0ZV0nXG4gICAgfSksXG4gICAgX19wYXJhbSgwLCBPcHRpb25hbCgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1RlbXBsYXRlUmVmXSlcbl0sIFNlcmllc1Rvb2x0aXBUZW1wbGF0ZURpcmVjdGl2ZSk7XG5cbi8qKlxuICogQSBkaXJlY3RpdmUgdGhhdCBzZWxlY3RzIGEgW3RlbXBsYXRlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyd0ZW1wbGF0ZXN5bnRheCddIH19KVxuICogd2l0aGluIHRoZSBgPGtlbmRvLWNoYXJ0LXRvb2x0aXA+YCBjb21wb25lbnQgZm9yIHRoZVxuICogW3NoYXJlZCBzZXJpZXMgdG9vbHRpcF0oeyUgc2x1ZyB0b29sdGlwc19jaGFydF9jaGFydHMgJX0jdG9jLXNoYXJlZC10b29sdGlwKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICpcbiAqIF9AQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICB0ZW1wbGF0ZTogYFxuICogICAgIDxrZW5kby1jaGFydD5cbiAqICAgICAgIDxrZW5kby1jaGFydC10b29sdGlwIFtzaGFyZWRdPVwidHJ1ZVwiPlxuICogICAgICAgICA8bmctdGVtcGxhdGUga2VuZG9DaGFydFNoYXJlZFRvb2x0aXBUZW1wbGF0ZSBsZXQtY2F0ZWdvcnk9XCJjYXRlZ29yeVwiIGxldC1wb2ludHM9XCJwb2ludHNcIj5cbiAqICAgICAgICAgICAgIDxkaXY+IHt7IGNhdGVnb3J5IH19IDwvZGl2PlxuICogICAgICAgICAgICAgPGRpdiAqbmdGb3I9XCJsZXQgcG9pbnQgb2YgcG9pbnRzXCI+XG4gKiAgICAgICAgICAgICAgICAge3sgcG9pbnQuc2VyaWVzLm5hbWUgfX0gOiB7eyBwb2ludC52YWx1ZSB9fVxuICogICAgICAgICAgICAgPC9kaXY+XG4gKiAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICA8L2tlbmRvLWNoYXJ0LXRvb2x0aXA+XG4gKiAgICAgICA8a2VuZG8tY2hhcnQtY2F0ZWdvcnktYXhpcz5cbiAqICAgICAgICAgPGtlbmRvLWNoYXJ0LWNhdGVnb3J5LWF4aXMtaXRlbSBbY2F0ZWdvcmllc109XCJbJ0EnLCAnQicsICdDJ11cIj5cbiAqICAgICAgICAgPC9rZW5kby1jaGFydC1jYXRlZ29yeS1heGlzLWl0ZW0+XG4gKiAgICAgICA8L2tlbmRvLWNoYXJ0LWNhdGVnb3J5LWF4aXM+XG4gKiAgICAgICA8a2VuZG8tY2hhcnQtc2VyaWVzPlxuICogICAgICAgICA8a2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0gbmFtZT1cIkFcIiBbZGF0YV09XCJbMSwgMiwgM11cIj5cbiAqICAgICAgICAgPC9rZW5kby1jaGFydC1zZXJpZXMtaXRlbT5cbiAqICAgICAgICAgPGtlbmRvLWNoYXJ0LXNlcmllcy1pdGVtIG5hbWU9XCJCXCIgW2RhdGFdPVwiWzEsIDIsIDNdXCI+XG4gKiAgICAgICAgIDwva2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0+XG4gKiAgICAgICA8L2tlbmRvLWNoYXJ0LXNlcmllcz5cbiAqICAgICA8L2tlbmRvLWNoYXJ0PlxuICogICBgXG4gKiB9KVxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqIH1cbiAqXG4gKiBgYGBcbiAqL1xubGV0IFNoYXJlZFRvb2x0aXBUZW1wbGF0ZURpcmVjdGl2ZSA9IGNsYXNzIFNoYXJlZFRvb2x0aXBUZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cbn07XG5TaGFyZWRUb29sdGlwVGVtcGxhdGVEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0NoYXJ0U2hhcmVkVG9vbHRpcFRlbXBsYXRlXSdcbiAgICB9KSxcbiAgICBfX3BhcmFtKDAsIE9wdGlvbmFsKCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbVGVtcGxhdGVSZWZdKVxuXSwgU2hhcmVkVG9vbHRpcFRlbXBsYXRlRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBUaGUgcG9pbnQgdGhhdCBpcyBwYXNzZWQgdG8gdGhlIHRvb2x0aXAgdGVtcGxhdGUuXG4gKi9cbmNsYXNzIFRvb2x0aXBUZW1wbGF0ZVBvaW50IHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocG9pbnQsIGZvcm1hdCwgdGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHBvaW50LnZhbHVlO1xuICAgICAgICB0aGlzLmNhdGVnb3J5ID0gcG9pbnQuY2F0ZWdvcnk7XG4gICAgICAgIHRoaXMuY2F0ZWdvcnlJbmRleCA9IHBvaW50LmNhdGVnb3J5SXg7XG4gICAgICAgIHRoaXMuc2VyaWVzID0gcG9pbnQuc2VyaWVzO1xuICAgICAgICB0aGlzLmRhdGFJdGVtID0gcG9pbnQuZGF0YUl0ZW07XG4gICAgICAgIHRoaXMucGVyY2VudGFnZSA9IHBvaW50LnBlcmNlbnRhZ2U7XG4gICAgICAgIHRoaXMucnVubmluZ1RvdGFsID0gcG9pbnQucnVubmluZ1RvdGFsO1xuICAgICAgICB0aGlzLnRvdGFsID0gcG9pbnQudG90YWw7XG4gICAgICAgIHRoaXMubG93ID0gcG9pbnQubG93O1xuICAgICAgICB0aGlzLmhpZ2ggPSBwb2ludC5oaWdoO1xuICAgICAgICB0aGlzLnhMb3cgPSBwb2ludC54TG93O1xuICAgICAgICB0aGlzLnhIaWdoID0gcG9pbnQueEhpZ2g7XG4gICAgICAgIHRoaXMueUxvdyA9IHBvaW50LnlMb3c7XG4gICAgICAgIHRoaXMueUhpZ2ggPSBwb2ludC55SGlnaDtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgICAgICB0aGlzLnBvaW50ID0gcG9pbnQ7XG4gICAgICAgIHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGZvcm1hdHRlZFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQgPyB0aGlzLnBvaW50LmZvcm1hdFZhbHVlKHRoaXMuZm9ybWF0KSA6IFN0cmluZyh0aGlzLnZhbHVlKTtcbiAgICB9XG59XG5cbi8qIHRzbGludDpkaXNhYmxlOmFsaWduIG5vLWVtcHR5ICovXG5jb25zdCBQT1NJVElPTl9NT0RFID0gJ2Fic29sdXRlJztcbmNvbnN0IENPTExJU0lPTiA9IHsgaG9yaXpvbnRhbDogXCJmaXRcIiwgdmVydGljYWw6IFwiZml0XCIgfTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBCYXNlVG9vbHRpcCB7XG4gICAgY29uc3RydWN0b3IocG9wdXBTZXJ2aWNlLCBsb2NhbGl6YXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMucG9wdXBTZXJ2aWNlID0gcG9wdXBTZXJ2aWNlO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvblNlcnZpY2UgPSBsb2NhbGl6YXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLnN0eWxlID0ge307XG4gICAgICAgIHRoaXMucG9wdXBSZWYgPSBudWxsO1xuICAgIH1cbiAgICBnZXQgYWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3B1cFJlZiAhPT0gbnVsbDtcbiAgICB9XG4gICAgc2hvdyhlKSB7XG4gICAgICAgIGNvbnN0IGFsaWduID0gZS5hbmNob3IuYWxpZ247XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMucG9zaXRpb24oZS5hbmNob3IucG9pbnQpO1xuICAgICAgICB0aGlzLnN0eWxlID0gZS5zdHlsZTtcbiAgICAgICAgaWYgKCF0aGlzLnBvcHVwUmVmKSB7XG4gICAgICAgICAgICB0aGlzLnBvcHVwUmVmID0gdGhpcy5wb3B1cFNlcnZpY2Uub3BlbihPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICAgICAgICBwb3B1cEFsaWduOiBhbGlnbixcbiAgICAgICAgICAgICAgICBhbmltYXRlOiB0aGlzLmFuaW1hdGUsXG4gICAgICAgICAgICAgICAgY29udGVudDogdGhpcy50ZW1wbGF0ZVJlZixcbiAgICAgICAgICAgICAgICBjb2xsaXNpb246IENPTExJU0lPTixcbiAgICAgICAgICAgICAgICBwb3NpdGlvbk1vZGU6IFBPU0lUSU9OX01PREVcbiAgICAgICAgICAgIH0sIHRoaXMucG9wdXBTZXR0aW5ncykpO1xuICAgICAgICAgICAgaWYgKHRoaXMubG9jYWxpemF0aW9uU2VydmljZS5ydGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcHVwUmVmLnBvcHVwRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RpcicsICdydGwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub25Jbml0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwb3B1cCA9IHRoaXMucG9wdXBSZWYucG9wdXAuaW5zdGFuY2U7XG4gICAgICAgICAgICBwb3B1cC5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICBwb3B1cC5wb3B1cEFsaWduID0gYWxpZ247XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGlkZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucG9wdXBSZWYpIHtcbiAgICAgICAgICAgIHRoaXMucG9wdXBSZWYuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMucG9wdXBSZWYgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uSW5pdCgpIHtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH1cbiAgICBwb3NpdGlvbihvZmZzZXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBvcHVwU2V0dGluZ3MgfHwgIXRoaXMucG9wdXBTZXR0aW5ncy5hcHBlbmRUbykge1xuICAgICAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcHBlbmRUbyA9IHRoaXMucG9wdXBTZXR0aW5ncy5hcHBlbmRUby5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnNvbGUubG9nKCdhcHBlbmRUbycsIGFwcGVuZFRvKTtcbiAgICAgICAgY29uc3QgYmJveCA9IGFwcGVuZFRvLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCB7IHNjcm9sbExlZnQsIHNjcm9sbFRvcCB9ID0gdGhpcy5zY3JvbGxPZmZzZXQoYXBwZW5kVG8pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogb2Zmc2V0LmxlZnQgLSBiYm94LmxlZnQgLSBzY3JvbGxMZWZ0LFxuICAgICAgICAgICAgdG9wOiBvZmZzZXQudG9wIC0gYmJveC50b3AgLSBzY3JvbGxUb3BcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc2Nyb2xsT2Zmc2V0KGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2Nyb2xsTGVmdCA9IGVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICAgICAgbGV0IHNjcm9sbFRvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgICAgICBsZXQgcGFyZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgICBzY3JvbGxMZWZ0ICs9IHBhcmVudC5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgc2Nyb2xsVG9wICs9IHBhcmVudC5zY3JvbGxUb3A7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzY3JvbGxMZWZ0LCBzY3JvbGxUb3AgfTtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBoYXNQYXJlbnQoZWxlbWVudCwgcGFyZW50KSB7XG4gICAgbGV0IGN1cnJlbnQgPSBlbGVtZW50O1xuICAgIHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnQgIT09IHBhcmVudCkge1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudCA/IHRydWUgOiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGJvZHlGYWN0b3J5KCkge1xuICAgIGlmIChpc0RvY3VtZW50QXZhaWxhYmxlKCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50UmVmKGRvY3VtZW50LmJvZHkpO1xuICAgIH1cbn1cblxuY29uc3QgU0hBUkVEX1RPT0xUSVBfQ0xBU1MgPSAnay1jaGFydC1zaGFyZWQtdG9vbHRpcCc7XG5jb25zdCBUT09MVElQX0NMQVNTID0gXCJrLWNoYXJ0LXRvb2x0aXBcIjtcbmNvbnN0IMm1MCQyID0gYm9keUZhY3Rvcnk7XG4vLyBDb2RlbHl6ZXIgMi4wLjAtYmV0YTIgZG9lc24ndCBoYW5kbGUgaW5oZXJpdGVkIG1lbWJlcnNcbi8qIHRzbGludDpkaXNhYmxlOm5vLWFjY2Vzcy1taXNzaW5nLW1lbWJlciAqL1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBUb29sdGlwUG9wdXBDb21wb25lbnQgPSBjbGFzcyBUb29sdGlwUG9wdXBDb21wb25lbnQgZXh0ZW5kcyBCYXNlVG9vbHRpcCB7XG4gICAgY29uc3RydWN0b3IocG9wdXBTZXJ2aWNlLCB0ZW1wbGF0ZVNlcnZpY2UsIGxvY2FsaXphdGlvblNlcnZpY2UsIG5nWm9uZSkge1xuICAgICAgICBzdXBlcihwb3B1cFNlcnZpY2UsIGxvY2FsaXphdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLnBvcHVwU2VydmljZSA9IHBvcHVwU2VydmljZTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVNlcnZpY2UgPSB0ZW1wbGF0ZVNlcnZpY2U7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uU2VydmljZSA9IGxvY2FsaXphdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLnNlcmllc1Rvb2x0aXBDb250ZXh0ID0ge307XG4gICAgICAgIHRoaXMuc2VyaWVzU2hhcmVkVG9vbHRpcENvbnRleHQgPSB7fTtcbiAgICAgICAgdGhpcy5hbmltYXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy53cmFwcGVyQ2xhc3MgPSAnay1jaGFydC10b29sdGlwLXdyYXBwZXInO1xuICAgICAgICB0aGlzLmxlYXZlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnBvcHVwQ2xhc3NlcyA9IHt9O1xuICAgIH1cbiAgICBzaG93KGUpIHtcbiAgICAgICAgdGhpcy5zaGFyZWQgPSBlLnNoYXJlZDtcbiAgICAgICAgdGhpcy5wb3B1cENsYXNzZXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIFtTSEFSRURfVE9PTFRJUF9DTEFTU106IGUuc2hhcmVkLFxuICAgICAgICAgICAgW1RPT0xUSVBfQ0xBU1NdOiB0cnVlLFxuICAgICAgICAgICAgW2UuY2xhc3NOYW1lXTogISFlLmNsYXNzTmFtZVxuICAgICAgICB9LCB0aGlzLmNsYXNzTmFtZXMpO1xuICAgICAgICBpZiAoIWUuc2hhcmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNlcmllc1Rvb2x0aXBDb250ZXh0ID0gbmV3IFRvb2x0aXBUZW1wbGF0ZVBvaW50KGUucG9pbnQsIGUuZm9ybWF0KTtcbiAgICAgICAgICAgIHRoaXMuc2VyaWVzVG9vbHRpcFRlbXBsYXRlUmVmID0gdGhpcy5wb2ludFRlbXBsYXRlUmVmKGUucG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXJpZXNTaGFyZWRUb29sdGlwVGVtcGxhdGVSZWYgPSB0aGlzLnRlbXBsYXRlU2VydmljZS5nZXRTaGFyZWRUZW1wbGF0ZSgpXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5kZWZhdWx0U2hhcmVkVG9vbHRpcFRlbXBsYXRlLnRlbXBsYXRlUmVmO1xuICAgICAgICAgICAgdGhpcy5zZXJpZXNTaGFyZWRUb29sdGlwQ29udGV4dCA9IHRoaXMuc2hhcmVkVGVtcGxhdGVDb250ZXh0KGUpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLnNob3coZSk7XG4gICAgfVxuICAgIGNvbnRhaW5zRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnBvcHVwUmVmKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFzUGFyZW50KGVsZW1lbnQsIHRoaXMucG9wdXBSZWYucG9wdXBFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzaGFyZWRUZW1wbGF0ZUNvbnRleHQoZSkge1xuICAgICAgICBjb25zdCBwb2ludHMgPSBlLnBvaW50cztcbiAgICAgICAgY29uc3QgbmFtZUNvbHVtbiA9IHBvaW50cy5maWx0ZXIoKHBvaW50KSA9PiB0eXBlb2YgcG9pbnQuc2VyaWVzLm5hbWUgIT09ICd1bmRlZmluZWQnKS5sZW5ndGggPiAwO1xuICAgICAgICBjb25zdCBjb2xvck1hcmtlciA9IGUuc2VyaWVzLmxlbmd0aCA+IDE7XG4gICAgICAgIGxldCBjb2xzcGFuID0gMTtcbiAgICAgICAgaWYgKG5hbWVDb2x1bW4pIHtcbiAgICAgICAgICAgIGNvbHNwYW4rKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sb3JNYXJrZXIpIHtcbiAgICAgICAgICAgIGNvbHNwYW4rKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2F0ZWdvcnk6IGUuY2F0ZWdvcnksXG4gICAgICAgICAgICBjYXRlZ29yeVRleHQ6IGUuY2F0ZWdvcnlUZXh0LFxuICAgICAgICAgICAgY29sb3JNYXJrZXI6IGNvbG9yTWFya2VyLFxuICAgICAgICAgICAgY29sc3BhbjogY29sc3BhbixcbiAgICAgICAgICAgIG5hbWVDb2x1bW46IG5hbWVDb2x1bW4sXG4gICAgICAgICAgICBwb2ludHM6IHRoaXMud3JhcFBvaW50cyhlLnBvaW50cywgZS5mb3JtYXQpXG4gICAgICAgIH07XG4gICAgfVxuICAgIHBvaW50VGVtcGxhdGVSZWYocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGVtcGxhdGVTZXJ2aWNlLmdldFRlbXBsYXRlKHBvaW50LnNlcmllcy5pbmRleCkgfHwgdGhpcy5kZWZhdWx0U2VyaWVzVG9vbHRpcFRlbXBsYXRlLnRlbXBsYXRlUmVmO1xuICAgIH1cbiAgICB3cmFwUG9pbnRzKHBvaW50cywgZm9ybWF0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBwb2ludHMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaWR4XTtcbiAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGhpcy5wb2ludFRlbXBsYXRlUmVmKHBvaW50KTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50Rm9ybWF0ID0gKChwb2ludC5vcHRpb25zIHx8IHt9KS50b29sdGlwIHx8IHt9KS5mb3JtYXQgfHwgZm9ybWF0O1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFRvb2x0aXBUZW1wbGF0ZVBvaW50KHBvaW50LCBwb2ludEZvcm1hdCwgdGVtcGxhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBvbkluaXQoKSB7XG4gICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubW91c2VsZWF2ZVN1YnNjcmlwdGlvbiA9IHRoaXMucG9wdXBSZWYucG9wdXBFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCAoYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubGVhdmUuZW1pdChhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wb3B1cFJlZi5wb3B1cEVsZW1lbnQuY2xhc3NOYW1lICs9IGAgJHt0aGlzLndyYXBwZXJDbGFzc31gO1xuICAgIH1cbiAgICBoaWRlKCkge1xuICAgICAgICBpZiAodGhpcy5tb3VzZWxlYXZlU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm1vdXNlbGVhdmVTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgIHRoaXMubW91c2VsZWF2ZVN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuaGlkZSgpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoU2VyaWVzVG9vbHRpcFRlbXBsYXRlRGlyZWN0aXZlLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFNlcmllc1Rvb2x0aXBUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIFRvb2x0aXBQb3B1cENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVmYXVsdFNlcmllc1Rvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKFNoYXJlZFRvb2x0aXBUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTaGFyZWRUb29sdGlwVGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBUb29sdGlwUG9wdXBDb21wb25lbnQucHJvdG90eXBlLCBcImRlZmF1bHRTaGFyZWRUb29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgnY29udGVudCcsIHsgc3RhdGljOiB0cnVlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBUZW1wbGF0ZVJlZilcbl0sIFRvb2x0aXBQb3B1cENvbXBvbmVudC5wcm90b3R5cGUsIFwidGVtcGxhdGVSZWZcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUb29sdGlwUG9wdXBDb21wb25lbnQucHJvdG90eXBlLCBcImFuaW1hdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFRvb2x0aXBQb3B1cENvbXBvbmVudC5wcm90b3R5cGUsIFwiY2xhc3NOYW1lc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVG9vbHRpcFBvcHVwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwb3B1cFNldHRpbmdzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUb29sdGlwUG9wdXBDb21wb25lbnQucHJvdG90eXBlLCBcIndyYXBwZXJDbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFRvb2x0aXBQb3B1cENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVhdmVcIiwgdm9pZCAwKTtcblRvb2x0aXBQb3B1cENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHByb3ZpZGVyczogW1BvcHVwU2VydmljZSwge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IFBPUFVQX0NPTlRBSU5FUixcbiAgICAgICAgICAgICAgICB1c2VGYWN0b3J5OiDJtTAkMlxuICAgICAgICAgICAgfV0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtdG9vbHRpcC1wb3B1cCcsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPG5nLXRlbXBsYXRlICNjb250ZW50PlxuICAgICAgICA8ZGl2IFtuZ0NsYXNzXT1cInBvcHVwQ2xhc3Nlc1wiIFtuZ1N0eWxlXT1cInN0eWxlXCI+XG4gICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInNlcmllc1Rvb2x0aXBUZW1wbGF0ZVJlZlwiICpuZ0lmPVwiIXNoYXJlZFwiXG4gICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJzZXJpZXNUb29sdGlwQ29udGV4dFwiPlxuICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInNlcmllc1NoYXJlZFRvb2x0aXBUZW1wbGF0ZVJlZlwiICpuZ0lmPVwic2hhcmVkXCJcbiAgICAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInNlcmllc1NoYXJlZFRvb2x0aXBDb250ZXh0XCI+XG4gICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgIDxuZy10ZW1wbGF0ZSBrZW5kb0NoYXJ0U2VyaWVzVG9vbHRpcFRlbXBsYXRlIGxldC1mb3JtYXR0ZWRWYWx1ZT1cImZvcm1hdHRlZFZhbHVlXCI+XG4gICAgICAgIDxzcGFuIFtpbm5lckhUTUxdPVwiZm9ybWF0dGVkVmFsdWVcIj48L3NwYW4+XG4gICAgPC9uZy10ZW1wbGF0ZT5cbiAgICA8bmctdGVtcGxhdGUga2VuZG9DaGFydFNoYXJlZFRvb2x0aXBUZW1wbGF0ZSBsZXQtcG9pbnRzPVwicG9pbnRzXCIgbGV0LWNhdGVnb3J5VGV4dD1cImNhdGVnb3J5VGV4dFwiIGxldC1jb2xzcGFuPVwiY29sc3BhblwiIGxldC1jb2xvck1hcmtlcj1cImNvbG9yTWFya2VyXCIgbGV0LW5hbWVDb2x1bW49XCJuYW1lQ29sdW1uXCIgPlxuICAgICAgICA8dGFibGU+XG4gICAgICAgICAgICA8dHI+PHRoIFthdHRyLmNvbHNwYW5dPSdjb2xzcGFuJz4ge3sgY2F0ZWdvcnlUZXh0IH19IDwvdGg+PC90cj5cbiAgICAgICAgICAgIDx0ciAqbmdGb3I9XCJsZXQgcG9pbnQgb2YgcG9pbnRzXCI+XG4gICAgICAgICAgICAgICAgPHRkICpuZ0lmPVwiY29sb3JNYXJrZXJcIj48c3BhbiBjbGFzcz0nay1jaGFydC1zaGFyZWQtdG9vbHRpcC1tYXJrZXInIFtzdHlsZS5iYWNrZ3JvdW5kLWNvbG9yXT0ncG9pbnQuc2VyaWVzLmNvbG9yJz48L3NwYW4+PC90ZD5cbiAgICAgICAgICAgICAgICA8dGQgKm5nSWY9XCJuYW1lQ29sdW1uXCI+XG4gICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJwb2ludC5zZXJpZXMubmFtZSAhPT0gdW5kZWZpbmVkXCI+e3sgcG9pbnQuc2VyaWVzLm5hbWUgfX08L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cInBvaW50LnNlcmllcy5uYW1lID09PSB1bmRlZmluZWRcIj4mbmJzcDs8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICAgIDx0ZD5cbiAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdUZW1wbGF0ZU91dGxldF09XCJwb2ludC50ZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInBvaW50XCI+XG4gICAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICA8L3RyPlxuICAgICAgICA8L3RhYmxlPlxuICAgIDwvbmctdGVtcGxhdGU+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbUG9wdXBTZXJ2aWNlLFxuICAgICAgICBUb29sdGlwVGVtcGxhdGVTZXJ2aWNlLFxuICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICBOZ1pvbmVdKVxuXSwgVG9vbHRpcFBvcHVwQ29tcG9uZW50KTtcblxuY29uc3QgybUwJDMgPSBib2R5RmFjdG9yeTtcbi8vIENvZGVseXplciAyLjAuMC1iZXRhMiBkb2Vzbid0IGhhbmRsZSBpbmhlcml0ZWQgbWVtYmVyc1xuLyogdHNsaW50OmRpc2FibGU6bm8tYWNjZXNzLW1pc3NpbmctbWVtYmVyICovXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IENyb3NzaGFpclRvb2x0aXBDb21wb25lbnQgPSBjbGFzcyBDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50IGV4dGVuZHMgQmFzZVRvb2x0aXAge1xuICAgIGNvbnN0cnVjdG9yKHBvcHVwU2VydmljZSwgbG9jYWxpemF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihwb3B1cFNlcnZpY2UsIGxvY2FsaXphdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmFuaW1hdGUgPSBmYWxzZTtcbiAgICB9XG4gICAgc2hvdyhlKSB7XG4gICAgICAgIHN1cGVyLnNob3coZSk7XG4gICAgICAgIHRoaXMudmFsdWUgPSBlLnZhbHVlO1xuICAgICAgICB0aGlzLnBvcHVwUmVmLnBvcHVwLmNoYW5nZURldGVjdG9yUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKCdjb250ZW50JywgeyBzdGF0aWM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFRlbXBsYXRlUmVmKVxuXSwgQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudC5wcm90b3R5cGUsIFwidGVtcGxhdGVSZWZcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENyb3NzaGFpclRvb2x0aXBDb21wb25lbnQucHJvdG90eXBlLCBcImtleVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudC5wcm90b3R5cGUsIFwicG9wdXBTZXR0aW5nc1wiLCB2b2lkIDApO1xuQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHByb3ZpZGVyczogW1BvcHVwU2VydmljZSwge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IFBPUFVQX0NPTlRBSU5FUixcbiAgICAgICAgICAgICAgICB1c2VGYWN0b3J5OiDJtTAkM1xuICAgICAgICAgICAgfV0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtY3Jvc3NoYWlyLXRvb2x0aXAnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctdGVtcGxhdGUgI2NvbnRlbnQ+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiay1jaGFydC10b29sdGlwIGstY2hhcnQtY3Jvc3NoYWlyLXRvb2x0aXBcIiBbbmdTdHlsZV09XCJzdHlsZVwiPlxuICAgICAgICAgICAgICAgIHt7IHZhbHVlIH19XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtQb3B1cFNlcnZpY2UsIExvY2FsaXphdGlvblNlcnZpY2VdKVxuXSwgQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudCk7XG5cbmNvbnN0IEFYRVMgPSBbXCJjYXRlZ29yeUF4aXNcIiwgXCJ2YWx1ZUF4aXNcIiwgXCJ4QXhpc1wiLCBcInlBeGlzXCJdO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBDcm9zc2hhaXJUb29sdGlwc0NvbnRhaW5lckNvbXBvbmVudCA9IGNsYXNzIENyb3NzaGFpclRvb2x0aXBzQ29udGFpbmVyQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudG9vbHRpcEtleXMgPSBbXTtcbiAgICAgICAgdGhpcy50b29sdGlwc01hcCA9IHt9O1xuICAgIH1cbiAgICBzaG93KGUpIHtcbiAgICAgICAgY29uc3QgdG9vbHRpcENvbXBvbmVudHMgPSB0aGlzLmNyb3NzYWhpclRvb2x0aXBDb21wb25lbnRzLnRvQXJyYXkoKTtcbiAgICAgICAgY29uc3QgYXhpc05hbWUgPSBlLmF4aXNOYW1lO1xuICAgICAgICBjb25zdCBheGlzSW5kZXggPSBlLmF4aXNJbmRleDtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgdG9vbHRpcENvbXBvbmVudHMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgaWYgKHRvb2x0aXBDb21wb25lbnRzW2lkeF0ua2V5ID09PSBheGlzTmFtZSArIGF4aXNJbmRleCkge1xuICAgICAgICAgICAgICAgIHRvb2x0aXBDb21wb25lbnRzW2lkeF0uc2hvdyhlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBoaWRlKCkge1xuICAgICAgICBjb25zdCB0b29sdGlwQ29tcG9uZW50cyA9IHRoaXMuY3Jvc3NhaGlyVG9vbHRpcENvbXBvbmVudHMudG9BcnJheSgpO1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCB0b29sdGlwQ29tcG9uZW50cy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICB0b29sdGlwQ29tcG9uZW50c1tpZHhdLmhpZGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgYWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b29sdGlwS2V5cy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBjcmVhdGVDcm9zc2hhaXJUb29sdGlwcyhvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG5ld01hcCA9IHRoaXMubWFwVG9vbHRpcHMob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IG1hcCA9IHRoaXMudG9vbHRpcHNNYXA7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBtYXApIHtcbiAgICAgICAgICAgIGlmICghbmV3TWFwW2tleV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVRvb2x0aXAoa2V5KTtcbiAgICAgICAgICAgICAgICBkZWxldGUgbWFwW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQga2V5IGluIG5ld01hcCkge1xuICAgICAgICAgICAgaWYgKCFtYXBba2V5XSkge1xuICAgICAgICAgICAgICAgIG1hcFtrZXldID0gbmV3TWFwW2tleV07XG4gICAgICAgICAgICAgICAgdGhpcy50b29sdGlwS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlVG9vbHRpcChrZXkpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IHRoaXMudG9vbHRpcEtleXM7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGtleXMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgaWYgKGtleXNbaWR4XSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAga2V5cy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXBUb29sdGlwcyhvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG1hcCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBBWEVTLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRvb2x0aXBzID0gdGhpcy5heGVzQ3Jvc3NoYWlyVG9vbHRpcE9wdGlvbnMob3B0aW9ucywgQVhFU1tpZHhdKTtcbiAgICAgICAgICAgIGZvciAobGV0IHRvb2x0aXBJZHggPSAwOyB0b29sdGlwSWR4IDwgdG9vbHRpcHMubGVuZ3RoOyB0b29sdGlwSWR4KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29sdGlwID0gdG9vbHRpcHNbdG9vbHRpcElkeF07XG4gICAgICAgICAgICAgICAgbWFwW3Rvb2x0aXAubmFtZSArIHRvb2x0aXAuaW5kZXhdID0gdG9vbHRpcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICBheGVzQ3Jvc3NoYWlyVG9vbHRpcE9wdGlvbnMob3B0aW9ucywgbmFtZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKG9wdGlvbnNbbmFtZV0pIHtcbiAgICAgICAgICAgIGNvbnN0IGF4ZXMgPSBbXS5jb25jYXQob3B0aW9uc1tuYW1lXSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBheGVzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29sdGlwID0gKGF4ZXNbaWR4XS5jcm9zc2hhaXIgfHwge30pLnRvb2x0aXA7XG4gICAgICAgICAgICAgICAgaWYgKHRvb2x0aXAgJiYgdG9vbHRpcC52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpZHgsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDcm9zc2hhaXJUb29sdGlwc0NvbnRhaW5lckNvbXBvbmVudC5wcm90b3R5cGUsIFwicG9wdXBTZXR0aW5nc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkcmVuKENyb3NzaGFpclRvb2x0aXBDb21wb25lbnQpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBRdWVyeUxpc3QpXG5dLCBDcm9zc2hhaXJUb29sdGlwc0NvbnRhaW5lckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY3Jvc3NhaGlyVG9vbHRpcENvbXBvbmVudHNcIiwgdm9pZCAwKTtcbkNyb3NzaGFpclRvb2x0aXBzQ29udGFpbmVyQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1jcm9zc2hhaXItdG9vbHRpcHMtY29udGFpbmVyJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGtlbmRvLWNoYXJ0LWNyb3NzaGFpci10b29sdGlwICpuZ0Zvcj1cImxldCBrZXkgb2YgdG9vbHRpcEtleXNcIiBba2V5XT1cImtleVwiIFtwb3B1cFNldHRpbmdzXT1cInBvcHVwU2V0dGluZ3NcIj5cbiAgICAgICAgPC9rZW5kby1jaGFydC1jcm9zc2hhaXItdG9vbHRpcD5cbiAgICBgXG4gICAgfSlcbl0sIENyb3NzaGFpclRvb2x0aXBzQ29udGFpbmVyQ29tcG9uZW50KTtcblxuY29uc3QgZ2V0VG91Y2ggPSAoZG9tRXZlbnQpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiB7XG4gICAgICAgICAgICBsb2NhdGlvbjogZG9tRXZlbnQucGFnZVhcbiAgICAgICAgfSxcbiAgICAgICAgeToge1xuICAgICAgICAgICAgbG9jYXRpb246IGRvbUV2ZW50LnBhZ2VZXG4gICAgICAgIH1cbiAgICB9O1xufTtcbmNvbnN0IGV2ZW50QXJncyA9IChlLCBwcmV2aW91c0FyZ3MpID0+IHtcbiAgICBjb25zdCBwb2ludGVycyA9IGUucG9pbnRlcnM7XG4gICAgY29uc3QgcG9pbnRlciA9IHBvaW50ZXJzWzBdO1xuICAgIGNvbnN0IHhMb2NhdGlvbiA9IHBvaW50ZXIucGFnZVg7XG4gICAgY29uc3QgeUxvY2F0aW9uID0gcG9pbnRlci5wYWdlWTtcbiAgICBsZXQgZGlzdGFuY2UgPSAwO1xuICAgIGlmIChwb2ludGVycy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNvbnN0IHBvaW50ZXIxID0gcG9pbnRlcnNbMF07XG4gICAgICAgIGNvbnN0IHBvaW50ZXIyID0gcG9pbnRlcnNbMV07XG4gICAgICAgIGRpc3RhbmNlID0gTWF0aC5zcXJ0KE1hdGgucG93KHBvaW50ZXIxLnBhZ2VYIC0gcG9pbnRlcjIucGFnZVgsIDIpICsgTWF0aC5wb3cocG9pbnRlcjEucGFnZVkgLSBwb2ludGVyMi5wYWdlWSwgMikpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UsXG4gICAgICAgIGV2ZW50OiBlLnNyY0V2ZW50LFxuICAgICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9LFxuICAgICAgICB0YXJnZXQ6IGUudGFyZ2V0LFxuICAgICAgICB0b3VjaGVzOiBwb2ludGVycy5tYXAoZ2V0VG91Y2gpLFxuICAgICAgICB0eXBlOiBlLnR5cGUsXG4gICAgICAgIHg6IHtcbiAgICAgICAgICAgIGRlbHRhOiBwcmV2aW91c0FyZ3MgPyB4TG9jYXRpb24gLSBwcmV2aW91c0FyZ3MueC5sb2NhdGlvbiA6IDAsXG4gICAgICAgICAgICBpbml0aWFsRGVsdGE6IGUuZGVsdGFYLFxuICAgICAgICAgICAgbG9jYXRpb246IHhMb2NhdGlvbixcbiAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IHhMb2NhdGlvbiAtIGUuZGVsdGFYXG4gICAgICAgIH0sXG4gICAgICAgIHk6IHtcbiAgICAgICAgICAgIGRlbHRhOiBwcmV2aW91c0FyZ3MgPyB5TG9jYXRpb24gLSBwcmV2aW91c0FyZ3MueS5sb2NhdGlvbiA6IDAsXG4gICAgICAgICAgICBpbml0aWFsRGVsdGE6IGUuZGVsdGFZLFxuICAgICAgICAgICAgbG9jYXRpb246IHlMb2NhdGlvbixcbiAgICAgICAgICAgIHN0YXJ0TG9jYXRpb246IHlMb2NhdGlvbiAtIGUuZGVsdGFZXG4gICAgICAgIH1cbiAgICB9O1xufTtcbmZ1bmN0aW9uIHNob3VsZEJpbmRHcm91cChncm91cE5hbWVzLCBldmVudHMpIHtcbiAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBncm91cE5hbWVzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgaWYgKGV2ZW50c1tncm91cE5hbWVzW2lkeF1dKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5jb25zdCBldmVudEdyb3VwcyA9IFt7XG4gICAgICAgIGVuZDogJ3BhbmVuZCcsXG4gICAgICAgIG1vdmU6ICdwYW5tb3ZlJyxcbiAgICAgICAgc3RhcnQ6ICdwYW5zdGFydCdcbiAgICB9LCB7XG4gICAgICAgIGdlc3R1cmVjaGFuZ2U6ICdwaW5jaG1vdmUnLFxuICAgICAgICBnZXN0dXJlZW5kOiAncGluY2hlbmQnLFxuICAgICAgICBnZXN0dXJlc3RhcnQ6ICdwaW5jaHN0YXJ0J1xuICAgIH0sIHtcbiAgICAgICAgcHJlc3M6ICdwcmVzcydcbiAgICB9LCB7XG4gICAgICAgIHRhcDogJ3RhcCdcbiAgICB9XTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBEb21FdmVudHMge1xuICAgIGNvbnN0cnVjdG9yKGhhbW1lckluc3RhbmNlLCBldmVudHMpIHtcbiAgICAgICAgdGhpcy5oYW1tZXJJbnN0YW5jZSA9IGhhbW1lckluc3RhbmNlO1xuICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnMgPSB7fTtcbiAgICAgICAgdGhpcy50YXAgPSB0aGlzLnRhcC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnByZXNzID0gdGhpcy5wcmVzcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnBhbnN0YXJ0ID0gdGhpcy5wYW5zdGFydC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnBhbm1vdmUgPSB0aGlzLnBhbm1vdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5wYW5lbmQgPSB0aGlzLnBhbmVuZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnBpbmNoc3RhcnQgPSB0aGlzLnBpbmNoc3RhcnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5waW5jaG1vdmUgPSB0aGlzLnBpbmNobW92ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnBpbmNoZW5kID0gdGhpcy5waW5jaGVuZC5iaW5kKHRoaXMpO1xuICAgICAgICBpZiAoZXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmQoZXZlbnRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0YXAoZSkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3RhcCcsIGUpO1xuICAgIH1cbiAgICBwcmVzcyhlKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcigncHJlc3MnLCBlKTtcbiAgICB9XG4gICAgcGFuc3RhcnQoZSkge1xuICAgICAgICBkZWxldGUgdGhpcy5wcmV2aW91cztcbiAgICAgICAgdGhpcy5wcmV2aW91cyA9IHRoaXMudHJpZ2dlcignc3RhcnQnLCBlKTtcbiAgICB9XG4gICAgcGFubW92ZShlKSB7XG4gICAgICAgIHRoaXMucHJldmlvdXMgPSB0aGlzLnRyaWdnZXIoJ21vdmUnLCBlKTtcbiAgICB9XG4gICAgcGFuZW5kKGUpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdlbmQnLCBlKTtcbiAgICAgICAgZGVsZXRlIHRoaXMucHJldmlvdXM7XG4gICAgfVxuICAgIHBpbmNoc3RhcnQoZSkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2dlc3R1cmVzdGFydCcsIGUpO1xuICAgIH1cbiAgICBwaW5jaG1vdmUoZSkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2dlc3R1cmVjaGFuZ2UnLCBlKTtcbiAgICB9XG4gICAgcGluY2hlbmQoZSkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2dlc3R1cmVlbmQnLCBlKTtcbiAgICB9XG4gICAgdHJpZ2dlcihuYW1lLCBlKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBldmVudEFyZ3MoZSwgdGhpcy5wcmV2aW91cyk7XG4gICAgICAgIGlmICh0aGlzLmV2ZW50SGFuZGxlcnNbbmFtZV0pIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyc1tuYW1lXShhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJncztcbiAgICB9XG4gICAgYmluZChldmVudHMgPSB7fSkge1xuICAgICAgICB0aGlzLnVuYmluZCgpO1xuICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnMgPSBldmVudHM7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGV2ZW50R3JvdXBzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50R3JvdXAgPSBldmVudEdyb3Vwc1tpZHhdO1xuICAgICAgICAgICAgY29uc3QgZ3JvdXBOYW1lcyA9IE9iamVjdC5rZXlzKGV2ZW50R3JvdXApO1xuICAgICAgICAgICAgaWYgKHNob3VsZEJpbmRHcm91cChncm91cE5hbWVzLCBldmVudHMpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbmFtZUlkeCA9IDA7IG5hbWVJZHggPCBncm91cE5hbWVzLmxlbmd0aDsgbmFtZUlkeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBldmVudEdyb3VwW2dyb3VwTmFtZXNbbmFtZUlkeF1dO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbW1lckluc3RhbmNlLm9uKG5hbWUsIHRoaXNbbmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB1bmJpbmQoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhbW1lckluc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLmhhbW1lckluc3RhbmNlLm9mZigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRIYW5kbGVycyA9IHt9O1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5oYW1tZXJJbnN0YW5jZSkge1xuICAgICAgICAgICAgdGhpcy5oYW1tZXJJbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5oYW1tZXJJbnN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5ldmVudEhhbmRsZXJzO1xuICAgIH1cbiAgICB0b2dnbGVEcmFnKGVuYWJsZSkge1xuICAgICAgICB0aGlzLnRvZ2dsZSgncGFuJywgZW5hYmxlKTtcbiAgICB9XG4gICAgdG9nZ2xlWm9vbShlbmFibGUpIHtcbiAgICAgICAgdGhpcy50b2dnbGUoJ3BpbmNoJywgZW5hYmxlKTtcbiAgICB9XG4gICAgdG9nZ2xlKHJlY29nbml6ZXIsIGVuYWJsZSkge1xuICAgICAgICBpZiAodGhpcy5oYW1tZXJJbnN0YW5jZSkge1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2VSZWNvZ25pemVyID0gdGhpcy5oYW1tZXJJbnN0YW5jZS5nZXQocmVjb2duaXplcik7XG4gICAgICAgICAgICBpbnN0YW5jZVJlY29nbml6ZXIuc2V0KHtcbiAgICAgICAgICAgICAgICBlbmFibGU6IGVuYWJsZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IE1JU1NJTkdfSEFNTUVSX01FU1NBR0UgPSAnSGFtbWVyanMgaXMgbm90IGxvYWRlZC4nICtcbiAgICAnU29sdXRpb246IGh0dHA6Ly93d3cudGVsZXJpay5jb20va2VuZG8tYW5ndWxhci11aS9jb21wb25lbnRzL2NoYXJ0cy90cm91Ymxlc2hvb3RpbmcvI3RvYy1oYW1tZXJqcy1pcy1ub3QtbG9hZGVkJztcbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBEb21FdmVudHNCdWlsZGVyJDEge1xuICAgIHN0YXRpYyBjcmVhdGUoZWxlbWVudCwgZXZlbnRzKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc3QgSEFNTUVSID0gd2luZG93LkhhbW1lcjtcbiAgICAgICAgICAgIGlmICghSEFNTUVSKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGV2TW9kZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihNSVNTSU5HX0hBTU1FUl9NRVNTQUdFKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGFtbWVySW5zdGFuY2UgPSBuZXcgSEFNTUVSKGVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgICByZWNvZ25pemVyczogW1xuICAgICAgICAgICAgICAgICAgICBbSEFNTUVSLlRhcF0sXG4gICAgICAgICAgICAgICAgICAgIFtIQU1NRVIuUGFuXSxcbiAgICAgICAgICAgICAgICAgICAgW0hBTU1FUi5QaW5jaF0sXG4gICAgICAgICAgICAgICAgICAgIFtIQU1NRVIuUHJlc3MsIHsgdGltZTogMCB9XVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEb21FdmVudHMoaGFtbWVySW5zdGFuY2UsIGV2ZW50cyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IGRhdGVDYXRlZ29yeUF4aXNGb3JtYXRzID0gRGF0ZUNhdGVnb3J5QXhpcy5wcm90b3R5cGUub3B0aW9ucy5sYWJlbHMuZGF0ZUZvcm1hdHM7XG5jb25zdCBkYXRlVmFsdWVBeGlzRm9ybWF0cyA9IERhdGVWYWx1ZUF4aXMucHJvdG90eXBlLm9wdGlvbnMubGFiZWxzLmRhdGVGb3JtYXRzO1xuY29uc3QgZGF0ZUZvcm1hdHMgPSB7XG4gICAgbWlsbGlzZWNvbmRzOiBcIkhIOm1tOnNzLlNTU1wiLFxuICAgIHNlY29uZHM6IHsgdGltZTogJ21lZGl1bScgfSxcbiAgICBtaW51dGVzOiB7IHRpbWU6ICdzaG9ydCcgfSxcbiAgICBob3VyczogeyB0aW1lOiAnc2hvcnQnIH0sXG4gICAgZGF5czogeyBza2VsZXRvbjogJ01kJyB9LFxuICAgIHdlZWtzOiB7IHNrZWxldG9uOiAnTWQnIH0sXG4gICAgbW9udGhzOiB7IHNrZWxldG9uOiAneXlNTU0nIH0sXG4gICAgeWVhcnM6IHsgc2tlbGV0b246ICd5JyB9XG59O1xuT2JqZWN0LmFzc2lnbihkYXRlQ2F0ZWdvcnlBeGlzRm9ybWF0cywgZGF0ZUZvcm1hdHMpO1xuT2JqZWN0LmFzc2lnbihkYXRlVmFsdWVBeGlzRm9ybWF0cywgZGF0ZUZvcm1hdHMpO1xuRG9tRXZlbnRzQnVpbGRlci5yZWdpc3RlcihEb21FdmVudHNCdWlsZGVyJDEpO1xuXG5mdW5jdGlvbiBoYXNPYnNlcnZlcnMoZW1pdHRlcikge1xuICAgIHJldHVybiBlbWl0dGVyLm9ic2VydmVycy5sZW5ndGggPiAwO1xufVxuLyoqXG4gKiBUaGUgcm9vdCBDaGFydCBjb21wb25lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiBfQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgdGVtcGxhdGU6IGBcbiAqICAgICA8YnV0dG9uIChjbGljayk9XCJ0b2dnbGVMZWdlbmQoKVwiPlRvZ2dsZSBMZWdlbmQ8L2J1dHRvbj5cbiAqICAgICA8YnV0dG9uIChjbGljayk9XCJ0b2dnbGVTZXJpZXMoKVwiPlRvZ2dsZSBTZXJpZXM8L2J1dHRvbj5cbiAqICAgICA8a2VuZG8tY2hhcnQ+XG4gKiAgICAgICA8a2VuZG8tY2hhcnQtbGVnZW5kIFt2aXNpYmxlXT1cImxlZ2VuZFZpc2libGVcIj5cbiAqICAgICAgIDwva2VuZG8tY2hhcnQtbGVnZW5kPlxuICogICAgICAgPGtlbmRvLWNoYXJ0LXNlcmllcz5cbiAqICAgICAgICAgPGtlbmRvLWNoYXJ0LXNlcmllcy1pdGVtICpuZ0lmPVwic2VyaWVzVmlzaWJsZVwiIG5hbWU9XCJTZXJpZXMgIzFcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJsaW5lXCIgW2RhdGFdPVwiWzEsIDIsIDNdXCI+XG4gKiAgICAgICAgIDwva2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0+XG4gKiAgICAgICA8L2tlbmRvLWNoYXJ0LXNlcmllcz5cbiAqICAgICA8L2tlbmRvLWNoYXJ0PlxuICogICBgXG4gKiB9KVxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgcHVibGljIGxlZ2VuZFZpc2libGU6IGJvb2xlYW4gPSB0cnVlO1xuICogICBwdWJsaWMgc2VyaWVzVmlzaWJsZTogYm9vbGVhbiA9IHRydWU7XG4gKlxuICogICBwdWJsaWMgdG9nZ2xlU2VyaWVzKCk6IHZvaWQge1xuICogICAgIHRoaXMuc2VyaWVzVmlzaWJsZSA9ICF0aGlzLnNlcmllc1Zpc2libGU7XG4gKiAgIH1cbiAqXG4gKiAgIHB1YmxpYyB0b2dnbGVMZWdlbmQoKTogdm9pZCB7XG4gKiAgICAgdGhpcy5sZWdlbmRWaXNpYmxlID0gIXRoaXMubGVnZW5kVmlzaWJsZTtcbiAqICAgfVxuICogfVxuICpcbiAqIGBgYFxuICovXG5sZXQgQ2hhcnRDb21wb25lbnQgPSBjbGFzcyBDaGFydENvbXBvbmVudCBleHRlbmRzIENoYXJ0Q29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSwgdGhlbWVTZXJ2aWNlLCBlbGVtZW50LCBpbnRsLCBsb2NhbGl6YXRpb25TZXJ2aWNlLCBuZ1pvbmUsIGluc3RhbmNlRXZlbnRTZXJ2aWNlLCBjaGFuZ2VEZXRlY3RvciwgcmVuZGVyZXIpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMudGhlbWVTZXJ2aWNlID0gdGhlbWVTZXJ2aWNlO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmludGwgPSBpbnRsO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvblNlcnZpY2UgPSBsb2NhbGl6YXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZUV2ZW50U2VydmljZSA9IGluc3RhbmNlRXZlbnRTZXJ2aWNlO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yID0gY2hhbmdlRGV0ZWN0b3I7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gYSBsZWdlbmQgaXRlbSBpcyBjbGlja2VkIGJlZm9yZSB0aGUgc2VsZWN0ZWQgc2VyaWVzIHZpc2liaWxpdHkgaXMgdG9nZ2xlZC5cbiAgICAgICAgICogQ2FuIGJlIHByZXZlbnRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGVnZW5kSXRlbUNsaWNrID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTGltaXRzIHRoZSBhdXRvbWF0aWMgcmVzaXppbmcgb2YgdGhlIENoYXJ0LiBTZXRzIHRoZSBtYXhpbXVtIG51bWJlciBvZiB0aW1lcyBwZXIgc2Vjb25kXG4gICAgICAgICAqIHRoYXQgdGhlIGNvbXBvbmVudCByZWRyYXdzIGl0cyBjb250ZW50IHdoZW4gdGhlIHNpemUgb2YgaXRzIGNvbnRhaW5lciBjaGFuZ2VzLlxuICAgICAgICAgKiBEZWZhdWx0cyB0byBgMTBgLiBUbyBkaXNhYmxlIHRoZSBhdXRvbWF0aWMgcmVzaXppbmcsIHNldCBpdCB0byBgMGAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIF9AQ29tcG9uZW50KHtcbiAgICAgICAgICogICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAgICAgICAgICogICAgIHRlbXBsYXRlOiBgXG4gICAgICAgICAqICAgICAgICAgPGtlbmRvLWNoYXJ0IFtyZXNpemVSYXRlTGltaXRdPVwiMlwiPlxuICAgICAgICAgKiA8IS0tICAgICAgICAgICAgICAgICBeXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gICAgICAgICAqICAgICAgIFdpbGwgdXBkYXRlIHRoZSBzaXplIG9mIHRoZSBDaGFydCB1cCB0byB0d28gdGltZXMgYSBzZWNvbmQuXG4gICAgICAgICAqICAgICAgIFJlc2l6ZSB0aGUgUGx1bmtyIHBhbmUgb3Igd2luZG93IHRvIHRyeSBpdCBvdXQuXG4gICAgICAgICAqIC0tPlxuICAgICAgICAgKiAgICAgICAgICA8a2VuZG8tY2hhcnQtc2VyaWVzPlxuICAgICAgICAgKiAgICAgICAgICAgIDxrZW5kby1jaGFydC1zZXJpZXMtaXRlbSBbZGF0YV09XCJzZXJpZXNEYXRhXCI+XG4gICAgICAgICAqICAgICAgICAgICA8L2tlbmRvLWNoYXJ0LXNlcmllcy1pdGVtPlxuICAgICAgICAgKiAgICAgICAgIDwva2VuZG8tY2hhcnQtc2VyaWVzPlxuICAgICAgICAgKiAgICAgICA8L2tlbmRvLWNoYXJ0PlxuICAgICAgICAgKiAgIGBcbiAgICAgICAgICogfSlcbiAgICAgICAgICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XG4gICAgICAgICAqICAgIHNlcmllc0RhdGE6IG51bWJlcltdID0gWzEsIDIsIDMsIDVdO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXNpemVSYXRlTGltaXQgPSAxMDtcbiAgICAgICAgdGhpcy50aGVtZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3VwcHJlc3NUcmFuc2l0aW9ucyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJ0bCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhvc3RDbGFzc2VzID0gWydrLWNoYXJ0JywgJ2std2lkZ2V0J107XG4gICAgICAgIHZhbGlkYXRlUGFja2FnZShwYWNrYWdlTWV0YWRhdGEpO1xuICAgICAgICB0aGlzLnRoZW1lU2VydmljZS5sb2FkVGhlbWUoKTtcbiAgICAgICAgdGhpcy5yZWZyZXNoV2FpdCgpO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5ob3N0Q2xhc3Nlcy5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIG5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAncG9zaXRpb24nLCAncmVsYXRpdmUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhblJlbmRlcikge1xuICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYXJ0TW91c2VsZWF2ZSA9IHRoaXMucmVuZGVyZXIubGlzdGVuKHRoaXMuc3VyZmFjZUVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ21vdXNlbGVhdmUnLCB0aGlzLmNoYXJ0TW91c2VsZWF2ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbVN1YnNjcmlwdGlvbnMgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0TW91c2VsZWF2ZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldERpcmVjdGlvbigpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSB0aGlzLmludGwuY2hhbmdlcy5zdWJzY3JpYmUodGhpcy5pbnRsQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHRoaXMubG9jYWxpemF0aW9uU2VydmljZS5jaGFuZ2VzLnN1YnNjcmliZSh0aGlzLnJ0bENoYW5nZS5iaW5kKHRoaXMpKSk7XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3Q2hlY2tlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UgJiYgdGhpcy5hdXRvUmVzaXplKSB7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVzaXplVGltZW91dCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gdGhpcy5jb25maWd1cmF0aW9uU2VydmljZS5zdG9yZTtcbiAgICAgICAgY29weUNoYW5nZXMoY2hhbmdlcywgc3RvcmUpO1xuICAgICAgICBzdG9yZS5wb3B1cFNldHRpbmdzID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZS5wdXNoKHN0b3JlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY29tcG9uZW50IGZpZWxkcyB3aXRoIHRoZSBzcGVjaWZpZWQgdmFsdWVzIGFuZCByZWZyZXNoZXMgdGhlIENoYXJ0LlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHdoZW4gdGhlIGNvbmZpZ3VyYXRpb24gdmFsdWVzIGNhbm5vdCBiZSBzZXQgdGhyb3VnaCB0aGUgdGVtcGxhdGUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzLW5vLXJ1blxuICAgICAqIGNoYXJ0Lm5vdGlmeUNoYW5nZXMoeyB0aXRsZTogeyB0ZXh0OiAnTmV3IFRpdGxlJyB9IH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYW5nZXMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHVwZGF0ZWQgaW5wdXQgZmllbGRzLlxuICAgICAqL1xuICAgIG5vdGlmeUNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICB0aGlzLm5nT25DaGFuZ2VzKHRvU2ltcGxlQ2hhbmdlcyhjaGFuZ2VzKSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIGlmICh0aGlzLmRvbVN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICAgICAgdGhpcy5kb21TdWJzY3JpcHRpb25zID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXNpemVUaW1lb3V0KTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVkcmF3VGltZW91dCk7XG4gICAgfVxuICAgIGNyZWF0ZUluc3RhbmNlKGVsZW1lbnQsIG9ic2VydmVyKSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgQ2hhcnQoZWxlbWVudCwgdGhpcy5vcHRpb25zLCB0aGlzLnRoZW1lLCB7XG4gICAgICAgICAgICBpbnRsU2VydmljZTogdGhpcy5pbnRsLFxuICAgICAgICAgICAgb2JzZXJ2ZXI6IG9ic2VydmVyLFxuICAgICAgICAgICAgcnRsOiB0aGlzLnJ0bCxcbiAgICAgICAgICAgIHNlbmRlcjogdGhpc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhwb3J0cyB0aGUgQ2hhcnQgYXMgYW4gaW1hZ2UuIFRoZSBleHBvcnQgb3BlcmF0aW9uIGlzIGFzeW5jaHJvbm91cyBhbmQgcmV0dXJucyBhIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0ltYWdlRXhwb3J0T3B0aW9uc30gb3B0aW9ucyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZXhwb3J0ZWQgaW1hZ2UuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gLSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggYSBQTkcgaW1hZ2UgZW5jb2RlZCBhcyBhIERhdGEgVVJJLlxuICAgICAqL1xuICAgIGV4cG9ydEltYWdlKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0SW1hZ2UodGhpcy5leHBvcnRWaXN1YWwob3B0aW9ucyksIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHBvcnRzIHRoZSBDaGFydCBhcyBhbiBTVkcgZG9jdW1lbnQuIFRoZSBleHBvcnQgb3BlcmF0aW9uIGlzIGFzeW5jaHJvbm91cyBhbmQgcmV0dXJucyBhIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZXhwb3J0ZWQgZmlsZS5cbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2l0aCBhbiBTVkcgZG9jdW1lbnQgdGhhdCBpcyBlbmNvZGVkIGFzIGEgRGF0YSBVUkkuXG4gICAgICovXG4gICAgZXhwb3J0U1ZHKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0U1ZHKHRoaXMuZXhwb3J0VmlzdWFsKG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhwb3J0cyB0aGUgQ2hhcnQgYXMgYSBEcmF3aW5nIGBTY2VuZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZXhwb3J0IG9wZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyAtIFRoZSByb290IEdyb3VwIG9mIHRoZSBzY2VuZS5cbiAgICAgKi9cbiAgICBleHBvcnRWaXN1YWwob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlLmV4cG9ydFZpc3VhbChvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYXhpcyB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIGF4aXMgbmFtZS5cbiAgICAgKiBAcmV0dXJucyB7Q2hhcnRBeGlzfSAtIFRoZSBheGlzIHdpdGggYSBjb3JyZXNwb25kaW5nIG5hbWUuXG4gICAgICovXG4gICAgZmluZEF4aXNCeU5hbWUobmFtZSkge1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2UuZmluZEF4aXNCeU5hbWUobmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGFuZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIHBhbmUgaW5kZXguXG4gICAgICogQHJldHVybnMge0NoYXJ0UGFuZX0gLSBUaGUgcGFuZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgICAqL1xuICAgIGZpbmRQYW5lQnlJbmRleChpbmRleCkge1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2UuZmluZFBhbmVCeUluZGV4KGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwYW5lIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcGFuZS5cbiAgICAgKiBAcmV0dXJucyB7Q2hhcnRQYW5lfSAtIFRoZSBwYW5lIHdpdGggdGhlIHByb3ZpZGVkIG5hbWUuXG4gICAgICovXG4gICAgZmluZFBhbmVCeU5hbWUobmFtZSkge1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2UuZmluZFBhbmVCeU5hbWUobmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGxvdCBhcmVhIG9mIHRoZSBDaGFydC5cbiAgICAgKiBAcmV0dXJucyB7Q2hhcnRQbG90QXJlYX0gLSBUaGUgcGxvdCBhcmVhIG9mIHRoZSBDaGFydC5cbiAgICAgKi9cbiAgICBnZXRQbG90QXJlYSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlLnBsb3RBcmVhKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGlnaGxpZ2h0cyB0aGUgc2VyaWVzIHBvaW50cyBvciB0aGUgc2VnbWVudHMgb2YgYSBQaWUsIERvbnV0LCBvciBGdW5uZWwgY2hhcnRzLlxuICAgICAqXG4gICAgICogU2VlIFtTZXJpZXMgSGlnaGxpZ2h0XSh7JSBzbHVnIHNlcmllc2hpZ2hsaWdodF9jaGFydF9jaGFydHMgJX0pIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBJbiB0aGUgZm9sbG93aW5nIGV4YW1wbGUsIHRoZSBjYWxsYmFjayBpcyBldmFsdWF0ZWQgZm9yIGVhY2ggZGF0YSBwb2ludC5cbiAgICAgKiBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyBgdHJ1ZWAsIHRoZSBwb2ludCBpcyBoaWdobGlnaHRlZC5cbiAgICAgKlxuICAgICAqIHslIG1ldGEgaGVpZ2h0OjUwMCAlfVxuICAgICAqIHslIGVtYmVkX2ZpbGUgZWxlbWVudHMvaGlnaGxpZ2h0L2FwaS9hcHAuY29tcG9uZW50LnRzIHByZXZpZXcgJX1cbiAgICAgKiB7JSBlbWJlZF9maWxlIHNoYXJlZC9hcHAubW9kdWxlLnRzIGhpZGRlbiAlfVxuICAgICAqIHslIGVtYmVkX2ZpbGUgc2hhcmVkL21haW4udHMgaGlkZGVuICV9XG4gICAgICogeyUgZW5kbWV0YSAlfVxuICAgICAqXG4gICAgICogQHBhcmFtIHNob3cgLSBBIEJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgaGlnaGxpZ2h0IGlzIHNob3duIG9yIGhpZGRlbi5cbiAgICAgKiBAcGFyYW0gZmlsdGVyIC0gQSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIHRoZSBzZXJpZXMgb3IgY2F0ZWdvcnkgbmFtZSwgYW4gb2JqZWN0IHdpdGggdGhlIHNlcmllcyBhbmQgY2F0ZWdvcnkgbmFtZSwgb3IgYSBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaCBwb2ludC4gVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYHRydWVgIGZvciB0aGUgcG9pbnRzIGZvciB3aGljaCB0aGUgaGlnaGxpZ2h0IGlzIHRvZ2dsZWQuXG4gICAgICovXG4gICAgdG9nZ2xlSGlnaGxpZ2h0KHNob3csIGZpbHRlcikge1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS50b2dnbGVIaWdobGlnaHQoc2hvdywgZmlsdGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIaWRlcyB0aGUgdG9vbHRpcCBvZiB0aGUgQ2hhcnQuXG4gICAgICovXG4gICAgaGlkZVRvb2x0aXAoKSB7XG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLmhpZGVUb29sdGlwKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvd3MgdGhlIENoYXJ0IHRvb2x0aXAgb2YgYSBzcGVjaWZpYyBwb2ludCBvciB0aGUgc2hhcmVkIHRvb2x0aXAgb2YgYSBzcGVjaWZpYyBjYXRlZ29yeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWx0ZXIgLSBUaGUgY2F0ZWdvcnkgZm9yIGEgc2hhcmVkIHRvb2x0aXAgb3IgYSBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaCBwb2ludCB1bnRpbCB0aGUgZnVuY3Rpb24gcmV0dXJucyBgdHJ1ZWAuXG4gICAgICovXG4gICAgc2hvd1Rvb2x0aXAoZmlsdGVyKSB7XG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLnNob3dUb29sdGlwKGZpbHRlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhblJlbmRlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLnN1cmZhY2VFbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlT2JzZXJ2ZXIgPSBuZXcgQ2hhcnRJbnN0YW5jZU9ic2VydmVyKHRoaXMpO1xuICAgICAgICB0aGlzLmNyZWF0ZUluc3RhbmNlKGVsZW1lbnQsIGluc3RhbmNlT2JzZXJ2ZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlY3RzIHRoZSBzaXplIG9mIHRoZSBjb250YWluZXIgYW5kIHJlZHJhd3MgdGhlIENoYXJ0LlxuICAgICAqIFJlc2l6aW5nIGlzIGF1dG9tYXRpYyB1bmxlc3MgeW91IHNldCB0aGUgYHJlc2l6ZVJhdGVMaW1pdGAgb3B0aW9uIHRvIGAwYC5cbiAgICAgKi9cbiAgICByZXNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLnJlc2l6ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvblJlc2l6ZShfZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuYXV0b1Jlc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkxlZ2VuZEl0ZW1DbGljayhlKSB7XG4gICAgICAgIHRoaXMucnVuKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBuZXcgTGVnZW5kSXRlbUNsaWNrRXZlbnQoZSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLmxlZ2VuZEl0ZW1DbGljay5lbWl0KGFyZ3MpO1xuICAgICAgICAgICAgaWYgKCFhcmdzLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VyaWVzID0gdGhpcy5zZXJpZXNDb21wb25lbnRzLnRvQXJyYXkoKVtlLnNlcmllcy5pbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKCFzZXJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZS5wb2ludEluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzLnRvZ2dsZVZpc2liaWxpdHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcmllcy50b2dnbGVQb2ludFZpc2liaWxpdHkoZS5wb2ludEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zdXBwcmVzc1RyYW5zaXRpb25zID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFzT2JzZXJ2ZXJzKHRoaXMubGVnZW5kSXRlbUNsaWNrKSwgdGhpcy5zZXJpZXNDb21wb25lbnRzLmxlbmd0aCA+IDApO1xuICAgIH1cbiAgICBvbkluaXQoZSkge1xuICAgICAgICB0aGlzLmluc3RhbmNlID0gZS5zZW5kZXI7XG4gICAgfVxuICAgIG9uUmVuZGVyKGUpIHtcbiAgICAgICAgY29uc3QgZG9udXRDZW50ZXJTdHlsZSA9IHRoaXMuZ2V0RG9udXRDZW50ZXJTdHlsZSgpO1xuICAgICAgICB0aGlzLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhcmdzID0gbmV3IFJlbmRlckV2ZW50KGUsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zdXJmYWNlID0gZS5zZW5kZXIuc3VyZmFjZTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyLmVtaXQoYXJncyk7XG4gICAgICAgICAgICB0aGlzLmRvbnV0Q2VudGVyU3R5bGUgPSBkb251dENlbnRlclN0eWxlO1xuICAgICAgICB9LCBoYXNPYnNlcnZlcnModGhpcy5yZW5kZXIpLCB0aGlzLmRvbnV0Q2VudGVyU3R5bGUgIT09IGRvbnV0Q2VudGVyU3R5bGUpO1xuICAgIH1cbiAgICBvblNob3dUb29sdGlwKGUpIHtcbiAgICAgICAgdGhpcy5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFlLmNyb3NzaGFpcikge1xuICAgICAgICAgICAgICAgIHRoaXMudG9vbHRpcEluc3RhbmNlLnNob3coZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyb3NzYWhpclRvb2x0aXBzLnNob3coZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sICFlLmNyb3NzaGFpciwgdHJ1ZSk7XG4gICAgfVxuICAgIG9uSGlkZVRvb2x0aXAoZSkge1xuICAgICAgICBpZiAoIWUuY3Jvc3NoYWlyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50b29sdGlwSW5zdGFuY2UuYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b29sdGlwSW5zdGFuY2UuaGlkZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY3Jvc3NhaGlyVG9vbHRpcHMuYWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLmNyb3NzYWhpclRvb2x0aXBzLmhpZGUoKTtcbiAgICAgICAgICAgIHRoaXMuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRyaWdnZXIobmFtZSwgZSkge1xuICAgICAgICBpZiAobmFtZSA9PT0gJ3Jlc2l6ZScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbWl0dGVyID0gdGhpcy5hY3RpdmVFbWl0dGVyKG5hbWUpO1xuICAgICAgICBpZiAoZW1pdHRlcikge1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IHRoaXMuaW5zdGFuY2VFdmVudFNlcnZpY2UuY3JlYXRlKG5hbWUsIGUsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdChhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3MuaXNEZWZhdWx0UHJldmVudGVkICYmIGFyZ3MuaXNEZWZhdWx0UHJldmVudGVkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVxdWlyZXNIYW5kbGVycyhuYW1lcykge1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBuYW1lcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVFbWl0dGVyKG5hbWVzW2lkeF0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZWZyZXNoKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZWRyYXdUaW1lb3V0KTtcbiAgICAgICAgdGhpcy51cGRhdGVEaXJlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5jcm9zc2FoaXJUb29sdGlwcy5jcmVhdGVDcm9zc2hhaXJUb29sdGlwcyh0aGlzLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNldENoYXJ0QXJlYVNpemUoKTtcbiAgICAgICAgaWYgKCF0aGlzLmluc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2l0aW9ucyA9IHRoaXMub3B0aW9ucy50cmFuc2l0aW9ucztcbiAgICAgICAgaWYgKHRoaXMuc3VwcHJlc3NUcmFuc2l0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnRyYW5zaXRpb25zID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVPcHRpb25zKCk7XG4gICAgICAgIGlmICh0aGlzLnN1cHByZXNzVHJhbnNpdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy50cmFuc2l0aW9ucyA9IHRyYW5zaXRpb25zO1xuICAgICAgICAgICAgdGhpcy5zdXBwcmVzc1RyYW5zaXRpb25zID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0Q2hhcnRBcmVhU2l6ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGNoYXJ0QXJlYSA9IHRoaXMub3B0aW9ucy5jaGFydEFyZWEgfHwge307XG4gICAgICAgIGlmIChjaGFydEFyZWEud2lkdGgpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHtjaGFydEFyZWEud2lkdGh9cHhgO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFydEFyZWEuaGVpZ2h0KSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLmhlaWdodCA9IGAke2NoYXJ0QXJlYS5oZWlnaHR9cHhgO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZU9wdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0T3B0aW9ucyh0aGlzLm9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgdG9vbHRpcE1vdXNlbGVhdmUoZSkge1xuICAgICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0gZS5yZWxhdGVkVGFyZ2V0O1xuICAgICAgICBjb25zdCBjaGFydEVsZW1lbnQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UgJiYgKCFyZWxhdGVkVGFyZ2V0IHx8ICFoYXNQYXJlbnQocmVsYXRlZFRhcmdldCwgY2hhcnRFbGVtZW50KSkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UuaGlkZUVsZW1lbnRzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNoYXJ0TW91c2VsZWF2ZShlKSB7XG4gICAgICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSBlLnJlbGF0ZWRUYXJnZXQ7XG4gICAgICAgIGNvbnN0IGNoYXJ0RWxlbWVudCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSAmJiAoIXJlbGF0ZWRUYXJnZXQgfHwgISh0aGlzLnRvb2x0aXBJbnN0YW5jZS5jb250YWluc0VsZW1lbnQocmVsYXRlZFRhcmdldCkgfHwgaGFzUGFyZW50KHJlbGF0ZWRUYXJnZXQsIGNoYXJ0RWxlbWVudCkpKSAmJlxuICAgICAgICAgICAgIXRoaXMuaW5zdGFuY2UuaGFuZGxpbmdUYXApIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UuaGlkZUVsZW1lbnRzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGNhblJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIGlzRG9jdW1lbnRBdmFpbGFibGUoKSAmJiBCb29sZWFuKHRoaXMuc3VyZmFjZUVsZW1lbnQpO1xuICAgIH1cbiAgICBnZXQgYXV0b1Jlc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplUmF0ZUxpbWl0ID4gMDtcbiAgICB9XG4gICAgYWN0aXZlRW1pdHRlcihuYW1lKSB7XG4gICAgICAgIGNvbnN0IGVtaXR0ZXIgPSB0aGlzW25hbWVdO1xuICAgICAgICBpZiAoZW1pdHRlciAmJiBlbWl0dGVyLmVtaXQgJiYgaGFzT2JzZXJ2ZXJzKGVtaXR0ZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZW1pdHRlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXREb251dENlbnRlclN0eWxlKCkge1xuICAgICAgICBpZiAoIXRoaXMuaW5zdGFuY2UgfHwgIXRoaXMub3B0aW9ucyB8fCAhdGhpcy5vcHRpb25zLnNlcmllcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpcnN0U2VyaWVzID0gdGhpcy5vcHRpb25zLnNlcmllc1swXTtcbiAgICAgICAgY29uc3QgY2hhcnRzID0gdGhpcy5pbnN0YW5jZS5fcGxvdEFyZWEuY2hhcnRzO1xuICAgICAgICBpZiAoIWZpcnN0U2VyaWVzIHx8IGZpcnN0U2VyaWVzLnR5cGUgIT09ICdkb251dCcgfHwgY2hhcnRzWzBdLnBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaXJzdFBvaW50ID0gY2hhcnRzWzBdLnBvaW50c1swXTtcbiAgICAgICAgY29uc3QgY2VudGVyID0gZmlyc3RQb2ludC5ib3guY2VudGVyKCk7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IGZpcnN0UG9pbnQuc2VjdG9yLmlubmVyUmFkaXVzO1xuICAgICAgICBjb25zdCB0b3AgPSBjZW50ZXIueSAtIHJhZGl1cztcbiAgICAgICAgY29uc3QgbGVmdCA9IGNlbnRlci54IC0gcmFkaXVzO1xuICAgICAgICBjb25zdCBzaXplID0gcmFkaXVzICogMjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhlaWdodDogc2l6ZSArICdweCcsXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0ICsgJ3B4JyxcbiAgICAgICAgICAgIHRvcDogdG9wICsgJ3B4JyxcbiAgICAgICAgICAgIHdpZHRoOiBzaXplICsgJ3B4J1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWZyZXNoV2FpdCgpIHtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSBjb21iaW5lTGF0ZXN0KHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2Uub25DaGFuZ2UkLCB0aGlzLnRoZW1lU2VydmljZS5vbkNoYW5nZSQpLnBpcGUodGFwKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSByZXN1bHRbMF07XG4gICAgICAgICAgICAgICAgdGhpcy50aGVtZSA9IHJlc3VsdFsxXTtcbiAgICAgICAgICAgIH0pLCBhdWRpdFRpbWUoVEhST1RUTEVfTVMpKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBydW4oY2FsbGJhY2ssIGluWm9uZSA9IHRydWUsIGRldGVjdENoYW5nZXMpIHtcbiAgICAgICAgaWYgKGluWm9uZSkge1xuICAgICAgICAgICAgaWYgKGRldGVjdENoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBpZiAoZGV0ZWN0Q2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRldGVjdENoYW5nZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGludGxDaGFuZ2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLmRlZmVycmVkUmVkcmF3KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcnRsQ2hhbmdlKCkge1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSAmJiB0aGlzLnJ0bCAhPT0gdGhpcy5pc1JUTCkge1xuICAgICAgICAgICAgdGhpcy5kZWZlcnJlZFJlZHJhdygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlZmVycmVkUmVkcmF3KCkge1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZWRyYXdUaW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMucmVkcmF3VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRGlyZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5ub1RyYW5zaXRpb25zUmVkcmF3KCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZURpcmVjdGlvbigpIHtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuaXNSVEw7XG4gICAgICAgIGlmICh0aGlzLnJ0bCAhPT0gY3VycmVudCkge1xuICAgICAgICAgICAgdGhpcy5zZXREaXJlY3Rpb24oKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXREaXJlY3Rpb24oY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0RGlyZWN0aW9uKCkge1xuICAgICAgICB0aGlzLnJ0bCA9IHRoaXMuaXNSVEw7XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0QXR0cmlidXRlKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnZGlyJywgdGhpcy5ydGwgPyAncnRsJyA6ICdsdHInKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXNSVEwoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMubG9jYWxpemF0aW9uU2VydmljZS5ydGwpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImxlZ2VuZEl0ZW1DbGlja1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInJlc2l6ZVJhdGVMaW1pdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInBvcHVwU2V0dGluZ3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZHJlbihTZXJpZXNJdGVtQ29tcG9uZW50LCB7IGRlc2NlbmRhbnRzOiB0cnVlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBRdWVyeUxpc3QpXG5dLCBDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VyaWVzQ29tcG9uZW50c1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKERvbnV0Q2VudGVyVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRG9udXRDZW50ZXJUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIENoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJkb251dENlbnRlclRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoVG9vbHRpcFBvcHVwQ29tcG9uZW50LCB7IHN0YXRpYzogdHJ1ZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgVG9vbHRpcFBvcHVwQ29tcG9uZW50KVxuXSwgQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInRvb2x0aXBJbnN0YW5jZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKENyb3NzaGFpclRvb2x0aXBzQ29udGFpbmVyQ29tcG9uZW50LCB7IHN0YXRpYzogdHJ1ZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQ3Jvc3NoYWlyVG9vbHRpcHNDb250YWluZXJDb21wb25lbnQpXG5dLCBDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiY3Jvc3NhaGlyVG9vbHRpcHNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZCgnc3VyZmFjZScsIHsgc3RhdGljOiB0cnVlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFbGVtZW50UmVmKVxuXSwgQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInN1cmZhY2VFbGVtZW50XCIsIHZvaWQgMCk7XG5DaGFydENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBleHBvcnRBczogJ2tlbmRvQ2hhcnQnLFxuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIENvbmZpZ3VyYXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAgVG9vbHRpcFRlbXBsYXRlU2VydmljZSxcbiAgICAgICAgICAgIEluc3RhbmNlRXZlbnRTZXJ2aWNlLFxuICAgICAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBMMTBOX1BSRUZJWCxcbiAgICAgICAgICAgICAgICB1c2VWYWx1ZTogJ2tlbmRvLmNoYXJ0J1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0JyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8ZGl2ICNzdXJmYWNlIGNsYXNzPVwiay1jaGFydC1zdXJmYWNlXCI+PC9kaXY+XG4gICAgPGtlbmRvLWNoYXJ0LWNyb3NzaGFpci10b29sdGlwcy1jb250YWluZXIgW3BvcHVwU2V0dGluZ3NdPVwicG9wdXBTZXR0aW5nc1wiPlxuICAgIDwva2VuZG8tY2hhcnQtY3Jvc3NoYWlyLXRvb2x0aXBzLWNvbnRhaW5lcj5cbiAgICA8a2VuZG8tY2hhcnQtdG9vbHRpcC1wb3B1cCAobGVhdmUpPVwidG9vbHRpcE1vdXNlbGVhdmUoJGV2ZW50KVwiIFtwb3B1cFNldHRpbmdzXT1cInBvcHVwU2V0dGluZ3NcIj5cbiAgICA8L2tlbmRvLWNoYXJ0LXRvb2x0aXAtcG9wdXA+XG4gICAgPGtlbmRvLXJlc2l6ZS1zZW5zb3IgKHJlc2l6ZSk9XCJvblJlc2l6ZSgkZXZlbnQpXCIgW3JhdGVMaW1pdF09XCJyZXNpemVSYXRlTGltaXRcIj48L2tlbmRvLXJlc2l6ZS1zZW5zb3I+XG4gICAgPGRpdiBjbGFzcz1cImstY2hhcnQtZG9udXQtY2VudGVyXCIgW25nU3R5bGVdPVwiZG9udXRDZW50ZXJTdHlsZVwiICpuZ0lmPVwiZG9udXRDZW50ZXJTdHlsZSAmJiBkb251dENlbnRlclRlbXBsYXRlXCI+XG4gICAgICA8bmctdGVtcGxhdGUgW25nVGVtcGxhdGVPdXRsZXRdPVwiZG9udXRDZW50ZXJUZW1wbGF0ZS50ZW1wbGF0ZVJlZlwiPjwvbmctdGVtcGxhdGU+XG4gICAgPC9kaXY+XG4gIGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlLFxuICAgICAgICBUaGVtZVNlcnZpY2UsXG4gICAgICAgIEVsZW1lbnRSZWYsXG4gICAgICAgIEludGxTZXJ2aWNlLFxuICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICBOZ1pvbmUsXG4gICAgICAgIEluc3RhbmNlRXZlbnRTZXJ2aWNlLFxuICAgICAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgUmVuZGVyZXIyXSlcbl0sIENoYXJ0Q29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEF4aXNEZWZhdWx0c0NvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignYXhpc0RlZmF1bHRzJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQXhpc0RlZmF1bHRzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBBeGlzRGVmYXVsdHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBBeGlzRGVmYXVsdHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImxpbmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEF4aXNEZWZhdWx0c0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWFqb3JHcmlkTGluZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEF4aXNEZWZhdWx0c0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWFqb3JUaWNrc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQXhpc0RlZmF1bHRzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtaW5vckdyaWRMaW5lc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQXhpc0RlZmF1bHRzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtaW5vclRpY2tzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQXhpc0RlZmF1bHRzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJuYXJyb3dSYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQXhpc0RlZmF1bHRzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwYW5lXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIEF4aXNEZWZhdWx0c0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicGxvdEJhbmRzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQXhpc0RlZmF1bHRzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJyZXZlcnNlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBBeGlzRGVmYXVsdHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInN0YXJ0QW5nbGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBBeGlzRGVmYXVsdHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc2libGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEF4aXNEZWZhdWx0c0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY3Jvc3NoYWlyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBBeGlzRGVmYXVsdHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImxhYmVsc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQXhpc0RlZmF1bHRzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0aXRsZVwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIGFsbCBDaGFydCBheGVzLlxuICogQWNjZXB0cyB0aGUgb3B0aW9ucyB3aGljaCBhcmUgc3VwcG9ydGVkIGJ5IFtgY2F0ZWdvcnlBeGlzYF0oeyUgc2x1ZyBhcGlfY2hhcnRzX2NhdGVnb3J5YXhpc2l0ZW1jb21wb25lbnQgJX0pLFxuICogW2B2YWx1ZUF4aXNgXSh7JSBzbHVnIGFwaV9jaGFydHNfdmFsdWVheGlzaXRlbWNvbXBvbmVudCAlfSksXG4gKiBbYHhBeGlzYF0oeyUgc2x1ZyBhcGlfY2hhcnRzX3hheGlzaXRlbWNvbXBvbmVudCAlfSksXG4gKiBhbmQgW2B5QXhpc2BdKHslIHNsdWcgYXBpX2NoYXJ0c195YXhpc2l0ZW1jb21wb25lbnQgJX0pLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cy1wcmV2aWV3XG4gKiBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiBfQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgdGVtcGxhdGU6IGBcbiAqICA8ZGl2IHN0eWxlPVwiaGVpZ2h0OiA2MDBweDtcIj5cbiAqICA8a2VuZG8tY2hhcnQgW2NhdGVnb3J5QXhpc109XCJ7IGNhdGVnb3JpZXM6IGNhdGVnb3JpZXMgfVwiIFtjaGFydEFyZWFdPVwie2hlaWdodDogNjAwfVwiID5cbiAqICAgIDxrZW5kby1jaGFydC1heGlzLWRlZmF1bHRzXG4gKiAgICAgIFtiYWNrZ3JvdW5kXT1cImJhY2tncm91bmRcIlxuICogICAgICBbY29sb3JdPVwiY29sb3JcIlxuICogICAgICBbY3Jvc3NoYWlyXT1cImNyb3NzaGFpclwiXG4gKiAgICAgIFtsYWJlbHNdPVwibGFiZWxzXCJcbiAqICAgICAgW2xpbmVdPVwibGluZVwiXG4gKiAgICAgIFttYWpvckdyaWRMaW5lc109XCJtYWpvckdyaWRMaW5lc1wiXG4gKiAgICAgIFttaW5vckdyaWRMaW5lc109XCJtaW5vckdyaWRMaW5lc1wiXG4gKiAgICAgIFttYWpvclRpY2tzXT1cIm1ham9yVGlja3NcIlxuICogICAgICBbbWlub3JUaWNrc109XCJtaW5vclRpY2tzXCJcbiAqICAgICAgW3RpdGxlXT1cInRpdGxlXCJcbiAqICAgICAgPjwva2VuZG8tY2hhcnQtYXhpcy1kZWZhdWx0cz5cbiAqICAgIDxrZW5kby1jaGFydC10aXRsZSB0ZXh0PVwiR3Jvc3MgZG9tZXN0aWMgcHJvZHVjdCBncm93dGggL0dEUCBhbm51YWwgJS9cIj48L2tlbmRvLWNoYXJ0LXRpdGxlPlxuICogICAgPGtlbmRvLWNoYXJ0LWxlZ2VuZCBwb3NpdGlvbj1cImJvdHRvbVwiIG9yaWVudGF0aW9uPVwiaG9yaXpvbnRhbFwiPjwva2VuZG8tY2hhcnQtbGVnZW5kPlxuICogICAgPGtlbmRvLWNoYXJ0LXRvb2x0aXAgZm9ybWF0PVwiezB9JVwiPjwva2VuZG8tY2hhcnQtdG9vbHRpcD5cbiAqICAgIDxrZW5kby1jaGFydC1zZXJpZXM+XG4gKiAgICAgICAgPGtlbmRvLWNoYXJ0LXNlcmllcy1pdGVtICpuZ0Zvcj1cImxldCBpdGVtIG9mIHNlcmllc1wiXG4gKiAgICAgICAgICAgIHR5cGU9XCJsaW5lXCIgc3R5bGU9XCJzbW9vdGhcIiBbZGF0YV09XCJpdGVtLmRhdGFcIiBbbmFtZV09XCJpdGVtLm5hbWVcIj5cbiAqICAgICAgICA8L2tlbmRvLWNoYXJ0LXNlcmllcy1pdGVtPlxuICogICAgPC9rZW5kby1jaGFydC1zZXJpZXM+XG4gKiAgPC9rZW5kby1jaGFydD5cbiAqICA8L2Rpdj5cbiAqIGBcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqIHB1YmxpYyBzZXJpZXM6IGFueVtdID0gW3tcbiAqIG5hbWU6IFwiSW5kaWFcIixcbiAqIGRhdGE6IFs0LCA4LCA4LCA5LCA5LCA5LCAzLCA4LCA5LCA2XVxuICogfSwge1xuICogbmFtZTogXCJSdXNzaWFuIEZlZGVyYXRpb25cIixcbiAqIGRhdGE6IFs0LCA3LCA3LCA2LCA4LCA4LCA1LCA4LCA0LCA0XVxuICogfSwge1xuICogbmFtZTogXCJHZXJtYW55XCIsXG4gKiBkYXRhOiBbMCwgMCwgMSwgMSwgNCwgMywgMSwgNSwgNCwgM11cbiAqIH0se1xuICogbmFtZTogXCJXb3JsZFwiLFxuICogZGF0YTogWzIsIDMsIDQsIDQsIDQsIDQsIDEsIDIsIDQsIDNdXG4gKiB9XTtcbiAqXG4gKiBwdWJsaWMgIGNhdGVnb3JpZXM6IG51bWJlcltdID0gWzIwMDIsIDIwMDMsIDIwMDQsIDIwMDUsIDIwMDYsIDIwMDcsIDIwMDgsIDIwMDksIDIwMTAsIDIwMTFdO1xuICpcbiAqIHB1YmxpYyBiYWNrZ3JvdW5kID0gJ3doaXRlJztcbiAqIC8vIHB1YmxpYyBjb2xvciA9ICdjeWFuJzsgLy8gd2lsbCBvdmVycmlkZSB0aGUgbGluZS5jb2xvciBvcHRpb25cbiAqIHB1YmxpYyBjcm9zc2hhaXIgPSB7XG4gKiB2aXNpYmxlOiB0cnVlXG4gKiB9O1xuICogcHVibGljIGxhYmVscyA9IHtcbiAqIGZvbnQ6ICdib2xkIDEycHgvMzBweCBIZWx2ZXRpY2EsIEFyaWFsLCBzYW5zLXNlcmlmJyxcbiAqIGNvbG9yOiAnIzRDQUY1MCcsXG4gKiBwYWRkaW5nOiA1LFxuICogcm90YXRpb246IDQ1LFxuICogYmFja2dyb3VuZDogJ3doaXRlJyxcbiAqIGJvcmRlcjoge1xuICogY29sb3I6ICcjNENBRjUwJyxcbiAqIHdpZHRoOiAyXG4gKiB9LFxuICogfTtcbiAqIHB1YmxpYyBsaW5lID0ge1xuICogY29sb3I6ICdibGFjaycsXG4gKiB3aWR0aDogM1xuICogfTtcbiAqXG4gKiBwdWJsaWMgbWFqb3JHcmlkTGluZXMgPSB7XG4gKiBjb2xvcjogJ2JsYWNrJyxcbiAqIHZpc2libGU6IHRydWVcbiAqIH1cbiAqXG4gKiBwdWJsaWMgbWlub3JHcmlkTGluZXMgPSB7XG4gKiBjb2xvcjogJ2xpZ2h0Z3JheScsXG4gKiB2aXNpYmxlOiB0cnVlXG4gKiB9XG4gKlxuICogcHVibGljIG1ham9yVGlja3MgPSB7XG4gKiBjb2xvcjogJ2JsYWNrJyxcbiAqIHNpemU6IDE1XG4gKiB9XG4gKlxuICogcHVibGljIG1pbm9yVGlja3MgPSB7XG4gKiBjb2xvcjogJ2xpZ2h0Z3JheScsXG4gKiBzaXplOiAxMFxuICogfVxuICpcbiAqIHB1YmxpYyB0aXRsZSA9IHtcbiAqIHRleHQ6ICdEZWZhdWx0IEF4aXMgVGl0bGUnLFxuICogY29sb3I6ICdibGFjaycsXG4gKiBiYWNrZ3JvdW5kOiAnd2hpdGUnLFxuICogYm9yZGVyOiB7XG4gKiBjb2xvcjogJ2JsYWNrJyxcbiAqIHdpZHRoOiAyXG4gKiB9LFxuICogcGFkZGluZzogMTBcbiAqIH1cbiAqIH1cbiAqIGBgYFxuICovXG5sZXQgQXhpc0RlZmF1bHRzQ29tcG9uZW50ID0gY2xhc3MgQXhpc0RlZmF1bHRzQ29tcG9uZW50IGV4dGVuZHMgQXhpc0RlZmF1bHRzQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcbkF4aXNEZWZhdWx0c0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LWF4aXMtZGVmYXVsdHMnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIEF4aXNEZWZhdWx0c0NvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBBeGlzRGVmYXVsdHNDcm9zc2hhaXJDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ2F4aXNEZWZhdWx0cy5jcm9zc2hhaXInLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBBeGlzRGVmYXVsdHNDcm9zc2hhaXJDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBBeGlzRGVmYXVsdHNDcm9zc2hhaXJDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImRhc2hUeXBlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBBeGlzRGVmYXVsdHNDcm9zc2hhaXJDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm9wYWNpdHlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBBeGlzRGVmYXVsdHNDcm9zc2hhaXJDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc2libGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIEF4aXNEZWZhdWx0c0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwid2lkdGhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEF4aXNEZWZhdWx0c0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidG9vbHRpcFwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBjcm9zc2hhaXIgY29uZmlndXJhdGlvbiBvcHRpb25zIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgYXBpX2NoYXJ0c19heGlzZGVmYXVsdHNjb21wb25lbnQgJX0pKS5cbiAqL1xubGV0IEF4aXNEZWZhdWx0c0Nyb3NzaGFpckNvbXBvbmVudCA9IGNsYXNzIEF4aXNEZWZhdWx0c0Nyb3NzaGFpckNvbXBvbmVudCBleHRlbmRzIEF4aXNEZWZhdWx0c0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLm1hcmtBc1Zpc2libGUoKTtcbiAgICB9XG59O1xuQXhpc0RlZmF1bHRzQ3Jvc3NoYWlyQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtYXhpcy1kZWZhdWx0cy1jcm9zc2hhaXInLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIEF4aXNEZWZhdWx0c0Nyb3NzaGFpckNvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBBeGlzRGVmYXVsdHNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCdheGlzRGVmYXVsdHMuY3Jvc3NoYWlyLnRvb2x0aXAnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBBeGlzRGVmYXVsdHNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBBeGlzRGVmYXVsdHNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJib3JkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEF4aXNEZWZhdWx0c0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBBeGlzRGVmYXVsdHNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmb250XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBBeGlzRGVmYXVsdHNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmb3JtYXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEF4aXNEZWZhdWx0c0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBhZGRpbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBBeGlzRGVmYXVsdHNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIG9wdGlvbnMgb2YgdGhlIGNyb3NzaGFpciB0b29sdGlwIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgY3Jvc3NoYWlyc19jaGFydF9jaGFydHMgJX0pKS5cbiAqIFRoZSBjcm9zc2hhaXIgdG9vbHRpcCBpcyBkaXNwbGF5ZWQgd2hlbiB0aGUgW2BheGlzRGVmYXVsdHMuY3Jvc3NoYWlyLnRvb2x0aXAudmlzaWJsZWBdKHslIHNsdWcgYXBpX2NoYXJ0c19heGlzZGVmYXVsdHNjcm9zc2hhaXJ0b29sdGlwY29tcG9uZW50ICV9I3RvYy12aXNpYmxlKVxuICogb3B0aW9uIGlzIHNldCB0byBgdHJ1ZWAuXG4gKi9cbmxldCBBeGlzRGVmYXVsdHNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50ID0gY2xhc3MgQXhpc0RlZmF1bHRzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudCBleHRlbmRzIEF4aXNEZWZhdWx0c0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5tYXJrQXNWaXNpYmxlKCk7XG4gICAgfVxufTtcbkF4aXNEZWZhdWx0c0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1heGlzLWRlZmF1bHRzLWNyb3NzaGFpci10b29sdGlwJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBBeGlzRGVmYXVsdHNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEF4aXNEZWZhdWx0c0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignYXhpc0RlZmF1bHRzLmxhYmVscycsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgQXhpc0RlZmF1bHRzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjb250ZW50XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBBeGlzRGVmYXVsdHNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEF4aXNEZWZhdWx0c0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBBeGlzRGVmYXVsdHNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1hcmdpblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEF4aXNEZWZhdWx0c0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWlycm9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBBeGlzRGVmYXVsdHNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBhZGRpbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEF4aXNEZWZhdWx0c0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicm90YXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIEF4aXNEZWZhdWx0c0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwic2tpcFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgQXhpc0RlZmF1bHRzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJzdGVwXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQXhpc0RlZmF1bHRzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIEF4aXNEZWZhdWx0c0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzdWFsXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIGF4aXMgbGFiZWxzIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgYXBpX2NoYXJ0c19heGlzZGVmYXVsdHNjb21wb25lbnQgJX0pKS5cbiAqL1xubGV0IEF4aXNEZWZhdWx0c0xhYmVsc0NvbXBvbmVudCA9IGNsYXNzIEF4aXNEZWZhdWx0c0xhYmVsc0NvbXBvbmVudCBleHRlbmRzIEF4aXNEZWZhdWx0c0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5BeGlzRGVmYXVsdHNMYWJlbHNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1heGlzLWRlZmF1bHRzLWxhYmVscycsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgQXhpc0RlZmF1bHRzTGFiZWxzQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEF4aXNEZWZhdWx0c1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCdheGlzRGVmYXVsdHMudGl0bGUnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBBeGlzRGVmYXVsdHNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYmFja2dyb3VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQXhpc0RlZmF1bHRzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQXhpc0RlZmF1bHRzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBBeGlzRGVmYXVsdHNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9udFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQXhpc0RlZmF1bHRzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1hcmdpblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQXhpc0RlZmF1bHRzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBhZGRpbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEF4aXNEZWZhdWx0c1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgQXhpc0RlZmF1bHRzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInJvdGF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBBeGlzRGVmYXVsdHNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidGV4dFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEF4aXNEZWZhdWx0c1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIEF4aXNEZWZhdWx0c1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXN1YWxcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBvZiB0aGUgYXhpcyB0aXRsZSAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGFwaV9jaGFydHNfYXhpc2RlZmF1bHRzY29tcG9uZW50ICV9KSkuXG4gKi9cbmxldCBBeGlzRGVmYXVsdHNUaXRsZUNvbXBvbmVudCA9IGNsYXNzIEF4aXNEZWZhdWx0c1RpdGxlQ29tcG9uZW50IGV4dGVuZHMgQXhpc0RlZmF1bHRzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuQXhpc0RlZmF1bHRzVGl0bGVDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1heGlzLWRlZmF1bHRzLXRpdGxlJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBBeGlzRGVmYXVsdHNUaXRsZUNvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBDb2xsZWN0aW9uQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWdLZXksIGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uU2VydmljZSkge1xuICAgICAgICB0aGlzLmNvbmZpZ0tleSA9IGNvbmZpZ0tleTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25TZXJ2aWNlID0gY29sbGVjdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSBjb2xsZWN0aW9uU2VydmljZS5vbkl0ZW1DaGFuZ2UkLnN1YnNjcmliZShjaGFuZ2VzID0+IHRoaXMucHJvY2Vzc0NoYW5nZXMoY2hhbmdlcykpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICB0aGlzLnJlYWRJdGVtcygpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHRoaXMucmVhZEl0ZW1zKCkpO1xuICAgIH1cbiAgICBwcm9jZXNzQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmICghdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5jaGlsZHJlbi50b0FycmF5KCkuaW5kZXhPZihjaGFuZ2VzLnNlbmRlcik7XG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLml0ZW1zW2luZGV4XSA9IGNoYW5nZXMub3B0aW9ucztcbiAgICAgICAgdGhpcy5jaGFuZ2UoKTtcbiAgICB9XG4gICAgcmVhZEl0ZW1zKCkge1xuICAgICAgICB0aGlzLml0ZW1zID0gdGhpcy5jaGlsZHJlbi5tYXAocyA9PiBzLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLmNoYW5nZSgpO1xuICAgIH1cbiAgICBjaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2Uubm90aWZ5KG5ldyBDaGFuZ2UodGhpcy5jb25maWdLZXksIHRoaXMuaXRlbXMpKTtcbiAgICB9XG59XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBgd2Vla1N0YXJ0RGF5YCBvZiBhIFtDYXRlZ29yeUF4aXNJdGVtQ29tcG9uZW50XSh7JSBzbHVnIGFwaV9jaGFydHNfY2F0ZWdvcnlheGlzaXRlbWNvbXBvbmVudCAlfSkuXG4gKi9cbnZhciBXZWVrU3RhcnREYXk7XG4oZnVuY3Rpb24gKFdlZWtTdGFydERheSkge1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyBTdW5kYXkgYXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgKi9cbiAgICBXZWVrU3RhcnREYXlbV2Vla1N0YXJ0RGF5W1wiU3VuZGF5XCJdID0gMF0gPSBcIlN1bmRheVwiO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyBNb25kYXkgYXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgKi9cbiAgICBXZWVrU3RhcnREYXlbV2Vla1N0YXJ0RGF5W1wiTW9uZGF5XCJdID0gMV0gPSBcIk1vbmRheVwiO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyBUdWVzZGF5IGFzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICovXG4gICAgV2Vla1N0YXJ0RGF5W1dlZWtTdGFydERheVtcIlR1ZXNkYXlcIl0gPSAyXSA9IFwiVHVlc2RheVwiO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyBXZWRuZXNkYXkgYXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgKi9cbiAgICBXZWVrU3RhcnREYXlbV2Vla1N0YXJ0RGF5W1wiV2VkbmVzZGF5XCJdID0gM10gPSBcIldlZG5lc2RheVwiO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyBUaHVyc2RheSBhcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAqL1xuICAgIFdlZWtTdGFydERheVtXZWVrU3RhcnREYXlbXCJUaHVyc2RheVwiXSA9IDRdID0gXCJUaHVyc2RheVwiO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyBGcmlkYXkgYXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgKi9cbiAgICBXZWVrU3RhcnREYXlbV2Vla1N0YXJ0RGF5W1wiRnJpZGF5XCJdID0gNV0gPSBcIkZyaWRheVwiO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyBTYXR1cmRheSBhcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAqL1xuICAgIFdlZWtTdGFydERheVtXZWVrU3RhcnREYXlbXCJTYXR1cmRheVwiXSA9IDZdID0gXCJTYXR1cmRheVwiO1xufSkoV2Vla1N0YXJ0RGF5IHx8IChXZWVrU3RhcnREYXkgPSB7fSkpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgQ2F0ZWdvcnlBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIENvbGxlY3Rpb25JdGVtQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UsIGludGwsIGxvY2FsZUlkKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uU2VydmljZSA9IGNvbGxlY3Rpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLm5vdGlmeUNoYW5nZXMoeyB3ZWVrU3RhcnREYXk6IGludGwuZmlyc3REYXkobG9jYWxlSWQpIH0pO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENhdGVnb3J5QXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImF1dG9CYXNlVW5pdFN0ZXBzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDYXRlZ29yeUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJheGlzQ3Jvc3NpbmdWYWx1ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2F0ZWdvcnlBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYmFja2dyb3VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2F0ZWdvcnlBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYmFzZVVuaXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENhdGVnb3J5QXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhc2VVbml0U3RlcFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBDYXRlZ29yeUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjYXRlZ29yaWVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYXRlZ29yeUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENhdGVnb3J5QXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImp1c3RpZmllZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2F0ZWdvcnlBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibGluZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2F0ZWdvcnlBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWFqb3JHcmlkTGluZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENhdGVnb3J5QXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1ham9yVGlja3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENhdGVnb3J5QXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgQ2F0ZWdvcnlBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWF4RGF0ZUdyb3Vwc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgQ2F0ZWdvcnlBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWF4RGl2aXNpb25zXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDYXRlZ29yeUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENhdGVnb3J5QXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1pbm9yR3JpZExpbmVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDYXRlZ29yeUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtaW5vclRpY2tzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYXRlZ29yeUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYXRlZ29yeUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwYW5lXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIENhdGVnb3J5QXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBsb3RCYW5kc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENhdGVnb3J5QXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInJldmVyc2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDYXRlZ29yeUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJyb3VuZFRvQmFzZVVuaXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIENhdGVnb3J5QXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInN0YXJ0QW5nbGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENhdGVnb3J5QXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInR5cGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDYXRlZ29yeUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBDYXRlZ29yeUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ3ZWVrU3RhcnREYXlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENhdGVnb3J5QXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNyb3NzaGFpclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2F0ZWdvcnlBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibGFiZWxzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDYXRlZ29yeUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJub3Rlc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2F0ZWdvcnlBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDYXRlZ29yeUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0aXRsZVwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIGNvbXBvbmVudCBmb3IgYSBjYXRlZ29yeSBheGlzIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgYXhlc19jaGFydF9jaGFydHMgJX0pKS5cbiAqL1xubGV0IENhdGVnb3J5QXhpc0l0ZW1Db21wb25lbnQgPSBjbGFzcyBDYXRlZ29yeUF4aXNJdGVtQ29tcG9uZW50IGV4dGVuZHMgQ2F0ZWdvcnlBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlLCBpbnRsLCBsb2NhbGVJZCkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UsIGludGwsIGxvY2FsZUlkKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25TZXJ2aWNlID0gY29sbGVjdGlvblNlcnZpY2U7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENhdGVnb3J5QXhpc0l0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcInJhbmdlTGFiZWxzXCIsIHZvaWQgMCk7XG5DYXRlZ29yeUF4aXNJdGVtQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHByb3ZpZGVyczogW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1jYXRlZ29yeS1heGlzLWl0ZW0nLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX3BhcmFtKDMsIEluamVjdChMT0NBTEVfSUQpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlLFxuICAgICAgICBDb2xsZWN0aW9uU2VydmljZSxcbiAgICAgICAgSW50bFNlcnZpY2UsIFN0cmluZ10pXG5dLCBDYXRlZ29yeUF4aXNJdGVtQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIENhdGVnb3J5QXhpc0NvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIENvbGxlY3Rpb25Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignY2F0ZWdvcnlBeGlzJywgY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25TZXJ2aWNlID0gY29sbGVjdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkcmVuKENhdGVnb3J5QXhpc0l0ZW1Db21wb25lbnQpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBRdWVyeUxpc3QpXG5dLCBDYXRlZ29yeUF4aXNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNoaWxkcmVuXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIG9uZSBvciBtb3JlIGNhdGVnb3J5IGF4aXMgaXRlbXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiBfQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgdGVtcGxhdGU6IGBcbiAqICAgICA8a2VuZG8tY2hhcnQ+XG4gKiAgICAgICA8a2VuZG8tY2hhcnQtY2F0ZWdvcnktYXhpcz5cbiAqICAgICAgICAgPGtlbmRvLWNoYXJ0LWNhdGVnb3J5LWF4aXMtaXRlbSBbY2F0ZWdvcmllc109XCJbMjAxNSwgMjAxNl1cIiBjb2xvcj1cIiNmMDBcIj5cbiAqICAgICAgICAgPC9rZW5kby1jaGFydC1jYXRlZ29yeS1heGlzLWl0ZW0+XG4gKiAgICAgICA8L2tlbmRvLWNoYXJ0LWNhdGVnb3J5LWF4aXM+XG4gKiAgICAgICA8a2VuZG8tY2hhcnQtc2VyaWVzPlxuICogICAgICAgICA8a2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0gdHlwZT1cImxpbmVcIiBbZGF0YV09XCJbMSwgMiwgM11cIj5cbiAqICAgICAgICAgPC9rZW5kby1jaGFydC1zZXJpZXMtaXRlbT5cbiAqICAgICAgIDwva2VuZG8tY2hhcnQtc2VyaWVzPlxuICogICAgIDwva2VuZG8tY2hhcnQ+XG4gKiAgIGBcbiAqIH0pXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogfVxuICogYGBgXG4gKi9cbmxldCBDYXRlZ29yeUF4aXNDb21wb25lbnQgPSBjbGFzcyBDYXRlZ29yeUF4aXNDb21wb25lbnQgZXh0ZW5kcyBDYXRlZ29yeUF4aXNDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25TZXJ2aWNlID0gY29sbGVjdGlvblNlcnZpY2U7XG4gICAgfVxufTtcbkNhdGVnb3J5QXhpc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBwcm92aWRlcnM6IFtDb2xsZWN0aW9uU2VydmljZV0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtY2F0ZWdvcnktYXhpcycsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2UsXG4gICAgICAgIENvbGxlY3Rpb25TZXJ2aWNlXSlcbl0sIENhdGVnb3J5QXhpc0NvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBDYXRlZ29yeUF4aXNDcm9zc2hhaXJDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ2Nyb3NzaGFpcicsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENhdGVnb3J5QXhpc0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENhdGVnb3J5QXhpc0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZGFzaFR5cGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIENhdGVnb3J5QXhpc0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwib3BhY2l0eVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENhdGVnb3J5QXhpc0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgQ2F0ZWdvcnlBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ3aWR0aFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2F0ZWdvcnlBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0b29sdGlwXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIGNyb3NzaGFpciBjb25maWd1cmF0aW9uIG9wdGlvbnMgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBjcm9zc2hhaXJzX2NoYXJ0X2NoYXJ0cyAlfSkpLlxuICovXG5sZXQgQ2F0ZWdvcnlBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50ID0gY2xhc3MgQ2F0ZWdvcnlBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50IGV4dGVuZHMgQ2F0ZWdvcnlBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMubWFya0FzVmlzaWJsZSgpO1xuICAgIH1cbn07XG5DYXRlZ29yeUF4aXNDcm9zc2hhaXJDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1jYXRlZ29yeS1heGlzLWl0ZW0tY3Jvc3NoYWlyJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBDYXRlZ29yeUF4aXNDcm9zc2hhaXJDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgQ2F0ZWdvcnlBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignY3Jvc3NoYWlyLnRvb2x0aXAnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYXRlZ29yeUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDYXRlZ29yeUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJib3JkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENhdGVnb3J5QXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYXRlZ29yeUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmb250XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYXRlZ29yeUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmb3JtYXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENhdGVnb3J5QXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBhZGRpbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDYXRlZ29yeUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIG9wdGlvbnMgb2YgdGhlIGNyb3NzaGFpciB0b29sdGlwIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgY3Jvc3NoYWlyc19jaGFydF9jaGFydHMgJX0pKS5cbiAqIFRoZSBjcm9zc2hhaXIgdG9vbHRpcCBpcyBkaXNwbGF5ZWQgd2hlbiB0aGUgYHZpc2libGVgIG9wdGlvbiBpcyBzZXQgdG8gYHRydWVgLlxuICovXG5sZXQgQ2F0ZWdvcnlBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudCA9IGNsYXNzIENhdGVnb3J5QXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnQgZXh0ZW5kcyBDYXRlZ29yeUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMubWFya0FzVmlzaWJsZSgpO1xuICAgIH1cbn07XG5DYXRlZ29yeUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtY2F0ZWdvcnktYXhpcy1pdGVtLWNyb3NzaGFpci10b29sdGlwJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBDYXRlZ29yeUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50KTtcblxuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBvZiB0aGUgYXhpcyBsYWJlbHMgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBsYWJlbHNfY2hhcnRfY2hhcnRzICV9KSkuXG4gKi9cbmxldCBDYXRlZ29yeUF4aXNMYWJlbHNDb21wb25lbnQgPSBjbGFzcyBDYXRlZ29yeUF4aXNMYWJlbHNDb21wb25lbnQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ2xhYmVscycsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYXRlZ29yeUF4aXNMYWJlbHNDb21wb25lbnQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENhdGVnb3J5QXhpc0xhYmVsc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYXRlZ29yeUF4aXNMYWJlbHNDb21wb25lbnQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIENhdGVnb3J5QXhpc0xhYmVsc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiY29udGVudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2F0ZWdvcnlBeGlzTGFiZWxzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjdWx0dXJlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDYXRlZ29yeUF4aXNMYWJlbHNDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGVGb3JtYXRzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYXRlZ29yeUF4aXNMYWJlbHNDb21wb25lbnQucHJvdG90eXBlLCBcImZvbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENhdGVnb3J5QXhpc0xhYmVsc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDYXRlZ29yeUF4aXNMYWJlbHNDb21wb25lbnQucHJvdG90eXBlLCBcIm1hcmdpblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENhdGVnb3J5QXhpc0xhYmVsc0NvbXBvbmVudC5wcm90b3R5cGUsIFwibWlycm9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDYXRlZ29yeUF4aXNMYWJlbHNDb21wb25lbnQucHJvdG90eXBlLCBcInBhZGRpbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENhdGVnb3J5QXhpc0xhYmVsc0NvbXBvbmVudC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENhdGVnb3J5QXhpc0xhYmVsc0NvbXBvbmVudC5wcm90b3R5cGUsIFwicm90YXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIENhdGVnb3J5QXhpc0xhYmVsc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2tpcFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgQ2F0ZWdvcnlBeGlzTGFiZWxzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGVwXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ2F0ZWdvcnlBeGlzTGFiZWxzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIENhdGVnb3J5QXhpc0xhYmVsc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidmlzdWFsXCIsIHZvaWQgMCk7XG5DYXRlZ29yeUF4aXNMYWJlbHNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1jYXRlZ29yeS1heGlzLWl0ZW0tbGFiZWxzJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBDYXRlZ29yeUF4aXNMYWJlbHNDb21wb25lbnQpO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBheGlzIGRhdGUgcmFuZ2UgbGFiZWxzIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgbGFiZWxzX2NoYXJ0X2NoYXJ0cyAlfSkpLlxuICovXG5sZXQgQ2F0ZWdvcnlBeGlzUmFuZ2VMYWJlbHNDb21wb25lbnQgPSBjbGFzcyBDYXRlZ29yeUF4aXNSYW5nZUxhYmVsc0NvbXBvbmVudCBleHRlbmRzIENhdGVnb3J5QXhpc0xhYmVsc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuY29uZmlnS2V5ID0gJ3JhbmdlTGFiZWxzJztcbiAgICAgICAgdGhpcy5tYXJrQXNWaXNpYmxlKCk7XG4gICAgfVxufTtcbkNhdGVnb3J5QXhpc1JhbmdlTGFiZWxzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtY2F0ZWdvcnktYXhpcy1pdGVtLXJhbmdlLWxhYmVscycsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgQ2F0ZWdvcnlBeGlzUmFuZ2VMYWJlbHNDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgQ2F0ZWdvcnlBeGlzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ25vdGVzJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBDYXRlZ29yeUF4aXNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2F0ZWdvcnlBeGlzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImxpbmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENhdGVnb3J5QXhpc05vdGVzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBDYXRlZ29yeUF4aXNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzdWFsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDYXRlZ29yeUF4aXNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiaWNvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2F0ZWdvcnlBeGlzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImxhYmVsXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIGNhdGVnb3J5IGF4aXMgbm90ZXMgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBub3Rlc19jaGFydF9jaGFydHMgJX0jdG9jLWF4aXMtbm90ZXMpKS5cbiAqL1xubGV0IENhdGVnb3J5QXhpc05vdGVzQ29tcG9uZW50ID0gY2xhc3MgQ2F0ZWdvcnlBeGlzTm90ZXNDb21wb25lbnQgZXh0ZW5kcyBDYXRlZ29yeUF4aXNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5DYXRlZ29yeUF4aXNOb3Rlc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LWNhdGVnb3J5LWF4aXMtaXRlbS1ub3RlcycsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgQ2F0ZWdvcnlBeGlzTm90ZXNDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgQ2F0ZWdvcnlBeGlzTm90ZXNJY29uQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCdub3Rlcy5pY29uJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2F0ZWdvcnlBeGlzTm90ZXNJY29uQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDYXRlZ29yeUF4aXNOb3Rlc0ljb25Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgQ2F0ZWdvcnlBeGlzTm90ZXNJY29uQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJzaXplXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYXRlZ29yeUF4aXNOb3Rlc0ljb25Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInR5cGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDYXRlZ29yeUF4aXNOb3Rlc0ljb25Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc2libGVcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgaWNvbiBvZiB0aGUgbm90ZXMuXG4gKi9cbmxldCBDYXRlZ29yeUF4aXNOb3Rlc0ljb25Db21wb25lbnQgPSBjbGFzcyBDYXRlZ29yeUF4aXNOb3Rlc0ljb25Db21wb25lbnQgZXh0ZW5kcyBDYXRlZ29yeUF4aXNOb3Rlc0ljb25Db21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuQ2F0ZWdvcnlBeGlzTm90ZXNJY29uQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtY2F0ZWdvcnktYXhpcy1pdGVtLW5vdGVzLWljb24nLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIENhdGVnb3J5QXhpc05vdGVzSWNvbkNvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBDYXRlZ29yeUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCdub3Rlcy5sYWJlbCcsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENhdGVnb3J5QXhpc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENhdGVnb3J5QXhpc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2F0ZWdvcnlBeGlzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgQ2F0ZWdvcnlBeGlzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29udGVudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2F0ZWdvcnlBeGlzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9udFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2F0ZWdvcnlBeGlzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYXRlZ29yeUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgQ2F0ZWdvcnlBeGlzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicm90YXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDYXRlZ29yeUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIGxhYmVsIG9mIHRoZSBub3Rlcy5cbiAqL1xubGV0IENhdGVnb3J5QXhpc05vdGVzTGFiZWxDb21wb25lbnQgPSBjbGFzcyBDYXRlZ29yeUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50IGV4dGVuZHMgQ2F0ZWdvcnlBeGlzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5DYXRlZ29yeUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtY2F0ZWdvcnktYXhpcy1pdGVtLW5vdGVzLWxhYmVsJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBDYXRlZ29yeUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIENhdGVnb3J5QXhpc1NlbGVjdENvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignc2VsZWN0JywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2F0ZWdvcnlBeGlzU2VsZWN0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmcm9tXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDYXRlZ29yeUF4aXNTZWxlY3RDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2F0ZWdvcnlBeGlzU2VsZWN0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENhdGVnb3J5QXhpc1NlbGVjdENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibW91c2V3aGVlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2F0ZWdvcnlBeGlzU2VsZWN0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0b1wiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBzZWxlY3RlZCBheGlzIHJhbmdlLiBJZiBzZXQsIHRoZSBheGlzIHNlbGVjdGlvbiBpcyBlbmFibGVkLiBUaGUgcmFuZ2UgaXMgaW5kZXgtYmFzZWQgYW5kIHN0YXJ0cyBmcm9tIHplcm8uXG4gKiBDYXRlZ29yaWVzIHdpdGggaW5kZXhlcyBpbiB0aGVcbiAqIChbYHNlbGVjdC5mcm9tYF0oeyUgc2x1ZyBhcGlfY2hhcnRzX2NhdGVnb3J5YXhpc3NlbGVjdGNvbXBvbmVudCAlfSN0b2MtZnJvbSlcbiAqICZtZGFzaDtbYHNlbGVjdC50b2BdKHslIHNsdWcgYXBpX2NoYXJ0c19jYXRlZ29yeWF4aXNzZWxlY3Rjb21wb25lbnQgJX0jdG9jLXRvKSkgcmFuZ2Ugd2lsbCBiZSBzZWxlY3RlZC5cbiAqIFRoaXMgbWVhbnMgdGhhdCB0aGUgbGFzdCBjYXRlZ29yeSBpbiB0aGUgcmFuZ2Ugd2lsbCBub3QgYmUgaW5jbHVkZWQgaW4gdGhlIHNlbGVjdGlvbi5cbiAqIElmIHRoZSBjYXRlZ29yaWVzIGFyZSBkYXRlcywgdGhlIHJhbmdlIGhhcyB0byBiZSBhbHNvIHNwZWNpZmllZCB3aXRoIGRhdGUgdmFsdWVzLlxuICovXG5sZXQgQ2F0ZWdvcnlBeGlzU2VsZWN0Q29tcG9uZW50ID0gY2xhc3MgQ2F0ZWdvcnlBeGlzU2VsZWN0Q29tcG9uZW50IGV4dGVuZHMgQ2F0ZWdvcnlBeGlzU2VsZWN0Q29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcbkNhdGVnb3J5QXhpc1NlbGVjdENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LWNhdGVnb3J5LWF4aXMtaXRlbS1zZWxlY3QnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIENhdGVnb3J5QXhpc1NlbGVjdENvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBDYXRlZ29yeUF4aXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcigndGl0bGUnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYXRlZ29yeUF4aXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYmFja2dyb3VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2F0ZWdvcnlBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2F0ZWdvcnlBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYXRlZ29yeUF4aXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9udFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2F0ZWdvcnlBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1hcmdpblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2F0ZWdvcnlBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBhZGRpbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENhdGVnb3J5QXhpc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgQ2F0ZWdvcnlBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInJvdGF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYXRlZ29yeUF4aXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidGV4dFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENhdGVnb3J5QXhpc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIENhdGVnb3J5QXhpc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXN1YWxcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBvZiB0aGUgY2F0ZWdvcnkgYXhpcyB0aXRsZS5cbiAqL1xubGV0IENhdGVnb3J5QXhpc1RpdGxlQ29tcG9uZW50ID0gY2xhc3MgQ2F0ZWdvcnlBeGlzVGl0bGVDb21wb25lbnQgZXh0ZW5kcyBDYXRlZ29yeUF4aXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5DYXRlZ29yeUF4aXNUaXRsZUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LWNhdGVnb3J5LWF4aXMtaXRlbS10aXRsZScsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgQ2F0ZWdvcnlBeGlzVGl0bGVDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgQ2hhcnRBcmVhQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCdjaGFydEFyZWEnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDaGFydEFyZWFDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENoYXJ0QXJlYUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBDaGFydEFyZWFDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImhlaWdodFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2hhcnRBcmVhQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtYXJnaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIENoYXJ0QXJlYUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwib3BhY2l0eVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgQ2hhcnRBcmVhQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ3aWR0aFwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgb2YgdGhlIENoYXJ0IGFyZWEuXG4gKiBSZXByZXNlbnRzIHRoZSBlbnRpcmUgdmlzaWJsZSBhcmVhIG9mIHRoZSBDaGFydFxuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBjaGFydGFyZWFfY2hhcnRfY2hhcnRzICV9KSkuXG4gKi9cbmxldCBDaGFydEFyZWFDb21wb25lbnQgPSBjbGFzcyBDaGFydEFyZWFDb21wb25lbnQgZXh0ZW5kcyBDaGFydEFyZWFDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuQ2hhcnRBcmVhQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtYXJlYScsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgQ2hhcnRBcmVhQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIExlZ2VuZENvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignbGVnZW5kJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTGVnZW5kQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJhbGlnblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTGVnZW5kQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBMZWdlbmRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgTGVnZW5kQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJoZWlnaHRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIExlZ2VuZENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibGFiZWxzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBMZWdlbmRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1hcmdpblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgTGVnZW5kQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJvZmZzZXRYXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBMZWdlbmRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm9mZnNldFlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIExlZ2VuZENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwib3JpZW50YXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIExlZ2VuZENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTGVnZW5kQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIExlZ2VuZENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicmV2ZXJzZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIExlZ2VuZENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgTGVnZW5kQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ3aWR0aFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTGVnZW5kQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtYXJrZXJzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBMZWdlbmRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInNwYWNpbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIExlZ2VuZENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiaW5hY3RpdmVJdGVtc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTGVnZW5kQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJpdGVtXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBMZWdlbmRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInRpdGxlXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBvZiB0aGUgQ2hhcnQgbGVnZW5kXG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGxlZ2VuZF9jaGFydF9jaGFydHMgJX0pKS5cbiAqL1xubGV0IExlZ2VuZENvbXBvbmVudCA9IGNsYXNzIExlZ2VuZENvbXBvbmVudCBleHRlbmRzIExlZ2VuZENvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLm1hcmtBc1Zpc2libGUoKTtcbiAgICB9XG59O1xuTGVnZW5kQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtbGVnZW5kJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBMZWdlbmRDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgTGVnZW5kSW5hY3RpdmVJdGVtc0NvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignbGVnZW5kLmluYWN0aXZlSXRlbXMnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBMZWdlbmRJbmFjdGl2ZUl0ZW1zQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJsYWJlbHNcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBvZiB0aGUgaW5hY3RpdmUgQ2hhcnQgbGVnZW5kIGl0ZW1zLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgaHRtbC1uby1ydW5cbiAqIDxrZW5kby1jaGFydD5cbiAqICAgPGtlbmRvLWNoYXJ0LWxlZ2VuZD5cbiAqICAgICAgPGtlbmRvLWNoYXJ0LWxlZ2VuZC1pbmFjdGl2ZS1pdGVtcyBbbGFiZWxzXT1cIntjb2xvcjogJ3BpbmsnfVwiPjwva2VuZG8tY2hhcnQtbGVnZW5kLWluYWN0aXZlLWl0ZW1zPlxuICogICA8L2tlbmRvLWNoYXJ0LWxlZ2VuZD5cbiAqIDwva2VuZG8tY2hhcnQ+XG4gKiBgYGBcbiAqL1xubGV0IExlZ2VuZEluYWN0aXZlSXRlbXNDb21wb25lbnQgPSBjbGFzcyBMZWdlbmRJbmFjdGl2ZUl0ZW1zQ29tcG9uZW50IGV4dGVuZHMgTGVnZW5kSW5hY3RpdmVJdGVtc0NvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5MZWdlbmRJbmFjdGl2ZUl0ZW1zQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtbGVnZW5kLWluYWN0aXZlLWl0ZW1zJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBMZWdlbmRJbmFjdGl2ZUl0ZW1zQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIExlZ2VuZEl0ZW1Db21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ2xlZ2VuZC5pdGVtJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTGVnZW5kSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY3Vyc29yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIExlZ2VuZEl0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc3VhbFwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBDaGFydCBsZWdlbmQgaXRlbS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGh0bWwtbm8tcnVuXG4gKiA8a2VuZG8tY2hhcnQ+XG4gKiAgIDxrZW5kby1jaGFydC1sZWdlbmQ+XG4gKiAgICAgIDxrZW5kby1jaGFydC1sZWdlbmQtaXRlbSBjdXJzb3I9XCJjcm9zc2hhaXJcIj48L2tlbmRvLWNoYXJ0LWxlZ2VuZC1pdGVtPlxuICogICA8L2tlbmRvLWNoYXJ0LWxlZ2VuZD5cbiAqIDwva2VuZG8tY2hhcnQ+XG4gKiBgYGBcbiAqL1xubGV0IExlZ2VuZEl0ZW1Db21wb25lbnQgPSBjbGFzcyBMZWdlbmRJdGVtQ29tcG9uZW50IGV4dGVuZHMgTGVnZW5kSXRlbUNvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5MZWdlbmRJdGVtQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtbGVnZW5kLWl0ZW0nLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIExlZ2VuZEl0ZW1Db21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgUGFuZUNvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIENvbGxlY3Rpb25JdGVtQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25TZXJ2aWNlID0gY29sbGVjdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgUGFuZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYmFja2dyb3VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgUGFuZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgUGFuZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY2xpcFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgUGFuZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBQYW5lQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtYXJnaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFBhbmVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm5hbWVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFBhbmVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBhZGRpbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFBhbmVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInRpdGxlXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gY29tcG9uZW50IGZvciBhIENoYXJ0IHBhbmUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiBfQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgdGVtcGxhdGU6IGBcbiAqICAgICAgIDxrZW5kby1jaGFydD5cbiAqICAgICAgICAgPGtlbmRvLWNoYXJ0LXBhbmVzPlxuICogICAgICAgICAgICAgPGtlbmRvLWNoYXJ0LXBhbmUgbmFtZT1cInRvcFwiIGJhY2tncm91bmQ9XCJwaW5rXCIgW2JvcmRlcl09XCJ7IGNvbG9yOiAnYmxhY2snLCBkYXNodHlwZTogJ2Rhc2gnLCB3aWR0aDogMiB9XCI+XG4gKiAgICAgICAgICAgICAgIDwhLS0gICAgICAgICAgICBeXl5eXl5eXl5eXG4gKiAgICAgICAgICAgICAgICAgICBVbmlxdWUgSUQgZm9yIHRoZSBwYW5lLlxuICogICAgICAgICAgICAgICAtLT5cbiAqICAgICAgICAgICAgIDwva2VuZG8tY2hhcnQtcGFuZT5cbiAqICAgICAgICAgICAgIDxrZW5kby1jaGFydC1wYW5lIG5hbWU9XCJib3R0b21cIiBbaGVpZ2h0XT1cIjE1MFwiIHRpdGxlPVwiQm90dG9tIHBhbmVcIj5cbiAqICAgICAgICAgICAgICAgPCEtLSAgICAgICAgICAgICAgICAgICAgICAgICAgXl5eXl5eXl5eXl5eXl5cbiAqICAgICAgICAgICAgICAgICAgIE5vdGUgdGhhdCB0aGUgYmluZGluZyBpcyByZXF1aXJlZCxcbiAqICAgICAgICAgICAgICAgICAgIG90aGVyd2lzZSB0aGUgcHJvcGVydHkgd2lsbCBiZVxuICogICAgICAgICAgICAgICAgICAgYm91bmQgdG8gYSAnMTAwJyBzdHJpbmcuXG4gKiAgICAgICAgICAgICAgIC0tPlxuICogICAgICAgICAgICAgPC9rZW5kby1jaGFydC1wYW5lPlxuICogICAgICAgICA8L2tlbmRvLWNoYXJ0LXBhbmVzPlxuICpcbiAqICAgICAgICAgPGtlbmRvLWNoYXJ0LXZhbHVlLWF4aXM+XG4gKiAgICAgICAgICAgICA8a2VuZG8tY2hhcnQtdmFsdWUtYXhpcy1pdGVtIG5hbWU9XCJ0b3BcIj5cbiAqICAgICAgICAgICAgICAgPCEtLSAgICAgICAgICAgICAgICAgICAgICAgXl5eXl5eXl5eXlxuICogICAgICAgICAgICAgICAgICAgVW5pcXVlIElEIGZvciB0aGUgYXhpcy5cbiAqICAgICAgICAgICAgICAgICAgIE5vIG5lZWQgdG8gc2V0IGEgcGFuZSBhcyBpdCB3aWxsIHVzZSB0aGUgZmlyc3QsXG4gKiAgICAgICAgICAgICAgICAgICAndG9wJyBwYW5lIGJ5IGRlZmF1bHQuXG4gKiAgICAgICAgICAgICAgIC0tPlxuICogICAgICAgICAgICAgPC9rZW5kby1jaGFydC12YWx1ZS1heGlzLWl0ZW0+XG4gKiAgICAgICAgICAgICA8a2VuZG8tY2hhcnQtdmFsdWUtYXhpcy1pdGVtIG5hbWU9XCJib3R0b21cIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYW5lPVwiYm90dG9tXCI+XG4gKiAgICAgICAgICAgICAgIDwhLS0gICAgICAgICAgICAgICAgICAgICAgIF5eXl5eXl5eXl5eXl5cbiAqICAgICAgICAgICAgICAgICAgIE1vdmUgdGhlIGF4aXMgdG8gdGhlIGJvdHRvbSBwYW5lLlxuICogICAgICAgICAgICAgICAtLT5cbiAqICAgICAgICAgICAgIDwva2VuZG8tY2hhcnQtdmFsdWUtYXhpcy1pdGVtPlxuICogICAgICAgICA8L2tlbmRvLWNoYXJ0LXZhbHVlLWF4aXM+XG4gKiAgICAgICAgIDxrZW5kby1jaGFydC1zZXJpZXM+XG4gKiAgICAgICAgICAgPGtlbmRvLWNoYXJ0LXNlcmllcy1pdGVtIFtkYXRhXT1cInNlcmllc0RhdGFbMF1cIj5cbiAqICAgICAgICAgICAgICAgPCEtLSBXaWxsIHVzZSB0aGUgZmlyc3QsICd0b3AnIHZhbHVlIGF4aXMgYnkgZGVmYXVsdC4gLS0+XG4gKiAgICAgICAgICAgPC9rZW5kby1jaGFydC1zZXJpZXMtaXRlbT5cbiAqICAgICAgICAgICA8a2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0gdHlwZT1cImxpbmVcIiBbZGF0YV09XCJzZXJpZXNEYXRhWzFdXCIgYXhpcz1cImJvdHRvbVwiPlxuICogICAgICAgICAgICAgICA8IS0tIFBsb3QgdGhpcyBzZXJpZXMgdG8gdGhlICdib3R0b20nIGF4aXMuICAgICAgICAgICAgICBeXl5eXl5eXl5eXl5eIC0tPlxuICogICAgICAgICAgIDwva2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0+XG4gKiAgICAgICAgIDwva2VuZG8tY2hhcnQtc2VyaWVzPlxuICogICAgICAgPC9rZW5kby1jaGFydD5cbiAqICAgYFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQge1xuICogICBwdWJsaWMgc2VyaWVzRGF0YTogbnVtYmVyW11bXSA9IFtbMSwgMiwgMywgNV0sIFswLCAxLCAwLCAxXV07XG4gKiB9XG4gKiBgYGBcbiAqL1xubGV0IFBhbmVDb21wb25lbnQgPSBjbGFzcyBQYW5lQ29tcG9uZW50IGV4dGVuZHMgUGFuZUNvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvblNlcnZpY2UgPSBjb2xsZWN0aW9uU2VydmljZTtcbiAgICB9XG59O1xuUGFuZUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBwcm92aWRlcnM6IFtDb25maWd1cmF0aW9uU2VydmljZV0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtcGFuZSwga2VuZG8tY2hhcnQtcGFuZXMtaXRlbScsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2UsXG4gICAgICAgIENvbGxlY3Rpb25TZXJ2aWNlXSlcbl0sIFBhbmVDb21wb25lbnQpO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIGFsbCBjaGFydCBwYW5lcyxcbiAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgcGFuZXNfY2hhcnRfY2hhcnRzICV9I3RvYy1kZWZhdWx0LXBhbmVzLWNvbmZpZ3VyYXRpb24pKS5cbiAqL1xubGV0IFBhbmVEZWZhdWx0c0NvbXBvbmVudCA9IGNsYXNzIFBhbmVEZWZhdWx0c0NvbXBvbmVudCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcigncGFuZURlZmF1bHRzJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFBhbmVEZWZhdWx0c0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYmFja2dyb3VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgUGFuZURlZmF1bHRzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJib3JkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBQYW5lRGVmYXVsdHNDb21wb25lbnQucHJvdG90eXBlLCBcImNsaXBcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFBhbmVEZWZhdWx0c0NvbXBvbmVudC5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBQYW5lRGVmYXVsdHNDb21wb25lbnQucHJvdG90eXBlLCBcIm1hcmdpblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgUGFuZURlZmF1bHRzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwYWRkaW5nXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBQYW5lRGVmYXVsdHNDb21wb25lbnQucHJvdG90eXBlLCBcInRpdGxlXCIsIHZvaWQgMCk7XG5QYW5lRGVmYXVsdHNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1wYW5lLWRlZmF1bHRzJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBQYW5lRGVmYXVsdHNDb21wb25lbnQpO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBwYW5lIGRlZmF1bHQgdGl0bGUuXG4gKi9cbmxldCBQYW5lRGVmYXVsdHNUaXRsZUNvbXBvbmVudCA9IGNsYXNzIFBhbmVEZWZhdWx0c1RpdGxlQ29tcG9uZW50IGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCdwYW5lRGVmYXVsdHMudGl0bGUnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgUGFuZURlZmF1bHRzVGl0bGVDb21wb25lbnQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFBhbmVEZWZhdWx0c1RpdGxlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJib3JkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFBhbmVEZWZhdWx0c1RpdGxlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgUGFuZURlZmF1bHRzVGl0bGVDb21wb25lbnQucHJvdG90eXBlLCBcImZvbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFBhbmVEZWZhdWx0c1RpdGxlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXJnaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFBhbmVEZWZhdWx0c1RpdGxlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFBhbmVEZWZhdWx0c1RpdGxlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFBhbmVEZWZhdWx0c1RpdGxlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2aXN1YWxcIiwgdm9pZCAwKTtcblBhbmVEZWZhdWx0c1RpdGxlQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtcGFuZS1kZWZhdWx0cy10aXRsZScsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgUGFuZURlZmF1bHRzVGl0bGVDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgUGFuZXNDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBDb2xsZWN0aW9uQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ3BhbmVzJywgY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25TZXJ2aWNlID0gY29sbGVjdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkcmVuKFBhbmVDb21wb25lbnQpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBRdWVyeUxpc3QpXG5dLCBQYW5lc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY2hpbGRyZW5cIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2Ygb25lIG9yIG1vcmUgcGFuZSBjb25maWd1cmF0aW9uIGNvbXBvbmVudHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiBfQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgdGVtcGxhdGU6IGBcbiAqICAgICA8a2VuZG8tY2hhcnQ+XG4gKiAgICAgICA8a2VuZG8tY2hhcnQtcGFuZXM+XG4gKiAgICAgICAgIDxrZW5kby1jaGFydC1wYW5lIG5hbWU9XCJ0b3BQYW5lXCI+XG4gKiAgICAgICAgIDwva2VuZG8tY2hhcnQtcGFuZT5cbiAqICAgICAgICAgPGtlbmRvLWNoYXJ0LXBhbmUgbmFtZT1cImJvdHRvbVBhbmVcIj5cbiAqICAgICAgICAgPC9rZW5kby1jaGFydC1wYW5lPlxuICogICAgICAgPC9rZW5kby1jaGFydC1wYW5lcz5cbiAqICAgICAgIDxrZW5kby1jaGFydC12YWx1ZS1heGlzPlxuICogICAgICAgICA8a2VuZG8tY2hhcnQtdmFsdWUtYXhpcy1pdGVtIHBhbmU9XCJ0b3BQYW5lXCI+XG4gKiAgICAgICAgIDwva2VuZG8tY2hhcnQtdmFsdWUtYXhpcy1pdGVtPlxuICogICAgICAgICA8a2VuZG8tY2hhcnQtdmFsdWUtYXhpcy1pdGVtIG5hbWU9XCJib3R0b21BeGlzXCIgcGFuZT1cImJvdHRvbVBhbmVcIj5cbiAqICAgICAgICAgPC9rZW5kby1jaGFydC12YWx1ZS1heGlzLWl0ZW0+XG4gKiAgICAgICA8L2tlbmRvLWNoYXJ0LXZhbHVlLWF4aXM+XG4gKiAgICAgICA8a2VuZG8tY2hhcnQtc2VyaWVzPlxuICogICAgICAgICA8a2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0gdHlwZT1cImxpbmVcIiBbZGF0YV09XCJbMSwgMiwgM11cIj5cbiAqICAgICAgICAgPC9rZW5kby1jaGFydC1zZXJpZXMtaXRlbT5cbiAqICAgICAgICAgPGtlbmRvLWNoYXJ0LXNlcmllcy1pdGVtIHR5cGU9XCJsaW5lXCIgW2RhdGFdPVwiWzEsIDIsIDMsIDRdXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4aXM9XCJib3R0b21BeGlzXCI+XG4gKiAgICAgICAgIDwva2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0+XG4gKiAgICAgICA8L2tlbmRvLWNoYXJ0LXNlcmllcz5cbiAqICAgICA8L2tlbmRvLWNoYXJ0PlxuICogICBgXG4gKiB9KVxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqIH1cbiAqXG4gKiBgYGBcbiAqL1xubGV0IFBhbmVzQ29tcG9uZW50ID0gY2xhc3MgUGFuZXNDb21wb25lbnQgZXh0ZW5kcyBQYW5lc0NvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvblNlcnZpY2UgPSBjb2xsZWN0aW9uU2VydmljZTtcbiAgICB9XG59O1xuUGFuZXNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgcHJvdmlkZXJzOiBbQ29sbGVjdGlvblNlcnZpY2VdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXBhbmVzJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZSxcbiAgICAgICAgQ29sbGVjdGlvblNlcnZpY2VdKVxuXSwgUGFuZXNDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgUGFuZXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcigndGl0bGUnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBQYW5lc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBQYW5lc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJib3JkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFBhbmVzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBQYW5lc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmb250XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBQYW5lc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtYXJnaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFBhbmVzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBQYW5lc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0ZXh0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgUGFuZXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBQYW5lc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXN1YWxcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBvZiB0aGUgQ2hhcnQgcGFuZSB0aXRsZS5cbiAqL1xubGV0IFBhbmVzVGl0bGVDb21wb25lbnQgPSBjbGFzcyBQYW5lc1RpdGxlQ29tcG9uZW50IGV4dGVuZHMgUGFuZXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5QYW5lc1RpdGxlQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtcGFuZS10aXRsZScsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgUGFuZXNUaXRsZUNvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBQbG90QXJlYUNvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcigncGxvdEFyZWEnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBQbG90QXJlYUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYmFja2dyb3VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgUGxvdEFyZWFDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgUGxvdEFyZWFDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1hcmdpblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgUGxvdEFyZWFDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm9wYWNpdHlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFBsb3RBcmVhQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwYWRkaW5nXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBvZiB0aGUgcGxvdCBhcmVhXG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHBsb3RhcmVhX2NoYXJ0X2NoYXJ0cyAlfSkpLlxuICogVGhlIHBsb3QgYXJlYSBpcyB0aGUgYXJlYSB3aGljaCBkaXNwbGF5cyB0aGUgc2VyaWVzLlxuICovXG5sZXQgUGxvdEFyZWFDb21wb25lbnQgPSBjbGFzcyBQbG90QXJlYUNvbXBvbmVudCBleHRlbmRzIFBsb3RBcmVhQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcblBsb3RBcmVhQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtcGxvdC1hcmVhJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBQbG90QXJlYUNvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBTZXJpZXNDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBDb2xsZWN0aW9uQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ3NlcmllcycsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uU2VydmljZSA9IGNvbGxlY3Rpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZHJlbihTZXJpZXNJdGVtQ29tcG9uZW50KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KVxuXSwgU2VyaWVzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjaGlsZHJlblwiLCB2b2lkIDApO1xuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBvbmUgb3IgbW9yZSBzZXJpZXMgaXRlbXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiBfQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgdGVtcGxhdGU6IGBcbiAqICAgICA8a2VuZG8tY2hhcnQ+XG4gKiAgICAgICA8a2VuZG8tY2hhcnQtc2VyaWVzPlxuICogICAgICAgICA8a2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0gdHlwZT1cImxpbmVcIiBbZGF0YV09XCJbMSwgMiwgM11cIj5cbiAqICAgICAgICAgPC9rZW5kby1jaGFydC1zZXJpZXMtaXRlbT5cbiAqICAgICAgIDwva2VuZG8tY2hhcnQtc2VyaWVzPlxuICogICAgIDwva2VuZG8tY2hhcnQ+XG4gKiAgIGBcbiAqIH0pXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogfVxuICpcbiAqIGBgYFxuICovXG5sZXQgU2VyaWVzQ29tcG9uZW50ID0gY2xhc3MgU2VyaWVzQ29tcG9uZW50IGV4dGVuZHMgU2VyaWVzQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlLCB0b29sdGlwVGVtcGxhdGVTZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uU2VydmljZSA9IGNvbGxlY3Rpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLnRvb2x0aXBUZW1wbGF0ZVNlcnZpY2UgPSB0b29sdGlwVGVtcGxhdGVTZXJ2aWNlO1xuICAgIH1cbiAgICBuZ0FmdGVyQ29udGVudENoZWNrZWQoKSB7XG4gICAgICAgIHRoaXMucmVhZFRvb2x0aXBUZW1wbGF0ZXMoKTtcbiAgICB9XG4gICAgcmVhZFRvb2x0aXBUZW1wbGF0ZXMoKSB7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlcyA9IHRoaXMuY2hpbGRyZW4ubWFwKChpdGVtKSA9PiBpdGVtLnNlcmllc1Rvb2x0aXBUZW1wbGF0ZVJlZik7XG4gICAgICAgIHRoaXMudG9vbHRpcFRlbXBsYXRlU2VydmljZS5zZXRTZXJpZXNUZW1wbGF0ZXModGVtcGxhdGVzKTtcbiAgICB9XG59O1xuU2VyaWVzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHByb3ZpZGVyczogW0NvbGxlY3Rpb25TZXJ2aWNlXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1zZXJpZXMnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlLFxuICAgICAgICBDb2xsZWN0aW9uU2VydmljZSxcbiAgICAgICAgVG9vbHRpcFRlbXBsYXRlU2VydmljZV0pXG5dLCBTZXJpZXNDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU2VyaWVzRGVmYXVsdHNDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ3Nlcmllc0RlZmF1bHRzJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzRGVmYXVsdHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU2VyaWVzRGVmYXVsdHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImdhcFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzRGVmYXVsdHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImhpZ2hsaWdodFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzRGVmYXVsdHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm92ZXJsYXlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFNlcmllc0RlZmF1bHRzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJzcGFjaW5nXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNEZWZhdWx0c0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwic3RhY2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0RlZmF1bHRzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0eXBlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFNlcmllc0RlZmF1bHRzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXN1YWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0RlZmF1bHRzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJsYWJlbHNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0RlZmF1bHRzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJub3Rlc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzRGVmYXVsdHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInRvb2x0aXBcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBvcHRpb25zIGZvciBhbGwgc2VyaWVzXG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHNlcmllc19jaGFydF9jaGFydHMgJX0jdG9jLWRlZmF1bHQtc2VyaWVzLWNvbmZpZ3VyYXRpb24pKS5cbiAqL1xubGV0IFNlcmllc0RlZmF1bHRzQ29tcG9uZW50ID0gY2xhc3MgU2VyaWVzRGVmYXVsdHNDb21wb25lbnQgZXh0ZW5kcyBTZXJpZXNEZWZhdWx0c0NvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5TZXJpZXNEZWZhdWx0c0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXNlcmllcy1kZWZhdWx0cycsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgU2VyaWVzRGVmYXVsdHNDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU2VyaWVzRGVmYXVsdHNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ3Nlcmllc0RlZmF1bHRzLmxhYmVscycsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0RlZmF1bHRzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNEZWZhdWx0c0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNEZWZhdWx0c0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgU2VyaWVzRGVmYXVsdHNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbnRlbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0RlZmF1bHRzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmb250XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNEZWZhdWx0c0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNEZWZhdWx0c0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWFyZ2luXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNEZWZhdWx0c0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFNlcmllc0RlZmF1bHRzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFNlcmllc0RlZmF1bHRzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXN1YWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0RlZmF1bHRzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmcm9tXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNEZWZhdWx0c0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidG9cIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBvZiB0aGUgQ2hhcnQgc2VyaWVzIGxhYmVsLlxuICovXG5sZXQgU2VyaWVzRGVmYXVsdHNMYWJlbHNDb21wb25lbnQgPSBjbGFzcyBTZXJpZXNEZWZhdWx0c0xhYmVsc0NvbXBvbmVudCBleHRlbmRzIFNlcmllc0RlZmF1bHRzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMubWFya0FzVmlzaWJsZSgpO1xuICAgIH1cbn07XG5TZXJpZXNEZWZhdWx0c0xhYmVsc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXNlcmllcy1kZWZhdWx0cy1sYWJlbHMnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIFNlcmllc0RlZmF1bHRzTGFiZWxzQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFNlcmllc0RlZmF1bHRzTGFiZWxzRnJvbUNvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignc2VyaWVzRGVmYXVsdHMubGFiZWxzLmZyb20nLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNEZWZhdWx0c0xhYmVsc0Zyb21Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0RlZmF1bHRzTGFiZWxzRnJvbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNEZWZhdWx0c0xhYmVsc0Zyb21Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFNlcmllc0RlZmF1bHRzTGFiZWxzRnJvbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29udGVudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzRGVmYXVsdHNMYWJlbHNGcm9tQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmb250XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNEZWZhdWx0c0xhYmVsc0Zyb21Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvcm1hdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzRGVmYXVsdHNMYWJlbHNGcm9tQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtYXJnaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0RlZmF1bHRzTGFiZWxzRnJvbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFNlcmllc0RlZmF1bHRzTGFiZWxzRnJvbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBgZnJvbWAgbGFiZWwgY29uZmlndXJhdGlvbiBvZiB0aGUgQ2hhcnQgc2VyaWVzLlxuICovXG5sZXQgU2VyaWVzRGVmYXVsdHNMYWJlbHNGcm9tQ29tcG9uZW50ID0gY2xhc3MgU2VyaWVzRGVmYXVsdHNMYWJlbHNGcm9tQ29tcG9uZW50IGV4dGVuZHMgU2VyaWVzRGVmYXVsdHNMYWJlbHNGcm9tQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMubWFya0FzVmlzaWJsZSgpO1xuICAgIH1cbn07XG5TZXJpZXNEZWZhdWx0c0xhYmVsc0Zyb21Db21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1zZXJpZXMtZGVmYXVsdHMtbGFiZWxzLWZyb20nLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIFNlcmllc0RlZmF1bHRzTGFiZWxzRnJvbUNvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBTZXJpZXNEZWZhdWx0c0xhYmVsc1RvQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCdzZXJpZXNEZWZhdWx0cy5sYWJlbHMudG8nLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNEZWZhdWx0c0xhYmVsc1RvQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNEZWZhdWx0c0xhYmVsc1RvQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJib3JkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0RlZmF1bHRzTGFiZWxzVG9Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFNlcmllc0RlZmF1bHRzTGFiZWxzVG9Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbnRlbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0RlZmF1bHRzTGFiZWxzVG9Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0RlZmF1bHRzTGFiZWxzVG9Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvcm1hdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzRGVmYXVsdHNMYWJlbHNUb0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWFyZ2luXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNEZWZhdWx0c0xhYmVsc1RvQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwYWRkaW5nXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgU2VyaWVzRGVmYXVsdHNMYWJlbHNUb0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBgdG9gIGxhYmVsIGNvbmZpZ3VyYXRpb24gb2YgdGhlIENoYXJ0IHNlcmllcy5cbiAqL1xubGV0IFNlcmllc0RlZmF1bHRzTGFiZWxzVG9Db21wb25lbnQgPSBjbGFzcyBTZXJpZXNEZWZhdWx0c0xhYmVsc1RvQ29tcG9uZW50IGV4dGVuZHMgU2VyaWVzRGVmYXVsdHNMYWJlbHNUb0NvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLm1hcmtBc1Zpc2libGUoKTtcbiAgICB9XG59O1xuU2VyaWVzRGVmYXVsdHNMYWJlbHNUb0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXNlcmllcy1kZWZhdWx0cy1sYWJlbHMtdG8nLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIFNlcmllc0RlZmF1bHRzTGFiZWxzVG9Db21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU2VyaWVzRGVmYXVsdHNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignc2VyaWVzRGVmYXVsdHMubm90ZXMnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNEZWZhdWx0c05vdGVzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJsaW5lXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFNlcmllc0RlZmF1bHRzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc3VhbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzRGVmYXVsdHNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiaWNvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzRGVmYXVsdHNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibGFiZWxcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBvZiB0aGUgW2BzZXJpZXNEZWZhdWx0c2BdKHslIHNsdWcgYXBpX2NoYXJ0c19zZXJpZXNkZWZhdWx0c2NvbXBvbmVudCAlfSkgbm90ZXMuXG4gKi9cbmxldCBTZXJpZXNEZWZhdWx0c05vdGVzQ29tcG9uZW50ID0gY2xhc3MgU2VyaWVzRGVmYXVsdHNOb3Rlc0NvbXBvbmVudCBleHRlbmRzIFNlcmllc0RlZmF1bHRzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuU2VyaWVzRGVmYXVsdHNOb3Rlc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXNlcmllcy1kZWZhdWx0cy1ub3RlcycsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgU2VyaWVzRGVmYXVsdHNOb3Rlc0NvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBTZXJpZXNEZWZhdWx0c05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignc2VyaWVzRGVmYXVsdHMubm90ZXMuaWNvbicsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0RlZmF1bHRzTm90ZXNJY29uQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNEZWZhdWx0c05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBTZXJpZXNEZWZhdWx0c05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwic2l6ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzRGVmYXVsdHNOb3Rlc0ljb25Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInR5cGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBTZXJpZXNEZWZhdWx0c05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBpY29uIG9mIHRoZSBub3Rlcy5cbiAqL1xubGV0IFNlcmllc0RlZmF1bHRzTm90ZXNJY29uQ29tcG9uZW50ID0gY2xhc3MgU2VyaWVzRGVmYXVsdHNOb3Rlc0ljb25Db21wb25lbnQgZXh0ZW5kcyBTZXJpZXNEZWZhdWx0c05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5TZXJpZXNEZWZhdWx0c05vdGVzSWNvbkNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXNlcmllcy1kZWZhdWx0cy1ub3Rlcy1pY29uJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBTZXJpZXNEZWZhdWx0c05vdGVzSWNvbkNvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBTZXJpZXNEZWZhdWx0c05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ3Nlcmllc0RlZmF1bHRzLm5vdGVzLmxhYmVsJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzRGVmYXVsdHNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNEZWZhdWx0c05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzRGVmYXVsdHNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBTZXJpZXNEZWZhdWx0c05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbnRlbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0RlZmF1bHRzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9udFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzRGVmYXVsdHNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmb3JtYXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0RlZmF1bHRzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFNlcmllc0RlZmF1bHRzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicm90YXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBTZXJpZXNEZWZhdWx0c05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc2libGVcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgbGFiZWwgb2YgdGhlIG5vdGVzLlxuICovXG5sZXQgU2VyaWVzRGVmYXVsdHNOb3Rlc0xhYmVsQ29tcG9uZW50ID0gY2xhc3MgU2VyaWVzRGVmYXVsdHNOb3Rlc0xhYmVsQ29tcG9uZW50IGV4dGVuZHMgU2VyaWVzRGVmYXVsdHNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcblNlcmllc0RlZmF1bHRzTm90ZXNMYWJlbENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXNlcmllcy1kZWZhdWx0cy1ub3Rlcy1sYWJlbCcsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgU2VyaWVzRGVmYXVsdHNOb3Rlc0xhYmVsQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFNlcmllc0RlZmF1bHRzVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignc2VyaWVzRGVmYXVsdHMudG9vbHRpcCcsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0RlZmF1bHRzVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYmFja2dyb3VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzRGVmYXVsdHNUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJib3JkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0RlZmF1bHRzVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0RlZmF1bHRzVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9udFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzRGVmYXVsdHNUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmb3JtYXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0RlZmF1bHRzVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFNlcmllc0RlZmF1bHRzVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgb2YgdGhlIENoYXJ0IHNlcmllcyB0b29sdGlwLlxuICovXG5sZXQgU2VyaWVzRGVmYXVsdHNUb29sdGlwQ29tcG9uZW50ID0gY2xhc3MgU2VyaWVzRGVmYXVsdHNUb29sdGlwQ29tcG9uZW50IGV4dGVuZHMgU2VyaWVzRGVmYXVsdHNUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlLlxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLm1hcmtBc1Zpc2libGUoKTtcbiAgICB9XG59O1xuU2VyaWVzRGVmYXVsdHNUb29sdGlwQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtc2VyaWVzLWRlZmF1bHRzLXRvb2x0aXAnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIFNlcmllc0RlZmF1bHRzVG9vbHRpcENvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBTZXJpZXNFcnJvckJhcnNDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ2Vycm9yQmFycycsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0Vycm9yQmFyc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBTZXJpZXNFcnJvckJhcnNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImVuZENhcHNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0Vycm9yQmFyc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibGluZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzRXJyb3JCYXJzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBTZXJpZXNFcnJvckJhcnNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc3VhbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzRXJyb3JCYXJzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ4VmFsdWVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0Vycm9yQmFyc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwieVZhbHVlXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIGVycm9yIGJhcnMgb2YgdGhlIENoYXJ0IHNlcmllc1xuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBlcnJvcmJhcnNfY2hhcnRfY2hhcnRzICV9KSkuXG4gKi9cbmxldCBTZXJpZXNFcnJvckJhcnNDb21wb25lbnQgPSBjbGFzcyBTZXJpZXNFcnJvckJhcnNDb21wb25lbnQgZXh0ZW5kcyBTZXJpZXNFcnJvckJhcnNDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuU2VyaWVzRXJyb3JCYXJzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0tZXJyb3ItYmFycycsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgU2VyaWVzRXJyb3JCYXJzQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFNlcmllc0V4dHJlbWVzQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCdleHRyZW1lcycsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0V4dHJlbWVzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNFeHRyZW1lc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBTZXJpZXNFeHRyZW1lc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicm90YXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFNlcmllc0V4dHJlbWVzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJzaXplXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNFeHRyZW1lc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidHlwZVwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBDaGFydCBzZXJpZXMgZXh0cmVtZXMuXG4gKiBBcHBsaWVzIHRvIGV4dHJlbWUgb3V0bGllcnMuXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gW2BzZXJpZXMub3V0bGllcnNgXSh7JSBzbHVnIGFwaV9jaGFydHNfc2VyaWVzaXRlbWNvbXBvbmVudCAlfSN0b2Mtb3V0bGllcnMpLlxuICovXG5sZXQgU2VyaWVzRXh0cmVtZXNDb21wb25lbnQgPSBjbGFzcyBTZXJpZXNFeHRyZW1lc0NvbXBvbmVudCBleHRlbmRzIFNlcmllc0V4dHJlbWVzQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcblNlcmllc0V4dHJlbWVzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0tZXh0cmVtZXMnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIFNlcmllc0V4dHJlbWVzQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFNlcmllc0hpZ2hsaWdodENvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignaGlnaGxpZ2h0JywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzSGlnaGxpZ2h0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJib3JkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0hpZ2hsaWdodENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0hpZ2hsaWdodENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibGluZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzSGlnaGxpZ2h0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtYXJrZXJzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBTZXJpZXNIaWdobGlnaHRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm9wYWNpdHlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgU2VyaWVzSGlnaGxpZ2h0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0b2dnbGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBTZXJpZXNIaWdobGlnaHRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc2libGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgU2VyaWVzSGlnaGxpZ2h0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXN1YWxcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgQ2hhcnQgc2VyaWVzIGhpZ2hsaWdodGluZyBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gKi9cbmxldCBTZXJpZXNIaWdobGlnaHRDb21wb25lbnQgPSBjbGFzcyBTZXJpZXNIaWdobGlnaHRDb21wb25lbnQgZXh0ZW5kcyBTZXJpZXNIaWdobGlnaHRDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5TZXJpZXNIaWdobGlnaHRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1zZXJpZXMtaXRlbS1oaWdobGlnaHQnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIFNlcmllc0hpZ2hsaWdodENvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBTZXJpZXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ2xhYmVscycsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYWxpZ25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYmFja2dyb3VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJib3JkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgU2VyaWVzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjb250ZW50XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBTZXJpZXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImRpc3RhbmNlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1hcmdpblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwYWRkaW5nXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBTZXJpZXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInJvdGF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgU2VyaWVzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFNlcmllc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzdWFsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZyb21cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidG9cIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBvZiB0aGUgQ2hhcnQgc2VyaWVzIGxhYmVsXG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGxhYmVsc19jaGFydF9jaGFydHMgJX0pKS5cbiAqL1xubGV0IFNlcmllc0xhYmVsc0NvbXBvbmVudCA9IGNsYXNzIFNlcmllc0xhYmVsc0NvbXBvbmVudCBleHRlbmRzIFNlcmllc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLm1hcmtBc1Zpc2libGUoKTtcbiAgICB9XG59O1xuU2VyaWVzTGFiZWxzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0tbGFiZWxzJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBTZXJpZXNMYWJlbHNDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU2VyaWVzTGFiZWxzRnJvbUNvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignbGFiZWxzLmZyb20nLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNMYWJlbHNGcm9tQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNMYWJlbHNGcm9tQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJib3JkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0xhYmVsc0Zyb21Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFNlcmllc0xhYmVsc0Zyb21Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbnRlbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0xhYmVsc0Zyb21Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0xhYmVsc0Zyb21Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvcm1hdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzTGFiZWxzRnJvbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWFyZ2luXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNMYWJlbHNGcm9tQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwYWRkaW5nXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNMYWJlbHNGcm9tQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFNlcmllc0xhYmVsc0Zyb21Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc2libGVcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgYGZyb21gIGxhYmVsIGNvbmZpZ3VyYXRpb24gb2YgdGhlIENoYXJ0IHNlcmllcy5cbiAqL1xubGV0IFNlcmllc0xhYmVsc0Zyb21Db21wb25lbnQgPSBjbGFzcyBTZXJpZXNMYWJlbHNGcm9tQ29tcG9uZW50IGV4dGVuZHMgU2VyaWVzTGFiZWxzRnJvbUNvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLm1hcmtBc1Zpc2libGUoKTtcbiAgICB9XG59O1xuU2VyaWVzTGFiZWxzRnJvbUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXNlcmllcy1pdGVtLWxhYmVscy1mcm9tJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBTZXJpZXNMYWJlbHNGcm9tQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFNlcmllc0xhYmVsc1RvQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCdsYWJlbHMudG8nLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNMYWJlbHNUb0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYmFja2dyb3VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzTGFiZWxzVG9Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzTGFiZWxzVG9Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFNlcmllc0xhYmVsc1RvQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjb250ZW50XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNMYWJlbHNUb0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9udFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzTGFiZWxzVG9Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvcm1hdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzTGFiZWxzVG9Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1hcmdpblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzTGFiZWxzVG9Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBhZGRpbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0xhYmVsc1RvQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFNlcmllc0xhYmVsc1RvQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIGB0b2AgbGFiZWwgY29uZmlndXJhdGlvbiBvZiB0aGUgQ2hhcnQgc2VyaWVzLlxuICovXG5sZXQgU2VyaWVzTGFiZWxzVG9Db21wb25lbnQgPSBjbGFzcyBTZXJpZXNMYWJlbHNUb0NvbXBvbmVudCBleHRlbmRzIFNlcmllc0xhYmVsc1RvQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMubWFya0FzVmlzaWJsZSgpO1xuICAgIH1cbn07XG5TZXJpZXNMYWJlbHNUb0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXNlcmllcy1pdGVtLWxhYmVscy10bycsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgU2VyaWVzTGFiZWxzVG9Db21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU2VyaWVzTWFya2Vyc0NvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignbWFya2VycycsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc01hcmtlcnNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc01hcmtlcnNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU2VyaWVzTWFya2Vyc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicm90YXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFNlcmllc01hcmtlcnNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInNpemVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc01hcmtlcnNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInR5cGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBTZXJpZXNNYXJrZXJzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFNlcmllc01hcmtlcnNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc3VhbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzTWFya2Vyc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZnJvbVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzTWFya2Vyc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidG9cIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBvZiB0aGUgQ2hhcnQgc2VyaWVzIG1hcmtlci5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICpcbiAqIF9AQ29tcG9uZW50KHtcbiAqICAgICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgdGVtcGxhdGU6IGBcbiAqICAgICAgIDxrZW5kby1jaGFydCBbY2F0ZWdvcnlBeGlzXT1cInsgY2F0ZWdvcmllczogY2F0ZWdvcmllcyB9XCI+XG4gKiAgICAgICAgICAgPGtlbmRvLWNoYXJ0LXRpdGxlIHRleHQ9XCJHcm9zcyBkb21lc3RpYyBwcm9kdWN0IGdyb3d0aCAvR0RQIGFubnVhbCAlL1wiPjwva2VuZG8tY2hhcnQtdGl0bGU+XG4gKiAgICAgICAgICAgPGtlbmRvLWNoYXJ0LWxlZ2VuZCBwb3NpdGlvbj1cImJvdHRvbVwiIG9yaWVudGF0aW9uPVwiaG9yaXpvbnRhbFwiPjwva2VuZG8tY2hhcnQtbGVnZW5kPlxuICogICAgICAgICAgIDxrZW5kby1jaGFydC10b29sdGlwIGZvcm1hdD1cInswfSVcIj48L2tlbmRvLWNoYXJ0LXRvb2x0aXA+XG4gKiAgICAgICAgICAgPGtlbmRvLWNoYXJ0LXNlcmllcz5cbiAqICAgICAgICAgICAgICAgPGtlbmRvLWNoYXJ0LXNlcmllcy1pdGVtICpuZ0Zvcj1cImxldCBpdGVtIG9mIHNlcmllc1wiXG4gKiAgICAgICAgICAgICAgICAgICB0eXBlPVwibGluZVwiXG4gKiAgICAgICAgICAgICAgICAgICBzdHlsZT1cInNtb290aFwiXG4gKiAgICAgICAgICAgICAgICAgICBbZGF0YV09XCJpdGVtLmRhdGFcIlxuICogICAgICAgICAgICAgICAgICAgW25hbWVdPVwiaXRlbS5uYW1lXCJcbiAqICAgICAgICAgICAgICAgICAgIFttYXJrZXJzXT1cIml0ZW0ubWFya2Vyc1wiPlxuICogICAgICAgICAgICAgICA8L2tlbmRvLWNoYXJ0LXNlcmllcy1pdGVtPlxuICogICAgICAgICAgIDwva2VuZG8tY2hhcnQtc2VyaWVzPlxuICogICAgICAgPC9rZW5kby1jaGFydD5cbiAqICAgYFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQge1xuICogcHVibGljIHNlcmllczogYW55W10gPSBbe1xuICogICBuYW1lOiBcIkluZGlhXCIsXG4gKiAgIGRhdGE6IFszLjkwNywgNy45NDMsIDcuODQ4LCA5LjI4NCwgOS4yNjMsIDkuODAxLCAzLjg5MCwgOC4yMzgsIDkuNTUyLCA2Ljg1NV0sXG4gKiAgIG1hcmtlcnM6IHtcbiAqICAgICBiYWNrZ3JvdW5kOiAncmVkJyxcbiAqICAgICBzaXplOiAyMCxcbiAqICAgICB0eXBlOiAnY2lyY2xlJ1xuICogICB9XG4gKiB9LCB7XG4gKiAgIG5hbWU6IFwiUnVzc2lhbiBGZWRlcmF0aW9uXCIsXG4gKiAgIGRhdGE6IFs0Ljc0MywgNy4yOTUsIDcuMTc1LCA2LjM3NiwgOC4xNTMsIDguNTM1LCA1LjI0NywgLTcuODMyLCA0LjMsIDQuM10sXG4gKiAgIG1hcmtlcnM6IHtcbiAqICAgICBiYWNrZ3JvdW5kOiAneWVsbG93JyxcbiAqICAgICBzaXplOiAxMCxcbiAqICAgICB0eXBlOiAnc3F1YXJlJyxcbiAqICAgICByb3RhdGlvbjogNDVcbiAqICAgfVxuICogfSwge1xuICogICBuYW1lOiBcIkdlcm1hbnlcIixcbiAqICAgZGF0YTogWzAuMDEwLCAtMC4zNzUsIDEuMTYxLCAwLjY4NCwgMy43LCAzLjI2OSwgMS4wODMsIC01LjEyNywgMy42OTAsIDIuOTk1XSxcbiAqICAgbWFya2Vyczoge1xuICogICAgIGJhY2tncm91bmQ6ICdncmVlbicsXG4gKiAgICAgc2l6ZTogMjAsXG4gKiAgICAgdHlwZTogJ3RyaWFuZ2xlJ1xuICogICB9XG4gKiB9LHtcbiAqICAgbmFtZTogXCJXb3JsZFwiLFxuICogICBkYXRhOiBbMS45ODgsIDIuNzMzLCAzLjk5NCwgMy40NjQsIDQuMDAxLCAzLjkzOSwgMS4zMzMsIC0yLjI0NSwgNC4zMzksIDIuNzI3XSxcbiAqICAgbWFya2Vyczoge1xuICogICAgIGJhY2tncm91bmQ6ICdibHVlJyxcbiAqICAgICBzaXplOiAxMCxcbiAqICAgICB0eXBlOiAnY3Jvc3MnXG4gKiAgIH1cbiAqIH1dO1xuICogcHVibGljIGNhdGVnb3JpZXM6IG51bWJlcltdID0gWzIwMDIsIDIwMDMsIDIwMDQsIDIwMDUsIDIwMDYsIDIwMDcsIDIwMDgsIDIwMDksIDIwMTAsIDIwMTFdO1xuICogfVxuICogYGBgXG4gKi9cbmxldCBTZXJpZXNNYXJrZXJzQ29tcG9uZW50ID0gY2xhc3MgU2VyaWVzTWFya2Vyc0NvbXBvbmVudCBleHRlbmRzIFNlcmllc01hcmtlcnNDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuU2VyaWVzTWFya2Vyc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXNlcmllcy1pdGVtLW1hcmtlcnMnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIFNlcmllc01hcmtlcnNDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU2VyaWVzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ25vdGVzJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImxpbmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc05vdGVzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBTZXJpZXNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzdWFsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiaWNvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImxhYmVsXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIHNlcmllcyBub3RlcyBjb25maWd1cmF0aW9uXG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIG5vdGVzX2NoYXJ0X2NoYXJ0cyAlfSkpLlxuICovXG5sZXQgU2VyaWVzTm90ZXNDb21wb25lbnQgPSBjbGFzcyBTZXJpZXNOb3Rlc0NvbXBvbmVudCBleHRlbmRzIFNlcmllc05vdGVzQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcblNlcmllc05vdGVzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0tbm90ZXMnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIFNlcmllc05vdGVzQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFNlcmllc05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignbm90ZXMuaWNvbicsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYmFja2dyb3VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzTm90ZXNJY29uQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJib3JkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFNlcmllc05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwic2l6ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzTm90ZXNJY29uQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0eXBlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgU2VyaWVzTm90ZXNJY29uQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIGljb24gb2YgdGhlIG5vdGVzLlxuICovXG5sZXQgU2VyaWVzTm90ZXNJY29uQ29tcG9uZW50ID0gY2xhc3MgU2VyaWVzTm90ZXNJY29uQ29tcG9uZW50IGV4dGVuZHMgU2VyaWVzTm90ZXNJY29uQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcblNlcmllc05vdGVzSWNvbkNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXNlcmllcy1pdGVtLW5vdGVzLWljb24nLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIFNlcmllc05vdGVzSWNvbkNvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBTZXJpZXNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCdub3Rlcy5sYWJlbCcsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgU2VyaWVzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29udGVudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9udFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU2VyaWVzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicm90YXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBTZXJpZXNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIGxhYmVsIG9mIHRoZSBub3Rlcy5cbiAqL1xubGV0IFNlcmllc05vdGVzTGFiZWxDb21wb25lbnQgPSBjbGFzcyBTZXJpZXNOb3Rlc0xhYmVsQ29tcG9uZW50IGV4dGVuZHMgU2VyaWVzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5TZXJpZXNOb3Rlc0xhYmVsQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0tbm90ZXMtbGFiZWwnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIFNlcmllc05vdGVzTGFiZWxDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU2VyaWVzT3V0bGllcnNDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ291dGxpZXJzJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzT3V0bGllcnNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc091dGxpZXJzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJib3JkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFNlcmllc091dGxpZXJzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJyb3RhdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU2VyaWVzT3V0bGllcnNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInNpemVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc091dGxpZXJzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0eXBlXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIENoYXJ0IHNlcmllcyBvdXRsaWVycy5cbiAqIEFwcGxpZXMgdG8gbWlsZCBvdXRsaWVycy5cbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWZlciB0byB0aGUgW2BzZXJpZXMuZXh0cmVtZXNgXSh7JSBzbHVnIGFwaV9jaGFydHNfc2VyaWVzaXRlbWNvbXBvbmVudCAlfSN0b2MtZXh0cmVtZXMpIG9wdGlvbi5cbiAqL1xubGV0IFNlcmllc091dGxpZXJzQ29tcG9uZW50ID0gY2xhc3MgU2VyaWVzT3V0bGllcnNDb21wb25lbnQgZXh0ZW5kcyBTZXJpZXNPdXRsaWVyc0NvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5TZXJpZXNPdXRsaWVyc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXNlcmllcy1pdGVtLW91dGxpZXJzJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBTZXJpZXNPdXRsaWVyc0NvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBUaXRsZUNvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcigndGl0bGUnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYWxpZ25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmb250XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWFyZ2luXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidGV4dFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBvZiB0aGUgQ2hhcnQgdGl0bGUgb3IgdGV4dFxuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyB0aXRsZV9jaGFydF9jaGFydHMgJX0pKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMtcHJldmlld1xuICogaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKlxuICogX0BDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICA8a2VuZG8tY2hhcnQgW2NhdGVnb3J5QXhpc109XCJ7IGNhdGVnb3JpZXM6IGNhdGVnb3JpZXMgfVwiPlxuICogICAgICAgICAgICA8a2VuZG8tY2hhcnQtdGl0bGUgdGV4dD1cIkdyb3NzIGRvbWVzdGljIHByb2R1Y3QgZ3Jvd3RoIC9HRFAgYW5udWFsICUvXCI+PC9rZW5kby1jaGFydC10aXRsZT5cbiAqICAgICAgICAgICAgPGtlbmRvLWNoYXJ0LWxlZ2VuZFxuICogICAgICAgICAgICAgIHBvc2l0aW9uPVwiYm90dG9tXCJcbiAqICAgICAgICAgICAgICBvcmllbnRhdGlvbj1cImhvcml6b250YWxcIlxuICogICAgICAgICAgICAgIGFsaWduPVwiZW5kXCJcbiAqICAgICAgICAgICAgICBiYWNrZ3JvdW5kPVwicmdiYSgyNTUsIDAsIDAsIDAuMSlcIlxuICogICAgICAgICAgICAgIFtib3JkZXJdPVwiYm9yZGVyT3B0aW9uc1wiXG4gKiAgICAgICAgICAgICAgW21hcmdpbl09XCIxMFwiXG4gKiAgICAgICAgICAgICAgW3BhZGRpbmddPVwiMTBcIlxuICogICAgICAgICAgICAgIFt3aWR0aF09XCIxNTBcIlxuICogICAgICAgICAgICAgIFtvZmZzZXRYXT1cIjExXCJcbiAqICAgICAgICAgICAgICBbb2Zmc2V0WV09XCItMTAzXCJcbiAqICAgICAgICAgICAgICBbcmV2ZXJzZV09XCJ0cnVlXCJcbiAqICAgICAgICAgICAgICBbdmlzaWJsZV09XCJpc1Zpc2libGVcIlxuICogICAgICAgICAgICAgID48L2tlbmRvLWNoYXJ0LWxlZ2VuZD5cbiAqICAgICAgICAgICAgPGtlbmRvLWNoYXJ0LXRvb2x0aXAgZm9ybWF0PVwiezB9JVwiPjwva2VuZG8tY2hhcnQtdG9vbHRpcD5cbiAqICAgICAgICAgICAgPGtlbmRvLWNoYXJ0LXNlcmllcz5cbiAqICAgICAgICAgICAgICAgIDxrZW5kby1jaGFydC1zZXJpZXMtaXRlbSAqbmdGb3I9XCJsZXQgaXRlbSBvZiBzZXJpZXNcIlxuICogICAgICAgICAgICAgICAgICAgIHR5cGU9XCJsaW5lXCIgc3R5bGU9XCJzbW9vdGhcIiBbZGF0YV09XCJpdGVtLmRhdGFcIiBbbmFtZV09XCJpdGVtLm5hbWVcIj5cbiAqICAgICAgICAgICAgICAgIDwva2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0+XG4gKiAgICAgICAgICAgIDwva2VuZG8tY2hhcnQtc2VyaWVzPlxuICogICAgICAgIDwva2VuZG8tY2hhcnQ+XG4gKiAgICAgICAgPGJyIC8+PGJyIC8+XG4gKiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImstYnV0dG9uXCIgKGNsaWNrKT1cImlzVmlzaWJsZT0haXNWaXNpYmxlXCI+VG9nZ2xlIExlZ2VuZDwvYnV0dG9uPlxuICogICAgYFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQge1xuICogIHB1YmxpYyBpc1Zpc2libGUgPSB0cnVlO1xuICogIHB1YmxpYyBib3JkZXJPcHRpb25zID0ge1xuICogICAgY29sb3I6IFwicmdiYSgyNTUsIDAsIDAsIDAuOClcIixcbiAqICAgIGRhc2hUeXBlOiAnZGFzaCcsXG4gKiAgICB3aWR0aDogMlxuICogIH07XG4gKlxuICogcHVibGljIHNlcmllczogYW55W10gPSBbe1xuICogICBuYW1lOiBcIkluZGlhXCIsXG4gKiAgIGRhdGE6IFszLjkwNywgNy45NDMsIDcuODQ4LCA5LjI4NCwgOS4yNjMsIDkuODAxLCAzLjg5MCwgOC4yMzgsIDkuNTUyLCA2Ljg1NV1cbiAqIH0sIHtcbiAqICAgbmFtZTogXCJSdXNzaWFuIEZlZGVyYXRpb25cIixcbiAqICAgZGF0YTogWzQuNzQzLCA3LjI5NSwgNy4xNzUsIDYuMzc2LCA4LjE1MywgOC41MzUsIDUuMjQ3LCAtNy44MzIsIDQuMywgNC4zXVxuICogfSwge1xuICogICBuYW1lOiBcIkdlcm1hbnlcIixcbiAqICAgZGF0YTogWzAuMDEwLCAtMC4zNzUsIDEuMTYxLCAwLjY4NCwgMy43LCAzLjI2OSwgMS4wODMsIC01LjEyNywgMy42OTAsIDIuOTk1XVxuICogfSx7XG4gKiAgIG5hbWU6IFwiV29ybGRcIixcbiAqICAgZGF0YTogWzEuOTg4LCAyLjczMywgMy45OTQsIDMuNDY0LCA0LjAwMSwgMy45MzksIDEuMzMzLCAtMi4yNDUsIDQuMzM5LCAyLjcyN11cbiAqIH1dO1xuICogIHB1YmxpYyBjYXRlZ29yaWVzOiBudW1iZXJbXSA9IFsyMDAyLCAyMDAzLCAyMDA0LCAyMDA1LCAyMDA2LCAyMDA3LCAyMDA4LCAyMDA5LCAyMDEwLCAyMDExXTtcbiAqIH1cbiAqIGBgYFxuICovXG5sZXQgVGl0bGVDb21wb25lbnQgPSBjbGFzcyBUaXRsZUNvbXBvbmVudCBleHRlbmRzIFRpdGxlQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcblRpdGxlQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtdGl0bGUnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIFRpdGxlQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ3Rvb2x0aXAnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJib3JkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmb250XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmb3JtYXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm9wYWNpdHlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBhZGRpbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJzaGFyZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBvZiB0aGUgQ2hhcnQgc2VyaWVzIHRvb2x0aXBcbiAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgdG9vbHRpcHNfY2hhcnRfY2hhcnRzICV9KSkuXG4gKi9cbmxldCBUb29sdGlwQ29tcG9uZW50ID0gY2xhc3MgVG9vbHRpcENvbXBvbmVudCBleHRlbmRzIFRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCB0ZW1wbGF0ZVNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMudGVtcGxhdGVTZXJ2aWNlID0gdGVtcGxhdGVTZXJ2aWNlO1xuICAgICAgICB0aGlzLm1hcmtBc1Zpc2libGUoKTtcbiAgICB9XG4gICAgbmdBZnRlckNvbnRlbnRDaGVja2VkKCkge1xuICAgICAgICB0aGlzLnRlbXBsYXRlU2VydmljZS5zZXRUZW1wbGF0ZSh0aGlzLnNlcmllc1Rvb2x0aXBUZW1wbGF0ZSA/IHRoaXMuc2VyaWVzVG9vbHRpcFRlbXBsYXRlLnRlbXBsYXRlUmVmIDogbnVsbCk7XG4gICAgICAgIHRoaXMudGVtcGxhdGVTZXJ2aWNlLnNldFNoYXJlZFRlbXBsYXRlKHRoaXMuc2hhcmVkVG9vbHRpcFRlbXBsYXRlID8gdGhpcy5zaGFyZWRUb29sdGlwVGVtcGxhdGUudGVtcGxhdGVSZWYgOiBudWxsKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKFNlcmllc1Rvb2x0aXBUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTZXJpZXNUb29sdGlwVGVtcGxhdGVEaXJlY3RpdmUpXG5dLCBUb29sdGlwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZXJpZXNUb29sdGlwVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChTaGFyZWRUb29sdGlwVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU2hhcmVkVG9vbHRpcFRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgVG9vbHRpcENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hhcmVkVG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5Ub29sdGlwQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC10b29sdGlwJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZSxcbiAgICAgICAgVG9vbHRpcFRlbXBsYXRlU2VydmljZV0pXG5dLCBUb29sdGlwQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFZhbHVlQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBDb2xsZWN0aW9uSXRlbUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uU2VydmljZSA9IGNvbGxlY3Rpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFZhbHVlQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImF4aXNDcm9zc2luZ1ZhbHVlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBWYWx1ZUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBWYWx1ZUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVmFsdWVBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibGluZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVmFsdWVBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWFqb3JHcmlkTGluZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFZhbHVlQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1ham9yVGlja3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFZhbHVlQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1ham9yVW5pdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVmFsdWVBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWF4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBWYWx1ZUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFZhbHVlQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1pbm9yR3JpZExpbmVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBWYWx1ZUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtaW5vclRpY2tzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBWYWx1ZUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtaW5vclVuaXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFZhbHVlQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm5hbWVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBWYWx1ZUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJuYXJyb3dSYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVmFsdWVBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicGFuZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBWYWx1ZUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwbG90QmFuZHNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBWYWx1ZUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJyZXZlcnNlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBWYWx1ZUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0eXBlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVmFsdWVBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVmFsdWVBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY3Jvc3NoYWlyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBWYWx1ZUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJsYWJlbHNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFZhbHVlQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm5vdGVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBWYWx1ZUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0aXRsZVwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIGNvbXBvbmVudCBmb3IgYSB2YWx1ZSBheGlzLlxuICovXG5sZXQgVmFsdWVBeGlzSXRlbUNvbXBvbmVudCA9IGNsYXNzIFZhbHVlQXhpc0l0ZW1Db21wb25lbnQgZXh0ZW5kcyBWYWx1ZUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uU2VydmljZSA9IGNvbGxlY3Rpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5WYWx1ZUF4aXNJdGVtQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHByb3ZpZGVyczogW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC12YWx1ZS1heGlzLWl0ZW0nLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlLFxuICAgICAgICBDb2xsZWN0aW9uU2VydmljZV0pXG5dLCBWYWx1ZUF4aXNJdGVtQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFZhbHVlQXhpc0NvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIENvbGxlY3Rpb25Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcigndmFsdWVBeGlzJywgY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25TZXJ2aWNlID0gY29sbGVjdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkcmVuKFZhbHVlQXhpc0l0ZW1Db21wb25lbnQpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBRdWVyeUxpc3QpXG5dLCBWYWx1ZUF4aXNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNoaWxkcmVuXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIG9uZSBvciBtb3JlIHZhbHVlIGF4aXMgY29uZmlndXJhdGlvbiBjb21wb25lbnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKlxuICogX0BDb21wb25lbnQoe1xuICogICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgIHRlbXBsYXRlOiBgXG4gKiAgICAgPGtlbmRvLWNoYXJ0PlxuICogICAgICAgPGtlbmRvLWNoYXJ0LXZhbHVlLWF4aXM+XG4gKiAgICAgICAgIDxrZW5kby1jaGFydC12YWx1ZS1heGlzLWl0ZW0+XG4gKiAgICAgICAgIDwva2VuZG8tY2hhcnQtdmFsdWUtYXhpcy1pdGVtPlxuICogICAgICAgICA8a2VuZG8tY2hhcnQtdmFsdWUtYXhpcy1pdGVtIG5hbWU9XCJzZWNvbmRBeGlzXCI+XG4gKiAgICAgICAgIDwva2VuZG8tY2hhcnQtdmFsdWUtYXhpcy1pdGVtPlxuICogICAgICAgPC9rZW5kby1jaGFydC12YWx1ZS1heGlzPlxuICogICAgICAgPGtlbmRvLWNoYXJ0LXNlcmllcz5cbiAqICAgICAgICAgPGtlbmRvLWNoYXJ0LXNlcmllcy1pdGVtIHR5cGU9XCJsaW5lXCIgW2RhdGFdPVwiWzEsIDIsIDNdXCI+XG4gKiAgICAgICAgIDwva2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0+XG4gKiAgICAgICAgIDxrZW5kby1jaGFydC1zZXJpZXMtaXRlbSB0eXBlPVwibGluZVwiIFtkYXRhXT1cIlswLjEsIDAuMiwgMC4zXVwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzPVwic2Vjb25kQXhpc1wiPlxuICogICAgICAgICA8L2tlbmRvLWNoYXJ0LXNlcmllcy1pdGVtPlxuICogICAgICAgPC9rZW5kby1jaGFydC1zZXJpZXM+XG4gKiAgICAgPC9rZW5kby1jaGFydD5cbiAqICAgYFxuICogfSlcbiAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiB9XG4gKlxuICogYGBgXG4gKi9cbmxldCBWYWx1ZUF4aXNDb21wb25lbnQgPSBjbGFzcyBWYWx1ZUF4aXNDb21wb25lbnQgZXh0ZW5kcyBWYWx1ZUF4aXNDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25TZXJ2aWNlID0gY29sbGVjdGlvblNlcnZpY2U7XG4gICAgfVxufTtcblZhbHVlQXhpc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBwcm92aWRlcnM6IFtDb2xsZWN0aW9uU2VydmljZV0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtdmFsdWUtYXhpcycsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2UsXG4gICAgICAgIENvbGxlY3Rpb25TZXJ2aWNlXSlcbl0sIFZhbHVlQXhpc0NvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBWYWx1ZUF4aXNDcm9zc2hhaXJDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ2Nyb3NzaGFpcicsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFZhbHVlQXhpc0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFZhbHVlQXhpc0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwib3BhY2l0eVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFZhbHVlQXhpc0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgVmFsdWVBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ3aWR0aFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVmFsdWVBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0b29sdGlwXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIGNyb3NzaGFpciBjb25maWd1cmF0aW9uIG9wdGlvbnMgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBjcm9zc2hhaXJzX2NoYXJ0X2NoYXJ0cyAlfSkpLlxuICovXG5sZXQgVmFsdWVBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50ID0gY2xhc3MgVmFsdWVBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50IGV4dGVuZHMgVmFsdWVBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMubWFya0FzVmlzaWJsZSgpO1xuICAgIH1cbn07XG5WYWx1ZUF4aXNDcm9zc2hhaXJDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC12YWx1ZS1heGlzLWl0ZW0tY3Jvc3NoYWlyJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBWYWx1ZUF4aXNDcm9zc2hhaXJDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgVmFsdWVBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignY3Jvc3NoYWlyLnRvb2x0aXAnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBWYWx1ZUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBWYWx1ZUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJib3JkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFZhbHVlQXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBWYWx1ZUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmb250XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBWYWx1ZUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmb3JtYXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFZhbHVlQXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBhZGRpbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBWYWx1ZUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBvZiB0aGUgY3Jvc3NoYWlyIHRvb2x0aXAgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBjcm9zc2hhaXJzX2NoYXJ0X2NoYXJ0cyAlfSkpLlxuICogVGhlIGNyb3NzaGFpciB0b29sdGlwIGlzIGRpc3BsYXllZCB3aGVuIHRoZSBgdmlzaWJsZWAgb3B0aW9uIGlzIHNldCB0byBgdHJ1ZWAuXG4gKi9cbmxldCBWYWx1ZUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50ID0gY2xhc3MgVmFsdWVBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudCBleHRlbmRzIFZhbHVlQXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmUuXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMubWFya0FzVmlzaWJsZSgpO1xuICAgIH1cbn07XG5WYWx1ZUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtdmFsdWUtYXhpcy1pdGVtLWNyb3NzaGFpci10b29sdGlwJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBWYWx1ZUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFZhbHVlQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignbGFiZWxzJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVmFsdWVBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBWYWx1ZUF4aXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVmFsdWVBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBWYWx1ZUF4aXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbnRlbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFZhbHVlQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9udFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVmFsdWVBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmb3JtYXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFZhbHVlQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWFyZ2luXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVmFsdWVBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtaXJyb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFZhbHVlQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVmFsdWVBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVmFsdWVBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJyb3RhdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgVmFsdWVBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJza2lwXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBWYWx1ZUF4aXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInN0ZXBcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBWYWx1ZUF4aXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc2libGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgVmFsdWVBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXN1YWxcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgYXhpcyBsYWJlbHMgY29uZmlndXJhdGlvbi5cbiAqL1xubGV0IFZhbHVlQXhpc0xhYmVsc0NvbXBvbmVudCA9IGNsYXNzIFZhbHVlQXhpc0xhYmVsc0NvbXBvbmVudCBleHRlbmRzIFZhbHVlQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5WYWx1ZUF4aXNMYWJlbHNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC12YWx1ZS1heGlzLWl0ZW0tbGFiZWxzJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBWYWx1ZUF4aXNMYWJlbHNDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgVmFsdWVBeGlzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ25vdGVzJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBWYWx1ZUF4aXNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVmFsdWVBeGlzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImxpbmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFZhbHVlQXhpc05vdGVzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBWYWx1ZUF4aXNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzdWFsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBWYWx1ZUF4aXNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiaWNvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVmFsdWVBeGlzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImxhYmVsXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIHZhbHVlIGF4aXMgbm90ZXMgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBub3Rlc19jaGFydF9jaGFydHMgJX0jdG9jLWF4aXMtbm90ZXMpKS5cbiAqL1xubGV0IFZhbHVlQXhpc05vdGVzQ29tcG9uZW50ID0gY2xhc3MgVmFsdWVBeGlzTm90ZXNDb21wb25lbnQgZXh0ZW5kcyBWYWx1ZUF4aXNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5WYWx1ZUF4aXNOb3Rlc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXZhbHVlLWF4aXMtaXRlbS1ub3RlcycsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgVmFsdWVBeGlzTm90ZXNDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgVmFsdWVBeGlzTm90ZXNJY29uQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCdub3Rlcy5pY29uJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVmFsdWVBeGlzTm90ZXNJY29uQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBWYWx1ZUF4aXNOb3Rlc0ljb25Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgVmFsdWVBeGlzTm90ZXNJY29uQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJzaXplXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBWYWx1ZUF4aXNOb3Rlc0ljb25Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInR5cGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBWYWx1ZUF4aXNOb3Rlc0ljb25Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc2libGVcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgaWNvbiBvZiB0aGUgbm90ZXMuXG4gKi9cbmxldCBWYWx1ZUF4aXNOb3Rlc0ljb25Db21wb25lbnQgPSBjbGFzcyBWYWx1ZUF4aXNOb3Rlc0ljb25Db21wb25lbnQgZXh0ZW5kcyBWYWx1ZUF4aXNOb3Rlc0ljb25Db21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuVmFsdWVBeGlzTm90ZXNJY29uQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtdmFsdWUtYXhpcy1pdGVtLW5vdGVzLWljb24nLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIFZhbHVlQXhpc05vdGVzSWNvbkNvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBWYWx1ZUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCdub3Rlcy5sYWJlbCcsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFZhbHVlQXhpc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFZhbHVlQXhpc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVmFsdWVBeGlzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgVmFsdWVBeGlzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29udGVudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVmFsdWVBeGlzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9udFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVmFsdWVBeGlzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBWYWx1ZUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgVmFsdWVBeGlzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicm90YXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBWYWx1ZUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIGxhYmVsIG9mIHRoZSBub3Rlcy5cbiAqL1xubGV0IFZhbHVlQXhpc05vdGVzTGFiZWxDb21wb25lbnQgPSBjbGFzcyBWYWx1ZUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50IGV4dGVuZHMgVmFsdWVBeGlzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5WYWx1ZUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtdmFsdWUtYXhpcy1pdGVtLW5vdGVzLWxhYmVsJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBWYWx1ZUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFZhbHVlQXhpc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCd0aXRsZScsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFZhbHVlQXhpc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBWYWx1ZUF4aXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBWYWx1ZUF4aXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFZhbHVlQXhpc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmb250XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBWYWx1ZUF4aXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWFyZ2luXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBWYWx1ZUF4aXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVmFsdWVBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBWYWx1ZUF4aXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicm90YXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFZhbHVlQXhpc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0ZXh0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVmFsdWVBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc2libGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgVmFsdWVBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc3VhbFwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSB0aXRsZSBjb25maWd1cmF0aW9uIG9mIHRoZSB2YWx1ZSBheGlzLlxuICovXG5sZXQgVmFsdWVBeGlzVGl0bGVDb21wb25lbnQgPSBjbGFzcyBWYWx1ZUF4aXNUaXRsZUNvbXBvbmVudCBleHRlbmRzIFZhbHVlQXhpc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcblZhbHVlQXhpc1RpdGxlQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtdmFsdWUtYXhpcy1pdGVtLXRpdGxlJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBWYWx1ZUF4aXNUaXRsZUNvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBYQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBDb2xsZWN0aW9uSXRlbUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlLCBpbnRsLCBsb2NhbGVJZCkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvblNlcnZpY2UgPSBjb2xsZWN0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2VzKHsgd2Vla1N0YXJ0RGF5OiBpbnRsLmZpcnN0RGF5KGxvY2FsZUlkKSB9KTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBYQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImF4aXNDcm9zc2luZ1ZhbHVlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBYQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFhBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYmFzZVVuaXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFhBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFhBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibGluZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgWEF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtYWpvckdyaWRMaW5lc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgWEF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtYWpvclRpY2tzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBYQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1ham9yVW5pdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgWEF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtYXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFhBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBYQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1pbm9yR3JpZExpbmVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBYQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1pbm9yVGlja3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFhBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWlub3JVbml0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBYQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm5hbWVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBYQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm5hcnJvd1JhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBYQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBhbmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgWEF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwbG90QmFuZHNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBYQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInJldmVyc2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFhBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwic3RhcnRBbmdsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWEF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0eXBlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgWEF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBYQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIndlZWtTdGFydERheVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgWEF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjcm9zc2hhaXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFhBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibGFiZWxzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBYQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm5vdGVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBYQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInRpdGxlXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gY29tcG9uZW50IGZvciBhbiBYIGF4aXNcbiAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgYXBpX2NoYXJ0c194YXhpc2NvbXBvbmVudCAlfSkpLlxuICovXG5sZXQgWEF4aXNJdGVtQ29tcG9uZW50ID0gY2xhc3MgWEF4aXNJdGVtQ29tcG9uZW50IGV4dGVuZHMgWEF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlLCBpbnRsLCBsb2NhbGVJZCkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UsIGludGwsIGxvY2FsZUlkKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25TZXJ2aWNlID0gY29sbGVjdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuaW50bCA9IGludGw7XG4gICAgfVxufTtcblhBeGlzSXRlbUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBwcm92aWRlcnM6IFtDb25maWd1cmF0aW9uU2VydmljZV0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQteC1heGlzLWl0ZW0nLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX3BhcmFtKDMsIEluamVjdChMT0NBTEVfSUQpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlLFxuICAgICAgICBDb2xsZWN0aW9uU2VydmljZSxcbiAgICAgICAgSW50bFNlcnZpY2UsIFN0cmluZ10pXG5dLCBYQXhpc0l0ZW1Db21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgWEF4aXNDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBDb2xsZWN0aW9uQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ3hBeGlzJywgY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25TZXJ2aWNlID0gY29sbGVjdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkcmVuKFhBeGlzSXRlbUNvbXBvbmVudCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIFhBeGlzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjaGlsZHJlblwiLCB2b2lkIDApO1xuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBvbmUgb3IgbW9yZSBYLWF4aXMgY29uZmlndXJhdGlvbiBjb21wb25lbnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKlxuICogX0BDb21wb25lbnQoe1xuICogIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqIHRlbXBsYXRlOiBgXG4gKiAgIDxrZW5kby1jaGFydD5cbiAqICAgICA8a2VuZG8tY2hhcnQteC1heGlzPlxuICogICAgICAgPGtlbmRvLWNoYXJ0LXgtYXhpcy1pdGVtXG4gKiAgICAgICAgIFtiYWNrZ3JvdW5kXT1cIidyZ2JhKDEwMCwgMTAwLCAxMDAsIDAuMiknXCJcbiAqICAgICAgICAgW2NvbG9yXT1cIidyZWQnXCJcbiAqICAgICAgICAgW25vdGVzXT1cIm5vdGVzQ29uZmlnXCJcbiAqICAgICAgICAgW2Nyb3NzaGFpcl09XCJjcm9zc2hhaXJDb25maWdcIj5cbiAqICAgICAgIDwva2VuZG8tY2hhcnQteC1heGlzLWl0ZW0+XG4gKiAgICAgICA8a2VuZG8tY2hhcnQteC1heGlzLWl0ZW0gbmFtZT1cInNlY29uZEF4aXNcIj5cbiAqICAgICAgIDwva2VuZG8tY2hhcnQteC1heGlzLWl0ZW0+XG4gKiAgICAgPC9rZW5kby1jaGFydC14LWF4aXM+XG4gKiAgICAgPGtlbmRvLWNoYXJ0LXNlcmllcz5cbiAqICAgICAgIDxrZW5kby1jaGFydC1zZXJpZXMtaXRlbSB0eXBlPVwic2NhdHRlclwiIFtkYXRhXT1cIltbMSwgMl1dXCI+XG4gKiAgICAgICA8L2tlbmRvLWNoYXJ0LXNlcmllcy1pdGVtPlxuICogICAgICAgPGtlbmRvLWNoYXJ0LXNlcmllcy1pdGVtIHR5cGU9XCJzY2F0dGVyXCIgW2RhdGFdPVwiW1swLjEsIDAuMl1dXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4QXhpcz1cInNlY29uZEF4aXNcIj5cbiAqICAgICAgIDwva2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0+XG4gKiAgICAgPC9rZW5kby1jaGFydC1zZXJpZXM+XG4gKiAgIDwva2VuZG8tY2hhcnQ+XG4gKiBgXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiBwdWJsaWMgbm90ZXNDb25maWcgPSB7XG4gKiAgIGRhdGE6IFt7XG4gKiAgICAgICB2YWx1ZTogMC4yLFxuICogICAgICAgdGV4dDogXCJmb29cIlxuICogICAgIH0sIHtcbiAqICAgICAgIHZhbHVlOiAwLjgsXG4gKiAgICAgICB0ZXh0OiBcImJhclwiXG4gKiAgICAgfV0sXG4gKiAgIGxhYmVsOiB7XG4gKiAgICAgY29udGVudDogKGFyZ3M6IGFueSkgPT4gYXJncy5kYXRhSXRlbS50ZXh0LFxuICogICAgIGJhY2tncm91bmQ6ICdyZWQnLFxuICogICAgIGNvbG9yOiAnd2hpdGUnXG4gKiAgIH0sXG4gKiAgIGxpbmU6IHtcbiAqICAgICBjb2xvcjogJ2JsdWUnLFxuICogICAgIGRhc2hUeXBlOiAnZGFzaCcsXG4gKiAgICAgbGVuZ3RoOiAxNTAsXG4gKiAgICAgd2lkdGg6IDJcbiAqICAgfSxcbiAqICAgcG9zaXRpb246ICd0b3AnXG4gKiB9O1xuICpcbiAqIHB1YmxpYyBjcm9zc2hhaXJDb25maWcgPSB7XG4gKiAgIGNvbG9yOiAnZ3JlZW4nLFxuICogICBvcGFjaXR5OiAwLjgsXG4gKiAgIHZpc2libGU6IHRydWUsXG4gKiAgIHdpZHRoOiAzXG4gKiB9O1xuICogfVxuICpcbiAqIGBgYFxuICovXG5sZXQgWEF4aXNDb21wb25lbnQgPSBjbGFzcyBYQXhpc0NvbXBvbmVudCBleHRlbmRzIFhBeGlzQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uU2VydmljZSA9IGNvbGxlY3Rpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5YQXhpc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBwcm92aWRlcnM6IFtDb2xsZWN0aW9uU2VydmljZV0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQteC1heGlzJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZSxcbiAgICAgICAgQ29sbGVjdGlvblNlcnZpY2VdKVxuXSwgWEF4aXNDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgWEF4aXNDcm9zc2hhaXJDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ2Nyb3NzaGFpcicsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFhBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgWEF4aXNDcm9zc2hhaXJDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm9wYWNpdHlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBYQXhpc0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgWEF4aXNDcm9zc2hhaXJDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIndpZHRoXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBYQXhpc0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidG9vbHRpcFwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBjcm9zc2hhaXIgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGFwaV9jaGFydHNfeGF4aXNjb21wb25lbnQgJX0pKS5cbiAqL1xubGV0IFhBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50ID0gY2xhc3MgWEF4aXNDcm9zc2hhaXJDb21wb25lbnQgZXh0ZW5kcyBYQXhpc0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLm1hcmtBc1Zpc2libGUoKTtcbiAgICB9XG59O1xuWEF4aXNDcm9zc2hhaXJDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC14LWF4aXMtaXRlbS1jcm9zc2hhaXInLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIFhBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFhBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignY3Jvc3NoYWlyLnRvb2x0aXAnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBYQXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFhBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBYQXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBYQXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFhBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBYQXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBhZGRpbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBYQXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc2libGVcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIG9mIHRoZSBjcm9zc2hhaXIgdG9vbHRpcC5cbiAqIFRoZSBjcm9zc2hhaXIgdG9vbHRpcCBpcyBkaXNwbGF5ZWQgd2hlbiB0aGUgYHZpc2libGVgIG9wdGlvbiBpcyBzZXQgdG8gYHRydWVgLlxuICovXG5sZXQgWEF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50ID0gY2xhc3MgWEF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50IGV4dGVuZHMgWEF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlLlxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLm1hcmtBc1Zpc2libGUoKTtcbiAgICB9XG59O1xuWEF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQteC1heGlzLWl0ZW0tY3Jvc3NoYWlyLXRvb2x0aXAnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIFhBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBYQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignbGFiZWxzJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWEF4aXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFhBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJib3JkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFhBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBYQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29udGVudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWEF4aXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImN1bHR1cmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFhBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJkYXRlRm9ybWF0c1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWEF4aXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFhBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmb3JtYXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFhBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtYXJnaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBYQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWlycm9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBYQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWEF4aXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBYQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicm90YXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFhBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJza2lwXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBYQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwic3RlcFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFhBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFhBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXN1YWxcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgYXhpcyBsYWJlbHMgY29uZmlndXJhdGlvbi5cbiAqL1xubGV0IFhBeGlzTGFiZWxzQ29tcG9uZW50ID0gY2xhc3MgWEF4aXNMYWJlbHNDb21wb25lbnQgZXh0ZW5kcyBYQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5YQXhpc0xhYmVsc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXgtYXhpcy1pdGVtLWxhYmVscycsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgWEF4aXNMYWJlbHNDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgWEF4aXNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignbm90ZXMnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIFhBeGlzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFhBeGlzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImxpbmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFhBeGlzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFhBeGlzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc3VhbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgWEF4aXNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiaWNvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgWEF4aXNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibGFiZWxcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBvZiB0aGUgWC1heGlzIG5vdGVzLlxuICogRm9yIGFuIGV4YW1wbGUgb24gdGhlIGJhc2ljIHVzYWdlIG9mIHRoZSBYQXhpc05vdGVzQ29tcG9uZW50LFxuICogcmVmZXIgdG8gdGhlIFtkZW1vIG9uIHRoZSBYQXhpc0NvbXBvbmVudF0oeyUgc2x1ZyBhcGlfY2hhcnRzX3hheGlzY29tcG9uZW50ICV9KVxuICogb3IgdG8gdGhlIGRvY3VtZW50YXRpb24gYWJvdXQgdGhlXG4gKiBbYXhpcyBub3Rlc10oeyUgc2x1ZyBub3Rlc19jaGFydF9jaGFydHMgJX0jdG9jLWF4aXMtbm90ZXMpLlxuICovXG5sZXQgWEF4aXNOb3Rlc0NvbXBvbmVudCA9IGNsYXNzIFhBeGlzTm90ZXNDb21wb25lbnQgZXh0ZW5kcyBYQXhpc05vdGVzQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcblhBeGlzTm90ZXNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC14LWF4aXMtaXRlbS1ub3RlcycsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgWEF4aXNOb3Rlc0NvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBYQXhpc05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignbm90ZXMuaWNvbicsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFhBeGlzTm90ZXNJY29uQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBYQXhpc05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBYQXhpc05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwic2l6ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWEF4aXNOb3Rlc0ljb25Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInR5cGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBYQXhpc05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBpY29uIG9mIHRoZSBub3Rlcy5cbiAqL1xubGV0IFhBeGlzTm90ZXNJY29uQ29tcG9uZW50ID0gY2xhc3MgWEF4aXNOb3Rlc0ljb25Db21wb25lbnQgZXh0ZW5kcyBYQXhpc05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5YQXhpc05vdGVzSWNvbkNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXgtYXhpcy1pdGVtLW5vdGVzLWljb24nLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIFhBeGlzTm90ZXNJY29uQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFhBeGlzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignbm90ZXMubGFiZWwnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBYQXhpc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFhBeGlzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBYQXhpc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFhBeGlzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29udGVudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWEF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmb250XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBYQXhpc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvcm1hdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWEF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgWEF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJyb3RhdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFhBeGlzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBsYWJlbCBvZiB0aGUgbm90ZXMuXG4gKi9cbmxldCBYQXhpc05vdGVzTGFiZWxDb21wb25lbnQgPSBjbGFzcyBYQXhpc05vdGVzTGFiZWxDb21wb25lbnQgZXh0ZW5kcyBYQXhpc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuWEF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQteC1heGlzLWl0ZW0tbm90ZXMtbGFiZWwnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIFhBeGlzTm90ZXNMYWJlbENvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBYQXhpc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCd0aXRsZScsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFhBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFhBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWEF4aXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFhBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFhBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1hcmdpblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgWEF4aXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWEF4aXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFhBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInJvdGF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBYQXhpc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0ZXh0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgWEF4aXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBYQXhpc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXN1YWxcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgdGl0bGUgY29uZmlndXJhdGlvbiBvZiB0aGUgU2NhdHRlciBDaGFydCBYIGF4aXMuXG4gKi9cbmxldCBYQXhpc1RpdGxlQ29tcG9uZW50ID0gY2xhc3MgWEF4aXNUaXRsZUNvbXBvbmVudCBleHRlbmRzIFhBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuWEF4aXNUaXRsZUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXgtYXhpcy1pdGVtLXRpdGxlJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBYQXhpc1RpdGxlQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFlBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIENvbGxlY3Rpb25JdGVtQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25TZXJ2aWNlID0gY29sbGVjdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgWUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJheGlzQ3Jvc3NpbmdWYWx1ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBZQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhc2VVbml0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBZQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBZQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImxpbmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFlBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWFqb3JHcmlkTGluZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFlBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWFqb3JUaWNrc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgWUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtYWpvclVuaXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFlBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWF4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBZQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1pblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgWUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtaW5vckdyaWRMaW5lc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgWUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtaW5vclRpY2tzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBZQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1pbm9yVW5pdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgWUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJuYXJyb3dSYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwYW5lXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIFlBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicGxvdEJhbmRzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgWUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJyZXZlcnNlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBZQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInR5cGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBZQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc2libGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFlBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY3Jvc3NoYWlyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBZQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImxhYmVsc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgWUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJub3Rlc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgWUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0aXRsZVwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIGNvbXBvbmVudCBmb3IgdGhlIFkgYXhpc1xuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBhcGlfY2hhcnRzX3lheGlzY29tcG9uZW50ICV9KSkuXG4gKi9cbmxldCBZQXhpc0l0ZW1Db21wb25lbnQgPSBjbGFzcyBZQXhpc0l0ZW1Db21wb25lbnQgZXh0ZW5kcyBZQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25TZXJ2aWNlID0gY29sbGVjdGlvblNlcnZpY2U7XG4gICAgfVxufTtcbllBeGlzSXRlbUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBwcm92aWRlcnM6IFtDb25maWd1cmF0aW9uU2VydmljZV0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQteS1heGlzLWl0ZW0nLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlLFxuICAgICAgICBDb2xsZWN0aW9uU2VydmljZV0pXG5dLCBZQXhpc0l0ZW1Db21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgWUF4aXNDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBDb2xsZWN0aW9uQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ3lBeGlzJywgY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25TZXJ2aWNlID0gY29sbGVjdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkcmVuKFlBeGlzSXRlbUNvbXBvbmVudCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIFlBeGlzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjaGlsZHJlblwiLCB2b2lkIDApO1xuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBvbmUgb3IgbW9yZSBZLWF4aXMgY29uZmlndXJhdGlvbiBjb21wb25lbnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKlxuICogX0BDb21wb25lbnQoe1xuICogIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICB0ZW1wbGF0ZTogYFxuICogICAgPGtlbmRvLWNoYXJ0PlxuICogICAgIDxrZW5kby1jaGFydC15LWF4aXM+XG4gKiAgICAgICA8a2VuZG8tY2hhcnQteS1heGlzLWl0ZW1cbiAqICAgICAgICAgW2JhY2tncm91bmRdPVwiJ3JnYmEoMTAwLCAxMDAsIDEwMCwgMC4yKSdcIlxuICogICAgICAgICBbY29sb3JdPVwiJ3JlZCdcIlxuICogICAgICAgICBbbm90ZXNdPVwibm90ZXNDb25maWdcIlxuICogICAgICAgICBbY3Jvc3NoYWlyXT1cImNyb3NzaGFpckNvbmZpZ1wiPlxuICogICAgICAgPC9rZW5kby1jaGFydC15LWF4aXMtaXRlbT5cbiAqICAgICAgIDxrZW5kby1jaGFydC15LWF4aXMtaXRlbSBuYW1lPVwic2Vjb25kQXhpc1wiPlxuICogICAgICAgPC9rZW5kby1jaGFydC15LWF4aXMtaXRlbT5cbiAqICAgICA8L2tlbmRvLWNoYXJ0LXktYXhpcz5cbiAqICAgICA8a2VuZG8tY2hhcnQtc2VyaWVzPlxuICogICAgICAgPGtlbmRvLWNoYXJ0LXNlcmllcy1pdGVtIHR5cGU9XCJzY2F0dGVyXCIgW2RhdGFdPVwiW1sxLCAyXV1cIj5cbiAqICAgICAgIDwva2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0+XG4gKiAgICAgICA8a2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0gdHlwZT1cInNjYXR0ZXJcIiBbZGF0YV09XCJbWzAuMSwgMC4yXV1cIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlBeGlzPVwic2Vjb25kQXhpc1wiPlxuICogICAgICAgPC9rZW5kby1jaGFydC1zZXJpZXMtaXRlbT5cbiAqICAgICA8L2tlbmRvLWNoYXJ0LXNlcmllcz5cbiAqICAgPC9rZW5kby1jaGFydD5cbiAqIGBcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqIHB1YmxpYyBub3Rlc0NvbmZpZyA9IHtcbiAqICAgZGF0YTogW3tcbiAqICAgICAgIHZhbHVlOiAwLjIsXG4gKiAgICAgICB0ZXh0OiBcImZvb1wiXG4gKiAgICAgfSwge1xuICogICAgICAgdmFsdWU6IDAuOCxcbiAqICAgICAgIHRleHQ6IFwiYmFyXCJcbiAqICAgICB9XSxcbiAqICAgIGxhYmVsOiB7XG4gKiAgICAgY29udGVudDogKGFyZ3M6IGFueSkgPT4gYXJncy5kYXRhSXRlbS50ZXh0LFxuICogICAgIGJhY2tncm91bmQ6ICdyZWQnLFxuICogICAgIGNvbG9yOiAnd2hpdGUnXG4gKiAgIH0sXG4gKiAgIGxpbmU6IHtcbiAqICAgICBjb2xvcjogJ2JsdWUnLFxuICogICAgIGRhc2hUeXBlOiAnZGFzaCcsXG4gKiAgICAgbGVuZ3RoOiAxNTAsXG4gKiAgICAgd2lkdGg6IDJcbiAqICAgfSxcbiAqICAgcG9zaXRpb246ICd0b3AnXG4gKiB9O1xuICpcbiAqIHB1YmxpYyBjcm9zc2hhaXJDb25maWcgPSB7XG4gKiAgIGNvbG9yOiAnZ3JlZW4nLFxuICogICBvcGFjaXR5OiAwLjgsXG4gKiAgIHZpc2libGU6IHRydWUsXG4gKiAgIHdpZHRoOiAzXG4gKiB9O1xuICogfVxuICpcbiAqIGBgYFxuICovXG5sZXQgWUF4aXNDb21wb25lbnQgPSBjbGFzcyBZQXhpc0NvbXBvbmVudCBleHRlbmRzIFlBeGlzQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uU2VydmljZSA9IGNvbGxlY3Rpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5ZQXhpc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBwcm92aWRlcnM6IFtDb2xsZWN0aW9uU2VydmljZV0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQteS1heGlzJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZSxcbiAgICAgICAgQ29sbGVjdGlvblNlcnZpY2VdKVxuXSwgWUF4aXNDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgWUF4aXNDcm9zc2hhaXJDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ2Nyb3NzaGFpcicsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFlBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgWUF4aXNDcm9zc2hhaXJDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm9wYWNpdHlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBZQXhpc0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgWUF4aXNDcm9zc2hhaXJDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIndpZHRoXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBZQXhpc0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidG9vbHRpcFwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBjcm9zc2hhaXIgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGFwaV9jaGFydHNfeWF4aXNjb21wb25lbnQgJX0pKS5cbiAqL1xubGV0IFlBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50ID0gY2xhc3MgWUF4aXNDcm9zc2hhaXJDb21wb25lbnQgZXh0ZW5kcyBZQXhpc0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLm1hcmtBc1Zpc2libGUoKTtcbiAgICB9XG59O1xuWUF4aXNDcm9zc2hhaXJDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC15LWF4aXMtaXRlbS1jcm9zc2hhaXInLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIFlBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFlBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignY3Jvc3NoYWlyLnRvb2x0aXAnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBZQXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFlBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBZQXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBZQXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFlBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBZQXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBhZGRpbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBZQXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc2libGVcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIG9mIHRoZSBjcm9zc2hhaXIgdG9vbHRpcC5cbiAqIFRoZSBjcm9zc2hhaXIgdG9vbHRpcCBpcyBkaXNwbGF5ZWQgd2hlbiB0aGUgYHZpc2libGVgIG9wdGlvbiBpcyBzZXQgdG8gYHRydWVgLlxuICovXG5sZXQgWUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50ID0gY2xhc3MgWUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50IGV4dGVuZHMgWUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlLlxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLm1hcmtBc1Zpc2libGUoKTtcbiAgICB9XG59O1xuWUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQteS1heGlzLWl0ZW0tY3Jvc3NoYWlyLXRvb2x0aXAnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIFlBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBZQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignbGFiZWxzJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWUF4aXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFlBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJib3JkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFlBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBZQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29udGVudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWUF4aXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImN1bHR1cmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFlBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJkYXRlRm9ybWF0c1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWUF4aXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFlBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmb3JtYXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFlBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtYXJnaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBZQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWlycm9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBZQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWUF4aXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBZQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicm90YXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFlBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJza2lwXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBZQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwic3RlcFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFlBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFlBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXN1YWxcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgYXhpcyBsYWJlbHMgY29uZmlndXJhdGlvbi5cbiAqL1xubGV0IFlBeGlzTGFiZWxzQ29tcG9uZW50ID0gY2xhc3MgWUF4aXNMYWJlbHNDb21wb25lbnQgZXh0ZW5kcyBZQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5ZQXhpc0xhYmVsc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXktYXhpcy1pdGVtLWxhYmVscycsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgWUF4aXNMYWJlbHNDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgWUF4aXNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignbm90ZXMnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIFlBeGlzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFlBeGlzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImxpbmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFlBeGlzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFlBeGlzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc3VhbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgWUF4aXNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiaWNvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgWUF4aXNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibGFiZWxcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBvZiB0aGUgWSBheGlzIG5vdGVzXG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGFwaV9jaGFydHNfeWF4aXNjb21wb25lbnQgJX0pKS5cbiAqL1xubGV0IFlBeGlzTm90ZXNDb21wb25lbnQgPSBjbGFzcyBZQXhpc05vdGVzQ29tcG9uZW50IGV4dGVuZHMgWUF4aXNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5ZQXhpc05vdGVzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQteS1heGlzLWl0ZW0tbm90ZXMnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIFlBeGlzTm90ZXNDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgWUF4aXNOb3Rlc0ljb25Db21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ25vdGVzLmljb24nLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBZQXhpc05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYmFja2dyb3VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgWUF4aXNOb3Rlc0ljb25Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgWUF4aXNOb3Rlc0ljb25Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInNpemVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFlBeGlzTm90ZXNJY29uQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0eXBlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgWUF4aXNOb3Rlc0ljb25Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc2libGVcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgaWNvbiBvZiB0aGUgbm90ZXMuXG4gKi9cbmxldCBZQXhpc05vdGVzSWNvbkNvbXBvbmVudCA9IGNsYXNzIFlBeGlzTm90ZXNJY29uQ29tcG9uZW50IGV4dGVuZHMgWUF4aXNOb3Rlc0ljb25Db21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuWUF4aXNOb3Rlc0ljb25Db21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC15LWF4aXMtaXRlbS1ub3Rlcy1pY29uJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBZQXhpc05vdGVzSWNvbkNvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBZQXhpc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ25vdGVzLmxhYmVsJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBZQXhpc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBZQXhpc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbnRlbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFlBeGlzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9udFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmb3JtYXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFlBeGlzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFlBeGlzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicm90YXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBZQXhpc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc2libGVcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgbGFiZWwgb2YgdGhlIG5vdGVzLlxuICovXG5sZXQgWUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50ID0gY2xhc3MgWUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50IGV4dGVuZHMgWUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcbllBeGlzTm90ZXNMYWJlbENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXktYXhpcy1pdGVtLW5vdGVzLWxhYmVsJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBZQXhpc05vdGVzTGFiZWxDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgWUF4aXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcigndGl0bGUnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBZQXhpc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBZQXhpc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJib3JkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFlBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBZQXhpc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmb250XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBZQXhpc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtYXJnaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFlBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBhZGRpbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFlBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBZQXhpc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJyb3RhdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWUF4aXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidGV4dFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFlBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc2libGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgWUF4aXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzdWFsXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIHRpdGxlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIFNjYXR0ZXIgQ2hhcnQgWSBheGlzLlxuICovXG5sZXQgWUF4aXNUaXRsZUNvbXBvbmVudCA9IGNsYXNzIFlBeGlzVGl0bGVDb21wb25lbnQgZXh0ZW5kcyBZQXhpc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcbllBeGlzVGl0bGVDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC15LWF4aXMtaXRlbS10aXRsZScsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgWUF4aXNUaXRsZUNvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBab29tYWJsZUNvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignem9vbWFibGUnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBab29tYWJsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibW91c2V3aGVlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgWm9vbWFibGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInNlbGVjdGlvblwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFNwZWNpZmllcyBpZiB0aGUgQ2hhcnQgY2FuIGJlIHpvb21lZC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGh0bWwtbm8tcnVuXG4gKiA8a2VuZG8tY2hhcnQ+XG4gKiAgIDxrZW5kby1jaGFydC16b29tYWJsZSBbbW91c2V3aGVlbF09XCJmYWxzZVwiPjwva2VuZG8tY2hhcnQtem9vbWFibGU+XG4gKiA8L2tlbmRvLWNoYXJ0PlxuICogYGBgXG4gKi9cbmxldCBab29tYWJsZUNvbXBvbmVudCA9IGNsYXNzIFpvb21hYmxlQ29tcG9uZW50IGV4dGVuZHMgWm9vbWFibGVDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuWm9vbWFibGVDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC16b29tYWJsZScsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgWm9vbWFibGVDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgQ0hBUlRfRElSRUNUSVZFUyA9IFtcbiAgICBDaGFydENvbXBvbmVudCxcbiAgICBUb29sdGlwUG9wdXBDb21wb25lbnQsXG4gICAgU2VyaWVzVG9vbHRpcFRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIFNoYXJlZFRvb2x0aXBUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBDcm9zc2hhaXJUb29sdGlwc0NvbnRhaW5lckNvbXBvbmVudCxcbiAgICBDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50LFxuICAgIERvbnV0Q2VudGVyVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgQXhpc0RlZmF1bHRzQ29tcG9uZW50LFxuICAgIEF4aXNEZWZhdWx0c0Nyb3NzaGFpckNvbXBvbmVudCxcbiAgICBBeGlzRGVmYXVsdHNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50LFxuICAgIEF4aXNEZWZhdWx0c0xhYmVsc0NvbXBvbmVudCxcbiAgICBBeGlzRGVmYXVsdHNUaXRsZUNvbXBvbmVudCxcbiAgICBDYXRlZ29yeUF4aXNDb21wb25lbnQsXG4gICAgQ2F0ZWdvcnlBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50LFxuICAgIENhdGVnb3J5QXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnQsXG4gICAgQ2F0ZWdvcnlBeGlzSXRlbUNvbXBvbmVudCxcbiAgICBDYXRlZ29yeUF4aXNMYWJlbHNDb21wb25lbnQsXG4gICAgQ2F0ZWdvcnlBeGlzUmFuZ2VMYWJlbHNDb21wb25lbnQsXG4gICAgQ2F0ZWdvcnlBeGlzTm90ZXNDb21wb25lbnQsXG4gICAgQ2F0ZWdvcnlBeGlzTm90ZXNJY29uQ29tcG9uZW50LFxuICAgIENhdGVnb3J5QXhpc05vdGVzTGFiZWxDb21wb25lbnQsXG4gICAgQ2F0ZWdvcnlBeGlzU2VsZWN0Q29tcG9uZW50LFxuICAgIENhdGVnb3J5QXhpc1RpdGxlQ29tcG9uZW50LFxuICAgIENoYXJ0QXJlYUNvbXBvbmVudCxcbiAgICBMZWdlbmRDb21wb25lbnQsXG4gICAgTGVnZW5kSW5hY3RpdmVJdGVtc0NvbXBvbmVudCxcbiAgICBMZWdlbmRJdGVtQ29tcG9uZW50LFxuICAgIFBhbmVDb21wb25lbnQsXG4gICAgUGFuZURlZmF1bHRzQ29tcG9uZW50LFxuICAgIFBhbmVEZWZhdWx0c1RpdGxlQ29tcG9uZW50LFxuICAgIFBhbmVzQ29tcG9uZW50LFxuICAgIFBhbmVzVGl0bGVDb21wb25lbnQsXG4gICAgUGxvdEFyZWFDb21wb25lbnQsXG4gICAgU2VyaWVzQ29tcG9uZW50LFxuICAgIFNlcmllc0RlZmF1bHRzQ29tcG9uZW50LFxuICAgIFNlcmllc0RlZmF1bHRzTGFiZWxzQ29tcG9uZW50LFxuICAgIFNlcmllc0RlZmF1bHRzTGFiZWxzRnJvbUNvbXBvbmVudCxcbiAgICBTZXJpZXNEZWZhdWx0c0xhYmVsc1RvQ29tcG9uZW50LFxuICAgIFNlcmllc0RlZmF1bHRzTm90ZXNDb21wb25lbnQsXG4gICAgU2VyaWVzRGVmYXVsdHNOb3Rlc0ljb25Db21wb25lbnQsXG4gICAgU2VyaWVzRGVmYXVsdHNOb3Rlc0xhYmVsQ29tcG9uZW50LFxuICAgIFNlcmllc0RlZmF1bHRzVG9vbHRpcENvbXBvbmVudCxcbiAgICBTZXJpZXNFcnJvckJhcnNDb21wb25lbnQsXG4gICAgU2VyaWVzRXh0cmVtZXNDb21wb25lbnQsXG4gICAgU2VyaWVzSGlnaGxpZ2h0Q29tcG9uZW50LFxuICAgIFNlcmllc0l0ZW1Db21wb25lbnQsXG4gICAgU2VyaWVzTGFiZWxzQ29tcG9uZW50LFxuICAgIFNlcmllc0xhYmVsc0Zyb21Db21wb25lbnQsXG4gICAgU2VyaWVzTGFiZWxzVG9Db21wb25lbnQsXG4gICAgU2VyaWVzTWFya2Vyc0NvbXBvbmVudCxcbiAgICBTZXJpZXNOb3Rlc0NvbXBvbmVudCxcbiAgICBTZXJpZXNOb3Rlc0ljb25Db21wb25lbnQsXG4gICAgU2VyaWVzTm90ZXNMYWJlbENvbXBvbmVudCxcbiAgICBTZXJpZXNPdXRsaWVyc0NvbXBvbmVudCxcbiAgICBTZXJpZXNUb29sdGlwQ29tcG9uZW50LFxuICAgIFRpdGxlQ29tcG9uZW50LFxuICAgIFRvb2x0aXBDb21wb25lbnQsXG4gICAgVmFsdWVBeGlzQ29tcG9uZW50LFxuICAgIFZhbHVlQXhpc0Nyb3NzaGFpckNvbXBvbmVudCxcbiAgICBWYWx1ZUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50LFxuICAgIFZhbHVlQXhpc0l0ZW1Db21wb25lbnQsXG4gICAgVmFsdWVBeGlzTGFiZWxzQ29tcG9uZW50LFxuICAgIFZhbHVlQXhpc05vdGVzQ29tcG9uZW50LFxuICAgIFZhbHVlQXhpc05vdGVzSWNvbkNvbXBvbmVudCxcbiAgICBWYWx1ZUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50LFxuICAgIFZhbHVlQXhpc1RpdGxlQ29tcG9uZW50LFxuICAgIFhBeGlzQ29tcG9uZW50LFxuICAgIFhBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50LFxuICAgIFhBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudCxcbiAgICBYQXhpc0l0ZW1Db21wb25lbnQsXG4gICAgWEF4aXNMYWJlbHNDb21wb25lbnQsXG4gICAgWEF4aXNOb3Rlc0NvbXBvbmVudCxcbiAgICBYQXhpc05vdGVzSWNvbkNvbXBvbmVudCxcbiAgICBYQXhpc05vdGVzTGFiZWxDb21wb25lbnQsXG4gICAgWEF4aXNUaXRsZUNvbXBvbmVudCxcbiAgICBZQXhpc0NvbXBvbmVudCxcbiAgICBZQXhpc0Nyb3NzaGFpckNvbXBvbmVudCxcbiAgICBZQXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnQsXG4gICAgWUF4aXNJdGVtQ29tcG9uZW50LFxuICAgIFlBeGlzTGFiZWxzQ29tcG9uZW50LFxuICAgIFlBeGlzTm90ZXNDb21wb25lbnQsXG4gICAgWUF4aXNOb3Rlc0ljb25Db21wb25lbnQsXG4gICAgWUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50LFxuICAgIFlBeGlzVGl0bGVDb21wb25lbnQsXG4gICAgWm9vbWFibGVDb21wb25lbnRcbl07XG5cbi8vIFJlLWV4cG9ydCBldmVudCB0eXBlc1xuXG4vKipcbiAqIFRoZSBhcmd1bWVudHMgZm9yIHRoZSBgbmF2aWdhdG9yRmlsdGVyYCBldmVudC5cbiAqL1xuY2xhc3MgTmF2aWdhdG9yRmlsdGVyRXZlbnQgZXh0ZW5kcyBCYXNlRXZlbnQge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgdGhlIGV2ZW50IGFyZ3VtZW50cyBmcm9tIGEgcmF3IG9iamVjdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlLCBzZW5kZXIpIHtcbiAgICAgICAgc3VwZXIoc2VuZGVyKTtcbiAgICAgICAgdGhpcy5mcm9tID0gZS5mcm9tO1xuICAgICAgICB0aGlzLnRvID0gZS50bztcbiAgICB9XG59XG5cbi8vIFJlLWV4cG9ydCBldmVudCB0eXBlc1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IFJvb3RDb25maWd1cmF0aW9uU2VydmljZSA9IGNsYXNzIFJvb3RDb25maWd1cmF0aW9uU2VydmljZSBleHRlbmRzIENvbmZpZ3VyYXRpb25TZXJ2aWNlIHtcbn07XG5Sb290Q29uZmlndXJhdGlvblNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKClcbl0sIFJvb3RDb25maWd1cmF0aW9uU2VydmljZSk7XG5cbmNvbnN0IEVWRU5UX01BUCQxID0ge1xuICAgIG5hdmlnYXRvckZpbHRlcjogTmF2aWdhdG9yRmlsdGVyRXZlbnRcbn07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU3RvY2tJbnN0YW5jZUV2ZW50U2VydmljZSBleHRlbmRzIEluc3RhbmNlRXZlbnRTZXJ2aWNlIHtcbiAgICBjcmVhdGUobmFtZSwgYXJncywgc2VuZGVyKSB7XG4gICAgICAgIGlmIChFVkVOVF9NQVAkMVtuYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFVkVOVF9NQVAkMVtuYW1lXShhcmdzLCBzZW5kZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5jcmVhdGUobmFtZSwgYXJncywgc2VuZGVyKTtcbiAgICB9XG59XG5cbmNvbnN0IE5BVklHQVRPUl9ERUZBVUxUUyA9IHtcbiAgICBhdXRvQmluZEVsZW1lbnRzOiB0cnVlLFxuICAgIGxpdmVEcmFnOiBmYWxzZSxcbiAgICBwYXJ0aWFsUmVkcmF3OiB0cnVlXG59O1xuLyogdHNsaW50OmRpc2FibGU6bm8tYWNjZXNzLW1pc3NpbmctbWVtYmVyICovXG4vKipcbiAqIFRoZSByb290IFN0b2NrQ2hhcnQgY29tcG9uZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKlxuICogX0BDb21wb25lbnQoe1xuICogICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgIHRlbXBsYXRlOiBgXG4gKiAgICAgPGtlbmRvLXN0b2NrY2hhcnQ+XG4gKiAgICAgICAgIDxrZW5kby1jaGFydC1zZXJpZXM+XG4gKiAgICAgICAgICAgICA8a2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0gdHlwZT1cImxpbmVcIiBbZGF0YV09XCJkYXRhXCIgZmllbGQ9XCJ2YWx1ZVwiIGNhdGVnb3J5RmllbGQ9XCJkYXRlXCI+XG4gKiAgICAgICAgICAgICA8L2tlbmRvLWNoYXJ0LXNlcmllcy1pdGVtPlxuICogICAgICAgICA8L2tlbmRvLWNoYXJ0LXNlcmllcz5cbiAqICAgICAgICAgPGtlbmRvLWNoYXJ0LW5hdmlnYXRvcj5cbiAqICAgICAgICAgICAgIDxrZW5kby1jaGFydC1uYXZpZ2F0b3Itc2VsZWN0IHRvPVwiMjAxNy8wMi8wMVwiPlxuICogICAgICAgICAgICAgPC9rZW5kby1jaGFydC1uYXZpZ2F0b3Itc2VsZWN0PlxuICogICAgICAgICAgICAgPGtlbmRvLWNoYXJ0LW5hdmlnYXRvci1zZXJpZXM+XG4gKiAgICAgICAgICAgICAgICAgPGtlbmRvLWNoYXJ0LW5hdmlnYXRvci1zZXJpZXMtaXRlbSB0eXBlPVwiYXJlYVwiIFtkYXRhXT1cImRhdGFcIiBmaWVsZD1cInZhbHVlXCIgY2F0ZWdvcnlGaWVsZD1cImRhdGVcIj5cbiAqICAgICAgICAgICAgICAgICA8L2tlbmRvLWNoYXJ0LW5hdmlnYXRvci1zZXJpZXMtaXRlbT5cbiAqICAgICAgICAgICAgIDwva2VuZG8tY2hhcnQtbmF2aWdhdG9yLXNlcmllcz5cbiAqICAgICAgICAgPC9rZW5kby1jaGFydC1uYXZpZ2F0b3I+XG4gKiAgICAgPC9rZW5kby1zdG9ja2NoYXJ0PlxuICogICBgXG4gKiB9KVxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgcHVibGljIGRhdGE6IGFueVtdID0gW107XG4gKlxuICogICBjb25zdHJ1Y3RvcigpIHtcbiAqICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgMTAwOyBpZHgrKykge1xuICogICAgICAgICAgdGhpcy5kYXRhLnB1c2goe1xuICogICAgICAgICAgICAgIGRhdGU6IG5ldyBEYXRlKDIwMTcsIDAsIGlkeCksXG4gKiAgICAgICAgICAgICAgdmFsdWU6IE1hdGgucmFuZG9tKCkgKiAxMDBcbiAqICAgICAgICAgIH0pO1xuICogICAgICB9XG4gKiAgIH1cbiAqIH1cbiAqXG4gKiBgYGBcbiAqL1xubGV0IFN0b2NrQ2hhcnRDb21wb25lbnQgPSBjbGFzcyBTdG9ja0NoYXJ0Q29tcG9uZW50IGV4dGVuZHMgQ2hhcnRDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCB0aGVtZVNlcnZpY2UsIGVsZW1lbnQsIGludGwsIGxvY2FsaXphdGlvblNlcnZpY2UsIG5nWm9uZSwgaW5zdGFuY2VFdmVudFNlcnZpY2UsIGNoYW5nZURldGVjdG9yLCByZW5kZXJlcikge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSwgdGhlbWVTZXJ2aWNlLCBlbGVtZW50LCBpbnRsLCBsb2NhbGl6YXRpb25TZXJ2aWNlLCBuZ1pvbmUsIGluc3RhbmNlRXZlbnRTZXJ2aWNlLCBjaGFuZ2VEZXRlY3RvciwgcmVuZGVyZXIpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMudGhlbWVTZXJ2aWNlID0gdGhlbWVTZXJ2aWNlO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmludGwgPSBpbnRsO1xuICAgICAgICB0aGlzLmxvY2FsaXphdGlvblNlcnZpY2UgPSBsb2NhbGl6YXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZUV2ZW50U2VydmljZSA9IGluc3RhbmNlRXZlbnRTZXJ2aWNlO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yID0gY2hhbmdlRGV0ZWN0b3I7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG5hdmlnYXRvciByYW5nZSBpcyBjaGFuZ2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYXZpZ2F0b3JGaWx0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMucmVkcmF3U2xhdmVzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaG9zdENsYXNzZXMgPSBbJ2stY2hhcnQnLCAnay1zdG9ja2NoYXJ0J107XG4gICAgICAgIHZhbGlkYXRlUGFja2FnZShwYWNrYWdlTWV0YWRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiBjYWxsZWQsIHRoZSBuYXZpZ2F0b3IgcGFuZSBpcyBub3QgcmVkcmF3biB0aGUgbmV4dCB0aW1lIHRoZSBTdG9ja0NoYXJ0IG9wdGlvbnMgYXJlIHVwZGF0ZWQuXG4gICAgICogVGhlIG1ldGhvZCBpcyB1c2VmdWwgaWYgeW91IG5lZWQgdG8gdXBkYXRlIG9ubHkgdGhlIG1haW4gc2VyaWVzIGRhdGEgZm9yIHRoZSBzZWxlY3RlZCBwZXJpb2QuXG4gICAgICovXG4gICAgc2tpcE5hdmlnYXRvclJlZHJhdygpIHtcbiAgICAgICAgdGhpcy5yZWRyYXdTbGF2ZXMgPSB0cnVlO1xuICAgIH1cbiAgICBjcmVhdGVJbnN0YW5jZShlbGVtZW50LCBvYnNlcnZlcikge1xuICAgICAgICB0aGlzLmFwcGx5TmF2aWdhdG9yRGVmYXVsdHMoKTtcbiAgICAgICAgaWYgKHRoaXMuaXNEZXZNb2RlKCkgJiYgKHRoaXMub3B0aW9ucy56b29tYWJsZSB8fCB0aGlzLm9wdGlvbnMucGFubmFibGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwYW5uYWJsZSBhbmQgem9vbWFibGUgb3B0aW9ucyBhcmUgbm90IHN1cHBvcnRlZCBieSB0aGUgU3RvY2tDaGFydCBjb21wb25lbnQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBTdG9ja0NoYXJ0KGVsZW1lbnQsIHRoaXMub3B0aW9ucywgdGhpcy50aGVtZSwge1xuICAgICAgICAgICAgaW50bFNlcnZpY2U6IHRoaXMuaW50bCxcbiAgICAgICAgICAgIG9ic2VydmVyOiBvYnNlcnZlcixcbiAgICAgICAgICAgIHJ0bDogdGhpcy5ydGwsXG4gICAgICAgICAgICBzZW5kZXI6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZU9wdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuYXBwbHlOYXZpZ2F0b3JEZWZhdWx0cygpO1xuICAgICAgICBpZiAodGhpcy5yZWRyYXdTbGF2ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UuYXBwbHlPcHRpb25zKHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLmJpbmRDYXRlZ29yaWVzKCk7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLm5hdmlnYXRvci5yZWRyYXdTbGF2ZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0T3B0aW9ucyh0aGlzLm9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVkcmF3U2xhdmVzID0gZmFsc2U7XG4gICAgfVxuICAgIGFwcGx5TmF2aWdhdG9yRGVmYXVsdHMoKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5uYXZpZ2F0b3IgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMubmF2aWdhdG9yLCBOQVZJR0FUT1JfREVGQVVMVFMpO1xuICAgIH1cbiAgICBpc0Rldk1vZGUoKSB7XG4gICAgICAgIHJldHVybiBpc0Rldk1vZGUoKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU3RvY2tDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibmF2aWdhdG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTdG9ja0NoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJwYW5uYWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU3RvY2tDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiem9vbWFibGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBTdG9ja0NoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJuYXZpZ2F0b3JGaWx0ZXJcIiwgdm9pZCAwKTtcblN0b2NrQ2hhcnRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgZXhwb3J0QXM6ICdrZW5kb1N0b2NrQ2hhcnQnLFxuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIENvbmZpZ3VyYXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAgVG9vbHRpcFRlbXBsYXRlU2VydmljZSxcbiAgICAgICAgICAgIHsgcHJvdmlkZTogUm9vdENvbmZpZ3VyYXRpb25TZXJ2aWNlLCB1c2VFeGlzdGluZzogQ29uZmlndXJhdGlvblNlcnZpY2UgfSxcbiAgICAgICAgICAgIFN0b2NrSW5zdGFuY2VFdmVudFNlcnZpY2UsXG4gICAgICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEwxME5fUFJFRklYLFxuICAgICAgICAgICAgICAgIHVzZVZhbHVlOiAna2VuZG8uY2hhcnQnXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tc3RvY2tjaGFydCcsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxkaXYgI3N1cmZhY2UgY2xhc3M9XCJrLWNoYXJ0LXN1cmZhY2VcIj48L2Rpdj5cbiAgICAgICAgPGtlbmRvLWNoYXJ0LWNyb3NzaGFpci10b29sdGlwcy1jb250YWluZXIgW3BvcHVwU2V0dGluZ3NdPVwicG9wdXBTZXR0aW5nc1wiPlxuICAgICAgICA8L2tlbmRvLWNoYXJ0LWNyb3NzaGFpci10b29sdGlwcy1jb250YWluZXI+XG4gICAgICAgIDxrZW5kby1jaGFydC10b29sdGlwLXBvcHVwIChsZWF2ZSk9XCJ0b29sdGlwTW91c2VsZWF2ZSgkZXZlbnQpXCIgW3BvcHVwU2V0dGluZ3NdPVwicG9wdXBTZXR0aW5nc1wiPlxuICAgICAgICA8L2tlbmRvLWNoYXJ0LXRvb2x0aXAtcG9wdXA+XG4gICAgICAgIDxrZW5kby1yZXNpemUtc2Vuc29yIChyZXNpemUpPVwib25SZXNpemUoJGV2ZW50KVwiPjwva2VuZG8tcmVzaXplLXNlbnNvcj5cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZSxcbiAgICAgICAgVGhlbWVTZXJ2aWNlLFxuICAgICAgICBFbGVtZW50UmVmLFxuICAgICAgICBJbnRsU2VydmljZSxcbiAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgTmdab25lLFxuICAgICAgICBTdG9ja0luc3RhbmNlRXZlbnRTZXJ2aWNlLFxuICAgICAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgUmVuZGVyZXIyXSlcbl0sIFN0b2NrQ2hhcnRDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgUFJFRklYID0gbmV3IEluamVjdGlvblRva2VuKCdjb25maWd1cmF0aW9uIHByZWZpeCcpO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBQcmVmaXhDb25maWd1cmF0aW9uU2VydmljZSA9IGNsYXNzIFByZWZpeENvbmZpZ3VyYXRpb25TZXJ2aWNlIGV4dGVuZHMgQ29uZmlndXJhdGlvblNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKHJvb3RTZXJ2aWNlLCBwcmVmaXgsIG5nWm9uZSkge1xuICAgICAgICBzdXBlcihuZ1pvbmUpO1xuICAgICAgICB0aGlzLnJvb3RTZXJ2aWNlID0gcm9vdFNlcnZpY2U7XG4gICAgICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgIH1cbiAgICBwdXNoKHN0b3JlKSB7XG4gICAgICAgIHRoaXMucm9vdFNlcnZpY2Uubm90aWZ5KG5ldyBDaGFuZ2UodGhpcy5wcmVmaXgsIHN0b3JlKSk7XG4gICAgfVxuICAgIG5vdGlmeShjaGFuZ2UpIHtcbiAgICAgICAgY2hhbmdlLmtleSA9IHRoaXMucHJlZml4ICsgKGNoYW5nZS5rZXkgPyBgLiR7Y2hhbmdlLmtleX1gIDogJycpO1xuICAgICAgICB0aGlzLnJvb3RTZXJ2aWNlLm5vdGlmeShjaGFuZ2UpO1xuICAgIH1cbn07XG5QcmVmaXhDb25maWd1cmF0aW9uU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX3BhcmFtKDAsIEluamVjdChSb290Q29uZmlndXJhdGlvblNlcnZpY2UpKSxcbiAgICBfX3BhcmFtKDEsIEluamVjdChQUkVGSVgpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1Jvb3RDb25maWd1cmF0aW9uU2VydmljZSwgU3RyaW5nLCBOZ1pvbmVdKVxuXSwgUHJlZml4Q29uZmlndXJhdGlvblNlcnZpY2UpO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgb2YgdGhlIG5hdmlnYXRvclxuICogKFtzZWUgcnVubmFibGUgZXhhbXBsZV0oeyUgc2x1ZyBvdmVydmlld19zdG9ja2NoYXJ0X2NoYXJ0cyAlfSN0b2MtbmF2aWdhdG9yKSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzLW5vLXJ1blxuICogX0BDb21wb25lbnQoe1xuICogICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgIDxrZW5kby1zdG9ja2NoYXJ0IChuYXZpZ2F0b3JGaWx0ZXIpPVwib25OYXZpZ2F0b3JGaWx0ZXIoJGV2ZW50KVwiPlxuICogICAgICAgICAgICAgPGtlbmRvLWNoYXJ0LXNlcmllcz5cbiAqICAgICAgICAgICAgICAgIDxrZW5kby1jaGFydC1zZXJpZXMtaXRlbVxuICogICAgICAgICAgICAgICAgdHlwZT1cImNhbmRsZXN0aWNrXCJcbiAqICAgICAgICAgICAgICAgICBbZGF0YV09XCJzZXJpZXNEYXRhXCJcbiAqICAgICAgICAgICAgICAgICBvcGVuRmllbGQ9XCJPcGVuXCJcbiAqICAgICAgICAgICAgICAgICBjbG9zZUZpZWxkPVwiQ2xvc2VcIlxuICogICAgICAgICAgICAgICAgIGxvd0ZpZWxkPVwiTG93XCJcbiAqICAgICAgICAgICAgICAgICBoaWdoRmllbGQ9XCJIaWdoXCJcbiAqICAgICAgICAgICAgICAgICBjYXRlZ29yeUZpZWxkPVwiRGF0ZVwiPlxuICogICAgICAgICAgICAgPC9rZW5kby1jaGFydC1zZXJpZXMtaXRlbT5cbiAqICAgICAgICAgIDwva2VuZG8tY2hhcnQtc2VyaWVzPlxuICogICAgICAgICAgPGtlbmRvLWNoYXJ0LW5hdmlnYXRvclxuICogICAgICAgICAgICBbY2F0ZWdvcnlBeGlzXT1cImNhdGVnb3J5QXhpc09wdGlvbnNcIlxuICogICAgICAgICAgICBbaGludF09XCJoaW50T3B0aW9uc1wiXG4gKiAgICAgICAgICAgIFtwYW5lXT1cInBhbmVPcHRpb25zXCJcbiAqICAgICAgICAgICAgW3Zpc2libGVdPVwiaXNWaXNpYmxlXCI+XG4gKiAgICAgICAgICAgIDxrZW5kby1jaGFydC1uYXZpZ2F0b3Itc2VsZWN0IFtmcm9tXT1cImZyb21cIiBbdG9dPVwidG9cIj5cbiAqICAgICAgICAgICAgPC9rZW5kby1jaGFydC1uYXZpZ2F0b3Itc2VsZWN0PlxuICogICAgICAgICAgICA8a2VuZG8tY2hhcnQtbmF2aWdhdG9yLXNlcmllcz5cbiAqICAgICAgICAgICAgICA8a2VuZG8tY2hhcnQtbmF2aWdhdG9yLXNlcmllcy1pdGVtIHR5cGU9XCJhcmVhXCIgW2RhdGFdPVwibmF2aWdhdG9yRGF0YVwiIGZpZWxkPVwiQ2xvc2VcIiBjYXRlZ29yeUZpZWxkPVwiRGF0ZVwiPlxuICogICAgICAgICAgICAgIDwva2VuZG8tY2hhcnQtbmF2aWdhdG9yLXNlcmllcy1pdGVtPlxuICogICAgICAgICAgIDwva2VuZG8tY2hhcnQtbmF2aWdhdG9yLXNlcmllcz5cbiAqICAgICAgICAgIDwva2VuZG8tY2hhcnQtbmF2aWdhdG9yPlxuICogICAgICAgIDwva2VuZG8tc3RvY2tjaGFydD5cbiAqICAgICAgICA8YnIgLz48YnIgLz5cbiAqICAgICAgICA8YnV0dG9uIGNsYXNzPVwiay1idXR0b25cIiAoY2xpY2spPVwiaXNWaXNpYmxlID0gIWlzVmlzaWJsZVwiPlRvZ2dsZSBOYXZpZ2F0b3I8L2J1dHRvbj5cbiAqICAgIGBcbiAqIH0pXG4gKiBgYGBcbiAqL1xubGV0IE5hdmlnYXRvckNvbXBvbmVudCA9IGNsYXNzIE5hdmlnYXRvckNvbXBvbmVudCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBOYXZpZ2F0b3JDb21wb25lbnQucHJvdG90eXBlLCBcInZpc2libGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5hdmlnYXRvckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY2F0ZWdvcnlBeGlzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYXZpZ2F0b3JDb21wb25lbnQucHJvdG90eXBlLCBcImhpbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5hdmlnYXRvckNvbXBvbmVudC5wcm90b3R5cGUsIFwicGFuZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmF2aWdhdG9yQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5hdmlnYXRvckNvbXBvbmVudC5wcm90b3R5cGUsIFwic2VyaWVzXCIsIHZvaWQgMCk7XG5OYXZpZ2F0b3JDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBQUkVGSVgsIHVzZVZhbHVlOiAnbmF2aWdhdG9yJyB9LCB7IHByb3ZpZGU6IENvbmZpZ3VyYXRpb25TZXJ2aWNlLCB1c2VDbGFzczogUHJlZml4Q29uZmlndXJhdGlvblNlcnZpY2UgfV0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtbmF2aWdhdG9yJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBOYXZpZ2F0b3JDb21wb25lbnQpO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIGNvbXBvbmVudCBvZiB0aGUgbmF2aWdhdG9yIGNhdGVnb3J5IGF4aXMuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBodG1sLW5vLXJ1blxuICogPGtlbmRvLXN0b2NrY2hhcnQ+XG4gKiAgIDxrZW5kby1jaGFydC1uYXZpZ2F0b3I+XG4gKiAgICAgPGtlbmRvLWNoYXJ0LW5hdmlnYXRvci1jYXRlZ29yeS1heGlzXG4gKiAgICAgICBjb2xvcj1cIm1hcm9vblwiXG4gKiAgICAgICBbbGFiZWxzXT1cIntjb2xvcjogJ2dyZWVuJ31cIj5cbiAqICAgICA8L2tlbmRvLWNoYXJ0LW5hdmlnYXRvci1jYXRlZ29yeS1heGlzPlxuICogICA8L2tlbmRvLWNoYXJ0LW5hdmlnYXRvcj5cbiAqIDwva2VuZG8tc3RvY2tjaGFydD5cbiAqIGBgYFxuICovXG5sZXQgTmF2aWdhdG9yQ2F0ZWdvcnlBeGlzQ29tcG9uZW50ID0gY2xhc3MgTmF2aWdhdG9yQ2F0ZWdvcnlBeGlzQ29tcG9uZW50IGV4dGVuZHMgQ2F0ZWdvcnlBeGlzSXRlbUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UsIGludGwsIGxvY2FsZUlkKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBudWxsLCBpbnRsLCBsb2NhbGVJZCk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuTmF2aWdhdG9yQ2F0ZWdvcnlBeGlzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHByb3ZpZGVyczogW3tcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBQUkVGSVgsXG4gICAgICAgICAgICAgICAgdXNlVmFsdWU6ICduYXZpZ2F0b3IuY2F0ZWdvcnlBeGlzJ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IENvbmZpZ3VyYXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHVzZUNsYXNzOiBQcmVmaXhDb25maWd1cmF0aW9uU2VydmljZVxuICAgICAgICAgICAgfV0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtbmF2aWdhdG9yLWNhdGVnb3J5LWF4aXMnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX3BhcmFtKDIsIEluamVjdChMT0NBTEVfSUQpKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlLFxuICAgICAgICBJbnRsU2VydmljZSwgU3RyaW5nXSlcbl0sIE5hdmlnYXRvckNhdGVnb3J5QXhpc0NvbXBvbmVudCk7XG5cbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBvZiB0aGUgY3Jvc3NoYWlyLlxuICovXG5sZXQgTmF2aWdhdG9yQ2F0ZWdvcnlBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50ID0gY2xhc3MgTmF2aWdhdG9yQ2F0ZWdvcnlBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50IGV4dGVuZHMgQ2F0ZWdvcnlBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuTmF2aWdhdG9yQ2F0ZWdvcnlBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtbmF2aWdhdG9yLWNhdGVnb3J5LWF4aXMtY3Jvc3NoYWlyJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBOYXZpZ2F0b3JDYXRlZ29yeUF4aXNDcm9zc2hhaXJDb21wb25lbnQpO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgb2YgdGhlIGNyb3NzaGFpciB0b29sdGlwLlxuICogVGhlIGNyb3NzaGFpciB0b29sdGlwIGlzIGRpc3BsYXllZCB3aGVuIHRoZSBgdmlzaWJsZWAgb3B0aW9uIGlzIHNldCB0byBgdHJ1ZWAuXG4gKi9cbmxldCBOYXZpZ2F0b3JDYXRlZ29yeUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50ID0gY2xhc3MgTmF2aWdhdG9yQ2F0ZWdvcnlBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudCBleHRlbmRzIENhdGVnb3J5QXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5OYXZpZ2F0b3JDYXRlZ29yeUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtbmF2aWdhdG9yLWNhdGVnb3J5LWF4aXMtY3Jvc3NoYWlyLXRvb2x0aXAnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIE5hdmlnYXRvckNhdGVnb3J5QXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnQpO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBheGlzIGxhYmVscy5cbiAqL1xubGV0IE5hdmlnYXRvckNhdGVnb3J5QXhpc0xhYmVsc0NvbXBvbmVudCA9IGNsYXNzIE5hdmlnYXRvckNhdGVnb3J5QXhpc0xhYmVsc0NvbXBvbmVudCBleHRlbmRzIENhdGVnb3J5QXhpc0xhYmVsc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcbk5hdmlnYXRvckNhdGVnb3J5QXhpc0xhYmVsc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LW5hdmlnYXRvci1jYXRlZ29yeS1heGlzLWxhYmVscycsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgTmF2aWdhdG9yQ2F0ZWdvcnlBeGlzTGFiZWxzQ29tcG9uZW50KTtcblxuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBvZiB0aGUgY2F0ZWdvcnkgYXhpcyBub3Rlcy5cbiAqL1xubGV0IE5hdmlnYXRvckNhdGVnb3J5QXhpc05vdGVzQ29tcG9uZW50ID0gY2xhc3MgTmF2aWdhdG9yQ2F0ZWdvcnlBeGlzTm90ZXNDb21wb25lbnQgZXh0ZW5kcyBDYXRlZ29yeUF4aXNOb3Rlc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcbk5hdmlnYXRvckNhdGVnb3J5QXhpc05vdGVzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtbmF2aWdhdG9yLWNhdGVnb3J5LWF4aXMtbm90ZXMnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIE5hdmlnYXRvckNhdGVnb3J5QXhpc05vdGVzQ29tcG9uZW50KTtcblxuLyoqXG4gKiBUaGUgaWNvbiBvZiB0aGUgbm90ZXMuXG4gKi9cbmxldCBOYXZpZ2F0b3JDYXRlZ29yeUF4aXNOb3Rlc0ljb25Db21wb25lbnQgPSBjbGFzcyBOYXZpZ2F0b3JDYXRlZ29yeUF4aXNOb3Rlc0ljb25Db21wb25lbnQgZXh0ZW5kcyBDYXRlZ29yeUF4aXNOb3Rlc0ljb25Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5OYXZpZ2F0b3JDYXRlZ29yeUF4aXNOb3Rlc0ljb25Db21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1uYXZpZ2F0b3ItY2F0ZWdvcnktYXhpcy1ub3Rlcy1pY29uJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBOYXZpZ2F0b3JDYXRlZ29yeUF4aXNOb3Rlc0ljb25Db21wb25lbnQpO1xuXG4vKipcbiAqIFRoZSBsYWJlbCBvZiB0aGUgbm90ZXMuXG4gKi9cbmxldCBOYXZpZ2F0b3JDYXRlZ29yeUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50ID0gY2xhc3MgTmF2aWdhdG9yQ2F0ZWdvcnlBeGlzTm90ZXNMYWJlbENvbXBvbmVudCBleHRlbmRzIENhdGVnb3J5QXhpc05vdGVzTGFiZWxDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5OYXZpZ2F0b3JDYXRlZ29yeUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtbmF2aWdhdG9yLWNhdGVnb3J5LWF4aXMtbm90ZXMtbGFiZWwnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIE5hdmlnYXRvckNhdGVnb3J5QXhpc05vdGVzTGFiZWxDb21wb25lbnQpO1xuXG4vKipcbiAqIFRoZSBzZWxlY3RlZCBheGlzIHJhbmdlLiBJZiBzZXQsIHRoZSBheGlzIHNlbGVjdGlvbiBpcyBlbmFibGVkLiBUaGUgcmFuZ2UgaXMgaW5kZXgtYmFzZWQgYW5kIHN0YXJ0cyBmcm9tIHplcm8uXG4gKiBDYXRlZ29yaWVzIHdpdGggaW5kZXhlcyBpbiB0aGUgcmFuZ2UgKGBzZWxlY3QuZnJvbWAsIGBzZWxlY3QudG9gKSB3aWxsIGJlIHNlbGVjdGVkLlxuICogVGhpcyBtZWFucyB0aGF0IHRoZSBsYXN0IGNhdGVnb3J5IGluIHRoZSByYW5nZSB3aWxsIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgc2VsZWN0aW9uLlxuICogSWYgdGhlIGNhdGVnb3JpZXMgYXJlIGRhdGVzLCB0aGUgcmFuZ2UgaGFzIGFsc28gdG8gYmUgc3BlY2lmaWVkIHdpdGggZGF0ZSB2YWx1ZXMuXG4gKi9cbmxldCBOYXZpZ2F0b3JDYXRlZ29yeUF4aXNTZWxlY3RDb21wb25lbnQgPSBjbGFzcyBOYXZpZ2F0b3JDYXRlZ29yeUF4aXNTZWxlY3RDb21wb25lbnQgZXh0ZW5kcyBDYXRlZ29yeUF4aXNTZWxlY3RDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5OYXZpZ2F0b3JDYXRlZ29yeUF4aXNTZWxlY3RDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1uYXZpZ2F0b3ItY2F0ZWdvcnktYXhpcy1zZWxlY3QnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIE5hdmlnYXRvckNhdGVnb3J5QXhpc1NlbGVjdENvbXBvbmVudCk7XG5cbi8qKlxuICogVGhlIHRpdGxlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIG5hdmlnYXRvciBjYXRlZ29yeSBheGlzLlxuICovXG5sZXQgTmF2aWdhdG9yQ2F0ZWdvcnlBeGlzVGl0bGVDb21wb25lbnQgPSBjbGFzcyBOYXZpZ2F0b3JDYXRlZ29yeUF4aXNUaXRsZUNvbXBvbmVudCBleHRlbmRzIENhdGVnb3J5QXhpc1RpdGxlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuTmF2aWdhdG9yQ2F0ZWdvcnlBeGlzVGl0bGVDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1uYXZpZ2F0b3ItY2F0ZWdvcnktYXhpcy10aXRsZScsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgTmF2aWdhdG9yQ2F0ZWdvcnlBeGlzVGl0bGVDb21wb25lbnQpO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IG9wdGlvbnMgb2YgdGhlIG5hdmlnYXRvciBoaW50XG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIG92ZXJ2aWV3X3N0b2NrY2hhcnRfY2hhcnRzICV9I3RvYy1uYXZpZ2F0b3IpKS5cbiAqL1xubGV0IE5hdmlnYXRvckhpbnRDb21wb25lbnQgPSBjbGFzcyBOYXZpZ2F0b3JIaW50Q29tcG9uZW50IGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCdoaW50JywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgTmF2aWdhdG9ySGludENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29udGVudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmF2aWdhdG9ySGludENvbXBvbmVudC5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgTmF2aWdhdG9ySGludENvbXBvbmVudC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuTmF2aWdhdG9ySGludENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LW5hdmlnYXRvci1oaW50JyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBOYXZpZ2F0b3JIaW50Q29tcG9uZW50KTtcblxuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBjb21wb25lbnQgb2YgdGhlIG5hdmlnYXRvciBwYW5lXG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIG92ZXJ2aWV3X3N0b2NrY2hhcnRfY2hhcnRzICV9I3RvYy1uYXZpZ2F0b3IpKS5cbiAqL1xubGV0IE5hdmlnYXRvclBhbmVDb21wb25lbnQgPSBjbGFzcyBOYXZpZ2F0b3JQYW5lQ29tcG9uZW50IGV4dGVuZHMgUGFuZUNvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UsIG51bGwpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcbk5hdmlnYXRvclBhbmVDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBQUkVGSVgsIHVzZVZhbHVlOiAnbmF2aWdhdG9yLnBhbmUnIH0sIHsgcHJvdmlkZTogQ29uZmlndXJhdGlvblNlcnZpY2UsIHVzZUNsYXNzOiBQcmVmaXhDb25maWd1cmF0aW9uU2VydmljZSB9XSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1uYXZpZ2F0b3ItcGFuZScsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgTmF2aWdhdG9yUGFuZUNvbXBvbmVudCk7XG5cbi8qKlxuICogVGhlIHRpdGxlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIFN0b2NrQ2hhcnQgbmF2aWdhdG9yIHBhbmUuXG4gKi9cbmxldCBOYXZpZ2F0b3JQYW5lVGl0bGVDb21wb25lbnQgPSBjbGFzcyBOYXZpZ2F0b3JQYW5lVGl0bGVDb21wb25lbnQgZXh0ZW5kcyBQYW5lc1RpdGxlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuTmF2aWdhdG9yUGFuZVRpdGxlQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtbmF2aWdhdG9yLXBhbmUtdGl0bGUnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIE5hdmlnYXRvclBhbmVUaXRsZUNvbXBvbmVudCk7XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBpbml0aWFsbHkgc2VsZWN0ZWQgcmFuZ2UuXG4gKiBJZiBubyByYW5nZSBpcyBzcGVjaWZpZWQsIHRoZSBmdWxsIHJhbmdlIG9mIHZhbHVlcyBpcyByZW5kZXJlZC5cbiAqL1xubGV0IE5hdmlnYXRvclNlbGVjdENvbXBvbmVudCA9IGNsYXNzIE5hdmlnYXRvclNlbGVjdENvbXBvbmVudCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignc2VsZWN0JywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpXG5dLCBOYXZpZ2F0b3JTZWxlY3RDb21wb25lbnQucHJvdG90eXBlLCBcImZyb21cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpXG5dLCBOYXZpZ2F0b3JTZWxlY3RDb21wb25lbnQucHJvdG90eXBlLCBcInRvXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYXZpZ2F0b3JTZWxlY3RDb21wb25lbnQucHJvdG90eXBlLCBcIm1vdXNld2hlZWxcIiwgdm9pZCAwKTtcbk5hdmlnYXRvclNlbGVjdENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LW5hdmlnYXRvci1zZWxlY3QnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIE5hdmlnYXRvclNlbGVjdENvbXBvbmVudCk7XG5cbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gY29tcG9uZW50IG9mIGEgbmF2aWdhdG9yIHNlcmllcyBpdGVtXG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIG5hdmlnYXRvcl9zdG9ja2NoYXJ0X2NoYXJ0cyAlfSkpLlxuICovXG5sZXQgTmF2aWdhdG9yU2VyaWVzSXRlbUNvbXBvbmVudCA9IGNsYXNzIE5hdmlnYXRvclNlcmllc0l0ZW1Db21wb25lbnQgZXh0ZW5kcyBTZXJpZXNJdGVtQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25TZXJ2aWNlID0gY29sbGVjdGlvblNlcnZpY2U7XG4gICAgfVxufTtcbk5hdmlnYXRvclNlcmllc0l0ZW1Db21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgcHJvdmlkZXJzOiBbQ29uZmlndXJhdGlvblNlcnZpY2VdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LW5hdmlnYXRvci1zZXJpZXMtaXRlbScsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2UsXG4gICAgICAgIENvbGxlY3Rpb25TZXJ2aWNlXSlcbl0sIE5hdmlnYXRvclNlcmllc0l0ZW1Db21wb25lbnQpO1xuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBvbmUgb3IgbW9yZSBuYXZpZ2F0b3Igc2VyaWVzIGl0ZW1zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKlxuICogX0BDb21wb25lbnQoe1xuICogICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgIHRlbXBsYXRlOiBgXG4gKiAgICAgPGtlbmRvLXN0b2NrY2hhcnQ+XG4gKiAgICAgICAgIDxrZW5kby1jaGFydC1uYXZpZ2F0b3I+XG4gKiAgICAgICAgICAgICA8a2VuZG8tY2hhcnQtbmF2aWdhdG9yLXNlcmllcz5cbiAqICAgICAgICAgICAgICAgICA8a2VuZG8tY2hhcnQtbmF2aWdhdG9yLXNlcmllcy1pdGVtIHR5cGU9XCJhcmVhXCIgW2RhdGFdPVwiZGF0YVwiIGZpZWxkPVwidmFsdWVcIiBjYXRlZ29yeUZpZWxkPVwiZGF0ZVwiPlxuICogICAgICAgICAgICAgICAgIDwva2VuZG8tY2hhcnQtbmF2aWdhdG9yLXNlcmllcy1pdGVtPlxuICogICAgICAgICAgICAgPC9rZW5kby1jaGFydC1uYXZpZ2F0b3Itc2VyaWVzPlxuICogICAgICAgICA8L2tlbmRvLWNoYXJ0LW5hdmlnYXRvcj5cbiAqICAgICA8L2tlbmRvLXN0b2NrY2hhcnQ+XG4gKiAgIGBcbiAqIH0pXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogICBwdWJsaWMgZGF0YTogYW55W10gPSBbXTtcbiAqXG4gKiAgIGNvbnN0cnVjdG9yKCkge1xuICogICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCAxMDA7IGlkeCsrKSB7XG4gKiAgICAgICAgICB0aGlzLmRhdGEucHVzaCh7XG4gKiAgICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoMjAxNywgMCwgaWR4KSxcbiAqICAgICAgICAgICAgICB2YWx1ZTogTWF0aC5yYW5kb20oKSAqIDEwMFxuICogICAgICAgICAgfSk7XG4gKiAgICAgIH1cbiAqICAgfVxuICogfVxuICpcbiAqIGBgYFxuICovXG5sZXQgTmF2aWdhdG9yU2VyaWVzQ29tcG9uZW50ID0gY2xhc3MgTmF2aWdhdG9yU2VyaWVzQ29tcG9uZW50IGV4dGVuZHMgU2VyaWVzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UsIHRvb2x0aXBUZW1wbGF0ZVNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlLCB0b29sdGlwVGVtcGxhdGVTZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25TZXJ2aWNlID0gY29sbGVjdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMudG9vbHRpcFRlbXBsYXRlU2VydmljZSA9IHRvb2x0aXBUZW1wbGF0ZVNlcnZpY2U7XG4gICAgfVxuICAgIHJlYWRUb29sdGlwVGVtcGxhdGVzKCkge1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGRyZW4oTmF2aWdhdG9yU2VyaWVzSXRlbUNvbXBvbmVudCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIE5hdmlnYXRvclNlcmllc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiY2hpbGRyZW5cIiwgdm9pZCAwKTtcbk5hdmlnYXRvclNlcmllc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBwcm92aWRlcnM6IFtDb2xsZWN0aW9uU2VydmljZV0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtbmF2aWdhdG9yLXNlcmllcycsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2UsXG4gICAgICAgIENvbGxlY3Rpb25TZXJ2aWNlLFxuICAgICAgICBUb29sdGlwVGVtcGxhdGVTZXJ2aWNlXSlcbl0sIE5hdmlnYXRvclNlcmllc0NvbXBvbmVudCk7XG5cbi8qKlxuICogVGhlIGVycm9yIGJhcnMgb2YgdGhlIFN0b2NrQ2hhcnQgbmF2aWdhdG9yIHNlcmllcy5cbiAqL1xubGV0IE5hdmlnYXRvclNlcmllc0Vycm9yQmFyc0NvbXBvbmVudCA9IGNsYXNzIE5hdmlnYXRvclNlcmllc0Vycm9yQmFyc0NvbXBvbmVudCBleHRlbmRzIFNlcmllc0Vycm9yQmFyc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcbk5hdmlnYXRvclNlcmllc0Vycm9yQmFyc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LW5hdmlnYXRvci1zZXJpZXMtaXRlbS1lcnJvci1iYXJzJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBOYXZpZ2F0b3JTZXJpZXNFcnJvckJhcnNDb21wb25lbnQpO1xuXG4vKipcbiAqIFRoZSBleHRyZW1lcyBjb25maWd1cmF0aW9uIG9mIHRoZSBTdG9ja0NoYXJ0IG5hdmlnYXRvciBzZXJpZXMuIEFwcGxpZXMgdG8gZXh0cmVtZSBvdXRsaWVycy5cbiAqL1xubGV0IE5hdmlnYXRvclNlcmllc0V4dHJlbWVzQ29tcG9uZW50ID0gY2xhc3MgTmF2aWdhdG9yU2VyaWVzRXh0cmVtZXNDb21wb25lbnQgZXh0ZW5kcyBTZXJpZXNFeHRyZW1lc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcbk5hdmlnYXRvclNlcmllc0V4dHJlbWVzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtbmF2aWdhdG9yLXNlcmllcy1pdGVtLWV4dHJlbWVzJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBOYXZpZ2F0b3JTZXJpZXNFeHRyZW1lc0NvbXBvbmVudCk7XG5cbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBvZiB0aGUgU3RvY2tDaGFydCBzZXJpZXMgaGlnaGxpZ2h0LlxuICovXG5sZXQgTmF2aWdhdG9yU2VyaWVzSGlnaGxpZ2h0Q29tcG9uZW50ID0gY2xhc3MgTmF2aWdhdG9yU2VyaWVzSGlnaGxpZ2h0Q29tcG9uZW50IGV4dGVuZHMgU2VyaWVzSGlnaGxpZ2h0Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuTmF2aWdhdG9yU2VyaWVzSGlnaGxpZ2h0Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtbmF2aWdhdG9yLXNlcmllcy1pdGVtLWhpZ2hsaWdodCcsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgTmF2aWdhdG9yU2VyaWVzSGlnaGxpZ2h0Q29tcG9uZW50KTtcblxuLyoqXG4gKiBUaGUgbGFiZWwgY29uZmlndXJhdGlvbiBvZiB0aGUgU3RvY2tDaGFydCBuYXZpZ2F0b3Igc2VyaWVzLlxuICovXG5sZXQgTmF2aWdhdG9yU2VyaWVzTGFiZWxzQ29tcG9uZW50ID0gY2xhc3MgTmF2aWdhdG9yU2VyaWVzTGFiZWxzQ29tcG9uZW50IGV4dGVuZHMgU2VyaWVzTGFiZWxzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5tYXJrQXNWaXNpYmxlKCk7XG4gICAgfVxufTtcbk5hdmlnYXRvclNlcmllc0xhYmVsc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LW5hdmlnYXRvci1zZXJpZXMtaXRlbS1sYWJlbHMnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIE5hdmlnYXRvclNlcmllc0xhYmVsc0NvbXBvbmVudCk7XG5cbi8qKlxuICogVGhlIGBmcm9tYCBsYWJlbCBjb25maWd1cmF0aW9uIG9mIHRoZSBTdG9ja0NoYXJ0IG5hdmlnYXRvciBzZXJpZXMuXG4gKi9cbmxldCBOYXZpZ2F0b3JTZXJpZXNMYWJlbHNGcm9tQ29tcG9uZW50ID0gY2xhc3MgTmF2aWdhdG9yU2VyaWVzTGFiZWxzRnJvbUNvbXBvbmVudCBleHRlbmRzIFNlcmllc0xhYmVsc0Zyb21Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLm1hcmtBc1Zpc2libGUoKTtcbiAgICB9XG59O1xuTmF2aWdhdG9yU2VyaWVzTGFiZWxzRnJvbUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LW5hdmlnYXRvci1zZXJpZXMtaXRlbS1sYWJlbHMtZnJvbScsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgTmF2aWdhdG9yU2VyaWVzTGFiZWxzRnJvbUNvbXBvbmVudCk7XG5cbi8qKlxuICogVGhlIGB0b2AgbGFiZWwgY29uZmlndXJhdGlvbiBvZiB0aGUgU3RvY2tDaGFydCBuYXZpZ2F0b3Igc2VyaWVzLlxuICovXG5sZXQgTmF2aWdhdG9yU2VyaWVzTGFiZWxzVG9Db21wb25lbnQgPSBjbGFzcyBOYXZpZ2F0b3JTZXJpZXNMYWJlbHNUb0NvbXBvbmVudCBleHRlbmRzIFNlcmllc0xhYmVsc1RvQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5tYXJrQXNWaXNpYmxlKCk7XG4gICAgfVxufTtcbk5hdmlnYXRvclNlcmllc0xhYmVsc1RvQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtbmF2aWdhdG9yLXNlcmllcy1pdGVtLWxhYmVscy10bycsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgTmF2aWdhdG9yU2VyaWVzTGFiZWxzVG9Db21wb25lbnQpO1xuXG4vKipcbiAqIFRoZSBtYXJrZXIgY29uZmlndXJhdGlvbiBvZiB0aGUgU3RvY2tDaGFydCBuYXZpZ2F0b3Igc2VyaWVzLlxuICovXG5sZXQgTmF2aWdhdG9yU2VyaWVzTWFya2Vyc0NvbXBvbmVudCA9IGNsYXNzIE5hdmlnYXRvclNlcmllc01hcmtlcnNDb21wb25lbnQgZXh0ZW5kcyBTZXJpZXNNYXJrZXJzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuTmF2aWdhdG9yU2VyaWVzTWFya2Vyc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LW5hdmlnYXRvci1zZXJpZXMtaXRlbS1tYXJrZXJzJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBOYXZpZ2F0b3JTZXJpZXNNYXJrZXJzQ29tcG9uZW50KTtcblxuLyoqXG4gKiBUaGUgbm90ZXMgY29uZmlndXJhdGlvbiBvZiB0aGUgU3RvY2tDaGFydCBuYXZpZ2F0b3Igc2VyaWVzLlxuICovXG5sZXQgTmF2aWdhdG9yU2VyaWVzTm90ZXNDb21wb25lbnQgPSBjbGFzcyBOYXZpZ2F0b3JTZXJpZXNOb3Rlc0NvbXBvbmVudCBleHRlbmRzIFNlcmllc05vdGVzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuTmF2aWdhdG9yU2VyaWVzTm90ZXNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1uYXZpZ2F0b3Itc2VyaWVzLWl0ZW0tbm90ZXMnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIE5hdmlnYXRvclNlcmllc05vdGVzQ29tcG9uZW50KTtcblxuLyoqXG4gKiBUaGUgaWNvbiBvZiB0aGUgbm90ZXMuXG4gKi9cbmxldCBOYXZpZ2F0b3JTZXJpZXNOb3Rlc0ljb25Db21wb25lbnQgPSBjbGFzcyBOYXZpZ2F0b3JTZXJpZXNOb3Rlc0ljb25Db21wb25lbnQgZXh0ZW5kcyBTZXJpZXNOb3Rlc0ljb25Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5OYXZpZ2F0b3JTZXJpZXNOb3Rlc0ljb25Db21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1uYXZpZ2F0b3Itc2VyaWVzLWl0ZW0tbm90ZXMtaWNvbicsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgTmF2aWdhdG9yU2VyaWVzTm90ZXNJY29uQ29tcG9uZW50KTtcblxuLyoqXG4gKiBUaGUgbGFiZWwgb2YgdGhlIG5vdGVzLlxuICovXG5sZXQgTmF2aWdhdG9yU2VyaWVzTm90ZXNMYWJlbENvbXBvbmVudCA9IGNsYXNzIE5hdmlnYXRvclNlcmllc05vdGVzTGFiZWxDb21wb25lbnQgZXh0ZW5kcyBTZXJpZXNOb3Rlc0xhYmVsQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuTmF2aWdhdG9yU2VyaWVzTm90ZXNMYWJlbENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LW5hdmlnYXRvci1zZXJpZXMtaXRlbS1ub3Rlcy1sYWJlbCcsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgTmF2aWdhdG9yU2VyaWVzTm90ZXNMYWJlbENvbXBvbmVudCk7XG5cbi8qKlxuICogVGhlIG91dGxpZXJzIGNvbmZpZ3VyYXRpb24gb2YgdGhlIFN0b2NrQ2hhcnQgbmF2aWdhdG9yIHNlcmllcy4gQXBwbGllcyB0byBtaWxkIG91dGxpZXJzLlxuICovXG5sZXQgTmF2aWdhdG9yU2VyaWVzT3V0bGllcnNDb21wb25lbnQgPSBjbGFzcyBOYXZpZ2F0b3JTZXJpZXNPdXRsaWVyc0NvbXBvbmVudCBleHRlbmRzIFNlcmllc091dGxpZXJzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuTmF2aWdhdG9yU2VyaWVzT3V0bGllcnNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1uYXZpZ2F0b3Itc2VyaWVzLWl0ZW0tb3V0bGllcnMnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIE5hdmlnYXRvclNlcmllc091dGxpZXJzQ29tcG9uZW50KTtcblxuLyoqXG4gKiBUaGUgdG9vbHRpcCBjb25maWd1cmF0aW9uIG9mIHRoZSBTdG9ja0NoYXJ0IG5hdmlnYXRvciBzZXJpZXMuXG4gKiBUaGUgU3RvY2tDaGFydCBuYXZpZ2F0b3Igc2VyaWVzIHRvb2x0aXAgaXMgZGlzcGxheWVkIHdoZW4gdGhlIGBuYXZpZ2F0b3Iuc2VyaWVzLnRvb2x0aXAudmlzaWJsZWAgb3B0aW9uIGlzIHNldCB0byBgdHJ1ZWAuXG4gKi9cbmxldCBOYXZpZ2F0b3JTZXJpZXNUb29sdGlwQ29tcG9uZW50ID0gY2xhc3MgTmF2aWdhdG9yU2VyaWVzVG9vbHRpcENvbXBvbmVudCBleHRlbmRzIFNlcmllc1Rvb2x0aXBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5OYXZpZ2F0b3JTZXJpZXNUb29sdGlwQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtbmF2aWdhdG9yLXNlcmllcy1pdGVtLXRvb2x0aXAnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIE5hdmlnYXRvclNlcmllc1Rvb2x0aXBDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgU1RPQ0tfQ0hBUlRfRElSRUNUSVZFUyA9IFtcbiAgICBTdG9ja0NoYXJ0Q29tcG9uZW50LFxuICAgIE5hdmlnYXRvckNvbXBvbmVudCxcbiAgICBOYXZpZ2F0b3JDYXRlZ29yeUF4aXNDb21wb25lbnQsXG4gICAgTmF2aWdhdG9yQ2F0ZWdvcnlBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50LFxuICAgIE5hdmlnYXRvckNhdGVnb3J5QXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnQsXG4gICAgTmF2aWdhdG9yQ2F0ZWdvcnlBeGlzTGFiZWxzQ29tcG9uZW50LFxuICAgIE5hdmlnYXRvckNhdGVnb3J5QXhpc05vdGVzQ29tcG9uZW50LFxuICAgIE5hdmlnYXRvckNhdGVnb3J5QXhpc05vdGVzSWNvbkNvbXBvbmVudCxcbiAgICBOYXZpZ2F0b3JDYXRlZ29yeUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50LFxuICAgIE5hdmlnYXRvckNhdGVnb3J5QXhpc1NlbGVjdENvbXBvbmVudCxcbiAgICBOYXZpZ2F0b3JDYXRlZ29yeUF4aXNUaXRsZUNvbXBvbmVudCxcbiAgICBOYXZpZ2F0b3JIaW50Q29tcG9uZW50LFxuICAgIE5hdmlnYXRvclBhbmVDb21wb25lbnQsXG4gICAgTmF2aWdhdG9yUGFuZVRpdGxlQ29tcG9uZW50LFxuICAgIE5hdmlnYXRvclNlbGVjdENvbXBvbmVudCxcbiAgICBOYXZpZ2F0b3JTZXJpZXNDb21wb25lbnQsXG4gICAgTmF2aWdhdG9yU2VyaWVzSXRlbUNvbXBvbmVudCxcbiAgICBOYXZpZ2F0b3JTZXJpZXNFcnJvckJhcnNDb21wb25lbnQsXG4gICAgTmF2aWdhdG9yU2VyaWVzRXh0cmVtZXNDb21wb25lbnQsXG4gICAgTmF2aWdhdG9yU2VyaWVzSGlnaGxpZ2h0Q29tcG9uZW50LFxuICAgIE5hdmlnYXRvclNlcmllc0xhYmVsc0NvbXBvbmVudCxcbiAgICBOYXZpZ2F0b3JTZXJpZXNMYWJlbHNGcm9tQ29tcG9uZW50LFxuICAgIE5hdmlnYXRvclNlcmllc0xhYmVsc1RvQ29tcG9uZW50LFxuICAgIE5hdmlnYXRvclNlcmllc01hcmtlcnNDb21wb25lbnQsXG4gICAgTmF2aWdhdG9yU2VyaWVzTm90ZXNDb21wb25lbnQsXG4gICAgTmF2aWdhdG9yU2VyaWVzTm90ZXNJY29uQ29tcG9uZW50LFxuICAgIE5hdmlnYXRvclNlcmllc05vdGVzTGFiZWxDb21wb25lbnQsXG4gICAgTmF2aWdhdG9yU2VyaWVzT3V0bGllcnNDb21wb25lbnQsXG4gICAgTmF2aWdhdG9yU2VyaWVzVG9vbHRpcENvbXBvbmVudFxuXTtcblxuLyogdHNsaW50OmRpc2FibGU6bm8tYWNjZXNzLW1pc3NpbmctbWVtYmVyICovXG4vKipcbiAqIFRoZSByb290IENoYXJ0IGNvbXBvbmVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICpcbiAqIF9AQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICB0ZW1wbGF0ZTogYFxuICogICAgIDxrZW5kby1zcGFya2xpbmUgW2RhdGFdPVwiZGF0YVwiIHR5cGU9XCJjb2x1bW5cIj5cbiAqICAgICA8L2tlbmRvLXNwYXJrbGluZT5cbiAqICAgYFxuICogfSlcbiAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiAgIHB1YmxpYyBkYXRhOiBhbnlbXSA9IFtcbiAqICAgICA5MzYsIDk2OCwgMTAyNSwgOTk5LCA5OTgsIDEwMTQsIDEwMTcsIDEwMTAsIDEwMTAsIDEwMDcsXG4gKiAgICAgMTAwNCwgOTg4LCA5OTAsIDk4OCwgOTg3LCA5OTUsIDk0NiwgOTU0LCA5OTEsIDk4NCxcbiAqICAgICA5NzQsIDk1NiwgOTg2LCA5MzYsIDk1NSwgMTAyMSwgMTAxMywgMTAwNSwgOTU4LCA5NTMsXG4gKiAgICAgOTUyLCA5NDAsIDkzNywgOTgwLCA5NjYsIDk2NSwgOTI4LCA5MTYsIDkxMCwgOTgwXG4gKiAgIF07XG4gKiB9XG4gKlxuICogYGBgXG4gKi9cbmxldCBTcGFya2xpbmVDb21wb25lbnQgPSBjbGFzcyBTcGFya2xpbmVDb21wb25lbnQgZXh0ZW5kcyBDaGFydENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UsIHRoZW1lU2VydmljZSwgZWxlbWVudCwgaW50bCwgbG9jYWxpemF0aW9uU2VydmljZSwgbmdab25lLCBpbnN0YW5jZUV2ZW50U2VydmljZSwgY2hhbmdlRGV0ZWN0b3IsIHJlbmRlcmVyKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCB0aGVtZVNlcnZpY2UsIGVsZW1lbnQsIGludGwsIGxvY2FsaXphdGlvblNlcnZpY2UsIG5nWm9uZSwgaW5zdGFuY2VFdmVudFNlcnZpY2UsIGNoYW5nZURldGVjdG9yLCByZW5kZXJlcik7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy50aGVtZVNlcnZpY2UgPSB0aGVtZVNlcnZpY2U7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuaW50bCA9IGludGw7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uU2VydmljZSA9IGxvY2FsaXphdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLmluc3RhbmNlRXZlbnRTZXJ2aWNlID0gaW5zdGFuY2VFdmVudFNlcnZpY2U7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IgPSBjaGFuZ2VEZXRlY3RvcjtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGhpZGRlblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50b29sdGlwV3JhcHBlckNsYXNzID0gJ2stc3BhcmtsaW5lLXRvb2x0aXAtd3JhcHBlcic7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRvb2x0aXBDb250ZW50Q2xhc3NlcyA9IHtcbiAgICAgICAgICAgICdrLXNwYXJrbGluZS10b29sdGlwJzogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhvc3RDbGFzc2VzID0gWydrLXNwYXJrbGluZScsICdrLXdpZGdldCddO1xuICAgICAgICB2YWxpZGF0ZVBhY2thZ2UocGFja2FnZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgY3JlYXRlSW5zdGFuY2UoZWxlbWVudCwgb2JzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBTcGFya2xpbmUoZWxlbWVudCwgU3BhcmtsaW5lLm5vcm1hbGl6ZU9wdGlvbnModGhpcy5vcHRpb25zKSwgdGhpcy50aGVtZSwge1xuICAgICAgICAgICAgaW50bFNlcnZpY2U6IHRoaXMuaW50bCxcbiAgICAgICAgICAgIG9ic2VydmVyOiBvYnNlcnZlcixcbiAgICAgICAgICAgIHJ0bDogdGhpcy5ydGwsXG4gICAgICAgICAgICBzZW5kZXI6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZU9wdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0T3B0aW9ucyhTcGFya2xpbmUubm9ybWFsaXplT3B0aW9ucyh0aGlzLm9wdGlvbnMpKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU3BhcmtsaW5lQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0eXBlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIFNwYXJrbGluZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xuU3BhcmtsaW5lQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIGV4cG9ydEFzOiAna2VuZG9TcGFya2xpbmUnLFxuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIENvbmZpZ3VyYXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAgVG9vbHRpcFRlbXBsYXRlU2VydmljZSxcbiAgICAgICAgICAgIEluc3RhbmNlRXZlbnRTZXJ2aWNlLFxuICAgICAgICAgICAgTG9jYWxpemF0aW9uU2VydmljZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBMMTBOX1BSRUZJWCxcbiAgICAgICAgICAgICAgICB1c2VWYWx1ZTogJ2tlbmRvLmNoYXJ0J1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLXNwYXJrbGluZScsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxzcGFuICNzdXJmYWNlIGNsYXNzPVwiay1jaGFydC1zdXJmYWNlXCI+PC9zcGFuPlxuICAgICAgICA8a2VuZG8tY2hhcnQtY3Jvc3NoYWlyLXRvb2x0aXBzLWNvbnRhaW5lciBbcG9wdXBTZXR0aW5nc109XCJwb3B1cFNldHRpbmdzXCI+XG4gICAgICAgIDwva2VuZG8tY2hhcnQtY3Jvc3NoYWlyLXRvb2x0aXBzLWNvbnRhaW5lcj5cbiAgICAgICAgPGtlbmRvLWNoYXJ0LXRvb2x0aXAtcG9wdXAgW2FuaW1hdGVdPVwiZmFsc2VcIiBbd3JhcHBlckNsYXNzXT1cInRvb2x0aXBXcmFwcGVyQ2xhc3NcIlxuICAgICAgICAgICAgW2NsYXNzTmFtZXNdPVwidG9vbHRpcENvbnRlbnRDbGFzc2VzXCIgKGxlYXZlKT1cInRvb2x0aXBNb3VzZWxlYXZlKCRldmVudClcIiBbcG9wdXBTZXR0aW5nc109XCJwb3B1cFNldHRpbmdzXCI+XG4gICAgICAgIDwva2VuZG8tY2hhcnQtdG9vbHRpcC1wb3B1cD5cbiAgICAgICAgPGtlbmRvLXJlc2l6ZS1zZW5zb3IgKHJlc2l6ZSk9XCJvblJlc2l6ZSgkZXZlbnQpXCI+PC9rZW5kby1yZXNpemUtc2Vuc29yPlxuICAgIGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlLFxuICAgICAgICBUaGVtZVNlcnZpY2UsXG4gICAgICAgIEVsZW1lbnRSZWYsXG4gICAgICAgIEludGxTZXJ2aWNlLFxuICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICBOZ1pvbmUsXG4gICAgICAgIEluc3RhbmNlRXZlbnRTZXJ2aWNlLFxuICAgICAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgUmVuZGVyZXIyXSlcbl0sIFNwYXJrbGluZUNvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBTUEFSS0xJTkVfRElSRUNUSVZFUyA9IFtcbiAgICBTcGFya2xpbmVDb21wb25lbnRcbl07XG5cbi8qKlxuICogQSBbbW9kdWxlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyduZ21vZHVsZWFwaSddIH19KSB0aGF0IGluY2x1ZGVzIHRoZSBDaGFydCBjb21wb25lbnQgYW5kIGRpcmVjdGl2ZXMuXG4gKlxuICogSW1wb3J0cyB0aGUgQ2hhcnRNb2R1bGUgaW50byB5b3VyIGFwcGxpY2F0aW9uXG4gKiBbcm9vdCBtb2R1bGVdKHt7IHNpdGUuZGF0YS51cmwuYW5ndWxhclsnbmdtb2R1bGVzJ10gfX0jYW5ndWxhci1tb2R1bGFyaXR5KSBvciBhbnkgb3RoZXIgc3ViLW1vZHVsZVxuICogdGhhdCB3aWxsIHVzZSB0aGUgQ2hhcnQgY29tcG9uZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cy1uby1ydW5cbiAqIGltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKiBpbXBvcnQgeyBCcm93c2VyTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XG4gKiBpbXBvcnQgeyBDaGFydE1vZHVsZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWNoYXJ0cyc7XG4gKiBpbXBvcnQgeyBBcHBDb21wb25lbnQgfSBmcm9tICcuL2FwcC5jb21wb25lbnQnO1xuICpcbiAqIF9ATmdNb2R1bGUoe1xuICogICAgIGJvb3RzdHJhcDogICAgW0FwcENvbXBvbmVudF0sXG4gKiAgICAgZGVjbGFyYXRpb25zOiBbQXBwQ29tcG9uZW50XSxcbiAqICAgICBpbXBvcnRzOiAgICAgIFtCcm93c2VyTW9kdWxlLCBDaGFydE1vZHVsZV1cbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwTW9kdWxlIHtcbiAqIH1cbiAqIGBgYFxuICovXG5sZXQgQ2hhcnRNb2R1bGUgPSBjbGFzcyBDaGFydE1vZHVsZSB7XG59O1xuQ2hhcnRNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGRlY2xhcmF0aW9uczogW0NIQVJUX0RJUkVDVElWRVNdLFxuICAgICAgICBleHBvcnRzOiBbQ0hBUlRfRElSRUNUSVZFU10sXG4gICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIFBvcHVwTW9kdWxlLCBSZXNpemVTZW5zb3JNb2R1bGVdLFxuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIFRoZW1lU2VydmljZVxuICAgICAgICBdXG4gICAgfSlcbl0sIENoYXJ0TW9kdWxlKTtcblxuLyoqXG4gKiBBIFttb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pIHRoYXQgaW5jbHVkZXMgdGhlIFN0b2NrQ2hhcnQgY29tcG9uZW50IGFuZCBkaXJlY3RpdmVzLlxuICpcbiAqIEltcG9ydHMgdGhlIFN0b2NrQ2hhcnRNb2R1bGUgaW50byB5b3VyIGFwcGxpY2F0aW9uXG4gKiBbcm9vdCBtb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlcyddIH19I2FuZ3VsYXItbW9kdWxhcml0eSkgb3IgYW55IG90aGVyIHN1Yi1tb2R1bGVcbiAqIHRoYXQgd2lsbCB1c2UgdGhlIFN0b2NrQ2hhcnQgY29tcG9uZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cy1uby1ydW5cbiAqIGltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKiBpbXBvcnQgeyBCcm93c2VyTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XG4gKiBpbXBvcnQgeyBTdG9ja0NoYXJ0TW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItY2hhcnRzJztcbiAqIGltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG4gKlxuICogX0BOZ01vZHVsZSh7XG4gKiAgICAgYm9vdHN0cmFwOiAgICBbQXBwQ29tcG9uZW50XSxcbiAqICAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLFxuICogICAgIGltcG9ydHM6ICAgICAgW0Jyb3dzZXJNb2R1bGUsIFN0b2NrQ2hhcnRNb2R1bGVdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7XG4gKiB9XG4gKiBgYGBcbiAqL1xubGV0IFN0b2NrQ2hhcnRNb2R1bGUgPSBjbGFzcyBTdG9ja0NoYXJ0TW9kdWxlIHtcbn07XG5TdG9ja0NoYXJ0TW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBkZWNsYXJhdGlvbnM6IFtTVE9DS19DSEFSVF9ESVJFQ1RJVkVTXSxcbiAgICAgICAgZXhwb3J0czogW1NUT0NLX0NIQVJUX0RJUkVDVElWRVMsIENoYXJ0TW9kdWxlXSxcbiAgICAgICAgaW1wb3J0czogW0NoYXJ0TW9kdWxlLCBDb21tb25Nb2R1bGUsIFBvcHVwTW9kdWxlLCBSZXNpemVTZW5zb3JNb2R1bGVdXG4gICAgfSlcbl0sIFN0b2NrQ2hhcnRNb2R1bGUpO1xuXG4vKipcbiAqIEEgW21vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVhcGknXSB9fSkgdGhhdCBpbmNsdWRlcyB0aGUgU3BhcmtsaW5lIGNvbXBvbmVudCBhbmQgZGlyZWN0aXZlcy5cbiAqXG4gKiBJbXBvcnRzIHRoZSBTcGFya2xpbmVNb2R1bGUgaW50byB5b3VyIGFwcGxpY2F0aW9uXG4gKiBbcm9vdCBtb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlcyddIH19I2FuZ3VsYXItbW9kdWxhcml0eSkgb3IgYW55IG90aGVyIHN1Yi1tb2R1bGVcbiAqIHRoYXQgd2lsbCB1c2UgdGhlIFNwYXJrbGluZSBjb21wb25lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzLW5vLXJ1blxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqIGltcG9ydCB7IEJyb3dzZXJNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbiAqIGltcG9ydCB7IFNwYXJrbGluZU1vZHVsZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWNoYXJ0cyc7XG4gKiBpbXBvcnQgeyBBcHBDb21wb25lbnQgfSBmcm9tICcuL2FwcC5jb21wb25lbnQnO1xuICpcbiAqIF9ATmdNb2R1bGUoe1xuICogICAgIGJvb3RzdHJhcDogICAgW0FwcENvbXBvbmVudF0sXG4gKiAgICAgZGVjbGFyYXRpb25zOiBbQXBwQ29tcG9uZW50XSxcbiAqICAgICBpbXBvcnRzOiAgICAgIFtCcm93c2VyTW9kdWxlLCBTcGFya2xpbmVNb2R1bGVdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7XG4gKiB9XG4gKiBgYGBcbiAqL1xubGV0IFNwYXJrbGluZU1vZHVsZSA9IGNsYXNzIFNwYXJrbGluZU1vZHVsZSB7XG59O1xuU3BhcmtsaW5lTW9kdWxlID0gX19kZWNvcmF0ZShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBkZWNsYXJhdGlvbnM6IFtTUEFSS0xJTkVfRElSRUNUSVZFU10sXG4gICAgICAgIGV4cG9ydHM6IFtTUEFSS0xJTkVfRElSRUNUSVZFUywgQ2hhcnRNb2R1bGVdLFxuICAgICAgICBpbXBvcnRzOiBbQ2hhcnRNb2R1bGUsIENvbW1vbk1vZHVsZSwgUG9wdXBNb2R1bGUsIFJlc2l6ZVNlbnNvck1vZHVsZV1cbiAgICB9KVxuXSwgU3BhcmtsaW5lTW9kdWxlKTtcblxuLyoqXG4gKiBBIFttb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pIHRoYXQgaW5jbHVkZXMgYWxsIENoYXJ0IGNvbXBvbmVudHMgYW5kIGRpcmVjdGl2ZXMuXG4gKlxuICogSW1wb3J0cyB0aGUgQ2hhcnRzTW9kdWxlIGludG8geW91ciBhcHBsaWNhdGlvblxuICogW3Jvb3QgbW9kdWxlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyduZ21vZHVsZXMnXSB9fSNhbmd1bGFyLW1vZHVsYXJpdHkpIG9yIGFueSBvdGhlciBzdWItbW9kdWxlXG4gKiB0aGF0IHdpbGwgdXNlIHRoZSBDaGFydHMgY29tcG9uZW50cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMtbm8tcnVuXG4gKiBpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICogaW1wb3J0IHsgQnJvd3Nlck1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuICogaW1wb3J0IHsgQ2hhcnRzTW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItY2hhcnRzJztcbiAqIGltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG4gKlxuICogX0BOZ01vZHVsZSh7XG4gKiAgICAgYm9vdHN0cmFwOiAgICBbQXBwQ29tcG9uZW50XSxcbiAqICAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLFxuICogICAgIGltcG9ydHM6ICAgICAgW0Jyb3dzZXJNb2R1bGUsIENoYXJ0c01vZHVsZV1cbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwTW9kdWxlIHtcbiAqIH1cbiAqIGBgYFxuICovXG5sZXQgQ2hhcnRzTW9kdWxlID0gY2xhc3MgQ2hhcnRzTW9kdWxlIHtcbn07XG5DaGFydHNNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGV4cG9ydHM6IFtDaGFydE1vZHVsZSwgU3BhcmtsaW5lTW9kdWxlLCBTdG9ja0NoYXJ0TW9kdWxlXVxuICAgIH0pXG5dLCBDaGFydHNNb2R1bGUpO1xuXG4vKipcbiAqIEdlbmVyYXRlZCBidW5kbGUgaW5kZXguIERvIG5vdCBlZGl0LlxuICovXG5cbmV4cG9ydCB7IENoYXJ0Q29tcG9uZW50R2VuZXJhdGVkLCBBeGlzRGVmYXVsdHNDb21wb25lbnRHZW5lcmF0ZWQsIEF4aXNEZWZhdWx0c0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZCwgQXhpc0RlZmF1bHRzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZCwgQXhpc0RlZmF1bHRzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLCBBeGlzRGVmYXVsdHNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZCwgQ2F0ZWdvcnlBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZCwgQ2F0ZWdvcnlBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50R2VuZXJhdGVkLCBDYXRlZ29yeUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLCBDYXRlZ29yeUF4aXNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZCwgQ2F0ZWdvcnlBeGlzTm90ZXNJY29uQ29tcG9uZW50R2VuZXJhdGVkLCBDYXRlZ29yeUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLCBDYXRlZ29yeUF4aXNTZWxlY3RDb21wb25lbnRHZW5lcmF0ZWQsIENhdGVnb3J5QXhpc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLCBDYXRlZ29yeUF4aXNDb21wb25lbnRHZW5lcmF0ZWQsIENoYXJ0QXJlYUNvbXBvbmVudEdlbmVyYXRlZCwgRG9udXRDZW50ZXJUZW1wbGF0ZURpcmVjdGl2ZSwgTGVnZW5kQ29tcG9uZW50R2VuZXJhdGVkLCBMZWdlbmRJbmFjdGl2ZUl0ZW1zQ29tcG9uZW50R2VuZXJhdGVkLCBMZWdlbmRJdGVtQ29tcG9uZW50R2VuZXJhdGVkLCBQYW5lQ29tcG9uZW50R2VuZXJhdGVkLCBQYW5lc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLCBQYW5lc0NvbXBvbmVudEdlbmVyYXRlZCwgUGxvdEFyZWFDb21wb25lbnRHZW5lcmF0ZWQsIFNlcmllc0RlZmF1bHRzQ29tcG9uZW50R2VuZXJhdGVkLCBTZXJpZXNEZWZhdWx0c0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZCwgU2VyaWVzRGVmYXVsdHNMYWJlbHNGcm9tQ29tcG9uZW50R2VuZXJhdGVkLCBTZXJpZXNEZWZhdWx0c0xhYmVsc1RvQ29tcG9uZW50R2VuZXJhdGVkLCBTZXJpZXNEZWZhdWx0c05vdGVzQ29tcG9uZW50R2VuZXJhdGVkLCBTZXJpZXNEZWZhdWx0c05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZCwgU2VyaWVzRGVmYXVsdHNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLCBTZXJpZXNEZWZhdWx0c1Rvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQsIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQsIFNlcmllc0Vycm9yQmFyc0NvbXBvbmVudEdlbmVyYXRlZCwgU2VyaWVzRXh0cmVtZXNDb21wb25lbnRHZW5lcmF0ZWQsIFNlcmllc0hpZ2hsaWdodENvbXBvbmVudEdlbmVyYXRlZCwgU2VyaWVzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLCBTZXJpZXNMYWJlbHNGcm9tQ29tcG9uZW50R2VuZXJhdGVkLCBTZXJpZXNMYWJlbHNUb0NvbXBvbmVudEdlbmVyYXRlZCwgU2VyaWVzTWFya2Vyc0NvbXBvbmVudEdlbmVyYXRlZCwgU2VyaWVzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQsIFNlcmllc05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZCwgU2VyaWVzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZCwgU2VyaWVzT3V0bGllcnNDb21wb25lbnRHZW5lcmF0ZWQsIFNlcmllc1Rvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQsIFNlcmllc0NvbXBvbmVudEdlbmVyYXRlZCwgVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQsIFRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQsIEJhc2VUb29sdGlwLCBib2R5RmFjdG9yeSwgQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudCwgU2VyaWVzVG9vbHRpcFRlbXBsYXRlRGlyZWN0aXZlLCBTaGFyZWRUb29sdGlwVGVtcGxhdGVEaXJlY3RpdmUsIFZhbHVlQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQsIFZhbHVlQXhpc0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZCwgVmFsdWVBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZCwgVmFsdWVBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLCBWYWx1ZUF4aXNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZCwgVmFsdWVBeGlzTm90ZXNJY29uQ29tcG9uZW50R2VuZXJhdGVkLCBWYWx1ZUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLCBWYWx1ZUF4aXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZCwgVmFsdWVBeGlzQ29tcG9uZW50R2VuZXJhdGVkLCBYQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQsIFhBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50R2VuZXJhdGVkLCBYQXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQsIFhBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLCBYQXhpc05vdGVzQ29tcG9uZW50R2VuZXJhdGVkLCBYQXhpc05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZCwgWEF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLCBYQXhpc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLCBYQXhpc0NvbXBvbmVudEdlbmVyYXRlZCwgWUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLCBZQXhpc0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZCwgWUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLCBZQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZCwgWUF4aXNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZCwgWUF4aXNOb3Rlc0ljb25Db21wb25lbnRHZW5lcmF0ZWQsIFlBeGlzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZCwgWUF4aXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZCwgWUF4aXNDb21wb25lbnRHZW5lcmF0ZWQsIFpvb21hYmxlQ29tcG9uZW50R2VuZXJhdGVkLCBDb2xsZWN0aW9uSXRlbUNvbXBvbmVudCwgQ29sbGVjdGlvbkNvbXBvbmVudCwgQ29sbGVjdGlvblNlcnZpY2UsIENvbmZpZ3VyYXRpb25TZXJ2aWNlLCBQUkVGSVgsIFByZWZpeENvbmZpZ3VyYXRpb25TZXJ2aWNlLCBSb290Q29uZmlndXJhdGlvblNlcnZpY2UsIFNldHRpbmdzQ29tcG9uZW50LCBUaGVtZVNlcnZpY2UsIFRvb2x0aXBUZW1wbGF0ZVNlcnZpY2UsIEJhc2VFdmVudCwgSW5zdGFuY2VFdmVudFNlcnZpY2UsIExlZ2VuZEV2ZW50LCBOb3RlRXZlbnQsIFByZXZlbnRhYmxlRXZlbnQsIFNlcmllc0V2ZW50LCBTdG9ja0luc3RhbmNlRXZlbnRTZXJ2aWNlLCBOYXZpZ2F0b3JDb21wb25lbnQsIE5hdmlnYXRvckNhdGVnb3J5QXhpc0NvbXBvbmVudCwgTmF2aWdhdG9yQ2F0ZWdvcnlBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50LCBOYXZpZ2F0b3JDYXRlZ29yeUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50LCBOYXZpZ2F0b3JDYXRlZ29yeUF4aXNMYWJlbHNDb21wb25lbnQsIE5hdmlnYXRvckNhdGVnb3J5QXhpc05vdGVzQ29tcG9uZW50LCBOYXZpZ2F0b3JDYXRlZ29yeUF4aXNOb3Rlc0ljb25Db21wb25lbnQsIE5hdmlnYXRvckNhdGVnb3J5QXhpc05vdGVzTGFiZWxDb21wb25lbnQsIE5hdmlnYXRvckNhdGVnb3J5QXhpc1NlbGVjdENvbXBvbmVudCwgTmF2aWdhdG9yQ2F0ZWdvcnlBeGlzVGl0bGVDb21wb25lbnQsIE5hdmlnYXRvckhpbnRDb21wb25lbnQsIE5hdmlnYXRvclBhbmVDb21wb25lbnQsIE5hdmlnYXRvclBhbmVUaXRsZUNvbXBvbmVudCwgTmF2aWdhdG9yU2VsZWN0Q29tcG9uZW50LCBOYXZpZ2F0b3JTZXJpZXNJdGVtQ29tcG9uZW50LCBOYXZpZ2F0b3JTZXJpZXNFcnJvckJhcnNDb21wb25lbnQsIE5hdmlnYXRvclNlcmllc0V4dHJlbWVzQ29tcG9uZW50LCBOYXZpZ2F0b3JTZXJpZXNIaWdobGlnaHRDb21wb25lbnQsIE5hdmlnYXRvclNlcmllc0xhYmVsc0NvbXBvbmVudCwgTmF2aWdhdG9yU2VyaWVzTGFiZWxzRnJvbUNvbXBvbmVudCwgTmF2aWdhdG9yU2VyaWVzTGFiZWxzVG9Db21wb25lbnQsIE5hdmlnYXRvclNlcmllc01hcmtlcnNDb21wb25lbnQsIE5hdmlnYXRvclNlcmllc05vdGVzQ29tcG9uZW50LCBOYXZpZ2F0b3JTZXJpZXNOb3Rlc0ljb25Db21wb25lbnQsIE5hdmlnYXRvclNlcmllc05vdGVzTGFiZWxDb21wb25lbnQsIE5hdmlnYXRvclNlcmllc091dGxpZXJzQ29tcG9uZW50LCBOYXZpZ2F0b3JTZXJpZXNUb29sdGlwQ29tcG9uZW50LCBOYXZpZ2F0b3JTZXJpZXNDb21wb25lbnQsIENoYXJ0TW9kdWxlLCBTdG9ja0NoYXJ0TW9kdWxlLCBTcGFya2xpbmVNb2R1bGUsIENoYXJ0c01vZHVsZSwgVG9vbHRpcFBvcHVwQ29tcG9uZW50LCBDcm9zc2hhaXJUb29sdGlwc0NvbnRhaW5lckNvbXBvbmVudCwgQ2hhcnRDb21wb25lbnQsIEF4aXNEZWZhdWx0c0NvbXBvbmVudCwgQXhpc0RlZmF1bHRzQ3Jvc3NoYWlyQ29tcG9uZW50LCBBeGlzRGVmYXVsdHNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50LCBBeGlzRGVmYXVsdHNMYWJlbHNDb21wb25lbnQsIEF4aXNEZWZhdWx0c1RpdGxlQ29tcG9uZW50LCBDYXRlZ29yeUF4aXNDb21wb25lbnQsIENhdGVnb3J5QXhpc0Nyb3NzaGFpckNvbXBvbmVudCwgQ2F0ZWdvcnlBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudCwgQ2F0ZWdvcnlBeGlzSXRlbUNvbXBvbmVudCwgQ2F0ZWdvcnlBeGlzTGFiZWxzQ29tcG9uZW50LCBDYXRlZ29yeUF4aXNSYW5nZUxhYmVsc0NvbXBvbmVudCwgQ2F0ZWdvcnlBeGlzTm90ZXNDb21wb25lbnQsIENhdGVnb3J5QXhpc05vdGVzSWNvbkNvbXBvbmVudCwgQ2F0ZWdvcnlBeGlzTm90ZXNMYWJlbENvbXBvbmVudCwgQ2F0ZWdvcnlBeGlzU2VsZWN0Q29tcG9uZW50LCBDYXRlZ29yeUF4aXNUaXRsZUNvbXBvbmVudCwgQ2hhcnRBcmVhQ29tcG9uZW50LCBMZWdlbmRDb21wb25lbnQsIExlZ2VuZEluYWN0aXZlSXRlbXNDb21wb25lbnQsIExlZ2VuZEl0ZW1Db21wb25lbnQsIFBhbmVDb21wb25lbnQsIFBhbmVEZWZhdWx0c0NvbXBvbmVudCwgUGFuZURlZmF1bHRzVGl0bGVDb21wb25lbnQsIFBhbmVzQ29tcG9uZW50LCBQYW5lc1RpdGxlQ29tcG9uZW50LCBQbG90QXJlYUNvbXBvbmVudCwgU2VyaWVzQ29tcG9uZW50LCBTZXJpZXNEZWZhdWx0c0NvbXBvbmVudCwgU2VyaWVzRGVmYXVsdHNMYWJlbHNDb21wb25lbnQsIFNlcmllc0RlZmF1bHRzTGFiZWxzRnJvbUNvbXBvbmVudCwgU2VyaWVzRGVmYXVsdHNMYWJlbHNUb0NvbXBvbmVudCwgU2VyaWVzRGVmYXVsdHNOb3Rlc0NvbXBvbmVudCwgU2VyaWVzRGVmYXVsdHNOb3Rlc0ljb25Db21wb25lbnQsIFNlcmllc0RlZmF1bHRzTm90ZXNMYWJlbENvbXBvbmVudCwgU2VyaWVzRGVmYXVsdHNUb29sdGlwQ29tcG9uZW50LCBTZXJpZXNFcnJvckJhcnNDb21wb25lbnQsIFNlcmllc0V4dHJlbWVzQ29tcG9uZW50LCBTZXJpZXNIaWdobGlnaHRDb21wb25lbnQsIFNlcmllc0l0ZW1Db21wb25lbnQsIFNlcmllc0xhYmVsc0NvbXBvbmVudCwgU2VyaWVzTGFiZWxzRnJvbUNvbXBvbmVudCwgU2VyaWVzTGFiZWxzVG9Db21wb25lbnQsIFNlcmllc01hcmtlcnNDb21wb25lbnQsIFNlcmllc05vdGVzQ29tcG9uZW50LCBTZXJpZXNOb3Rlc0ljb25Db21wb25lbnQsIFNlcmllc05vdGVzTGFiZWxDb21wb25lbnQsIFNlcmllc091dGxpZXJzQ29tcG9uZW50LCBTZXJpZXNUb29sdGlwQ29tcG9uZW50LCBUaXRsZUNvbXBvbmVudCwgVG9vbHRpcENvbXBvbmVudCwgVmFsdWVBeGlzQ29tcG9uZW50LCBWYWx1ZUF4aXNDcm9zc2hhaXJDb21wb25lbnQsIFZhbHVlQXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnQsIFZhbHVlQXhpc0l0ZW1Db21wb25lbnQsIFZhbHVlQXhpc0xhYmVsc0NvbXBvbmVudCwgVmFsdWVBeGlzTm90ZXNDb21wb25lbnQsIFZhbHVlQXhpc05vdGVzSWNvbkNvbXBvbmVudCwgVmFsdWVBeGlzTm90ZXNMYWJlbENvbXBvbmVudCwgVmFsdWVBeGlzVGl0bGVDb21wb25lbnQsIFhBeGlzQ29tcG9uZW50LCBYQXhpc0Nyb3NzaGFpckNvbXBvbmVudCwgWEF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50LCBYQXhpc0l0ZW1Db21wb25lbnQsIFhBeGlzTGFiZWxzQ29tcG9uZW50LCBYQXhpc05vdGVzQ29tcG9uZW50LCBYQXhpc05vdGVzSWNvbkNvbXBvbmVudCwgWEF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50LCBYQXhpc1RpdGxlQ29tcG9uZW50LCBZQXhpc0NvbXBvbmVudCwgWUF4aXNDcm9zc2hhaXJDb21wb25lbnQsIFlBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudCwgWUF4aXNJdGVtQ29tcG9uZW50LCBZQXhpc0xhYmVsc0NvbXBvbmVudCwgWUF4aXNOb3Rlc0NvbXBvbmVudCwgWUF4aXNOb3Rlc0ljb25Db21wb25lbnQsIFlBeGlzTm90ZXNMYWJlbENvbXBvbmVudCwgWUF4aXNUaXRsZUNvbXBvbmVudCwgWm9vbWFibGVDb21wb25lbnQsIENIQVJUX0RJUkVDVElWRVMsIEF4aXNMYWJlbENsaWNrRXZlbnQsIERyYWdFbmRFdmVudCwgRHJhZ0V2ZW50LCBEcmFnU3RhcnRFdmVudCwgTGVnZW5kSXRlbUNsaWNrRXZlbnQsIExlZ2VuZEl0ZW1Ib3ZlckV2ZW50LCBOb3RlQ2xpY2tFdmVudCwgTm90ZUhvdmVyRXZlbnQsIFBhbmVSZW5kZXJFdmVudCwgUGxvdEFyZWFDbGlja0V2ZW50LCBQbG90QXJlYUhvdmVyRXZlbnQsIFJlbmRlckV2ZW50LCBTZWxlY3RFbmRFdmVudCwgU2VsZWN0RXZlbnQsIFNlbGVjdFN0YXJ0RXZlbnQsIFNlcmllc0NsaWNrRXZlbnQsIFNlcmllc0hvdmVyRXZlbnQsIFpvb21FbmRFdmVudCwgWm9vbUV2ZW50LCBab29tU3RhcnRFdmVudCwgV2Vla1N0YXJ0RGF5LCBOYXZpZ2F0b3JGaWx0ZXJFdmVudCwgU3RvY2tDaGFydENvbXBvbmVudCwgU1RPQ0tfQ0hBUlRfRElSRUNUSVZFUywgU3BhcmtsaW5lQ29tcG9uZW50LCBTUEFSS0xJTkVfRElSRUNUSVZFUyB9O1xuIl19\n\n\n/***/ }),\n\n/***/ \"tZVE\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"V34t\");\n\n\nlet renderSVG = function(container, svg) {\n    container.innerHTML = svg;\n};\n\nif (typeof document !== \"undefined\") {\n    const testFragment = \"<svg xmlns='\" + _constants__WEBPACK_IMPORTED_MODULE_0__[/* SVG_NS */ \"b\"] + \"'></svg>\";\n    const testContainer = document.createElement(\"div\");\n    const hasParser = typeof DOMParser !== \"undefined\";\n\n    testContainer.innerHTML = testFragment;\n\n    if (hasParser && testContainer.firstChild.namespaceURI !== _constants__WEBPACK_IMPORTED_MODULE_0__[/* SVG_NS */ \"b\"]) {\n        renderSVG = function(container, svg) {\n            const parser = new DOMParser();\n            const chartDoc = parser.parseFromString(svg, \"text/xml\");\n            const importedDoc = document.adoptNode(chartDoc.documentElement);\n\n            container.innerHTML = \"\";\n            container.appendChild(importedDoc);\n        };\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (renderSVG);\n\n/***/ }),\n\n/***/ \"uBxF\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return transform; });\n/* harmony import */ var _transformation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"gofQ\");\n\n\nfunction transform(matrix) {\n    if (matrix === null) {\n        return null;\n    }\n\n    if (matrix instanceof _transformation__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"]) {\n        return matrix;\n    }\n\n    return new _transformation__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"](matrix);\n}\n\n/***/ }),\n\n/***/ \"uNz1\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nconst NODE_MAP = {};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (NODE_MAP);\n\n/***/ }),\n\n/***/ \"uekK\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return exportImage; });\n/* harmony import */ var _surface__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"kGoT\");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"uBxF\");\n/* harmony import */ var _shapes_group__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"qUqW\");\n\n\n\n\nfunction exportImage(group, options) {\n    const defaults = {\n        width: \"800px\", height: \"600px\",\n        cors: \"Anonymous\"\n    };\n\n    let exportRoot = group;\n    const bbox = group.clippedBBox();\n\n\n    if (bbox) {\n        const origin = bbox.getOrigin();\n        exportRoot = new _shapes_group__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"]();\n        exportRoot.transform(Object(_geometry__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])().translate(-origin.x, -origin.y));\n        exportRoot.children.push(group);\n\n        const size = bbox.getSize();\n        defaults.width = size.width + \"px\";\n        defaults.height = size.height + \"px\";\n    }\n\n    const surfaceOptions = Object.assign(defaults, options);\n\n    const container = document.createElement(\"div\");\n    const style = container.style;\n\n    style.display = \"none\";\n    style.width = surfaceOptions.width;\n    style.height = surfaceOptions.height;\n    document.body.appendChild(container);\n\n    const surface = new _surface__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"](container, surfaceOptions);\n    surface.suspendTracking();\n    surface.draw(exportRoot);\n\n    const promise = surface.image();\n    const destroy = () => {\n        surface.destroy();\n        document.body.removeChild(container);\n    };\n    promise.then(destroy, destroy);\n\n    return promise;\n}\n\n/***/ }),\n\n/***/ \"wBpk\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _text_metrics_lru_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"kTcp\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return _text_metrics_lru_cache__WEBPACK_IMPORTED_MODULE_0__[\"a\"]; });\n\n/* harmony import */ var _text_metrics_text_metrics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"jQ5i\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return _text_metrics_text_metrics__WEBPACK_IMPORTED_MODULE_1__[\"a\"]; });\n\n/* harmony import */ var _text_metrics_measure_text__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"ouFi\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return _text_metrics_measure_text__WEBPACK_IMPORTED_MODULE_2__[\"a\"]; });\n\n/* harmony import */ var _text_metrics_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"C91f\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return _text_metrics_util__WEBPACK_IMPORTED_MODULE_3__[\"a\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return _text_metrics_util__WEBPACK_IMPORTED_MODULE_3__[\"b\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return _text_metrics_util__WEBPACK_IMPORTED_MODULE_3__[\"c\"]; });\n\n\n\n\n\n\n\n/***/ }),\n\n/***/ \"wJcK\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _core_base_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"ztN+\");\n/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"7Prh\");\n/* harmony import */ var _definition_node__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"7WKN\");\n\n\n\n\nclass RootNode extends _node__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"] {\n    constructor(options) {\n        super();\n        this.options = options;\n        this.defs = new _definition_node__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"]();\n    }\n\n    attachTo(domElement) {\n        this.element = domElement;\n        this.defs.attachTo(domElement.firstElementChild);\n    }\n\n    clear() {\n        _core_base_node__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].prototype.clear.call(this);\n    }\n\n    template() {\n        return this.defs.render() + this.renderChildren();\n    }\n\n    definitionChange(e) {\n        this.defs.definitionChange(e);\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (RootNode);\n\n/***/ }),\n\n/***/ \"wbRH\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return elementsClippedBoundingBox; });\n/* harmony import */ var _geometry_rect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"XJRY\");\n\n\nfunction elementsClippedBoundingBox(elements, transformation) {\n    let boundingBox;\n\n    for (let i = 0; i < elements.length; i++) {\n        let element = elements[i];\n        if (element.visible()) {\n            let elementBoundingBox = element.clippedBBox(transformation);\n            if (elementBoundingBox) {\n                if (boundingBox) {\n                    boundingBox = _geometry_rect__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].union(boundingBox, elementBoundingBox);\n                } else {\n                    boundingBox = elementBoundingBox;\n                }\n            }\n        }\n    }\n\n    return boundingBox;\n}\n\n/***/ }),\n\n/***/ \"wd4i\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return elementSize; });\n/* harmony import */ var _element_styles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"oY8A\");\n/* harmony import */ var _defined__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"VqL+\");\n\n\n\nfunction getPixels(value) {\n    if (isNaN(value)) {\n        return value;\n    }\n    return value + \"px\";\n}\n\nfunction elementSize(element, size) {\n    if (size) {\n        const { width, height } = size;\n\n        if (Object(_defined__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(width)) {\n            element.style.width = getPixels(width);\n        }\n\n        if (Object(_defined__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(height)) {\n            element.style.height = getPixels(height);\n        }\n\n    } else {\n        const size = Object(_element_styles__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(element, [ 'width', 'height' ]);\n\n        return {\n            width: parseInt(size.width, 10),\n            height: parseInt(size.height, 10)\n        };\n    }\n}\n\n/***/ }),\n\n/***/ \"wfnd\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _geometry_arc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"HKF7\");\n/* harmony import */ var _element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"XdXH\");\n/* harmony import */ var _path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"Ah4p\");\n/* harmony import */ var _mixins_paintable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"T3aN\");\n/* harmony import */ var _mixins_measurable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"qNx/\");\n/* harmony import */ var _mixins_with_geometry__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"O6F+\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(\"VqL+\");\n\n\n\n\n\n\n\n\n\nconst DEFAULT_STROKE = \"#000\";\n\nclass Arc extends Object(_mixins_paintable__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(Object(_mixins_measurable__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"])(Object(_mixins_with_geometry__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"])(_element__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"]))) {\n    get nodeType() {\n        return \"Arc\";\n    }\n\n    constructor(geometry = new _geometry_arc__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"](), options = {}) {\n        super(options);\n\n        this.geometry(geometry);\n\n        if (!Object(_util__WEBPACK_IMPORTED_MODULE_6__[/* default */ \"a\"])(this.options.stroke)) {\n            this.stroke(DEFAULT_STROKE);\n        }\n    }\n\n    _bbox(matrix) {\n        return this._geometry.bbox(matrix);\n    }\n\n    rawBBox() {\n        return this.geometry().bbox();\n    }\n\n    toPath() {\n        const path = new _path__WEBPACK_IMPORTED_MODULE_2__[/* Path */ \"b\"]();\n        const curvePoints = this.geometry().curvePoints();\n\n        if (curvePoints.length > 0) {\n            path.moveTo(curvePoints[0].x, curvePoints[0].y);\n\n            for (let i = 1; i < curvePoints.length; i += 3) {\n                path.curveTo(curvePoints[i], curvePoints[i + 1], curvePoints[i + 2]);\n            }\n        }\n\n        return path;\n    }\n\n    _containsPoint(point) {\n        return this.geometry().containsPoint(point);\n    }\n\n    _isOnPath(point) {\n        return this.geometry()._isOnPath(point, this.options.stroke.width / 2);\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Arc);\n\n\n/***/ }),\n\n/***/ \"wm+B\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _shapes_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"XdXH\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return _shapes_element__WEBPACK_IMPORTED_MODULE_0__[\"a\"]; });\n\n/* harmony import */ var _shapes_circle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"Ual8\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return _shapes_circle__WEBPACK_IMPORTED_MODULE_1__[\"a\"]; });\n\n/* harmony import */ var _shapes_arc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"wfnd\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return _shapes_arc__WEBPACK_IMPORTED_MODULE_2__[\"a\"]; });\n\n/* harmony import */ var _shapes_path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"Ah4p\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return _shapes_path__WEBPACK_IMPORTED_MODULE_3__[\"b\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return _shapes_path__WEBPACK_IMPORTED_MODULE_3__[\"a\"]; });\n\n/* harmony import */ var _shapes_text__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"r0sM\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"j\", function() { return _shapes_text__WEBPACK_IMPORTED_MODULE_4__[\"a\"]; });\n\n/* harmony import */ var _shapes_image__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"BK/f\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return _shapes_image__WEBPACK_IMPORTED_MODULE_5__[\"a\"]; });\n\n/* harmony import */ var _shapes_group__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(\"qUqW\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return _shapes_group__WEBPACK_IMPORTED_MODULE_6__[\"a\"]; });\n\n/* harmony import */ var _shapes_layout__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(\"e5dn\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return _shapes_layout__WEBPACK_IMPORTED_MODULE_7__[\"a\"]; });\n\n/* harmony import */ var _shapes_rect__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(\"K3Ik\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"i\", function() { return _shapes_rect__WEBPACK_IMPORTED_MODULE_8__[\"a\"]; });\n\n\n\n\n\n\n\n\n\n\n\n\n/***/ }),\n\n/***/ \"x/GK\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return toMatrix; });\nfunction toMatrix(transformation) {\n    if (transformation && typeof transformation.matrix === \"function\") {\n        return transformation.matrix();\n    }\n\n    return transformation;\n}\n\n/***/ }),\n\n/***/ \"x/aw\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return elementsBoundingBox; });\n/* harmony import */ var _geometry_rect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"XJRY\");\n\n\nfunction elementsBoundingBox(elements, applyTransform, transformation) {\n    let boundingBox;\n\n    for (let i = 0; i < elements.length; i++) {\n        let element = elements[i];\n        if (element.visible()) {\n            let elementBoundingBox = applyTransform ? element.bbox(transformation) : element.rawBBox();\n            if (elementBoundingBox) {\n                if (boundingBox) {\n                    boundingBox = _geometry_rect__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].union(boundingBox, elementBoundingBox);\n                } else {\n                    boundingBox = elementBoundingBox;\n                }\n            }\n        }\n    }\n\n    return boundingBox;\n}\n\n\n\n/***/ }),\n\n/***/ \"xYjD\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"o+K8\");\n/* harmony import */ var _mixins_traversable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"fdcc\");\n\n\n\n\nclass GroupNode extends Object(_mixins_traversable__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"])(_node__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"], \"childNodes\") {\n    renderTo(ctx) {\n        if (!this.visible()) {\n            return;\n        }\n\n        ctx.save();\n\n        this.setTransform(ctx);\n        this.setClip(ctx);\n        this.setOpacity(ctx);\n\n        const childNodes = this.childNodes;\n        for (let i = 0; i < childNodes.length; i++) {\n            let child = childNodes[i];\n            if (child.visible()) {\n                child.renderTo(ctx);\n            }\n        }\n\n        ctx.restore();\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (GroupNode);\n\n\n/***/ }),\n\n/***/ \"yhXd\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _mixins_with_points__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"zZ53\");\n/* harmony import */ var _geometry_point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"lRJa\");\n/* harmony import */ var _gradient__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"4DQW\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"VqL+\");\n\n\n\n\n\n\nclass RadialGradient extends Object(_mixins_with_points__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(_gradient__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"], [ \"center\" ]) {\n    constructor(options = {}) {\n        super(options);\n\n        this.center(options.center || new _geometry_point__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"]());\n        this._radius = Object(_util__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(options.radius) ? options.radius : 1;\n        this._fallbackFill = options.fallbackFill;\n    }\n\n    radius(value) {\n        if (Object(_util__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(value)) {\n            this._radius = value;\n            this.geometryChange();\n            return this;\n        }\n\n        return this._radius;\n    }\n\n    fallbackFill(value) {\n        if (Object(_util__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"])(value)) {\n            this._fallbackFill = value;\n            this.optionsChange();\n            return this;\n        }\n\n        return this._fallbackFill;\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (RadialGradient);\n\n\n/***/ }),\n\n/***/ \"zZ53\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"VqL+\");\n/* harmony import */ var _geometry_point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"lRJa\");\n\n\n\nfunction pointAccessor(name) {\n    const fieldName = \"_\" + name;\n    return function(value) {\n        if (Object(_util__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"])(value)) {\n            this._observerField(fieldName, _geometry_point__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"].create(value));\n            this.geometryChange();\n            return this;\n        }\n\n        return this[fieldName];\n    };\n}\n\nfunction definePointAccessors(fn, names) {\n    for (let i = 0; i < names.length; i++) {\n        fn[names[i]] = pointAccessor(names[i]);\n    }\n}\n\nconst withPoints = (TBase, names) => {\n    const result = class extends TBase {};\n    definePointAccessors(result.prototype, names);\n\n    return result;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (withPoints);\n\n\n/***/ }),\n\n/***/ \"ztN+\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"LHUb\");\n\n\nclass BaseNode extends _common__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"] {\n    constructor(srcElement) {\n        super();\n\n        this.childNodes = [];\n        this.parent = null;\n\n        if (srcElement) {\n            this.srcElement = srcElement;\n            this.observe();\n        }\n    }\n\n    destroy() {\n        if (this.srcElement) {\n            this.srcElement.removeObserver(this);\n        }\n\n        const children = this.childNodes;\n        for (let i = 0; i < children.length; i++) {\n            this.childNodes[i].destroy();\n        }\n\n        this.parent = null;\n    }\n\n    load() {}\n\n    observe() {\n        if (this.srcElement) {\n            this.srcElement.addObserver(this);\n        }\n    }\n\n    append(node) {\n        this.childNodes.push(node);\n        node.parent = this;\n    }\n\n    insertAt(node, pos) {\n        this.childNodes.splice(pos, 0, node);\n        node.parent = this;\n    }\n\n    remove(index, count) {\n        const end = index + count;\n        for (let i = index; i < end; i++) {\n            this.childNodes[i].removeSelf();\n        }\n        this.childNodes.splice(index, count);\n    }\n\n    removeSelf() {\n        this.clear();\n        this.destroy();\n    }\n\n    clear() {\n        this.remove(0, this.childNodes.length);\n    }\n\n    invalidate() {\n        if (this.parent) {\n            this.parent.invalidate();\n        }\n    }\n\n    geometryChange() {\n        this.invalidate();\n    }\n\n    optionsChange() {\n        this.invalidate();\n    }\n\n    childrenChange(e) {\n        if (e.action === \"add\") {\n            this.load(e.items, e.index);\n        } else if (e.action === \"remove\") {\n            this.remove(e.index, e.items.length);\n        }\n\n        this.invalidate();\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (BaseNode);\n\n/***/ })\n\n}]);","inputSourceMap":null}