{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{\"5+WD\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return drag_drop_CdkDrag}),__webpack_require__.d(__webpack_exports__,\"b\",function(){return drag_drop_CdkDropList}),__webpack_require__.d(__webpack_exports__,\"c\",function(){return drag_drop_DragDropModule}),__webpack_require__.d(__webpack_exports__,\"d\",function(){return moveItemInArray});var core=__webpack_require__(\"fXoL\"),common=__webpack_require__(\"ofXK\"),scrolling=__webpack_require__(\"vxfF\"),platform=__webpack_require__(\"nLfN\"),coercion=__webpack_require__(\"8LU1\"),Subject=__webpack_require__(\"XNiG\"),Subscription=__webpack_require__(\"quSY\"),Observable=__webpack_require__(\"HDdC\"),scheduler_async=__webpack_require__(\"D0XW\"),isNumeric=__webpack_require__(\"Y7HM\");function dispatch(state){const{subscriber:subscriber,counter:counter,period:period}=state;subscriber.next(counter),this.schedule({subscriber:subscriber,counter:counter+1,period:period},period)}var animationFrame=__webpack_require__(\"eNwd\"),merge=__webpack_require__(\"VRyK\"),takeUntil=__webpack_require__(\"1G5W\"),startWith=__webpack_require__(\"JX91\"),map=__webpack_require__(\"lJxs\"),take=__webpack_require__(\"IzEk\"),tap=__webpack_require__(\"vkgz\"),switchMap=__webpack_require__(\"eIep\"),bidi=__webpack_require__(\"cH1L\");function extendStyles(dest,source){for(let key in source)source.hasOwnProperty(key)&&(dest[key]=source[key]);return dest}function toggleNativeDragInteractions(element,enable){const userSelect=enable?\"\":\"none\";extendStyles(element.style,{touchAction:enable?\"\":\"none\",webkitUserDrag:enable?\"\":\"none\",webkitTapHighlightColor:enable?\"\":\"transparent\",userSelect:userSelect,msUserSelect:userSelect,webkitUserSelect:userSelect,MozUserSelect:userSelect})}function toggleVisibility(element,enable){const styles=element.style;styles.position=enable?\"\":\"fixed\",styles.top=styles.opacity=enable?\"\":\"0\",styles.left=enable?\"\":\"-999em\"}function parseCssTimeUnitsToMs(value){const multiplier=value.toLowerCase().indexOf(\"ms\")>-1?1:1e3;return parseFloat(value)*multiplier}function parseCssPropertyValue(computedStyle,name){return computedStyle.getPropertyValue(name).split(\",\").map(part=>part.trim())}function getMutableClientRect(element){const clientRect=element.getBoundingClientRect();return{top:clientRect.top,right:clientRect.right,bottom:clientRect.bottom,left:clientRect.left,width:clientRect.width,height:clientRect.height}}function isInsideClientRect(clientRect,x,y){const{top:top,bottom:bottom,left:left,right:right}=clientRect;return y>=top&&y<=bottom&&x>=left&&x<=right}function adjustClientRect(clientRect,top,left){clientRect.top+=top,clientRect.bottom=clientRect.top+clientRect.height,clientRect.left+=left,clientRect.right=clientRect.left+clientRect.width}function isPointerNearClientRect(rect,threshold,pointerX,pointerY){const{top:top,right:right,bottom:bottom,left:left,width:width,height:height}=rect,xThreshold=width*threshold,yThreshold=height*threshold;return pointerY>top-yThreshold&&pointerY<bottom+yThreshold&&pointerX>left-xThreshold&&pointerX<right+xThreshold}class ParentPositionTracker{constructor(_document,_viewportRuler){this._document=_document,this._viewportRuler=_viewportRuler,this.positions=new Map}clear(){this.positions.clear()}cache(elements){this.clear(),this.positions.set(this._document,{scrollPosition:this._viewportRuler.getViewportScrollPosition()}),elements.forEach(element=>{this.positions.set(element,{scrollPosition:{top:element.scrollTop,left:element.scrollLeft},clientRect:getMutableClientRect(element)})})}handleScroll(event){const target=event.target,cachedPosition=this.positions.get(target);if(!cachedPosition)return null;const scrolledParentNode=target===this._document?target.documentElement:target,scrollPosition=cachedPosition.scrollPosition;let newTop,newLeft;if(target===this._document){const viewportScrollPosition=this._viewportRuler.getViewportScrollPosition();newTop=viewportScrollPosition.top,newLeft=viewportScrollPosition.left}else newTop=target.scrollTop,newLeft=target.scrollLeft;const topDifference=scrollPosition.top-newTop,leftDifference=scrollPosition.left-newLeft;return this.positions.forEach((position,node)=>{position.clientRect&&target!==node&&scrolledParentNode.contains(node)&&adjustClientRect(position.clientRect,topDifference,leftDifference)}),scrollPosition.top=newTop,scrollPosition.left=newLeft,{top:topDifference,left:leftDifference}}}function deepCloneNode(node){const clone=node.cloneNode(!0),descendantsWithId=clone.querySelectorAll(\"[id]\"),nodeName=node.nodeName.toLowerCase();clone.removeAttribute(\"id\");for(let i=0;i<descendantsWithId.length;i++)descendantsWithId[i].removeAttribute(\"id\");return\"canvas\"===nodeName?transferCanvasData(node,clone):\"input\"!==nodeName&&\"select\"!==nodeName&&\"textarea\"!==nodeName||transferInputData(node,clone),transferData(\"canvas\",node,clone,transferCanvasData),transferData(\"input, textarea, select\",node,clone,transferInputData),clone}function transferData(selector,node,clone,callback){const descendantElements=node.querySelectorAll(selector);if(descendantElements.length){const cloneElements=clone.querySelectorAll(selector);for(let i=0;i<descendantElements.length;i++)callback(descendantElements[i],cloneElements[i])}}let cloneUniqueId=0;function transferInputData(source,clone){\"file\"!==clone.type&&(clone.value=source.value),\"radio\"===clone.type&&clone.name&&(clone.name=`mat-clone-${clone.name}-${cloneUniqueId++}`)}function transferCanvasData(source,clone){const context=clone.getContext(\"2d\");if(context)try{context.drawImage(source,0,0)}catch(_a){}}const passiveEventListenerOptions=Object(platform.f)({passive:!0}),activeEventListenerOptions=Object(platform.f)({passive:!1});class drag_drop_DragRef{constructor(element,_config,_document,_ngZone,_viewportRuler,_dragDropRegistry){this._config=_config,this._document=_document,this._ngZone=_ngZone,this._viewportRuler=_viewportRuler,this._dragDropRegistry=_dragDropRegistry,this._passiveTransform={x:0,y:0},this._activeTransform={x:0,y:0},this._moveEvents=new Subject.a,this._pointerMoveSubscription=Subscription.a.EMPTY,this._pointerUpSubscription=Subscription.a.EMPTY,this._scrollSubscription=Subscription.a.EMPTY,this._resizeSubscription=Subscription.a.EMPTY,this._boundaryElement=null,this._nativeInteractionsEnabled=!0,this._handles=[],this._disabledHandles=new Set,this._direction=\"ltr\",this.dragStartDelay=0,this._disabled=!1,this.beforeStarted=new Subject.a,this.started=new Subject.a,this.released=new Subject.a,this.ended=new Subject.a,this.entered=new Subject.a,this.exited=new Subject.a,this.dropped=new Subject.a,this.moved=this._moveEvents,this._pointerDown=event=>{if(this.beforeStarted.next(),this._handles.length){const targetHandle=this._handles.find(handle=>{const target=event.target;return!!target&&(target===handle||handle.contains(target))});!targetHandle||this._disabledHandles.has(targetHandle)||this.disabled||this._initializeDragSequence(targetHandle,event)}else this.disabled||this._initializeDragSequence(this._rootElement,event)},this._pointerMove=event=>{event.preventDefault();const pointerPosition=this._getPointerPositionOnPage(event);if(!this._hasStartedDragging){if(Math.abs(pointerPosition.x-this._pickupPositionOnPage.x)+Math.abs(pointerPosition.y-this._pickupPositionOnPage.y)>=this._config.dragStartThreshold){const isDelayElapsed=Date.now()>=this._dragStartTime+this._getDragStartDelay(event),container=this._dropContainer;if(!isDelayElapsed)return void this._endDragSequence(event);container&&(container.isDragging()||container.isReceiving())||(this._hasStartedDragging=!0,this._ngZone.run(()=>this._startDragSequence(event)))}return}this._boundaryElement&&(this._previewRect&&(this._previewRect.width||this._previewRect.height)||(this._previewRect=(this._preview||this._rootElement).getBoundingClientRect()));const constrainedPointerPosition=this._getConstrainedPointerPosition(pointerPosition);if(this._hasMoved=!0,this._lastKnownPointerPosition=pointerPosition,this._updatePointerDirectionDelta(constrainedPointerPosition),this._dropContainer)this._updateActiveDropContainer(constrainedPointerPosition,pointerPosition);else{const activeTransform=this._activeTransform;activeTransform.x=constrainedPointerPosition.x-this._pickupPositionOnPage.x+this._passiveTransform.x,activeTransform.y=constrainedPointerPosition.y-this._pickupPositionOnPage.y+this._passiveTransform.y,this._applyRootElementTransform(activeTransform.x,activeTransform.y),\"undefined\"!=typeof SVGElement&&this._rootElement instanceof SVGElement&&this._rootElement.setAttribute(\"transform\",`translate(${activeTransform.x} ${activeTransform.y})`)}this._moveEvents.observers.length&&this._ngZone.run(()=>{this._moveEvents.next({source:this,pointerPosition:constrainedPointerPosition,event:event,distance:this._getDragDistance(constrainedPointerPosition),delta:this._pointerDirectionDelta})})},this._pointerUp=event=>{this._endDragSequence(event)},this.withRootElement(element),this._parentPositions=new ParentPositionTracker(_document,_viewportRuler),_dragDropRegistry.registerDragItem(this)}get disabled(){return this._disabled||!(!this._dropContainer||!this._dropContainer.disabled)}set disabled(value){const newValue=Object(coercion.c)(value);newValue!==this._disabled&&(this._disabled=newValue,this._toggleNativeDragInteractions(),this._handles.forEach(handle=>toggleNativeDragInteractions(handle,newValue)))}getPlaceholderElement(){return this._placeholder}getRootElement(){return this._rootElement}getVisibleElement(){return this.isDragging()?this.getPlaceholderElement():this.getRootElement()}withHandles(handles){this._handles=handles.map(handle=>Object(coercion.e)(handle)),this._handles.forEach(handle=>toggleNativeDragInteractions(handle,this.disabled)),this._toggleNativeDragInteractions();const disabledHandles=new Set;return this._disabledHandles.forEach(handle=>{this._handles.indexOf(handle)>-1&&disabledHandles.add(handle)}),this._disabledHandles=disabledHandles,this}withPreviewTemplate(template){return this._previewTemplate=template,this}withPlaceholderTemplate(template){return this._placeholderTemplate=template,this}withRootElement(rootElement){const element=Object(coercion.e)(rootElement);return element!==this._rootElement&&(this._rootElement&&this._removeRootElementListeners(this._rootElement),this._ngZone.runOutsideAngular(()=>{element.addEventListener(\"mousedown\",this._pointerDown,activeEventListenerOptions),element.addEventListener(\"touchstart\",this._pointerDown,passiveEventListenerOptions)}),this._initialTransform=void 0,this._rootElement=element),\"undefined\"!=typeof SVGElement&&this._rootElement instanceof SVGElement&&(this._ownerSVGElement=this._rootElement.ownerSVGElement),this}withBoundaryElement(boundaryElement){return this._boundaryElement=boundaryElement?Object(coercion.e)(boundaryElement):null,this._resizeSubscription.unsubscribe(),boundaryElement&&(this._resizeSubscription=this._viewportRuler.change(10).subscribe(()=>this._containInsideBoundaryOnResize())),this}dispose(){this._removeRootElementListeners(this._rootElement),this.isDragging()&&removeNode(this._rootElement),removeNode(this._anchor),this._destroyPreview(),this._destroyPlaceholder(),this._dragDropRegistry.removeDragItem(this),this._removeSubscriptions(),this.beforeStarted.complete(),this.started.complete(),this.released.complete(),this.ended.complete(),this.entered.complete(),this.exited.complete(),this.dropped.complete(),this._moveEvents.complete(),this._handles=[],this._disabledHandles.clear(),this._dropContainer=void 0,this._resizeSubscription.unsubscribe(),this._parentPositions.clear(),this._boundaryElement=this._rootElement=this._ownerSVGElement=this._placeholderTemplate=this._previewTemplate=this._anchor=null}isDragging(){return this._hasStartedDragging&&this._dragDropRegistry.isDragging(this)}reset(){this._rootElement.style.transform=this._initialTransform||\"\",this._activeTransform={x:0,y:0},this._passiveTransform={x:0,y:0}}disableHandle(handle){!this._disabledHandles.has(handle)&&this._handles.indexOf(handle)>-1&&(this._disabledHandles.add(handle),toggleNativeDragInteractions(handle,!0))}enableHandle(handle){this._disabledHandles.has(handle)&&(this._disabledHandles.delete(handle),toggleNativeDragInteractions(handle,this.disabled))}withDirection(direction){return this._direction=direction,this}_withDropContainer(container){this._dropContainer=container}getFreeDragPosition(){const position=this.isDragging()?this._activeTransform:this._passiveTransform;return{x:position.x,y:position.y}}setFreeDragPosition(value){return this._activeTransform={x:0,y:0},this._passiveTransform.x=value.x,this._passiveTransform.y=value.y,this._dropContainer||this._applyRootElementTransform(value.x,value.y),this}_sortFromLastPointerPosition(){const position=this._lastKnownPointerPosition;position&&this._dropContainer&&this._updateActiveDropContainer(this._getConstrainedPointerPosition(position),position)}_removeSubscriptions(){this._pointerMoveSubscription.unsubscribe(),this._pointerUpSubscription.unsubscribe(),this._scrollSubscription.unsubscribe()}_destroyPreview(){this._preview&&removeNode(this._preview),this._previewRef&&this._previewRef.destroy(),this._preview=this._previewRef=null}_destroyPlaceholder(){this._placeholder&&removeNode(this._placeholder),this._placeholderRef&&this._placeholderRef.destroy(),this._placeholder=this._placeholderRef=null}_endDragSequence(event){this._dragDropRegistry.isDragging(this)&&(this._removeSubscriptions(),this._dragDropRegistry.stopDragging(this),this._toggleNativeDragInteractions(),this._handles&&(this._rootElement.style.webkitTapHighlightColor=this._rootElementTapHighlight),this._hasStartedDragging&&(this.released.next({source:this}),this._dropContainer?(this._dropContainer._stopScrolling(),this._animatePreviewToPlaceholder().then(()=>{this._cleanupDragArtifacts(event),this._cleanupCachedDimensions(),this._dragDropRegistry.stopDragging(this)})):(this._passiveTransform.x=this._activeTransform.x,this._passiveTransform.y=this._activeTransform.y,this._ngZone.run(()=>{this.ended.next({source:this,distance:this._getDragDistance(this._getPointerPositionOnPage(event))})}),this._cleanupCachedDimensions(),this._dragDropRegistry.stopDragging(this))))}_startDragSequence(event){isTouchEvent(event)&&(this._lastTouchEventTime=Date.now()),this._toggleNativeDragInteractions();const dropContainer=this._dropContainer;if(dropContainer){const element=this._rootElement,parent=element.parentNode,preview=this._preview=this._createPreviewElement(),placeholder=this._placeholder=this._createPlaceholderElement(),anchor=this._anchor=this._anchor||this._document.createComment(\"\"),shadowRoot=this._getShadowRoot();parent.insertBefore(anchor,element),toggleVisibility(element,!1),this._document.body.appendChild(parent.replaceChild(placeholder,element)),function(documentRef,shadowRoot){return shadowRoot||documentRef.fullscreenElement||documentRef.webkitFullscreenElement||documentRef.mozFullScreenElement||documentRef.msFullscreenElement||documentRef.body}(this._document,shadowRoot).appendChild(preview),this.started.next({source:this}),dropContainer.start(),this._initialContainer=dropContainer,this._initialIndex=dropContainer.getItemIndex(this)}else this.started.next({source:this}),this._initialContainer=this._initialIndex=void 0;this._parentPositions.cache(dropContainer?dropContainer.getScrollableParents():[])}_initializeDragSequence(referenceElement,event){event.stopPropagation();const isDragging=this.isDragging(),isTouchSequence=isTouchEvent(event),isAuxiliaryMouseButton=!isTouchSequence&&0!==event.button,rootElement=this._rootElement,isSyntheticEvent=!isTouchSequence&&this._lastTouchEventTime&&this._lastTouchEventTime+800>Date.now();if(event.target&&event.target.draggable&&\"mousedown\"===event.type&&event.preventDefault(),isDragging||isAuxiliaryMouseButton||isSyntheticEvent)return;this._handles.length&&(this._rootElementTapHighlight=rootElement.style.webkitTapHighlightColor||\"\",rootElement.style.webkitTapHighlightColor=\"transparent\"),this._hasStartedDragging=this._hasMoved=!1,this._removeSubscriptions(),this._pointerMoveSubscription=this._dragDropRegistry.pointerMove.subscribe(this._pointerMove),this._pointerUpSubscription=this._dragDropRegistry.pointerUp.subscribe(this._pointerUp),this._scrollSubscription=this._dragDropRegistry.scroll.subscribe(scrollEvent=>{this._updateOnScroll(scrollEvent)}),this._boundaryElement&&(this._boundaryRect=getMutableClientRect(this._boundaryElement));const previewTemplate=this._previewTemplate;this._pickupPositionInElement=previewTemplate&&previewTemplate.template&&!previewTemplate.matchSize?{x:0,y:0}:this._getPointerPositionInElement(referenceElement,event);const pointerPosition=this._pickupPositionOnPage=this._lastKnownPointerPosition=this._getPointerPositionOnPage(event);this._pointerDirectionDelta={x:0,y:0},this._pointerPositionAtLastDirectionChange={x:pointerPosition.x,y:pointerPosition.y},this._dragStartTime=Date.now(),this._dragDropRegistry.startDragging(this,event)}_cleanupDragArtifacts(event){toggleVisibility(this._rootElement,!0),this._anchor.parentNode.replaceChild(this._rootElement,this._anchor),this._destroyPreview(),this._destroyPlaceholder(),this._boundaryRect=this._previewRect=void 0,this._ngZone.run(()=>{const container=this._dropContainer,currentIndex=container.getItemIndex(this),pointerPosition=this._getPointerPositionOnPage(event),distance=this._getDragDistance(this._getPointerPositionOnPage(event)),isPointerOverContainer=container._isOverContainer(pointerPosition.x,pointerPosition.y);this.ended.next({source:this,distance:distance}),this.dropped.next({item:this,currentIndex:currentIndex,previousIndex:this._initialIndex,container:container,previousContainer:this._initialContainer,isPointerOverContainer:isPointerOverContainer,distance:distance}),container.drop(this,currentIndex,this._initialIndex,this._initialContainer,isPointerOverContainer,distance),this._dropContainer=this._initialContainer})}_updateActiveDropContainer({x:x,y:y},{x:rawX,y:rawY}){let newContainer=this._initialContainer._getSiblingContainerFromPosition(this,x,y);!newContainer&&this._dropContainer!==this._initialContainer&&this._initialContainer._isOverContainer(x,y)&&(newContainer=this._initialContainer),newContainer&&newContainer!==this._dropContainer&&this._ngZone.run(()=>{this.exited.next({item:this,container:this._dropContainer}),this._dropContainer.exit(this),this._dropContainer=newContainer,this._dropContainer.enter(this,x,y,newContainer===this._initialContainer&&newContainer.sortingDisabled?this._initialIndex:void 0),this.entered.next({item:this,container:newContainer,currentIndex:newContainer.getItemIndex(this)})}),this._dropContainer._startScrollingIfNecessary(rawX,rawY),this._dropContainer._sortItem(this,x,y,this._pointerDirectionDelta),this._preview.style.transform=getTransform(x-this._pickupPositionInElement.x,y-this._pickupPositionInElement.y)}_createPreviewElement(){const previewConfig=this._previewTemplate,previewClass=this.previewClass,previewTemplate=previewConfig?previewConfig.template:null;let preview;if(previewTemplate&&previewConfig){const rootRect=previewConfig.matchSize?this._rootElement.getBoundingClientRect():null,viewRef=previewConfig.viewContainer.createEmbeddedView(previewTemplate,previewConfig.context);viewRef.detectChanges(),preview=getRootNode(viewRef,this._document),this._previewRef=viewRef,previewConfig.matchSize?matchElementSize(preview,rootRect):preview.style.transform=getTransform(this._pickupPositionOnPage.x,this._pickupPositionOnPage.y)}else{const element=this._rootElement;preview=deepCloneNode(element),matchElementSize(preview,element.getBoundingClientRect())}return extendStyles(preview.style,{pointerEvents:\"none\",margin:\"0\",position:\"fixed\",top:\"0\",left:\"0\",zIndex:\"\"+(this._config.zIndex||1e3)}),toggleNativeDragInteractions(preview,!1),preview.classList.add(\"cdk-drag-preview\"),preview.setAttribute(\"dir\",this._direction),previewClass&&(Array.isArray(previewClass)?previewClass.forEach(className=>preview.classList.add(className)):preview.classList.add(previewClass)),preview}_animatePreviewToPlaceholder(){if(!this._hasMoved)return Promise.resolve();const placeholderRect=this._placeholder.getBoundingClientRect();this._preview.classList.add(\"cdk-drag-animating\"),this._preview.style.transform=getTransform(placeholderRect.left,placeholderRect.top);const duration=function(element){const computedStyle=getComputedStyle(element),transitionedProperties=parseCssPropertyValue(computedStyle,\"transition-property\"),property=transitionedProperties.find(prop=>\"transform\"===prop||\"all\"===prop);if(!property)return 0;const propertyIndex=transitionedProperties.indexOf(property),rawDurations=parseCssPropertyValue(computedStyle,\"transition-duration\"),rawDelays=parseCssPropertyValue(computedStyle,\"transition-delay\");return parseCssTimeUnitsToMs(rawDurations[propertyIndex])+parseCssTimeUnitsToMs(rawDelays[propertyIndex])}(this._preview);return 0===duration?Promise.resolve():this._ngZone.runOutsideAngular(()=>new Promise(resolve=>{const handler=event=>{(!event||event.target===this._preview&&\"transform\"===event.propertyName)&&(this._preview.removeEventListener(\"transitionend\",handler),resolve(),clearTimeout(timeout))},timeout=setTimeout(handler,1.5*duration);this._preview.addEventListener(\"transitionend\",handler)}))}_createPlaceholderElement(){const placeholderConfig=this._placeholderTemplate,placeholderTemplate=placeholderConfig?placeholderConfig.template:null;let placeholder;return placeholderTemplate?(this._placeholderRef=placeholderConfig.viewContainer.createEmbeddedView(placeholderTemplate,placeholderConfig.context),this._placeholderRef.detectChanges(),placeholder=getRootNode(this._placeholderRef,this._document)):placeholder=deepCloneNode(this._rootElement),placeholder.classList.add(\"cdk-drag-placeholder\"),placeholder}_getPointerPositionInElement(referenceElement,event){const elementRect=this._rootElement.getBoundingClientRect(),handleElement=referenceElement===this._rootElement?null:referenceElement,referenceRect=handleElement?handleElement.getBoundingClientRect():elementRect,point=isTouchEvent(event)?event.targetTouches[0]:event,scrollPosition=this._getViewportScrollPosition();return{x:referenceRect.left-elementRect.left+(point.pageX-referenceRect.left-scrollPosition.left),y:referenceRect.top-elementRect.top+(point.pageY-referenceRect.top-scrollPosition.top)}}_getPointerPositionOnPage(event){const scrollPosition=this._getViewportScrollPosition(),point=isTouchEvent(event)?event.touches[0]||event.changedTouches[0]||{pageX:0,pageY:0}:event,x=point.pageX-scrollPosition.left,y=point.pageY-scrollPosition.top;if(this._ownerSVGElement){const svgMatrix=this._ownerSVGElement.getScreenCTM();if(svgMatrix){const svgPoint=this._ownerSVGElement.createSVGPoint();return svgPoint.x=x,svgPoint.y=y,svgPoint.matrixTransform(svgMatrix.inverse())}}return{x:x,y:y}}_getConstrainedPointerPosition(point){const dropContainerLock=this._dropContainer?this._dropContainer.lockAxis:null;let{x:x,y:y}=this.constrainPosition?this.constrainPosition(point,this):point;if(\"x\"===this.lockAxis||\"x\"===dropContainerLock?y=this._pickupPositionOnPage.y:\"y\"!==this.lockAxis&&\"y\"!==dropContainerLock||(x=this._pickupPositionOnPage.x),this._boundaryRect){const{x:pickupX,y:pickupY}=this._pickupPositionInElement,boundaryRect=this._boundaryRect,previewRect=this._previewRect,minY=boundaryRect.top+pickupY,maxY=boundaryRect.bottom-(previewRect.height-pickupY);x=clamp(x,boundaryRect.left+pickupX,boundaryRect.right-(previewRect.width-pickupX)),y=clamp(y,minY,maxY)}return{x:x,y:y}}_updatePointerDirectionDelta(pointerPositionOnPage){const{x:x,y:y}=pointerPositionOnPage,delta=this._pointerDirectionDelta,positionSinceLastChange=this._pointerPositionAtLastDirectionChange,changeX=Math.abs(x-positionSinceLastChange.x),changeY=Math.abs(y-positionSinceLastChange.y);return changeX>this._config.pointerDirectionChangeThreshold&&(delta.x=x>positionSinceLastChange.x?1:-1,positionSinceLastChange.x=x),changeY>this._config.pointerDirectionChangeThreshold&&(delta.y=y>positionSinceLastChange.y?1:-1,positionSinceLastChange.y=y),delta}_toggleNativeDragInteractions(){if(!this._rootElement||!this._handles)return;const shouldEnable=this._handles.length>0||!this.isDragging();shouldEnable!==this._nativeInteractionsEnabled&&(this._nativeInteractionsEnabled=shouldEnable,toggleNativeDragInteractions(this._rootElement,shouldEnable))}_removeRootElementListeners(element){element.removeEventListener(\"mousedown\",this._pointerDown,activeEventListenerOptions),element.removeEventListener(\"touchstart\",this._pointerDown,passiveEventListenerOptions)}_applyRootElementTransform(x,y){const transform=getTransform(x,y);null==this._initialTransform&&(this._initialTransform=this._rootElement.style.transform||\"\"),this._rootElement.style.transform=this._initialTransform?transform+\" \"+this._initialTransform:transform}_getDragDistance(currentPosition){const pickupPosition=this._pickupPositionOnPage;return pickupPosition?{x:currentPosition.x-pickupPosition.x,y:currentPosition.y-pickupPosition.y}:{x:0,y:0}}_cleanupCachedDimensions(){this._boundaryRect=this._previewRect=void 0,this._parentPositions.clear()}_containInsideBoundaryOnResize(){let{x:x,y:y}=this._passiveTransform;if(0===x&&0===y||this.isDragging()||!this._boundaryElement)return;const boundaryRect=this._boundaryElement.getBoundingClientRect(),elementRect=this._rootElement.getBoundingClientRect();if(0===boundaryRect.width&&0===boundaryRect.height||0===elementRect.width&&0===elementRect.height)return;const leftOverflow=boundaryRect.left-elementRect.left,rightOverflow=elementRect.right-boundaryRect.right,topOverflow=boundaryRect.top-elementRect.top,bottomOverflow=elementRect.bottom-boundaryRect.bottom;boundaryRect.width>elementRect.width?(leftOverflow>0&&(x+=leftOverflow),rightOverflow>0&&(x-=rightOverflow)):x=0,boundaryRect.height>elementRect.height?(topOverflow>0&&(y+=topOverflow),bottomOverflow>0&&(y-=bottomOverflow)):y=0,x===this._passiveTransform.x&&y===this._passiveTransform.y||this.setFreeDragPosition({y:y,x:x})}_getDragStartDelay(event){const value=this.dragStartDelay;return\"number\"==typeof value?value:isTouchEvent(event)?value.touch:value?value.mouse:0}_updateOnScroll(event){const scrollDifference=this._parentPositions.handleScroll(event);if(scrollDifference){const target=event.target;this._boundaryRect&&(target===this._document||target!==this._boundaryElement&&target.contains(this._boundaryElement))&&adjustClientRect(this._boundaryRect,scrollDifference.top,scrollDifference.left),this._pickupPositionOnPage.x+=scrollDifference.left,this._pickupPositionOnPage.y+=scrollDifference.top,this._dropContainer||(this._activeTransform.x-=scrollDifference.left,this._activeTransform.y-=scrollDifference.top,this._applyRootElementTransform(this._activeTransform.x,this._activeTransform.y))}}_getViewportScrollPosition(){const cachedPosition=this._parentPositions.positions.get(this._document);return cachedPosition?cachedPosition.scrollPosition:this._viewportRuler.getViewportScrollPosition()}_getShadowRoot(){return void 0===this._cachedShadowRoot&&(this._cachedShadowRoot=Object(platform.c)(this._rootElement)),this._cachedShadowRoot}}function getTransform(x,y){return`translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`}function clamp(value,min,max){return Math.max(min,Math.min(max,value))}function removeNode(node){node&&node.parentNode&&node.parentNode.removeChild(node)}function isTouchEvent(event){return\"t\"===event.type[0]}function getRootNode(viewRef,_document){const rootNodes=viewRef.rootNodes;if(1===rootNodes.length&&rootNodes[0].nodeType===_document.ELEMENT_NODE)return rootNodes[0];const wrapper=_document.createElement(\"div\");return rootNodes.forEach(node=>wrapper.appendChild(node)),wrapper}function matchElementSize(target,sourceRect){target.style.width=sourceRect.width+\"px\",target.style.height=sourceRect.height+\"px\",target.style.transform=getTransform(sourceRect.left,sourceRect.top)}function moveItemInArray(array,fromIndex,toIndex){const from=clamp$1(fromIndex,array.length-1),to=clamp$1(toIndex,array.length-1);if(from===to)return;const target=array[from],delta=to<from?-1:1;for(let i=from;i!==to;i+=delta)array[i]=array[i+delta];array[to]=target}function clamp$1(value,max){return Math.max(0,Math.min(max,value))}class drag_drop_DropListRef{constructor(element,_dragDropRegistry,_document,_ngZone,_viewportRuler){this._dragDropRegistry=_dragDropRegistry,this._ngZone=_ngZone,this._viewportRuler=_viewportRuler,this.disabled=!1,this.sortingDisabled=!1,this.autoScrollDisabled=!1,this.enterPredicate=()=>!0,this.sortPredicate=()=>!0,this.beforeStarted=new Subject.a,this.entered=new Subject.a,this.exited=new Subject.a,this.dropped=new Subject.a,this.sorted=new Subject.a,this._isDragging=!1,this._itemPositions=[],this._previousSwap={drag:null,delta:0,overlaps:!1},this._siblings=[],this._orientation=\"vertical\",this._activeSiblings=new Set,this._direction=\"ltr\",this._viewportScrollSubscription=Subscription.a.EMPTY,this._verticalScrollDirection=0,this._horizontalScrollDirection=0,this._stopScrollTimers=new Subject.a,this._cachedShadowRoot=null,this._startScrollInterval=()=>{this._stopScrolling(),function(period=0,scheduler=scheduler_async.a){return(!Object(isNumeric.a)(period)||period<0)&&(period=0),scheduler&&\"function\"==typeof scheduler.schedule||(scheduler=scheduler_async.a),new Observable.a(subscriber=>(subscriber.add(scheduler.schedule(dispatch,period,{subscriber:subscriber,counter:0,period:period})),subscriber))}(0,animationFrame.a).pipe(Object(takeUntil.a)(this._stopScrollTimers)).subscribe(()=>{const node=this._scrollNode;1===this._verticalScrollDirection?incrementVerticalScroll(node,-2):2===this._verticalScrollDirection&&incrementVerticalScroll(node,2),1===this._horizontalScrollDirection?incrementHorizontalScroll(node,-2):2===this._horizontalScrollDirection&&incrementHorizontalScroll(node,2)})},this.element=Object(coercion.e)(element),this._document=_document,this.withScrollableParents([this.element]),_dragDropRegistry.registerDropContainer(this),this._parentPositions=new ParentPositionTracker(_document,_viewportRuler)}dispose(){this._stopScrolling(),this._stopScrollTimers.complete(),this._viewportScrollSubscription.unsubscribe(),this.beforeStarted.complete(),this.entered.complete(),this.exited.complete(),this.dropped.complete(),this.sorted.complete(),this._activeSiblings.clear(),this._scrollNode=null,this._parentPositions.clear(),this._dragDropRegistry.removeDropContainer(this)}isDragging(){return this._isDragging}start(){const styles=Object(coercion.e)(this.element).style;this.beforeStarted.next(),this._isDragging=!0,this._initialScrollSnap=styles.msScrollSnapType||styles.scrollSnapType||\"\",styles.scrollSnapType=styles.msScrollSnapType=\"none\",this._cacheItems(),this._siblings.forEach(sibling=>sibling._startReceiving(this)),this._viewportScrollSubscription.unsubscribe(),this._listenToScrollEvents()}enter(item,pointerX,pointerY,index){let newIndex;this.start(),null==index?(newIndex=this.sortingDisabled?this._draggables.indexOf(item):-1,-1===newIndex&&(newIndex=this._getItemIndexFromPointerPosition(item,pointerX,pointerY))):newIndex=index;const activeDraggables=this._activeDraggables,currentIndex=activeDraggables.indexOf(item),placeholder=item.getPlaceholderElement();let newPositionReference=activeDraggables[newIndex];if(newPositionReference===item&&(newPositionReference=activeDraggables[newIndex+1]),currentIndex>-1&&activeDraggables.splice(currentIndex,1),newPositionReference&&!this._dragDropRegistry.isDragging(newPositionReference)){const element=newPositionReference.getRootElement();element.parentElement.insertBefore(placeholder,element),activeDraggables.splice(newIndex,0,item)}else if(this._shouldEnterAsFirstChild(pointerX,pointerY)){const reference=activeDraggables[0].getRootElement();reference.parentNode.insertBefore(placeholder,reference),activeDraggables.unshift(item)}else Object(coercion.e)(this.element).appendChild(placeholder),activeDraggables.push(item);placeholder.style.transform=\"\",this._cacheItemPositions(),this._cacheParentPositions(),this.entered.next({item:item,container:this,currentIndex:this.getItemIndex(item)})}exit(item){this._reset(),this.exited.next({item:item,container:this})}drop(item,currentIndex,previousIndex,previousContainer,isPointerOverContainer,distance){this._reset(),this.dropped.next({item:item,currentIndex:currentIndex,previousIndex:previousIndex,container:this,previousContainer:previousContainer,isPointerOverContainer:isPointerOverContainer,distance:distance})}withItems(items){const previousItems=this._draggables;return this._draggables=items,items.forEach(item=>item._withDropContainer(this)),this.isDragging()&&(previousItems.filter(item=>item.isDragging()).every(item=>-1===items.indexOf(item))?this._reset():this._cacheItems()),this}withDirection(direction){return this._direction=direction,this}connectedTo(connectedTo){return this._siblings=connectedTo.slice(),this}withOrientation(orientation){return this._orientation=orientation,this}withScrollableParents(elements){const element=Object(coercion.e)(this.element);return this._scrollableElements=-1===elements.indexOf(element)?[element,...elements]:elements.slice(),this}getScrollableParents(){return this._scrollableElements}getItemIndex(item){return this._isDragging?findIndex(\"horizontal\"===this._orientation&&\"rtl\"===this._direction?this._itemPositions.slice().reverse():this._itemPositions,currentItem=>currentItem.drag===item):this._draggables.indexOf(item)}isReceiving(){return this._activeSiblings.size>0}_sortItem(item,pointerX,pointerY,pointerDelta){if(this.sortingDisabled||!isPointerNearClientRect(this._clientRect,.05,pointerX,pointerY))return;const siblings=this._itemPositions,newIndex=this._getItemIndexFromPointerPosition(item,pointerX,pointerY,pointerDelta);if(-1===newIndex&&siblings.length>0)return;const isHorizontal=\"horizontal\"===this._orientation,currentIndex=findIndex(siblings,currentItem=>currentItem.drag===item),siblingAtNewPosition=siblings[newIndex],newPosition=siblingAtNewPosition.clientRect,delta=currentIndex>newIndex?1:-1,itemOffset=this._getItemOffsetPx(siblings[currentIndex].clientRect,newPosition,delta),siblingOffset=this._getSiblingOffsetPx(currentIndex,siblings,delta),oldOrder=siblings.slice();moveItemInArray(siblings,currentIndex,newIndex),this.sorted.next({previousIndex:currentIndex,currentIndex:newIndex,container:this,item:item}),siblings.forEach((sibling,index)=>{if(oldOrder[index]===sibling)return;const isDraggedItem=sibling.drag===item,offset=isDraggedItem?itemOffset:siblingOffset,elementToOffset=isDraggedItem?item.getPlaceholderElement():sibling.drag.getRootElement();sibling.offset+=offset,isHorizontal?(elementToOffset.style.transform=`translate3d(${Math.round(sibling.offset)}px, 0, 0)`,adjustClientRect(sibling.clientRect,0,offset)):(elementToOffset.style.transform=`translate3d(0, ${Math.round(sibling.offset)}px, 0)`,adjustClientRect(sibling.clientRect,offset,0))}),this._previousSwap.overlaps=isInsideClientRect(newPosition,pointerX,pointerY),this._previousSwap.drag=siblingAtNewPosition.drag,this._previousSwap.delta=isHorizontal?pointerDelta.x:pointerDelta.y}_startScrollingIfNecessary(pointerX,pointerY){if(this.autoScrollDisabled)return;let scrollNode,verticalScrollDirection=0,horizontalScrollDirection=0;if(this._parentPositions.positions.forEach((position,element)=>{element!==this._document&&position.clientRect&&!scrollNode&&isPointerNearClientRect(position.clientRect,.05,pointerX,pointerY)&&([verticalScrollDirection,horizontalScrollDirection]=function(element,clientRect,pointerX,pointerY){const computedVertical=getVerticalScrollDirection(clientRect,pointerY),computedHorizontal=getHorizontalScrollDirection(clientRect,pointerX);let verticalScrollDirection=0,horizontalScrollDirection=0;if(computedVertical){const scrollTop=element.scrollTop;1===computedVertical?scrollTop>0&&(verticalScrollDirection=1):element.scrollHeight-scrollTop>element.clientHeight&&(verticalScrollDirection=2)}if(computedHorizontal){const scrollLeft=element.scrollLeft;1===computedHorizontal?scrollLeft>0&&(horizontalScrollDirection=1):element.scrollWidth-scrollLeft>element.clientWidth&&(horizontalScrollDirection=2)}return[verticalScrollDirection,horizontalScrollDirection]}(element,position.clientRect,pointerX,pointerY),(verticalScrollDirection||horizontalScrollDirection)&&(scrollNode=element))}),!verticalScrollDirection&&!horizontalScrollDirection){const{width:width,height:height}=this._viewportRuler.getViewportSize(),clientRect={width:width,height:height,top:0,right:width,bottom:height,left:0};verticalScrollDirection=getVerticalScrollDirection(clientRect,pointerY),horizontalScrollDirection=getHorizontalScrollDirection(clientRect,pointerX),scrollNode=window}!scrollNode||verticalScrollDirection===this._verticalScrollDirection&&horizontalScrollDirection===this._horizontalScrollDirection&&scrollNode===this._scrollNode||(this._verticalScrollDirection=verticalScrollDirection,this._horizontalScrollDirection=horizontalScrollDirection,this._scrollNode=scrollNode,(verticalScrollDirection||horizontalScrollDirection)&&scrollNode?this._ngZone.runOutsideAngular(this._startScrollInterval):this._stopScrolling())}_stopScrolling(){this._stopScrollTimers.next()}_cacheParentPositions(){const element=Object(coercion.e)(this.element);this._parentPositions.cache(this._scrollableElements),this._clientRect=this._parentPositions.positions.get(element).clientRect}_cacheItemPositions(){const isHorizontal=\"horizontal\"===this._orientation;this._itemPositions=this._activeDraggables.map(drag=>{const elementToMeasure=drag.getVisibleElement();return{drag:drag,offset:0,clientRect:getMutableClientRect(elementToMeasure)}}).sort((a,b)=>isHorizontal?a.clientRect.left-b.clientRect.left:a.clientRect.top-b.clientRect.top)}_reset(){this._isDragging=!1;const styles=Object(coercion.e)(this.element).style;styles.scrollSnapType=styles.msScrollSnapType=this._initialScrollSnap,this._activeDraggables.forEach(item=>{const rootElement=item.getRootElement();rootElement&&(rootElement.style.transform=\"\")}),this._siblings.forEach(sibling=>sibling._stopReceiving(this)),this._activeDraggables=[],this._itemPositions=[],this._previousSwap.drag=null,this._previousSwap.delta=0,this._previousSwap.overlaps=!1,this._stopScrolling(),this._viewportScrollSubscription.unsubscribe(),this._parentPositions.clear()}_getSiblingOffsetPx(currentIndex,siblings,delta){const isHorizontal=\"horizontal\"===this._orientation,currentPosition=siblings[currentIndex].clientRect,immediateSibling=siblings[currentIndex+-1*delta];let siblingOffset=currentPosition[isHorizontal?\"width\":\"height\"]*delta;if(immediateSibling){const start=isHorizontal?\"left\":\"top\",end=isHorizontal?\"right\":\"bottom\";-1===delta?siblingOffset-=immediateSibling.clientRect[start]-currentPosition[end]:siblingOffset+=currentPosition[start]-immediateSibling.clientRect[end]}return siblingOffset}_getItemOffsetPx(currentPosition,newPosition,delta){const isHorizontal=\"horizontal\"===this._orientation;let itemOffset=isHorizontal?newPosition.left-currentPosition.left:newPosition.top-currentPosition.top;return-1===delta&&(itemOffset+=isHorizontal?newPosition.width-currentPosition.width:newPosition.height-currentPosition.height),itemOffset}_shouldEnterAsFirstChild(pointerX,pointerY){if(!this._activeDraggables.length)return!1;const itemPositions=this._itemPositions,isHorizontal=\"horizontal\"===this._orientation;if(itemPositions[0].drag!==this._activeDraggables[0]){const lastItemRect=itemPositions[itemPositions.length-1].clientRect;return isHorizontal?pointerX>=lastItemRect.right:pointerY>=lastItemRect.bottom}{const firstItemRect=itemPositions[0].clientRect;return isHorizontal?pointerX<=firstItemRect.left:pointerY<=firstItemRect.top}}_getItemIndexFromPointerPosition(item,pointerX,pointerY,delta){const isHorizontal=\"horizontal\"===this._orientation,index=findIndex(this._itemPositions,({drag:drag,clientRect:clientRect},_,array)=>{if(drag===item)return array.length<2;if(delta){const direction=isHorizontal?delta.x:delta.y;if(drag===this._previousSwap.drag&&this._previousSwap.overlaps&&direction===this._previousSwap.delta)return!1}return isHorizontal?pointerX>=Math.floor(clientRect.left)&&pointerX<Math.floor(clientRect.right):pointerY>=Math.floor(clientRect.top)&&pointerY<Math.floor(clientRect.bottom)});return-1!==index&&this.sortPredicate(index,item,this)?index:-1}_cacheItems(){this._activeDraggables=this._draggables.slice(),this._cacheItemPositions(),this._cacheParentPositions()}_isOverContainer(x,y){return isInsideClientRect(this._clientRect,x,y)}_getSiblingContainerFromPosition(item,x,y){return this._siblings.find(sibling=>sibling._canReceive(item,x,y))}_canReceive(item,x,y){if(!isInsideClientRect(this._clientRect,x,y)||!this.enterPredicate(item,this))return!1;const elementFromPoint=this._getShadowRoot().elementFromPoint(x,y);if(!elementFromPoint)return!1;const nativeElement=Object(coercion.e)(this.element);return elementFromPoint===nativeElement||nativeElement.contains(elementFromPoint)}_startReceiving(sibling){const activeSiblings=this._activeSiblings;activeSiblings.has(sibling)||(activeSiblings.add(sibling),this._cacheParentPositions(),this._listenToScrollEvents())}_stopReceiving(sibling){this._activeSiblings.delete(sibling),this._viewportScrollSubscription.unsubscribe()}_listenToScrollEvents(){this._viewportScrollSubscription=this._dragDropRegistry.scroll.subscribe(event=>{if(this.isDragging()){const scrollDifference=this._parentPositions.handleScroll(event);scrollDifference&&(this._itemPositions.forEach(({clientRect:clientRect})=>{adjustClientRect(clientRect,scrollDifference.top,scrollDifference.left)}),this._itemPositions.forEach(({drag:drag})=>{this._dragDropRegistry.isDragging(drag)&&drag._sortFromLastPointerPosition()}))}else this.isReceiving()&&this._cacheParentPositions()})}_getShadowRoot(){if(!this._cachedShadowRoot){const shadowRoot=Object(platform.c)(Object(coercion.e)(this.element));this._cachedShadowRoot=shadowRoot||this._document}return this._cachedShadowRoot}}function findIndex(array,predicate){for(let i=0;i<array.length;i++)if(predicate(array[i],i,array))return i;return-1}function incrementVerticalScroll(node,amount){node===window?node.scrollBy(0,amount):node.scrollTop+=amount}function incrementHorizontalScroll(node,amount){node===window?node.scrollBy(amount,0):node.scrollLeft+=amount}function getVerticalScrollDirection(clientRect,pointerY){const{top:top,bottom:bottom,height:height}=clientRect,yThreshold=.05*height;return pointerY>=top-yThreshold&&pointerY<=top+yThreshold?1:pointerY>=bottom-yThreshold&&pointerY<=bottom+yThreshold?2:0}function getHorizontalScrollDirection(clientRect,pointerX){const{left:left,right:right,width:width}=clientRect,xThreshold=.05*width;return pointerX>=left-xThreshold&&pointerX<=left+xThreshold?1:pointerX>=right-xThreshold&&pointerX<=right+xThreshold?2:0}const activeCapturingEventOptions=Object(platform.f)({passive:!1,capture:!0});let drag_drop_DragDropRegistry=(()=>{class DragDropRegistry{constructor(_ngZone,_document){this._ngZone=_ngZone,this._dropInstances=new Set,this._dragInstances=new Set,this._activeDragInstances=new Set,this._globalListeners=new Map,this.pointerMove=new Subject.a,this.pointerUp=new Subject.a,this.scroll=new Subject.a,this._preventDefaultWhileDragging=event=>{this._activeDragInstances.size&&event.preventDefault()},this._persistentTouchmoveListener=event=>{this._activeDragInstances.size&&(event.preventDefault(),this.pointerMove.next(event))},this._document=_document}registerDropContainer(drop){this._dropInstances.has(drop)||this._dropInstances.add(drop)}registerDragItem(drag){this._dragInstances.add(drag),1===this._dragInstances.size&&this._ngZone.runOutsideAngular(()=>{this._document.addEventListener(\"touchmove\",this._persistentTouchmoveListener,activeCapturingEventOptions)})}removeDropContainer(drop){this._dropInstances.delete(drop)}removeDragItem(drag){this._dragInstances.delete(drag),this.stopDragging(drag),0===this._dragInstances.size&&this._document.removeEventListener(\"touchmove\",this._persistentTouchmoveListener,activeCapturingEventOptions)}startDragging(drag,event){if(!this._activeDragInstances.has(drag)&&(this._activeDragInstances.add(drag),1===this._activeDragInstances.size)){const isTouchEvent=event.type.startsWith(\"touch\");this._globalListeners.set(isTouchEvent?\"touchend\":\"mouseup\",{handler:e=>this.pointerUp.next(e),options:!0}).set(\"scroll\",{handler:e=>this.scroll.next(e),options:!0}).set(\"selectstart\",{handler:this._preventDefaultWhileDragging,options:activeCapturingEventOptions}),isTouchEvent||this._globalListeners.set(\"mousemove\",{handler:e=>this.pointerMove.next(e),options:activeCapturingEventOptions}),this._ngZone.runOutsideAngular(()=>{this._globalListeners.forEach((config,name)=>{this._document.addEventListener(name,config.handler,config.options)})})}}stopDragging(drag){this._activeDragInstances.delete(drag),0===this._activeDragInstances.size&&this._clearGlobalListeners()}isDragging(drag){return this._activeDragInstances.has(drag)}ngOnDestroy(){this._dragInstances.forEach(instance=>this.removeDragItem(instance)),this._dropInstances.forEach(instance=>this.removeDropContainer(instance)),this._clearGlobalListeners(),this.pointerMove.complete(),this.pointerUp.complete()}_clearGlobalListeners(){this._globalListeners.forEach((config,name)=>{this._document.removeEventListener(name,config.handler,config.options)}),this._globalListeners.clear()}}return DragDropRegistry.ɵfac=function(t){return new(t||DragDropRegistry)(core.cc(core.B),core.cc(common.d))},DragDropRegistry.ɵprov=Object(core.Lb)({factory:function(){return new DragDropRegistry(Object(core.cc)(core.B),Object(core.cc)(common.d))},token:DragDropRegistry,providedIn:\"root\"}),DragDropRegistry})();const DEFAULT_CONFIG={dragStartThreshold:5,pointerDirectionChangeThreshold:5};let drag_drop_DragDrop=(()=>{class DragDrop{constructor(_document,_ngZone,_viewportRuler,_dragDropRegistry){this._document=_document,this._ngZone=_ngZone,this._viewportRuler=_viewportRuler,this._dragDropRegistry=_dragDropRegistry}createDrag(element,config=DEFAULT_CONFIG){return new drag_drop_DragRef(element,config,this._document,this._ngZone,this._viewportRuler,this._dragDropRegistry)}createDropList(element){return new drag_drop_DropListRef(element,this._dragDropRegistry,this._document,this._ngZone,this._viewportRuler)}}return DragDrop.ɵfac=function(t){return new(t||DragDrop)(core.cc(common.d),core.cc(core.B),core.cc(scrolling.e),core.cc(drag_drop_DragDropRegistry))},DragDrop.ɵprov=Object(core.Lb)({factory:function(){return new DragDrop(Object(core.cc)(common.d),Object(core.cc)(core.B),Object(core.cc)(scrolling.e),Object(core.cc)(drag_drop_DragDropRegistry))},token:DragDrop,providedIn:\"root\"}),DragDrop})();const CDK_DRAG_PARENT=new core.s(\"CDK_DRAG_PARENT\"),CDK_DROP_LIST_GROUP=new core.s(\"CdkDropListGroup\"),CDK_DRAG_CONFIG=new core.s(\"CDK_DRAG_CONFIG\");let _uniqueIdCounter=0;const CDK_DROP_LIST=new core.s(\"CdkDropList\");let drag_drop_CdkDropList=(()=>{class CdkDropList{constructor(element,dragDrop,_changeDetectorRef,_scrollDispatcher,_dir,_group,config){this.element=element,this._changeDetectorRef=_changeDetectorRef,this._scrollDispatcher=_scrollDispatcher,this._dir=_dir,this._group=_group,this._destroyed=new Subject.a,this.connectedTo=[],this.id=\"cdk-drop-list-\"+_uniqueIdCounter++,this.enterPredicate=()=>!0,this.sortPredicate=()=>!0,this.dropped=new core.o,this.entered=new core.o,this.exited=new core.o,this.sorted=new core.o,this._unsortedItems=new Set,this._dropListRef=dragDrop.createDropList(element),this._dropListRef.data=this,config&&this._assignDefaults(config),this._dropListRef.enterPredicate=(drag,drop)=>this.enterPredicate(drag.data,drop.data),this._dropListRef.sortPredicate=(index,drag,drop)=>this.sortPredicate(index,drag.data,drop.data),this._setupInputSyncSubscription(this._dropListRef),this._handleEvents(this._dropListRef),CdkDropList._dropLists.push(this),_group&&_group._items.add(this)}get disabled(){return this._disabled||!!this._group&&this._group.disabled}set disabled(value){this._dropListRef.disabled=this._disabled=Object(coercion.c)(value)}addItem(item){this._unsortedItems.add(item),this._dropListRef.isDragging()&&this._syncItemsWithRef()}removeItem(item){this._unsortedItems.delete(item),this._dropListRef.isDragging()&&this._syncItemsWithRef()}getSortedItems(){return Array.from(this._unsortedItems).sort((a,b)=>a._dragRef.getVisibleElement().compareDocumentPosition(b._dragRef.getVisibleElement())&Node.DOCUMENT_POSITION_FOLLOWING?-1:1)}ngOnDestroy(){const index=CdkDropList._dropLists.indexOf(this);index>-1&&CdkDropList._dropLists.splice(index,1),this._group&&this._group._items.delete(this),this._unsortedItems.clear(),this._dropListRef.dispose(),this._destroyed.next(),this._destroyed.complete()}_setupInputSyncSubscription(ref){this._dir&&this._dir.change.pipe(Object(startWith.a)(this._dir.value),Object(takeUntil.a)(this._destroyed)).subscribe(value=>ref.withDirection(value)),ref.beforeStarted.subscribe(()=>{const siblings=Object(coercion.b)(this.connectedTo).map(drop=>\"string\"==typeof drop?CdkDropList._dropLists.find(list=>list.id===drop):drop);if(this._group&&this._group._items.forEach(drop=>{-1===siblings.indexOf(drop)&&siblings.push(drop)}),!this._scrollableParentsResolved){const scrollableParents=this._scrollDispatcher.getAncestorScrollContainers(this.element).map(scrollable=>scrollable.getElementRef().nativeElement);this._dropListRef.withScrollableParents(scrollableParents),this._scrollableParentsResolved=!0}ref.disabled=this.disabled,ref.lockAxis=this.lockAxis,ref.sortingDisabled=Object(coercion.c)(this.sortingDisabled),ref.autoScrollDisabled=Object(coercion.c)(this.autoScrollDisabled),ref.connectedTo(siblings.filter(drop=>drop&&drop!==this).map(list=>list._dropListRef)).withOrientation(this.orientation)})}_handleEvents(ref){ref.beforeStarted.subscribe(()=>{this._syncItemsWithRef(),this._changeDetectorRef.markForCheck()}),ref.entered.subscribe(event=>{this.entered.emit({container:this,item:event.item.data,currentIndex:event.currentIndex})}),ref.exited.subscribe(event=>{this.exited.emit({container:this,item:event.item.data}),this._changeDetectorRef.markForCheck()}),ref.sorted.subscribe(event=>{this.sorted.emit({previousIndex:event.previousIndex,currentIndex:event.currentIndex,container:this,item:event.item.data})}),ref.dropped.subscribe(event=>{this.dropped.emit({previousIndex:event.previousIndex,currentIndex:event.currentIndex,previousContainer:event.previousContainer.data,container:event.container.data,item:event.item.data,isPointerOverContainer:event.isPointerOverContainer,distance:event.distance}),this._changeDetectorRef.markForCheck()})}_assignDefaults(config){const{lockAxis:lockAxis,draggingDisabled:draggingDisabled,sortingDisabled:sortingDisabled,listAutoScrollDisabled:listAutoScrollDisabled,listOrientation:listOrientation}=config;this.disabled=null!=draggingDisabled&&draggingDisabled,this.sortingDisabled=null!=sortingDisabled&&sortingDisabled,this.autoScrollDisabled=null!=listAutoScrollDisabled&&listAutoScrollDisabled,this.orientation=listOrientation||\"vertical\",lockAxis&&(this.lockAxis=lockAxis)}_syncItemsWithRef(){this._dropListRef.withItems(this.getSortedItems().map(item=>item._dragRef))}}return CdkDropList.ɵfac=function(t){return new(t||CdkDropList)(core.Pb(core.l),core.Pb(drag_drop_DragDrop),core.Pb(core.h),core.Pb(scrolling.c),core.Pb(bidi.b,8),core.Pb(CDK_DROP_LIST_GROUP,12),core.Pb(CDK_DRAG_CONFIG,8))},CdkDropList.ɵdir=core.Kb({type:CdkDropList,selectors:[[\"\",\"cdkDropList\",\"\"],[\"cdk-drop-list\"]],hostAttrs:[1,\"cdk-drop-list\"],hostVars:7,hostBindings:function(rf,ctx){2&rf&&(core.Db(\"id\",ctx.id),core.Hb(\"cdk-drop-list-disabled\",ctx.disabled)(\"cdk-drop-list-dragging\",ctx._dropListRef.isDragging())(\"cdk-drop-list-receiving\",ctx._dropListRef.isReceiving()))},inputs:{connectedTo:[\"cdkDropListConnectedTo\",\"connectedTo\"],id:\"id\",enterPredicate:[\"cdkDropListEnterPredicate\",\"enterPredicate\"],sortPredicate:[\"cdkDropListSortPredicate\",\"sortPredicate\"],disabled:[\"cdkDropListDisabled\",\"disabled\"],sortingDisabled:[\"cdkDropListSortingDisabled\",\"sortingDisabled\"],autoScrollDisabled:[\"cdkDropListAutoScrollDisabled\",\"autoScrollDisabled\"],orientation:[\"cdkDropListOrientation\",\"orientation\"],lockAxis:[\"cdkDropListLockAxis\",\"lockAxis\"],data:[\"cdkDropListData\",\"data\"]},outputs:{dropped:\"cdkDropListDropped\",entered:\"cdkDropListEntered\",exited:\"cdkDropListExited\",sorted:\"cdkDropListSorted\"},exportAs:[\"cdkDropList\"],features:[core.Bb([{provide:CDK_DROP_LIST_GROUP,useValue:void 0},{provide:CDK_DROP_LIST,useExisting:CdkDropList}])]}),CdkDropList._dropLists=[],CdkDropList})();const CDK_DRAG_HANDLE=new core.s(\"CdkDragHandle\"),CDK_DRAG_PLACEHOLDER=new core.s(\"CdkDragPlaceholder\"),CDK_DRAG_PREVIEW=new core.s(\"CdkDragPreview\");let drag_drop_CdkDrag=(()=>{class CdkDrag{constructor(element,dropContainer,_document,_ngZone,_viewContainerRef,config,_dir,dragDrop,_changeDetectorRef,_selfHandle){this.element=element,this.dropContainer=dropContainer,this._ngZone=_ngZone,this._viewContainerRef=_viewContainerRef,this._dir=_dir,this._changeDetectorRef=_changeDetectorRef,this._selfHandle=_selfHandle,this._destroyed=new Subject.a,this.started=new core.o,this.released=new core.o,this.ended=new core.o,this.entered=new core.o,this.exited=new core.o,this.dropped=new core.o,this.moved=new Observable.a(observer=>{const subscription=this._dragRef.moved.pipe(Object(map.a)(movedEvent=>({source:this,pointerPosition:movedEvent.pointerPosition,event:movedEvent.event,delta:movedEvent.delta,distance:movedEvent.distance}))).subscribe(observer);return()=>{subscription.unsubscribe()}}),this._dragRef=dragDrop.createDrag(element,{dragStartThreshold:config&&null!=config.dragStartThreshold?config.dragStartThreshold:5,pointerDirectionChangeThreshold:config&&null!=config.pointerDirectionChangeThreshold?config.pointerDirectionChangeThreshold:5,zIndex:null==config?void 0:config.zIndex}),this._dragRef.data=this,config&&this._assignDefaults(config),dropContainer&&(this._dragRef._withDropContainer(dropContainer._dropListRef),dropContainer.addItem(this)),this._syncInputs(this._dragRef),this._handleEvents(this._dragRef)}get disabled(){return this._disabled||this.dropContainer&&this.dropContainer.disabled}set disabled(value){this._disabled=Object(coercion.c)(value),this._dragRef.disabled=this._disabled}getPlaceholderElement(){return this._dragRef.getPlaceholderElement()}getRootElement(){return this._dragRef.getRootElement()}reset(){this._dragRef.reset()}getFreeDragPosition(){return this._dragRef.getFreeDragPosition()}ngAfterViewInit(){this._ngZone.onStable.pipe(Object(take.a)(1),Object(takeUntil.a)(this._destroyed)).subscribe(()=>{this._updateRootElement(),this._handles.changes.pipe(Object(startWith.a)(this._handles),Object(tap.a)(handles=>{const childHandleElements=handles.filter(handle=>handle._parentDrag===this).map(handle=>handle.element);this._selfHandle&&this.rootElementSelector&&childHandleElements.push(this.element),this._dragRef.withHandles(childHandleElements)}),Object(switchMap.a)(handles=>Object(merge.a)(...handles.map(item=>item._stateChanges.pipe(Object(startWith.a)(item))))),Object(takeUntil.a)(this._destroyed)).subscribe(handleInstance=>{const dragRef=this._dragRef,handle=handleInstance.element.nativeElement;handleInstance.disabled?dragRef.disableHandle(handle):dragRef.enableHandle(handle)}),this.freeDragPosition&&this._dragRef.setFreeDragPosition(this.freeDragPosition)})}ngOnChanges(changes){const rootSelectorChange=changes.rootElementSelector,positionChange=changes.freeDragPosition;rootSelectorChange&&!rootSelectorChange.firstChange&&this._updateRootElement(),positionChange&&!positionChange.firstChange&&this.freeDragPosition&&this._dragRef.setFreeDragPosition(this.freeDragPosition)}ngOnDestroy(){this.dropContainer&&this.dropContainer.removeItem(this),this._destroyed.next(),this._destroyed.complete(),this._dragRef.dispose()}_updateRootElement(){const element=this.element.nativeElement,rootElement=this.rootElementSelector?getClosestMatchingAncestor(element,this.rootElementSelector):element;this._dragRef.withRootElement(rootElement||element)}_getBoundaryElement(){const boundary=this.boundaryElement;return boundary?\"string\"==typeof boundary?getClosestMatchingAncestor(this.element.nativeElement,boundary):Object(coercion.e)(boundary):null}_syncInputs(ref){ref.beforeStarted.subscribe(()=>{if(!ref.isDragging()){const dir=this._dir,dragStartDelay=this.dragStartDelay,placeholder=this._placeholderTemplate?{template:this._placeholderTemplate.templateRef,context:this._placeholderTemplate.data,viewContainer:this._viewContainerRef}:null,preview=this._previewTemplate?{template:this._previewTemplate.templateRef,context:this._previewTemplate.data,matchSize:this._previewTemplate.matchSize,viewContainer:this._viewContainerRef}:null;ref.disabled=this.disabled,ref.lockAxis=this.lockAxis,ref.dragStartDelay=\"object\"==typeof dragStartDelay&&dragStartDelay?dragStartDelay:Object(coercion.f)(dragStartDelay),ref.constrainPosition=this.constrainPosition,ref.previewClass=this.previewClass,ref.withBoundaryElement(this._getBoundaryElement()).withPlaceholderTemplate(placeholder).withPreviewTemplate(preview),dir&&ref.withDirection(dir.value)}})}_handleEvents(ref){ref.started.subscribe(()=>{this.started.emit({source:this}),this._changeDetectorRef.markForCheck()}),ref.released.subscribe(()=>{this.released.emit({source:this})}),ref.ended.subscribe(event=>{this.ended.emit({source:this,distance:event.distance}),this._changeDetectorRef.markForCheck()}),ref.entered.subscribe(event=>{this.entered.emit({container:event.container.data,item:this,currentIndex:event.currentIndex})}),ref.exited.subscribe(event=>{this.exited.emit({container:event.container.data,item:this})}),ref.dropped.subscribe(event=>{this.dropped.emit({previousIndex:event.previousIndex,currentIndex:event.currentIndex,previousContainer:event.previousContainer.data,container:event.container.data,isPointerOverContainer:event.isPointerOverContainer,item:this,distance:event.distance})})}_assignDefaults(config){const{lockAxis:lockAxis,dragStartDelay:dragStartDelay,constrainPosition:constrainPosition,previewClass:previewClass,boundaryElement:boundaryElement,draggingDisabled:draggingDisabled,rootElementSelector:rootElementSelector}=config;this.disabled=null!=draggingDisabled&&draggingDisabled,this.dragStartDelay=dragStartDelay||0,lockAxis&&(this.lockAxis=lockAxis),constrainPosition&&(this.constrainPosition=constrainPosition),previewClass&&(this.previewClass=previewClass),boundaryElement&&(this.boundaryElement=boundaryElement),rootElementSelector&&(this.rootElementSelector=rootElementSelector)}}return CdkDrag.ɵfac=function(t){return new(t||CdkDrag)(core.Pb(core.l),core.Pb(CDK_DROP_LIST,12),core.Pb(common.d),core.Pb(core.B),core.Pb(core.S),core.Pb(CDK_DRAG_CONFIG,8),core.Pb(bidi.b,8),core.Pb(drag_drop_DragDrop),core.Pb(core.h),core.Pb(CDK_DRAG_HANDLE,10))},CdkDrag.ɵdir=core.Kb({type:CdkDrag,selectors:[[\"\",\"cdkDrag\",\"\"]],contentQueries:function(rf,ctx,dirIndex){if(1&rf&&(core.Ib(dirIndex,CDK_DRAG_PREVIEW,!0),core.Ib(dirIndex,CDK_DRAG_PLACEHOLDER,!0),core.Ib(dirIndex,CDK_DRAG_HANDLE,!0)),2&rf){let _t;core.wc(_t=core.hc())&&(ctx._previewTemplate=_t.first),core.wc(_t=core.hc())&&(ctx._placeholderTemplate=_t.first),core.wc(_t=core.hc())&&(ctx._handles=_t)}},hostAttrs:[1,\"cdk-drag\"],hostVars:4,hostBindings:function(rf,ctx){2&rf&&core.Hb(\"cdk-drag-disabled\",ctx.disabled)(\"cdk-drag-dragging\",ctx._dragRef.isDragging())},inputs:{disabled:[\"cdkDragDisabled\",\"disabled\"],dragStartDelay:[\"cdkDragStartDelay\",\"dragStartDelay\"],lockAxis:[\"cdkDragLockAxis\",\"lockAxis\"],constrainPosition:[\"cdkDragConstrainPosition\",\"constrainPosition\"],previewClass:[\"cdkDragPreviewClass\",\"previewClass\"],boundaryElement:[\"cdkDragBoundary\",\"boundaryElement\"],rootElementSelector:[\"cdkDragRootElement\",\"rootElementSelector\"],data:[\"cdkDragData\",\"data\"],freeDragPosition:[\"cdkDragFreeDragPosition\",\"freeDragPosition\"]},outputs:{started:\"cdkDragStarted\",released:\"cdkDragReleased\",ended:\"cdkDragEnded\",entered:\"cdkDragEntered\",exited:\"cdkDragExited\",dropped:\"cdkDragDropped\",moved:\"cdkDragMoved\"},exportAs:[\"cdkDrag\"],features:[core.Bb([{provide:CDK_DRAG_PARENT,useExisting:CdkDrag}]),core.Ab]}),CdkDrag})();function getClosestMatchingAncestor(element,selector){let currentElement=element.parentElement;for(;currentElement;){if(currentElement.matches?currentElement.matches(selector):currentElement.msMatchesSelector(selector))return currentElement;currentElement=currentElement.parentElement}return null}let drag_drop_DragDropModule=(()=>{class DragDropModule{}return DragDropModule.ɵmod=core.Nb({type:DragDropModule}),DragDropModule.ɵinj=core.Mb({factory:function(t){return new(t||DragDropModule)},providers:[drag_drop_DragDrop],imports:[scrolling.b]}),DragDropModule})()},mCIx:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return DeleteComponent});var _angular_core__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"fXoL\"),_ng_bootstrap_ng_bootstrap__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"1kSV\");let DeleteComponent=(()=>{class DeleteComponent{constructor(modalService,modal){this.modalService=modalService,this.modal=modal}ngOnInit(){}}return DeleteComponent.ɵfac=function(t){return new(t||DeleteComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Pb(_ng_bootstrap_ng_bootstrap__WEBPACK_IMPORTED_MODULE_1__.c),_angular_core__WEBPACK_IMPORTED_MODULE_0__.Pb(_ng_bootstrap_ng_bootstrap__WEBPACK_IMPORTED_MODULE_1__.b))},DeleteComponent.ɵcmp=_angular_core__WEBPACK_IMPORTED_MODULE_0__.Jb({type:DeleteComponent,selectors:[[\"app-delete\"]],decls:12,vars:0,consts:[[1,\"modal-header\"],[1,\"modal-title\"],[1,\"modal-body\"],[1,\"modal-footer\"],[\"type\",\"button\",1,\"btn\",\"btn-light\",3,\"click\"],[\"type\",\"button\",1,\"btn\",\"btn-danger\",3,\"click\"]],template:function(rf,ctx){1&rf&&(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Vb(0,\"div\"),_angular_core__WEBPACK_IMPORTED_MODULE_0__.Vb(1,\"div\",0),_angular_core__WEBPACK_IMPORTED_MODULE_0__.Vb(2,\"h4\",1),_angular_core__WEBPACK_IMPORTED_MODULE_0__.Mc(3,\"Delete\"),_angular_core__WEBPACK_IMPORTED_MODULE_0__.Ub(),_angular_core__WEBPACK_IMPORTED_MODULE_0__.Ub(),_angular_core__WEBPACK_IMPORTED_MODULE_0__.Vb(4,\"div\",2),_angular_core__WEBPACK_IMPORTED_MODULE_0__.Vb(5,\"p\"),_angular_core__WEBPACK_IMPORTED_MODULE_0__.Mc(6,\"Do you really want to delete?\"),_angular_core__WEBPACK_IMPORTED_MODULE_0__.Ub(),_angular_core__WEBPACK_IMPORTED_MODULE_0__.Ub(),_angular_core__WEBPACK_IMPORTED_MODULE_0__.Vb(7,\"div\",3),_angular_core__WEBPACK_IMPORTED_MODULE_0__.Vb(8,\"button\",4),_angular_core__WEBPACK_IMPORTED_MODULE_0__.gc(\"click\",function(){return ctx.modal.dismiss()}),_angular_core__WEBPACK_IMPORTED_MODULE_0__.Mc(9,\"Cancel\"),_angular_core__WEBPACK_IMPORTED_MODULE_0__.Ub(),_angular_core__WEBPACK_IMPORTED_MODULE_0__.Vb(10,\"button\",5),_angular_core__WEBPACK_IMPORTED_MODULE_0__.gc(\"click\",function(){return ctx.modal.close()}),_angular_core__WEBPACK_IMPORTED_MODULE_0__.Mc(11,\"Delete\"),_angular_core__WEBPACK_IMPORTED_MODULE_0__.Ub(),_angular_core__WEBPACK_IMPORTED_MODULE_0__.Ub(),_angular_core__WEBPACK_IMPORTED_MODULE_0__.Ub())},styles:[\"\"]}),DeleteComponent})()}}]);","name":"9-es2015.07a3e30719d35e468a60.js","input":"(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[9],{\n\n/***/ \"5+WD\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ drag_drop_CdkDrag; });\n__webpack_require__.d(__webpack_exports__, \"b\", function() { return /* binding */ drag_drop_CdkDropList; });\n__webpack_require__.d(__webpack_exports__, \"c\", function() { return /* binding */ drag_drop_DragDropModule; });\n__webpack_require__.d(__webpack_exports__, \"d\", function() { return /* binding */ moveItemInArray; });\n\n// UNUSED EXPORTS: CDK_DRAG_CONFIG, CDK_DRAG_HANDLE, CDK_DRAG_PARENT, CDK_DRAG_PLACEHOLDER, CDK_DRAG_PREVIEW, CDK_DROP_LIST, CDK_DROP_LIST_GROUP, CdkDragHandle, CdkDragPlaceholder, CdkDragPreview, CdkDropListGroup, DragDrop, DragDropRegistry, DragRef, DropListRef, copyArrayItem, transferArrayItem\n\n// EXTERNAL MODULE: ./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js\nvar core = __webpack_require__(\"fXoL\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/common/__ivy_ngcc__/fesm2015/common.js\nvar common = __webpack_require__(\"ofXK\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/scrolling.js + 11 modules\nvar scrolling = __webpack_require__(\"vxfF\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/platform.js\nvar platform = __webpack_require__(\"nLfN\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/cdk/fesm2015/coercion.js\nvar coercion = __webpack_require__(\"8LU1\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subject.js\nvar Subject = __webpack_require__(\"XNiG\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subscription.js + 1 modules\nvar Subscription = __webpack_require__(\"quSY\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Observable.js + 3 modules\nvar Observable = __webpack_require__(\"HDdC\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/async.js\nvar scheduler_async = __webpack_require__(\"D0XW\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/isNumeric.js\nvar isNumeric = __webpack_require__(\"Y7HM\");\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/observable/interval.js\n\n\n\nfunction interval(period = 0, scheduler = scheduler_async[\"a\" /* async */]) {\n    if (!Object(isNumeric[\"a\" /* isNumeric */])(period) || period < 0) {\n        period = 0;\n    }\n    if (!scheduler || typeof scheduler.schedule !== 'function') {\n        scheduler = scheduler_async[\"a\" /* async */];\n    }\n    return new Observable[\"a\" /* Observable */](subscriber => {\n        subscriber.add(scheduler.schedule(dispatch, period, { subscriber, counter: 0, period }));\n        return subscriber;\n    });\n}\nfunction dispatch(state) {\n    const { subscriber, counter, period } = state;\n    subscriber.next(counter);\n    this.schedule({ subscriber, counter: counter + 1, period }, period);\n}\n//# sourceMappingURL=interval.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/animationFrame.js + 2 modules\nvar animationFrame = __webpack_require__(\"eNwd\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/merge.js\nvar merge = __webpack_require__(\"VRyK\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/takeUntil.js\nvar takeUntil = __webpack_require__(\"1G5W\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/startWith.js\nvar startWith = __webpack_require__(\"JX91\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/map.js\nvar map = __webpack_require__(\"lJxs\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/take.js\nvar take = __webpack_require__(\"IzEk\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/tap.js\nvar tap = __webpack_require__(\"vkgz\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/switchMap.js\nvar switchMap = __webpack_require__(\"eIep\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/bidi.js\nvar bidi = __webpack_require__(\"cH1L\");\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/drag-drop.js\n\n\n\n\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Shallow-extends a stylesheet object with another stylesheet object.\n * @docs-private\n */\n\n\n\nfunction extendStyles(dest, source) {\n    for (let key in source) {\n        if (source.hasOwnProperty(key)) {\n            dest[key] = source[key];\n        }\n    }\n    return dest;\n}\n/**\n * Toggles whether the native drag interactions should be enabled for an element.\n * @param element Element on which to toggle the drag interactions.\n * @param enable Whether the drag interactions should be enabled.\n * @docs-private\n */\nfunction toggleNativeDragInteractions(element, enable) {\n    const userSelect = enable ? '' : 'none';\n    extendStyles(element.style, {\n        touchAction: enable ? '' : 'none',\n        webkitUserDrag: enable ? '' : 'none',\n        webkitTapHighlightColor: enable ? '' : 'transparent',\n        userSelect: userSelect,\n        msUserSelect: userSelect,\n        webkitUserSelect: userSelect,\n        MozUserSelect: userSelect\n    });\n}\n/**\n * Toggles whether an element is visible while preserving its dimensions.\n * @param element Element whose visibility to toggle\n * @param enable Whether the element should be visible.\n * @docs-private\n */\nfunction toggleVisibility(element, enable) {\n    const styles = element.style;\n    styles.position = enable ? '' : 'fixed';\n    styles.top = styles.opacity = enable ? '' : '0';\n    styles.left = enable ? '' : '-999em';\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Parses a CSS time value to milliseconds. */\nfunction parseCssTimeUnitsToMs(value) {\n    // Some browsers will return it in seconds, whereas others will return milliseconds.\n    const multiplier = value.toLowerCase().indexOf('ms') > -1 ? 1 : 1000;\n    return parseFloat(value) * multiplier;\n}\n/** Gets the transform transition duration, including the delay, of an element in milliseconds. */\nfunction getTransformTransitionDurationInMs(element) {\n    const computedStyle = getComputedStyle(element);\n    const transitionedProperties = parseCssPropertyValue(computedStyle, 'transition-property');\n    const property = transitionedProperties.find(prop => prop === 'transform' || prop === 'all');\n    // If there's no transition for `all` or `transform`, we shouldn't do anything.\n    if (!property) {\n        return 0;\n    }\n    // Get the index of the property that we're interested in and match\n    // it up to the same index in `transition-delay` and `transition-duration`.\n    const propertyIndex = transitionedProperties.indexOf(property);\n    const rawDurations = parseCssPropertyValue(computedStyle, 'transition-duration');\n    const rawDelays = parseCssPropertyValue(computedStyle, 'transition-delay');\n    return parseCssTimeUnitsToMs(rawDurations[propertyIndex]) +\n        parseCssTimeUnitsToMs(rawDelays[propertyIndex]);\n}\n/** Parses out multiple values from a computed style into an array. */\nfunction parseCssPropertyValue(computedStyle, name) {\n    const value = computedStyle.getPropertyValue(name);\n    return value.split(',').map(part => part.trim());\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Gets a mutable version of an element's bounding `ClientRect`. */\nfunction getMutableClientRect(element) {\n    const clientRect = element.getBoundingClientRect();\n    // We need to clone the `clientRect` here, because all the values on it are readonly\n    // and we need to be able to update them. Also we can't use a spread here, because\n    // the values on a `ClientRect` aren't own properties. See:\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect#Notes\n    return {\n        top: clientRect.top,\n        right: clientRect.right,\n        bottom: clientRect.bottom,\n        left: clientRect.left,\n        width: clientRect.width,\n        height: clientRect.height\n    };\n}\n/**\n * Checks whether some coordinates are within a `ClientRect`.\n * @param clientRect ClientRect that is being checked.\n * @param x Coordinates along the X axis.\n * @param y Coordinates along the Y axis.\n */\nfunction isInsideClientRect(clientRect, x, y) {\n    const { top, bottom, left, right } = clientRect;\n    return y >= top && y <= bottom && x >= left && x <= right;\n}\n/**\n * Updates the top/left positions of a `ClientRect`, as well as their bottom/right counterparts.\n * @param clientRect `ClientRect` that should be updated.\n * @param top Amount to add to the `top` position.\n * @param left Amount to add to the `left` position.\n */\nfunction adjustClientRect(clientRect, top, left) {\n    clientRect.top += top;\n    clientRect.bottom = clientRect.top + clientRect.height;\n    clientRect.left += left;\n    clientRect.right = clientRect.left + clientRect.width;\n}\n/**\n * Checks whether the pointer coordinates are close to a ClientRect.\n * @param rect ClientRect to check against.\n * @param threshold Threshold around the ClientRect.\n * @param pointerX Coordinates along the X axis.\n * @param pointerY Coordinates along the Y axis.\n */\nfunction isPointerNearClientRect(rect, threshold, pointerX, pointerY) {\n    const { top, right, bottom, left, width, height } = rect;\n    const xThreshold = width * threshold;\n    const yThreshold = height * threshold;\n    return pointerY > top - yThreshold && pointerY < bottom + yThreshold &&\n        pointerX > left - xThreshold && pointerX < right + xThreshold;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Keeps track of the scroll position and dimensions of the parents of an element. */\nclass ParentPositionTracker {\n    constructor(_document, _viewportRuler) {\n        this._document = _document;\n        this._viewportRuler = _viewportRuler;\n        /** Cached positions of the scrollable parent elements. */\n        this.positions = new Map();\n    }\n    /** Clears the cached positions. */\n    clear() {\n        this.positions.clear();\n    }\n    /** Caches the positions. Should be called at the beginning of a drag sequence. */\n    cache(elements) {\n        this.clear();\n        this.positions.set(this._document, {\n            scrollPosition: this._viewportRuler.getViewportScrollPosition(),\n        });\n        elements.forEach(element => {\n            this.positions.set(element, {\n                scrollPosition: { top: element.scrollTop, left: element.scrollLeft },\n                clientRect: getMutableClientRect(element)\n            });\n        });\n    }\n    /** Handles scrolling while a drag is taking place. */\n    handleScroll(event) {\n        const target = event.target;\n        const cachedPosition = this.positions.get(target);\n        if (!cachedPosition) {\n            return null;\n        }\n        // Used when figuring out whether an element is inside the scroll parent. If the scrolled\n        // parent is the `document`, we use the `documentElement`, because IE doesn't support\n        // `contains` on the `document`.\n        const scrolledParentNode = target === this._document ? target.documentElement : target;\n        const scrollPosition = cachedPosition.scrollPosition;\n        let newTop;\n        let newLeft;\n        if (target === this._document) {\n            const viewportScrollPosition = this._viewportRuler.getViewportScrollPosition();\n            newTop = viewportScrollPosition.top;\n            newLeft = viewportScrollPosition.left;\n        }\n        else {\n            newTop = target.scrollTop;\n            newLeft = target.scrollLeft;\n        }\n        const topDifference = scrollPosition.top - newTop;\n        const leftDifference = scrollPosition.left - newLeft;\n        // Go through and update the cached positions of the scroll\n        // parents that are inside the element that was scrolled.\n        this.positions.forEach((position, node) => {\n            if (position.clientRect && target !== node && scrolledParentNode.contains(node)) {\n                adjustClientRect(position.clientRect, topDifference, leftDifference);\n            }\n        });\n        scrollPosition.top = newTop;\n        scrollPosition.left = newLeft;\n        return { top: topDifference, left: leftDifference };\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Creates a deep clone of an element. */\nfunction deepCloneNode(node) {\n    const clone = node.cloneNode(true);\n    const descendantsWithId = clone.querySelectorAll('[id]');\n    const nodeName = node.nodeName.toLowerCase();\n    // Remove the `id` to avoid having multiple elements with the same id on the page.\n    clone.removeAttribute('id');\n    for (let i = 0; i < descendantsWithId.length; i++) {\n        descendantsWithId[i].removeAttribute('id');\n    }\n    if (nodeName === 'canvas') {\n        transferCanvasData(node, clone);\n    }\n    else if (nodeName === 'input' || nodeName === 'select' || nodeName === 'textarea') {\n        transferInputData(node, clone);\n    }\n    transferData('canvas', node, clone, transferCanvasData);\n    transferData('input, textarea, select', node, clone, transferInputData);\n    return clone;\n}\n/** Matches elements between an element and its clone and allows for their data to be cloned. */\nfunction transferData(selector, node, clone, callback) {\n    const descendantElements = node.querySelectorAll(selector);\n    if (descendantElements.length) {\n        const cloneElements = clone.querySelectorAll(selector);\n        for (let i = 0; i < descendantElements.length; i++) {\n            callback(descendantElements[i], cloneElements[i]);\n        }\n    }\n}\n// Counter for unique cloned radio button names.\nlet cloneUniqueId = 0;\n/** Transfers the data of one input element to another. */\nfunction transferInputData(source, clone) {\n    // Browsers throw an error when assigning the value of a file input programmatically.\n    if (clone.type !== 'file') {\n        clone.value = source.value;\n    }\n    // Radio button `name` attributes must be unique for radio button groups\n    // otherwise original radio buttons can lose their checked state\n    // once the clone is inserted in the DOM.\n    if (clone.type === 'radio' && clone.name) {\n        clone.name = `mat-clone-${clone.name}-${cloneUniqueId++}`;\n    }\n}\n/** Transfers the data of one canvas element to another. */\nfunction transferCanvasData(source, clone) {\n    const context = clone.getContext('2d');\n    if (context) {\n        // In some cases `drawImage` can throw (e.g. if the canvas size is 0x0).\n        // We can't do much about it so just ignore the error.\n        try {\n            context.drawImage(source, 0, 0);\n        }\n        catch (_a) { }\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Options that can be used to bind a passive event listener. */\nconst passiveEventListenerOptions = /*@__PURE__*/ Object(platform[\"f\" /* normalizePassiveListenerOptions */])({ passive: true });\n/** Options that can be used to bind an active event listener. */\nconst activeEventListenerOptions = /*@__PURE__*/ Object(platform[\"f\" /* normalizePassiveListenerOptions */])({ passive: false });\n/**\n * Time in milliseconds for which to ignore mouse events, after\n * receiving a touch event. Used to avoid doing double work for\n * touch devices where the browser fires fake mouse events, in\n * addition to touch events.\n */\nconst MOUSE_EVENT_IGNORE_TIME = 800;\n/**\n * Reference to a draggable item. Used to manipulate or dispose of the item.\n */\nclass drag_drop_DragRef {\n    constructor(element, _config, _document, _ngZone, _viewportRuler, _dragDropRegistry) {\n        this._config = _config;\n        this._document = _document;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        this._dragDropRegistry = _dragDropRegistry;\n        /**\n         * CSS `transform` applied to the element when it isn't being dragged. We need a\n         * passive transform in order for the dragged element to retain its new position\n         * after the user has stopped dragging and because we need to know the relative\n         * position in case they start dragging again. This corresponds to `element.style.transform`.\n         */\n        this._passiveTransform = { x: 0, y: 0 };\n        /** CSS `transform` that is applied to the element while it's being dragged. */\n        this._activeTransform = { x: 0, y: 0 };\n        /** Emits when the item is being moved. */\n        this._moveEvents = new Subject[\"a\" /* Subject */]();\n        /** Subscription to pointer movement events. */\n        this._pointerMoveSubscription = Subscription[\"a\" /* Subscription */].EMPTY;\n        /** Subscription to the event that is dispatched when the user lifts their pointer. */\n        this._pointerUpSubscription = Subscription[\"a\" /* Subscription */].EMPTY;\n        /** Subscription to the viewport being scrolled. */\n        this._scrollSubscription = Subscription[\"a\" /* Subscription */].EMPTY;\n        /** Subscription to the viewport being resized. */\n        this._resizeSubscription = Subscription[\"a\" /* Subscription */].EMPTY;\n        /** Cached reference to the boundary element. */\n        this._boundaryElement = null;\n        /** Whether the native dragging interactions have been enabled on the root element. */\n        this._nativeInteractionsEnabled = true;\n        /** Elements that can be used to drag the draggable item. */\n        this._handles = [];\n        /** Registered handles that are currently disabled. */\n        this._disabledHandles = new Set();\n        /** Layout direction of the item. */\n        this._direction = 'ltr';\n        /**\n         * Amount of milliseconds to wait after the user has put their\n         * pointer down before starting to drag the element.\n         */\n        this.dragStartDelay = 0;\n        this._disabled = false;\n        /** Emits as the drag sequence is being prepared. */\n        this.beforeStarted = new Subject[\"a\" /* Subject */]();\n        /** Emits when the user starts dragging the item. */\n        this.started = new Subject[\"a\" /* Subject */]();\n        /** Emits when the user has released a drag item, before any animations have started. */\n        this.released = new Subject[\"a\" /* Subject */]();\n        /** Emits when the user stops dragging an item in the container. */\n        this.ended = new Subject[\"a\" /* Subject */]();\n        /** Emits when the user has moved the item into a new container. */\n        this.entered = new Subject[\"a\" /* Subject */]();\n        /** Emits when the user removes the item its container by dragging it into another container. */\n        this.exited = new Subject[\"a\" /* Subject */]();\n        /** Emits when the user drops the item inside a container. */\n        this.dropped = new Subject[\"a\" /* Subject */]();\n        /**\n         * Emits as the user is dragging the item. Use with caution,\n         * because this event will fire for every pixel that the user has dragged.\n         */\n        this.moved = this._moveEvents;\n        /** Handler for the `mousedown`/`touchstart` events. */\n        this._pointerDown = (event) => {\n            this.beforeStarted.next();\n            // Delegate the event based on whether it started from a handle or the element itself.\n            if (this._handles.length) {\n                const targetHandle = this._handles.find(handle => {\n                    const target = event.target;\n                    return !!target && (target === handle || handle.contains(target));\n                });\n                if (targetHandle && !this._disabledHandles.has(targetHandle) && !this.disabled) {\n                    this._initializeDragSequence(targetHandle, event);\n                }\n            }\n            else if (!this.disabled) {\n                this._initializeDragSequence(this._rootElement, event);\n            }\n        };\n        /** Handler that is invoked when the user moves their pointer after they've initiated a drag. */\n        this._pointerMove = (event) => {\n            // Prevent the default action as early as possible in order to block\n            // native actions like dragging the selected text or images with the mouse.\n            event.preventDefault();\n            const pointerPosition = this._getPointerPositionOnPage(event);\n            if (!this._hasStartedDragging) {\n                const distanceX = Math.abs(pointerPosition.x - this._pickupPositionOnPage.x);\n                const distanceY = Math.abs(pointerPosition.y - this._pickupPositionOnPage.y);\n                const isOverThreshold = distanceX + distanceY >= this._config.dragStartThreshold;\n                // Only start dragging after the user has moved more than the minimum distance in either\n                // direction. Note that this is preferrable over doing something like `skip(minimumDistance)`\n                // in the `pointerMove` subscription, because we're not guaranteed to have one move event\n                // per pixel of movement (e.g. if the user moves their pointer quickly).\n                if (isOverThreshold) {\n                    const isDelayElapsed = Date.now() >= this._dragStartTime + this._getDragStartDelay(event);\n                    const container = this._dropContainer;\n                    if (!isDelayElapsed) {\n                        this._endDragSequence(event);\n                        return;\n                    }\n                    // Prevent other drag sequences from starting while something in the container is still\n                    // being dragged. This can happen while we're waiting for the drop animation to finish\n                    // and can cause errors, because some elements might still be moving around.\n                    if (!container || (!container.isDragging() && !container.isReceiving())) {\n                        this._hasStartedDragging = true;\n                        this._ngZone.run(() => this._startDragSequence(event));\n                    }\n                }\n                return;\n            }\n            // We only need the preview dimensions if we have a boundary element.\n            if (this._boundaryElement) {\n                // Cache the preview element rect if we haven't cached it already or if\n                // we cached it too early before the element dimensions were computed.\n                if (!this._previewRect || (!this._previewRect.width && !this._previewRect.height)) {\n                    this._previewRect = (this._preview || this._rootElement).getBoundingClientRect();\n                }\n            }\n            const constrainedPointerPosition = this._getConstrainedPointerPosition(pointerPosition);\n            this._hasMoved = true;\n            this._lastKnownPointerPosition = pointerPosition;\n            this._updatePointerDirectionDelta(constrainedPointerPosition);\n            if (this._dropContainer) {\n                this._updateActiveDropContainer(constrainedPointerPosition, pointerPosition);\n            }\n            else {\n                const activeTransform = this._activeTransform;\n                activeTransform.x =\n                    constrainedPointerPosition.x - this._pickupPositionOnPage.x + this._passiveTransform.x;\n                activeTransform.y =\n                    constrainedPointerPosition.y - this._pickupPositionOnPage.y + this._passiveTransform.y;\n                this._applyRootElementTransform(activeTransform.x, activeTransform.y);\n                // Apply transform as attribute if dragging and svg element to work for IE\n                if (typeof SVGElement !== 'undefined' && this._rootElement instanceof SVGElement) {\n                    const appliedTransform = `translate(${activeTransform.x} ${activeTransform.y})`;\n                    this._rootElement.setAttribute('transform', appliedTransform);\n                }\n            }\n            // Since this event gets fired for every pixel while dragging, we only\n            // want to fire it if the consumer opted into it. Also we have to\n            // re-enter the zone because we run all of the events on the outside.\n            if (this._moveEvents.observers.length) {\n                this._ngZone.run(() => {\n                    this._moveEvents.next({\n                        source: this,\n                        pointerPosition: constrainedPointerPosition,\n                        event,\n                        distance: this._getDragDistance(constrainedPointerPosition),\n                        delta: this._pointerDirectionDelta\n                    });\n                });\n            }\n        };\n        /** Handler that is invoked when the user lifts their pointer up, after initiating a drag. */\n        this._pointerUp = (event) => {\n            this._endDragSequence(event);\n        };\n        this.withRootElement(element);\n        this._parentPositions = new ParentPositionTracker(_document, _viewportRuler);\n        _dragDropRegistry.registerDragItem(this);\n    }\n    /** Whether starting to drag this element is disabled. */\n    get disabled() {\n        return this._disabled || !!(this._dropContainer && this._dropContainer.disabled);\n    }\n    set disabled(value) {\n        const newValue = Object(coercion[\"c\" /* coerceBooleanProperty */])(value);\n        if (newValue !== this._disabled) {\n            this._disabled = newValue;\n            this._toggleNativeDragInteractions();\n            this._handles.forEach(handle => toggleNativeDragInteractions(handle, newValue));\n        }\n    }\n    /**\n     * Returns the element that is being used as a placeholder\n     * while the current element is being dragged.\n     */\n    getPlaceholderElement() {\n        return this._placeholder;\n    }\n    /** Returns the root draggable element. */\n    getRootElement() {\n        return this._rootElement;\n    }\n    /**\n     * Gets the currently-visible element that represents the drag item.\n     * While dragging this is the placeholder, otherwise it's the root element.\n     */\n    getVisibleElement() {\n        return this.isDragging() ? this.getPlaceholderElement() : this.getRootElement();\n    }\n    /** Registers the handles that can be used to drag the element. */\n    withHandles(handles) {\n        this._handles = handles.map(handle => Object(coercion[\"e\" /* coerceElement */])(handle));\n        this._handles.forEach(handle => toggleNativeDragInteractions(handle, this.disabled));\n        this._toggleNativeDragInteractions();\n        // Delete any lingering disabled handles that may have been destroyed. Note that we re-create\n        // the set, rather than iterate over it and filter out the destroyed handles, because while\n        // the ES spec allows for sets to be modified while they're being iterated over, some polyfills\n        // use an array internally which may throw an error.\n        const disabledHandles = new Set();\n        this._disabledHandles.forEach(handle => {\n            if (this._handles.indexOf(handle) > -1) {\n                disabledHandles.add(handle);\n            }\n        });\n        this._disabledHandles = disabledHandles;\n        return this;\n    }\n    /**\n     * Registers the template that should be used for the drag preview.\n     * @param template Template that from which to stamp out the preview.\n     */\n    withPreviewTemplate(template) {\n        this._previewTemplate = template;\n        return this;\n    }\n    /**\n     * Registers the template that should be used for the drag placeholder.\n     * @param template Template that from which to stamp out the placeholder.\n     */\n    withPlaceholderTemplate(template) {\n        this._placeholderTemplate = template;\n        return this;\n    }\n    /**\n     * Sets an alternate drag root element. The root element is the element that will be moved as\n     * the user is dragging. Passing an alternate root element is useful when trying to enable\n     * dragging on an element that you might not have access to.\n     */\n    withRootElement(rootElement) {\n        const element = Object(coercion[\"e\" /* coerceElement */])(rootElement);\n        if (element !== this._rootElement) {\n            if (this._rootElement) {\n                this._removeRootElementListeners(this._rootElement);\n            }\n            this._ngZone.runOutsideAngular(() => {\n                element.addEventListener('mousedown', this._pointerDown, activeEventListenerOptions);\n                element.addEventListener('touchstart', this._pointerDown, passiveEventListenerOptions);\n            });\n            this._initialTransform = undefined;\n            this._rootElement = element;\n        }\n        if (typeof SVGElement !== 'undefined' && this._rootElement instanceof SVGElement) {\n            this._ownerSVGElement = this._rootElement.ownerSVGElement;\n        }\n        return this;\n    }\n    /**\n     * Element to which the draggable's position will be constrained.\n     */\n    withBoundaryElement(boundaryElement) {\n        this._boundaryElement = boundaryElement ? Object(coercion[\"e\" /* coerceElement */])(boundaryElement) : null;\n        this._resizeSubscription.unsubscribe();\n        if (boundaryElement) {\n            this._resizeSubscription = this._viewportRuler\n                .change(10)\n                .subscribe(() => this._containInsideBoundaryOnResize());\n        }\n        return this;\n    }\n    /** Removes the dragging functionality from the DOM element. */\n    dispose() {\n        this._removeRootElementListeners(this._rootElement);\n        // Do this check before removing from the registry since it'll\n        // stop being considered as dragged once it is removed.\n        if (this.isDragging()) {\n            // Since we move out the element to the end of the body while it's being\n            // dragged, we have to make sure that it's removed if it gets destroyed.\n            removeNode(this._rootElement);\n        }\n        removeNode(this._anchor);\n        this._destroyPreview();\n        this._destroyPlaceholder();\n        this._dragDropRegistry.removeDragItem(this);\n        this._removeSubscriptions();\n        this.beforeStarted.complete();\n        this.started.complete();\n        this.released.complete();\n        this.ended.complete();\n        this.entered.complete();\n        this.exited.complete();\n        this.dropped.complete();\n        this._moveEvents.complete();\n        this._handles = [];\n        this._disabledHandles.clear();\n        this._dropContainer = undefined;\n        this._resizeSubscription.unsubscribe();\n        this._parentPositions.clear();\n        this._boundaryElement = this._rootElement = this._ownerSVGElement = this._placeholderTemplate =\n            this._previewTemplate = this._anchor = null;\n    }\n    /** Checks whether the element is currently being dragged. */\n    isDragging() {\n        return this._hasStartedDragging && this._dragDropRegistry.isDragging(this);\n    }\n    /** Resets a standalone drag item to its initial position. */\n    reset() {\n        this._rootElement.style.transform = this._initialTransform || '';\n        this._activeTransform = { x: 0, y: 0 };\n        this._passiveTransform = { x: 0, y: 0 };\n    }\n    /**\n     * Sets a handle as disabled. While a handle is disabled, it'll capture and interrupt dragging.\n     * @param handle Handle element that should be disabled.\n     */\n    disableHandle(handle) {\n        if (!this._disabledHandles.has(handle) && this._handles.indexOf(handle) > -1) {\n            this._disabledHandles.add(handle);\n            toggleNativeDragInteractions(handle, true);\n        }\n    }\n    /**\n     * Enables a handle, if it has been disabled.\n     * @param handle Handle element to be enabled.\n     */\n    enableHandle(handle) {\n        if (this._disabledHandles.has(handle)) {\n            this._disabledHandles.delete(handle);\n            toggleNativeDragInteractions(handle, this.disabled);\n        }\n    }\n    /** Sets the layout direction of the draggable item. */\n    withDirection(direction) {\n        this._direction = direction;\n        return this;\n    }\n    /** Sets the container that the item is part of. */\n    _withDropContainer(container) {\n        this._dropContainer = container;\n    }\n    /**\n     * Gets the current position in pixels the draggable outside of a drop container.\n     */\n    getFreeDragPosition() {\n        const position = this.isDragging() ? this._activeTransform : this._passiveTransform;\n        return { x: position.x, y: position.y };\n    }\n    /**\n     * Sets the current position in pixels the draggable outside of a drop container.\n     * @param value New position to be set.\n     */\n    setFreeDragPosition(value) {\n        this._activeTransform = { x: 0, y: 0 };\n        this._passiveTransform.x = value.x;\n        this._passiveTransform.y = value.y;\n        if (!this._dropContainer) {\n            this._applyRootElementTransform(value.x, value.y);\n        }\n        return this;\n    }\n    /** Updates the item's sort order based on the last-known pointer position. */\n    _sortFromLastPointerPosition() {\n        const position = this._lastKnownPointerPosition;\n        if (position && this._dropContainer) {\n            this._updateActiveDropContainer(this._getConstrainedPointerPosition(position), position);\n        }\n    }\n    /** Unsubscribes from the global subscriptions. */\n    _removeSubscriptions() {\n        this._pointerMoveSubscription.unsubscribe();\n        this._pointerUpSubscription.unsubscribe();\n        this._scrollSubscription.unsubscribe();\n    }\n    /** Destroys the preview element and its ViewRef. */\n    _destroyPreview() {\n        if (this._preview) {\n            removeNode(this._preview);\n        }\n        if (this._previewRef) {\n            this._previewRef.destroy();\n        }\n        this._preview = this._previewRef = null;\n    }\n    /** Destroys the placeholder element and its ViewRef. */\n    _destroyPlaceholder() {\n        if (this._placeholder) {\n            removeNode(this._placeholder);\n        }\n        if (this._placeholderRef) {\n            this._placeholderRef.destroy();\n        }\n        this._placeholder = this._placeholderRef = null;\n    }\n    /**\n     * Clears subscriptions and stops the dragging sequence.\n     * @param event Browser event object that ended the sequence.\n     */\n    _endDragSequence(event) {\n        // Note that here we use `isDragging` from the service, rather than from `this`.\n        // The difference is that the one from the service reflects whether a dragging sequence\n        // has been initiated, whereas the one on `this` includes whether the user has passed\n        // the minimum dragging threshold.\n        if (!this._dragDropRegistry.isDragging(this)) {\n            return;\n        }\n        this._removeSubscriptions();\n        this._dragDropRegistry.stopDragging(this);\n        this._toggleNativeDragInteractions();\n        if (this._handles) {\n            this._rootElement.style.webkitTapHighlightColor = this._rootElementTapHighlight;\n        }\n        if (!this._hasStartedDragging) {\n            return;\n        }\n        this.released.next({ source: this });\n        if (this._dropContainer) {\n            // Stop scrolling immediately, instead of waiting for the animation to finish.\n            this._dropContainer._stopScrolling();\n            this._animatePreviewToPlaceholder().then(() => {\n                this._cleanupDragArtifacts(event);\n                this._cleanupCachedDimensions();\n                this._dragDropRegistry.stopDragging(this);\n            });\n        }\n        else {\n            // Convert the active transform into a passive one. This means that next time\n            // the user starts dragging the item, its position will be calculated relatively\n            // to the new passive transform.\n            this._passiveTransform.x = this._activeTransform.x;\n            this._passiveTransform.y = this._activeTransform.y;\n            this._ngZone.run(() => {\n                this.ended.next({\n                    source: this,\n                    distance: this._getDragDistance(this._getPointerPositionOnPage(event))\n                });\n            });\n            this._cleanupCachedDimensions();\n            this._dragDropRegistry.stopDragging(this);\n        }\n    }\n    /** Starts the dragging sequence. */\n    _startDragSequence(event) {\n        if (isTouchEvent(event)) {\n            this._lastTouchEventTime = Date.now();\n        }\n        this._toggleNativeDragInteractions();\n        const dropContainer = this._dropContainer;\n        if (dropContainer) {\n            const element = this._rootElement;\n            const parent = element.parentNode;\n            const preview = this._preview = this._createPreviewElement();\n            const placeholder = this._placeholder = this._createPlaceholderElement();\n            const anchor = this._anchor = this._anchor || this._document.createComment('');\n            // Needs to happen before the root element is moved.\n            const shadowRoot = this._getShadowRoot();\n            // Insert an anchor node so that we can restore the element's position in the DOM.\n            parent.insertBefore(anchor, element);\n            // We move the element out at the end of the body and we make it hidden, because keeping it in\n            // place will throw off the consumer's `:last-child` selectors. We can't remove the element\n            // from the DOM completely, because iOS will stop firing all subsequent events in the chain.\n            toggleVisibility(element, false);\n            this._document.body.appendChild(parent.replaceChild(placeholder, element));\n            getPreviewInsertionPoint(this._document, shadowRoot).appendChild(preview);\n            this.started.next({ source: this }); // Emit before notifying the container.\n            dropContainer.start();\n            this._initialContainer = dropContainer;\n            this._initialIndex = dropContainer.getItemIndex(this);\n        }\n        else {\n            this.started.next({ source: this });\n            this._initialContainer = this._initialIndex = undefined;\n        }\n        // Important to run after we've called `start` on the parent container\n        // so that it has had time to resolve its scrollable parents.\n        this._parentPositions.cache(dropContainer ? dropContainer.getScrollableParents() : []);\n    }\n    /**\n     * Sets up the different variables and subscriptions\n     * that will be necessary for the dragging sequence.\n     * @param referenceElement Element that started the drag sequence.\n     * @param event Browser event object that started the sequence.\n     */\n    _initializeDragSequence(referenceElement, event) {\n        // Always stop propagation for the event that initializes\n        // the dragging sequence, in order to prevent it from potentially\n        // starting another sequence for a draggable parent somewhere up the DOM tree.\n        event.stopPropagation();\n        const isDragging = this.isDragging();\n        const isTouchSequence = isTouchEvent(event);\n        const isAuxiliaryMouseButton = !isTouchSequence && event.button !== 0;\n        const rootElement = this._rootElement;\n        const isSyntheticEvent = !isTouchSequence && this._lastTouchEventTime &&\n            this._lastTouchEventTime + MOUSE_EVENT_IGNORE_TIME > Date.now();\n        // If the event started from an element with the native HTML drag&drop, it'll interfere\n        // with our own dragging (e.g. `img` tags do it by default). Prevent the default action\n        // to stop it from happening. Note that preventing on `dragstart` also seems to work, but\n        // it's flaky and it fails if the user drags it away quickly. Also note that we only want\n        // to do this for `mousedown` since doing the same for `touchstart` will stop any `click`\n        // events from firing on touch devices.\n        if (event.target && event.target.draggable && event.type === 'mousedown') {\n            event.preventDefault();\n        }\n        // Abort if the user is already dragging or is using a mouse button other than the primary one.\n        if (isDragging || isAuxiliaryMouseButton || isSyntheticEvent) {\n            return;\n        }\n        // If we've got handles, we need to disable the tap highlight on the entire root element,\n        // otherwise iOS will still add it, even though all the drag interactions on the handle\n        // are disabled.\n        if (this._handles.length) {\n            this._rootElementTapHighlight = rootElement.style.webkitTapHighlightColor || '';\n            rootElement.style.webkitTapHighlightColor = 'transparent';\n        }\n        this._hasStartedDragging = this._hasMoved = false;\n        // Avoid multiple subscriptions and memory leaks when multi touch\n        // (isDragging check above isn't enough because of possible temporal and/or dimensional delays)\n        this._removeSubscriptions();\n        this._pointerMoveSubscription = this._dragDropRegistry.pointerMove.subscribe(this._pointerMove);\n        this._pointerUpSubscription = this._dragDropRegistry.pointerUp.subscribe(this._pointerUp);\n        this._scrollSubscription = this._dragDropRegistry.scroll.subscribe(scrollEvent => {\n            this._updateOnScroll(scrollEvent);\n        });\n        if (this._boundaryElement) {\n            this._boundaryRect = getMutableClientRect(this._boundaryElement);\n        }\n        // If we have a custom preview we can't know ahead of time how large it'll be so we position\n        // it next to the cursor. The exception is when the consumer has opted into making the preview\n        // the same size as the root element, in which case we do know the size.\n        const previewTemplate = this._previewTemplate;\n        this._pickupPositionInElement = previewTemplate && previewTemplate.template &&\n            !previewTemplate.matchSize ? { x: 0, y: 0 } :\n            this._getPointerPositionInElement(referenceElement, event);\n        const pointerPosition = this._pickupPositionOnPage = this._lastKnownPointerPosition =\n            this._getPointerPositionOnPage(event);\n        this._pointerDirectionDelta = { x: 0, y: 0 };\n        this._pointerPositionAtLastDirectionChange = { x: pointerPosition.x, y: pointerPosition.y };\n        this._dragStartTime = Date.now();\n        this._dragDropRegistry.startDragging(this, event);\n    }\n    /** Cleans up the DOM artifacts that were added to facilitate the element being dragged. */\n    _cleanupDragArtifacts(event) {\n        // Restore the element's visibility and insert it at its old position in the DOM.\n        // It's important that we maintain the position, because moving the element around in the DOM\n        // can throw off `NgFor` which does smart diffing and re-creates elements only when necessary,\n        // while moving the existing elements in all other cases.\n        toggleVisibility(this._rootElement, true);\n        this._anchor.parentNode.replaceChild(this._rootElement, this._anchor);\n        this._destroyPreview();\n        this._destroyPlaceholder();\n        this._boundaryRect = this._previewRect = undefined;\n        // Re-enter the NgZone since we bound `document` events on the outside.\n        this._ngZone.run(() => {\n            const container = this._dropContainer;\n            const currentIndex = container.getItemIndex(this);\n            const pointerPosition = this._getPointerPositionOnPage(event);\n            const distance = this._getDragDistance(this._getPointerPositionOnPage(event));\n            const isPointerOverContainer = container._isOverContainer(pointerPosition.x, pointerPosition.y);\n            this.ended.next({ source: this, distance });\n            this.dropped.next({\n                item: this,\n                currentIndex,\n                previousIndex: this._initialIndex,\n                container: container,\n                previousContainer: this._initialContainer,\n                isPointerOverContainer,\n                distance\n            });\n            container.drop(this, currentIndex, this._initialIndex, this._initialContainer, isPointerOverContainer, distance);\n            this._dropContainer = this._initialContainer;\n        });\n    }\n    /**\n     * Updates the item's position in its drop container, or moves it\n     * into a new one, depending on its current drag position.\n     */\n    _updateActiveDropContainer({ x, y }, { x: rawX, y: rawY }) {\n        // Drop container that draggable has been moved into.\n        let newContainer = this._initialContainer._getSiblingContainerFromPosition(this, x, y);\n        // If we couldn't find a new container to move the item into, and the item has left its\n        // initial container, check whether the it's over the initial container. This handles the\n        // case where two containers are connected one way and the user tries to undo dragging an\n        // item into a new container.\n        if (!newContainer && this._dropContainer !== this._initialContainer &&\n            this._initialContainer._isOverContainer(x, y)) {\n            newContainer = this._initialContainer;\n        }\n        if (newContainer && newContainer !== this._dropContainer) {\n            this._ngZone.run(() => {\n                // Notify the old container that the item has left.\n                this.exited.next({ item: this, container: this._dropContainer });\n                this._dropContainer.exit(this);\n                // Notify the new container that the item has entered.\n                this._dropContainer = newContainer;\n                this._dropContainer.enter(this, x, y, newContainer === this._initialContainer &&\n                    // If we're re-entering the initial container and sorting is disabled,\n                    // put item the into its starting index to begin with.\n                    newContainer.sortingDisabled ? this._initialIndex : undefined);\n                this.entered.next({\n                    item: this,\n                    container: newContainer,\n                    currentIndex: newContainer.getItemIndex(this)\n                });\n            });\n        }\n        this._dropContainer._startScrollingIfNecessary(rawX, rawY);\n        this._dropContainer._sortItem(this, x, y, this._pointerDirectionDelta);\n        this._preview.style.transform =\n            getTransform(x - this._pickupPositionInElement.x, y - this._pickupPositionInElement.y);\n    }\n    /**\n     * Creates the element that will be rendered next to the user's pointer\n     * and will be used as a preview of the element that is being dragged.\n     */\n    _createPreviewElement() {\n        const previewConfig = this._previewTemplate;\n        const previewClass = this.previewClass;\n        const previewTemplate = previewConfig ? previewConfig.template : null;\n        let preview;\n        if (previewTemplate && previewConfig) {\n            // Measure the element before we've inserted the preview\n            // since the insertion could throw off the measurement.\n            const rootRect = previewConfig.matchSize ? this._rootElement.getBoundingClientRect() : null;\n            const viewRef = previewConfig.viewContainer.createEmbeddedView(previewTemplate, previewConfig.context);\n            viewRef.detectChanges();\n            preview = getRootNode(viewRef, this._document);\n            this._previewRef = viewRef;\n            if (previewConfig.matchSize) {\n                matchElementSize(preview, rootRect);\n            }\n            else {\n                preview.style.transform =\n                    getTransform(this._pickupPositionOnPage.x, this._pickupPositionOnPage.y);\n            }\n        }\n        else {\n            const element = this._rootElement;\n            preview = deepCloneNode(element);\n            matchElementSize(preview, element.getBoundingClientRect());\n        }\n        extendStyles(preview.style, {\n            // It's important that we disable the pointer events on the preview, because\n            // it can throw off the `document.elementFromPoint` calls in the `CdkDropList`.\n            pointerEvents: 'none',\n            // We have to reset the margin, because it can throw off positioning relative to the viewport.\n            margin: '0',\n            position: 'fixed',\n            top: '0',\n            left: '0',\n            zIndex: `${this._config.zIndex || 1000}`\n        });\n        toggleNativeDragInteractions(preview, false);\n        preview.classList.add('cdk-drag-preview');\n        preview.setAttribute('dir', this._direction);\n        if (previewClass) {\n            if (Array.isArray(previewClass)) {\n                previewClass.forEach(className => preview.classList.add(className));\n            }\n            else {\n                preview.classList.add(previewClass);\n            }\n        }\n        return preview;\n    }\n    /**\n     * Animates the preview element from its current position to the location of the drop placeholder.\n     * @returns Promise that resolves when the animation completes.\n     */\n    _animatePreviewToPlaceholder() {\n        // If the user hasn't moved yet, the transitionend event won't fire.\n        if (!this._hasMoved) {\n            return Promise.resolve();\n        }\n        const placeholderRect = this._placeholder.getBoundingClientRect();\n        // Apply the class that adds a transition to the preview.\n        this._preview.classList.add('cdk-drag-animating');\n        // Move the preview to the placeholder position.\n        this._preview.style.transform = getTransform(placeholderRect.left, placeholderRect.top);\n        // If the element doesn't have a `transition`, the `transitionend` event won't fire. Since\n        // we need to trigger a style recalculation in order for the `cdk-drag-animating` class to\n        // apply its style, we take advantage of the available info to figure out whether we need to\n        // bind the event in the first place.\n        const duration = getTransformTransitionDurationInMs(this._preview);\n        if (duration === 0) {\n            return Promise.resolve();\n        }\n        return this._ngZone.runOutsideAngular(() => {\n            return new Promise(resolve => {\n                const handler = ((event) => {\n                    if (!event || (event.target === this._preview && event.propertyName === 'transform')) {\n                        this._preview.removeEventListener('transitionend', handler);\n                        resolve();\n                        clearTimeout(timeout);\n                    }\n                });\n                // If a transition is short enough, the browser might not fire the `transitionend` event.\n                // Since we know how long it's supposed to take, add a timeout with a 50% buffer that'll\n                // fire if the transition hasn't completed when it was supposed to.\n                const timeout = setTimeout(handler, duration * 1.5);\n                this._preview.addEventListener('transitionend', handler);\n            });\n        });\n    }\n    /** Creates an element that will be shown instead of the current element while dragging. */\n    _createPlaceholderElement() {\n        const placeholderConfig = this._placeholderTemplate;\n        const placeholderTemplate = placeholderConfig ? placeholderConfig.template : null;\n        let placeholder;\n        if (placeholderTemplate) {\n            this._placeholderRef = placeholderConfig.viewContainer.createEmbeddedView(placeholderTemplate, placeholderConfig.context);\n            this._placeholderRef.detectChanges();\n            placeholder = getRootNode(this._placeholderRef, this._document);\n        }\n        else {\n            placeholder = deepCloneNode(this._rootElement);\n        }\n        placeholder.classList.add('cdk-drag-placeholder');\n        return placeholder;\n    }\n    /**\n     * Figures out the coordinates at which an element was picked up.\n     * @param referenceElement Element that initiated the dragging.\n     * @param event Event that initiated the dragging.\n     */\n    _getPointerPositionInElement(referenceElement, event) {\n        const elementRect = this._rootElement.getBoundingClientRect();\n        const handleElement = referenceElement === this._rootElement ? null : referenceElement;\n        const referenceRect = handleElement ? handleElement.getBoundingClientRect() : elementRect;\n        const point = isTouchEvent(event) ? event.targetTouches[0] : event;\n        const scrollPosition = this._getViewportScrollPosition();\n        const x = point.pageX - referenceRect.left - scrollPosition.left;\n        const y = point.pageY - referenceRect.top - scrollPosition.top;\n        return {\n            x: referenceRect.left - elementRect.left + x,\n            y: referenceRect.top - elementRect.top + y\n        };\n    }\n    /** Determines the point of the page that was touched by the user. */\n    _getPointerPositionOnPage(event) {\n        const scrollPosition = this._getViewportScrollPosition();\n        const point = isTouchEvent(event) ?\n            // `touches` will be empty for start/end events so we have to fall back to `changedTouches`.\n            // Also note that on real devices we're guaranteed for either `touches` or `changedTouches`\n            // to have a value, but Firefox in device emulation mode has a bug where both can be empty\n            // for `touchstart` and `touchend` so we fall back to a dummy object in order to avoid\n            // throwing an error. The value returned here will be incorrect, but since this only\n            // breaks inside a developer tool and the value is only used for secondary information,\n            // we can get away with it. See https://bugzilla.mozilla.org/show_bug.cgi?id=1615824.\n            (event.touches[0] || event.changedTouches[0] || { pageX: 0, pageY: 0 }) : event;\n        const x = point.pageX - scrollPosition.left;\n        const y = point.pageY - scrollPosition.top;\n        // if dragging SVG element, try to convert from the screen coordinate system to the SVG\n        // coordinate system\n        if (this._ownerSVGElement) {\n            const svgMatrix = this._ownerSVGElement.getScreenCTM();\n            if (svgMatrix) {\n                const svgPoint = this._ownerSVGElement.createSVGPoint();\n                svgPoint.x = x;\n                svgPoint.y = y;\n                return svgPoint.matrixTransform(svgMatrix.inverse());\n            }\n        }\n        return { x, y };\n    }\n    /** Gets the pointer position on the page, accounting for any position constraints. */\n    _getConstrainedPointerPosition(point) {\n        const dropContainerLock = this._dropContainer ? this._dropContainer.lockAxis : null;\n        let { x, y } = this.constrainPosition ? this.constrainPosition(point, this) : point;\n        if (this.lockAxis === 'x' || dropContainerLock === 'x') {\n            y = this._pickupPositionOnPage.y;\n        }\n        else if (this.lockAxis === 'y' || dropContainerLock === 'y') {\n            x = this._pickupPositionOnPage.x;\n        }\n        if (this._boundaryRect) {\n            const { x: pickupX, y: pickupY } = this._pickupPositionInElement;\n            const boundaryRect = this._boundaryRect;\n            const previewRect = this._previewRect;\n            const minY = boundaryRect.top + pickupY;\n            const maxY = boundaryRect.bottom - (previewRect.height - pickupY);\n            const minX = boundaryRect.left + pickupX;\n            const maxX = boundaryRect.right - (previewRect.width - pickupX);\n            x = clamp(x, minX, maxX);\n            y = clamp(y, minY, maxY);\n        }\n        return { x, y };\n    }\n    /** Updates the current drag delta, based on the user's current pointer position on the page. */\n    _updatePointerDirectionDelta(pointerPositionOnPage) {\n        const { x, y } = pointerPositionOnPage;\n        const delta = this._pointerDirectionDelta;\n        const positionSinceLastChange = this._pointerPositionAtLastDirectionChange;\n        // Amount of pixels the user has dragged since the last time the direction changed.\n        const changeX = Math.abs(x - positionSinceLastChange.x);\n        const changeY = Math.abs(y - positionSinceLastChange.y);\n        // Because we handle pointer events on a per-pixel basis, we don't want the delta\n        // to change for every pixel, otherwise anything that depends on it can look erratic.\n        // To make the delta more consistent, we track how much the user has moved since the last\n        // delta change and we only update it after it has reached a certain threshold.\n        if (changeX > this._config.pointerDirectionChangeThreshold) {\n            delta.x = x > positionSinceLastChange.x ? 1 : -1;\n            positionSinceLastChange.x = x;\n        }\n        if (changeY > this._config.pointerDirectionChangeThreshold) {\n            delta.y = y > positionSinceLastChange.y ? 1 : -1;\n            positionSinceLastChange.y = y;\n        }\n        return delta;\n    }\n    /** Toggles the native drag interactions, based on how many handles are registered. */\n    _toggleNativeDragInteractions() {\n        if (!this._rootElement || !this._handles) {\n            return;\n        }\n        const shouldEnable = this._handles.length > 0 || !this.isDragging();\n        if (shouldEnable !== this._nativeInteractionsEnabled) {\n            this._nativeInteractionsEnabled = shouldEnable;\n            toggleNativeDragInteractions(this._rootElement, shouldEnable);\n        }\n    }\n    /** Removes the manually-added event listeners from the root element. */\n    _removeRootElementListeners(element) {\n        element.removeEventListener('mousedown', this._pointerDown, activeEventListenerOptions);\n        element.removeEventListener('touchstart', this._pointerDown, passiveEventListenerOptions);\n    }\n    /**\n     * Applies a `transform` to the root element, taking into account any existing transforms on it.\n     * @param x New transform value along the X axis.\n     * @param y New transform value along the Y axis.\n     */\n    _applyRootElementTransform(x, y) {\n        const transform = getTransform(x, y);\n        // Cache the previous transform amount only after the first drag sequence, because\n        // we don't want our own transforms to stack on top of each other.\n        if (this._initialTransform == null) {\n            this._initialTransform = this._rootElement.style.transform || '';\n        }\n        // Preserve the previous `transform` value, if there was one. Note that we apply our own\n        // transform before the user's, because things like rotation can affect which direction\n        // the element will be translated towards.\n        this._rootElement.style.transform = this._initialTransform ?\n            transform + ' ' + this._initialTransform : transform;\n    }\n    /**\n     * Gets the distance that the user has dragged during the current drag sequence.\n     * @param currentPosition Current position of the user's pointer.\n     */\n    _getDragDistance(currentPosition) {\n        const pickupPosition = this._pickupPositionOnPage;\n        if (pickupPosition) {\n            return { x: currentPosition.x - pickupPosition.x, y: currentPosition.y - pickupPosition.y };\n        }\n        return { x: 0, y: 0 };\n    }\n    /** Cleans up any cached element dimensions that we don't need after dragging has stopped. */\n    _cleanupCachedDimensions() {\n        this._boundaryRect = this._previewRect = undefined;\n        this._parentPositions.clear();\n    }\n    /**\n     * Checks whether the element is still inside its boundary after the viewport has been resized.\n     * If not, the position is adjusted so that the element fits again.\n     */\n    _containInsideBoundaryOnResize() {\n        let { x, y } = this._passiveTransform;\n        if ((x === 0 && y === 0) || this.isDragging() || !this._boundaryElement) {\n            return;\n        }\n        const boundaryRect = this._boundaryElement.getBoundingClientRect();\n        const elementRect = this._rootElement.getBoundingClientRect();\n        // It's possible that the element got hidden away after dragging (e.g. by switching to a\n        // different tab). Don't do anything in this case so we don't clear the user's position.\n        if ((boundaryRect.width === 0 && boundaryRect.height === 0) ||\n            (elementRect.width === 0 && elementRect.height === 0)) {\n            return;\n        }\n        const leftOverflow = boundaryRect.left - elementRect.left;\n        const rightOverflow = elementRect.right - boundaryRect.right;\n        const topOverflow = boundaryRect.top - elementRect.top;\n        const bottomOverflow = elementRect.bottom - boundaryRect.bottom;\n        // If the element has become wider than the boundary, we can't\n        // do much to make it fit so we just anchor it to the left.\n        if (boundaryRect.width > elementRect.width) {\n            if (leftOverflow > 0) {\n                x += leftOverflow;\n            }\n            if (rightOverflow > 0) {\n                x -= rightOverflow;\n            }\n        }\n        else {\n            x = 0;\n        }\n        // If the element has become taller than the boundary, we can't\n        // do much to make it fit so we just anchor it to the top.\n        if (boundaryRect.height > elementRect.height) {\n            if (topOverflow > 0) {\n                y += topOverflow;\n            }\n            if (bottomOverflow > 0) {\n                y -= bottomOverflow;\n            }\n        }\n        else {\n            y = 0;\n        }\n        if (x !== this._passiveTransform.x || y !== this._passiveTransform.y) {\n            this.setFreeDragPosition({ y, x });\n        }\n    }\n    /** Gets the drag start delay, based on the event type. */\n    _getDragStartDelay(event) {\n        const value = this.dragStartDelay;\n        if (typeof value === 'number') {\n            return value;\n        }\n        else if (isTouchEvent(event)) {\n            return value.touch;\n        }\n        return value ? value.mouse : 0;\n    }\n    /** Updates the internal state of the draggable element when scrolling has occurred. */\n    _updateOnScroll(event) {\n        const scrollDifference = this._parentPositions.handleScroll(event);\n        if (scrollDifference) {\n            const target = event.target;\n            // ClientRect dimensions are based on the scroll position of the page and its parent node so\n            // we have to update the cached boundary ClientRect if the user has scrolled. Check for\n            // the `document` specifically since IE doesn't support `contains` on it.\n            if (this._boundaryRect && (target === this._document ||\n                (target !== this._boundaryElement && target.contains(this._boundaryElement)))) {\n                adjustClientRect(this._boundaryRect, scrollDifference.top, scrollDifference.left);\n            }\n            this._pickupPositionOnPage.x += scrollDifference.left;\n            this._pickupPositionOnPage.y += scrollDifference.top;\n            // If we're in free drag mode, we have to update the active transform, because\n            // it isn't relative to the viewport like the preview inside a drop list.\n            if (!this._dropContainer) {\n                this._activeTransform.x -= scrollDifference.left;\n                this._activeTransform.y -= scrollDifference.top;\n                this._applyRootElementTransform(this._activeTransform.x, this._activeTransform.y);\n            }\n        }\n    }\n    /** Gets the scroll position of the viewport. */\n    _getViewportScrollPosition() {\n        const cachedPosition = this._parentPositions.positions.get(this._document);\n        return cachedPosition ? cachedPosition.scrollPosition :\n            this._viewportRuler.getViewportScrollPosition();\n    }\n    /**\n     * Lazily resolves and returns the shadow root of the element. We do this in a function, rather\n     * than saving it in property directly on init, because we want to resolve it as late as possible\n     * in order to ensure that the element has been moved into the shadow DOM. Doing it inside the\n     * constructor might be too early if the element is inside of something like `ngFor` or `ngIf`.\n     */\n    _getShadowRoot() {\n        if (this._cachedShadowRoot === undefined) {\n            this._cachedShadowRoot = Object(platform[\"c\" /* _getShadowRoot */])(this._rootElement);\n        }\n        return this._cachedShadowRoot;\n    }\n}\n/**\n * Gets a 3d `transform` that can be applied to an element.\n * @param x Desired position of the element along the X axis.\n * @param y Desired position of the element along the Y axis.\n */\nfunction getTransform(x, y) {\n    // Round the transforms since some browsers will\n    // blur the elements for sub-pixel transforms.\n    return `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`;\n}\n/** Clamps a value between a minimum and a maximum. */\nfunction clamp(value, min, max) {\n    return Math.max(min, Math.min(max, value));\n}\n/**\n * Helper to remove a node from the DOM and to do all the necessary null checks.\n * @param node Node to be removed.\n */\nfunction removeNode(node) {\n    if (node && node.parentNode) {\n        node.parentNode.removeChild(node);\n    }\n}\n/** Determines whether an event is a touch event. */\nfunction isTouchEvent(event) {\n    // This function is called for every pixel that the user has dragged so we need it to be\n    // as fast as possible. Since we only bind mouse events and touch events, we can assume\n    // that if the event's name starts with `t`, it's a touch event.\n    return event.type[0] === 't';\n}\n/** Gets the element into which the drag preview should be inserted. */\nfunction getPreviewInsertionPoint(documentRef, shadowRoot) {\n    // We can't use the body if the user is in fullscreen mode,\n    // because the preview will render under the fullscreen element.\n    // TODO(crisbeto): dedupe this with the `FullscreenOverlayContainer` eventually.\n    return shadowRoot ||\n        documentRef.fullscreenElement ||\n        documentRef.webkitFullscreenElement ||\n        documentRef.mozFullScreenElement ||\n        documentRef.msFullscreenElement ||\n        documentRef.body;\n}\n/**\n * Gets the root HTML element of an embedded view.\n * If the root is not an HTML element it gets wrapped in one.\n */\nfunction getRootNode(viewRef, _document) {\n    const rootNodes = viewRef.rootNodes;\n    if (rootNodes.length === 1 && rootNodes[0].nodeType === _document.ELEMENT_NODE) {\n        return rootNodes[0];\n    }\n    const wrapper = _document.createElement('div');\n    rootNodes.forEach(node => wrapper.appendChild(node));\n    return wrapper;\n}\n/**\n * Matches the target element's size to the source's size.\n * @param target Element that needs to be resized.\n * @param sourceRect Dimensions of the source element.\n */\nfunction matchElementSize(target, sourceRect) {\n    target.style.width = `${sourceRect.width}px`;\n    target.style.height = `${sourceRect.height}px`;\n    target.style.transform = getTransform(sourceRect.left, sourceRect.top);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Moves an item one index in an array to another.\n * @param array Array in which to move the item.\n * @param fromIndex Starting index of the item.\n * @param toIndex Index to which the item should be moved.\n */\nfunction moveItemInArray(array, fromIndex, toIndex) {\n    const from = clamp$1(fromIndex, array.length - 1);\n    const to = clamp$1(toIndex, array.length - 1);\n    if (from === to) {\n        return;\n    }\n    const target = array[from];\n    const delta = to < from ? -1 : 1;\n    for (let i = from; i !== to; i += delta) {\n        array[i] = array[i + delta];\n    }\n    array[to] = target;\n}\n/**\n * Moves an item from one array to another.\n * @param currentArray Array from which to transfer the item.\n * @param targetArray Array into which to put the item.\n * @param currentIndex Index of the item in its current array.\n * @param targetIndex Index at which to insert the item.\n */\nfunction transferArrayItem(currentArray, targetArray, currentIndex, targetIndex) {\n    const from = clamp$1(currentIndex, currentArray.length - 1);\n    const to = clamp$1(targetIndex, targetArray.length);\n    if (currentArray.length) {\n        targetArray.splice(to, 0, currentArray.splice(from, 1)[0]);\n    }\n}\n/**\n * Copies an item from one array to another, leaving it in its\n * original position in current array.\n * @param currentArray Array from which to copy the item.\n * @param targetArray Array into which is copy the item.\n * @param currentIndex Index of the item in its current array.\n * @param targetIndex Index at which to insert the item.\n *\n */\nfunction copyArrayItem(currentArray, targetArray, currentIndex, targetIndex) {\n    const to = clamp$1(targetIndex, targetArray.length);\n    if (currentArray.length) {\n        targetArray.splice(to, 0, currentArray[currentIndex]);\n    }\n}\n/** Clamps a number between zero and a maximum. */\nfunction clamp$1(value, max) {\n    return Math.max(0, Math.min(max, value));\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Proximity, as a ratio to width/height, at which a\n * dragged item will affect the drop container.\n */\nconst DROP_PROXIMITY_THRESHOLD = 0.05;\n/**\n * Proximity, as a ratio to width/height at which to start auto-scrolling the drop list or the\n * viewport. The value comes from trying it out manually until it feels right.\n */\nconst SCROLL_PROXIMITY_THRESHOLD = 0.05;\n/**\n * Number of pixels to scroll for each frame when auto-scrolling an element.\n * The value comes from trying it out manually until it feels right.\n */\nconst AUTO_SCROLL_STEP = 2;\n/**\n * Reference to a drop list. Used to manipulate or dispose of the container.\n */\nclass drag_drop_DropListRef {\n    constructor(element, _dragDropRegistry, _document, _ngZone, _viewportRuler) {\n        this._dragDropRegistry = _dragDropRegistry;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        /** Whether starting a dragging sequence from this container is disabled. */\n        this.disabled = false;\n        /** Whether sorting items within the list is disabled. */\n        this.sortingDisabled = false;\n        /**\n         * Whether auto-scrolling the view when the user\n         * moves their pointer close to the edges is disabled.\n         */\n        this.autoScrollDisabled = false;\n        /**\n         * Function that is used to determine whether an item\n         * is allowed to be moved into a drop container.\n         */\n        this.enterPredicate = () => true;\n        /** Functions that is used to determine whether an item can be sorted into a particular index. */\n        this.sortPredicate = () => true;\n        /** Emits right before dragging has started. */\n        this.beforeStarted = new Subject[\"a\" /* Subject */]();\n        /**\n         * Emits when the user has moved a new drag item into this container.\n         */\n        this.entered = new Subject[\"a\" /* Subject */]();\n        /**\n         * Emits when the user removes an item from the container\n         * by dragging it into another container.\n         */\n        this.exited = new Subject[\"a\" /* Subject */]();\n        /** Emits when the user drops an item inside the container. */\n        this.dropped = new Subject[\"a\" /* Subject */]();\n        /** Emits as the user is swapping items while actively dragging. */\n        this.sorted = new Subject[\"a\" /* Subject */]();\n        /** Whether an item in the list is being dragged. */\n        this._isDragging = false;\n        /** Cache of the dimensions of all the items inside the container. */\n        this._itemPositions = [];\n        /**\n         * Keeps track of the item that was last swapped with the dragged item, as well as what direction\n         * the pointer was moving in when the swap occured and whether the user's pointer continued to\n         * overlap with the swapped item after the swapping occurred.\n         */\n        this._previousSwap = { drag: null, delta: 0, overlaps: false };\n        /** Drop lists that are connected to the current one. */\n        this._siblings = [];\n        /** Direction in which the list is oriented. */\n        this._orientation = 'vertical';\n        /** Connected siblings that currently have a dragged item. */\n        this._activeSiblings = new Set();\n        /** Layout direction of the drop list. */\n        this._direction = 'ltr';\n        /** Subscription to the window being scrolled. */\n        this._viewportScrollSubscription = Subscription[\"a\" /* Subscription */].EMPTY;\n        /** Vertical direction in which the list is currently scrolling. */\n        this._verticalScrollDirection = 0 /* NONE */;\n        /** Horizontal direction in which the list is currently scrolling. */\n        this._horizontalScrollDirection = 0 /* NONE */;\n        /** Used to signal to the current auto-scroll sequence when to stop. */\n        this._stopScrollTimers = new Subject[\"a\" /* Subject */]();\n        /** Shadow root of the current element. Necessary for `elementFromPoint` to resolve correctly. */\n        this._cachedShadowRoot = null;\n        /** Starts the interval that'll auto-scroll the element. */\n        this._startScrollInterval = () => {\n            this._stopScrolling();\n            interval(0, animationFrame[\"a\" /* animationFrameScheduler */])\n                .pipe(Object(takeUntil[\"a\" /* takeUntil */])(this._stopScrollTimers))\n                .subscribe(() => {\n                const node = this._scrollNode;\n                if (this._verticalScrollDirection === 1 /* UP */) {\n                    incrementVerticalScroll(node, -AUTO_SCROLL_STEP);\n                }\n                else if (this._verticalScrollDirection === 2 /* DOWN */) {\n                    incrementVerticalScroll(node, AUTO_SCROLL_STEP);\n                }\n                if (this._horizontalScrollDirection === 1 /* LEFT */) {\n                    incrementHorizontalScroll(node, -AUTO_SCROLL_STEP);\n                }\n                else if (this._horizontalScrollDirection === 2 /* RIGHT */) {\n                    incrementHorizontalScroll(node, AUTO_SCROLL_STEP);\n                }\n            });\n        };\n        this.element = Object(coercion[\"e\" /* coerceElement */])(element);\n        this._document = _document;\n        this.withScrollableParents([this.element]);\n        _dragDropRegistry.registerDropContainer(this);\n        this._parentPositions = new ParentPositionTracker(_document, _viewportRuler);\n    }\n    /** Removes the drop list functionality from the DOM element. */\n    dispose() {\n        this._stopScrolling();\n        this._stopScrollTimers.complete();\n        this._viewportScrollSubscription.unsubscribe();\n        this.beforeStarted.complete();\n        this.entered.complete();\n        this.exited.complete();\n        this.dropped.complete();\n        this.sorted.complete();\n        this._activeSiblings.clear();\n        this._scrollNode = null;\n        this._parentPositions.clear();\n        this._dragDropRegistry.removeDropContainer(this);\n    }\n    /** Whether an item from this list is currently being dragged. */\n    isDragging() {\n        return this._isDragging;\n    }\n    /** Starts dragging an item. */\n    start() {\n        const styles = Object(coercion[\"e\" /* coerceElement */])(this.element).style;\n        this.beforeStarted.next();\n        this._isDragging = true;\n        // We need to disable scroll snapping while the user is dragging, because it breaks automatic\n        // scrolling. The browser seems to round the value based on the snapping points which means\n        // that we can't increment/decrement the scroll position.\n        this._initialScrollSnap = styles.msScrollSnapType || styles.scrollSnapType || '';\n        styles.scrollSnapType = styles.msScrollSnapType = 'none';\n        this._cacheItems();\n        this._siblings.forEach(sibling => sibling._startReceiving(this));\n        this._viewportScrollSubscription.unsubscribe();\n        this._listenToScrollEvents();\n    }\n    /**\n     * Emits an event to indicate that the user moved an item into the container.\n     * @param item Item that was moved into the container.\n     * @param pointerX Position of the item along the X axis.\n     * @param pointerY Position of the item along the Y axis.\n     * @param index Index at which the item entered. If omitted, the container will try to figure it\n     *   out automatically.\n     */\n    enter(item, pointerX, pointerY, index) {\n        this.start();\n        // If sorting is disabled, we want the item to return to its starting\n        // position if the user is returning it to its initial container.\n        let newIndex;\n        if (index == null) {\n            newIndex = this.sortingDisabled ? this._draggables.indexOf(item) : -1;\n            if (newIndex === -1) {\n                // We use the coordinates of where the item entered the drop\n                // zone to figure out at which index it should be inserted.\n                newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY);\n            }\n        }\n        else {\n            newIndex = index;\n        }\n        const activeDraggables = this._activeDraggables;\n        const currentIndex = activeDraggables.indexOf(item);\n        const placeholder = item.getPlaceholderElement();\n        let newPositionReference = activeDraggables[newIndex];\n        // If the item at the new position is the same as the item that is being dragged,\n        // it means that we're trying to restore the item to its initial position. In this\n        // case we should use the next item from the list as the reference.\n        if (newPositionReference === item) {\n            newPositionReference = activeDraggables[newIndex + 1];\n        }\n        // Since the item may be in the `activeDraggables` already (e.g. if the user dragged it\n        // into another container and back again), we have to ensure that it isn't duplicated.\n        if (currentIndex > -1) {\n            activeDraggables.splice(currentIndex, 1);\n        }\n        // Don't use items that are being dragged as a reference, because\n        // their element has been moved down to the bottom of the body.\n        if (newPositionReference && !this._dragDropRegistry.isDragging(newPositionReference)) {\n            const element = newPositionReference.getRootElement();\n            element.parentElement.insertBefore(placeholder, element);\n            activeDraggables.splice(newIndex, 0, item);\n        }\n        else if (this._shouldEnterAsFirstChild(pointerX, pointerY)) {\n            const reference = activeDraggables[0].getRootElement();\n            reference.parentNode.insertBefore(placeholder, reference);\n            activeDraggables.unshift(item);\n        }\n        else {\n            Object(coercion[\"e\" /* coerceElement */])(this.element).appendChild(placeholder);\n            activeDraggables.push(item);\n        }\n        // The transform needs to be cleared so it doesn't throw off the measurements.\n        placeholder.style.transform = '';\n        // Note that the positions were already cached when we called `start` above,\n        // but we need to refresh them since the amount of items has changed and also parent rects.\n        this._cacheItemPositions();\n        this._cacheParentPositions();\n        this.entered.next({ item, container: this, currentIndex: this.getItemIndex(item) });\n    }\n    /**\n     * Removes an item from the container after it was dragged into another container by the user.\n     * @param item Item that was dragged out.\n     */\n    exit(item) {\n        this._reset();\n        this.exited.next({ item, container: this });\n    }\n    /**\n     * Drops an item into this container.\n     * @param item Item being dropped into the container.\n     * @param currentIndex Index at which the item should be inserted.\n     * @param previousIndex Index of the item when dragging started.\n     * @param previousContainer Container from which the item got dragged in.\n     * @param isPointerOverContainer Whether the user's pointer was over the\n     *    container when the item was dropped.\n     * @param distance Distance the user has dragged since the start of the dragging sequence.\n     */\n    drop(item, currentIndex, previousIndex, previousContainer, isPointerOverContainer, distance) {\n        this._reset();\n        this.dropped.next({\n            item,\n            currentIndex,\n            previousIndex,\n            container: this,\n            previousContainer,\n            isPointerOverContainer,\n            distance\n        });\n    }\n    /**\n     * Sets the draggable items that are a part of this list.\n     * @param items Items that are a part of this list.\n     */\n    withItems(items) {\n        const previousItems = this._draggables;\n        this._draggables = items;\n        items.forEach(item => item._withDropContainer(this));\n        if (this.isDragging()) {\n            const draggedItems = previousItems.filter(item => item.isDragging());\n            // If all of the items being dragged were removed\n            // from the list, abort the current drag sequence.\n            if (draggedItems.every(item => items.indexOf(item) === -1)) {\n                this._reset();\n            }\n            else {\n                this._cacheItems();\n            }\n        }\n        return this;\n    }\n    /** Sets the layout direction of the drop list. */\n    withDirection(direction) {\n        this._direction = direction;\n        return this;\n    }\n    /**\n     * Sets the containers that are connected to this one. When two or more containers are\n     * connected, the user will be allowed to transfer items between them.\n     * @param connectedTo Other containers that the current containers should be connected to.\n     */\n    connectedTo(connectedTo) {\n        this._siblings = connectedTo.slice();\n        return this;\n    }\n    /**\n     * Sets the orientation of the container.\n     * @param orientation New orientation for the container.\n     */\n    withOrientation(orientation) {\n        this._orientation = orientation;\n        return this;\n    }\n    /**\n     * Sets which parent elements are can be scrolled while the user is dragging.\n     * @param elements Elements that can be scrolled.\n     */\n    withScrollableParents(elements) {\n        const element = Object(coercion[\"e\" /* coerceElement */])(this.element);\n        // We always allow the current element to be scrollable\n        // so we need to ensure that it's in the array.\n        this._scrollableElements =\n            elements.indexOf(element) === -1 ? [element, ...elements] : elements.slice();\n        return this;\n    }\n    /** Gets the scrollable parents that are registered with this drop container. */\n    getScrollableParents() {\n        return this._scrollableElements;\n    }\n    /**\n     * Figures out the index of an item in the container.\n     * @param item Item whose index should be determined.\n     */\n    getItemIndex(item) {\n        if (!this._isDragging) {\n            return this._draggables.indexOf(item);\n        }\n        // Items are sorted always by top/left in the cache, however they flow differently in RTL.\n        // The rest of the logic still stands no matter what orientation we're in, however\n        // we need to invert the array when determining the index.\n        const items = this._orientation === 'horizontal' && this._direction === 'rtl' ?\n            this._itemPositions.slice().reverse() : this._itemPositions;\n        return findIndex(items, currentItem => currentItem.drag === item);\n    }\n    /**\n     * Whether the list is able to receive the item that\n     * is currently being dragged inside a connected drop list.\n     */\n    isReceiving() {\n        return this._activeSiblings.size > 0;\n    }\n    /**\n     * Sorts an item inside the container based on its position.\n     * @param item Item to be sorted.\n     * @param pointerX Position of the item along the X axis.\n     * @param pointerY Position of the item along the Y axis.\n     * @param pointerDelta Direction in which the pointer is moving along each axis.\n     */\n    _sortItem(item, pointerX, pointerY, pointerDelta) {\n        // Don't sort the item if sorting is disabled or it's out of range.\n        if (this.sortingDisabled ||\n            !isPointerNearClientRect(this._clientRect, DROP_PROXIMITY_THRESHOLD, pointerX, pointerY)) {\n            return;\n        }\n        const siblings = this._itemPositions;\n        const newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY, pointerDelta);\n        if (newIndex === -1 && siblings.length > 0) {\n            return;\n        }\n        const isHorizontal = this._orientation === 'horizontal';\n        const currentIndex = findIndex(siblings, currentItem => currentItem.drag === item);\n        const siblingAtNewPosition = siblings[newIndex];\n        const currentPosition = siblings[currentIndex].clientRect;\n        const newPosition = siblingAtNewPosition.clientRect;\n        const delta = currentIndex > newIndex ? 1 : -1;\n        // How many pixels the item's placeholder should be offset.\n        const itemOffset = this._getItemOffsetPx(currentPosition, newPosition, delta);\n        // How many pixels all the other items should be offset.\n        const siblingOffset = this._getSiblingOffsetPx(currentIndex, siblings, delta);\n        // Save the previous order of the items before moving the item to its new index.\n        // We use this to check whether an item has been moved as a result of the sorting.\n        const oldOrder = siblings.slice();\n        // Shuffle the array in place.\n        moveItemInArray(siblings, currentIndex, newIndex);\n        this.sorted.next({\n            previousIndex: currentIndex,\n            currentIndex: newIndex,\n            container: this,\n            item\n        });\n        siblings.forEach((sibling, index) => {\n            // Don't do anything if the position hasn't changed.\n            if (oldOrder[index] === sibling) {\n                return;\n            }\n            const isDraggedItem = sibling.drag === item;\n            const offset = isDraggedItem ? itemOffset : siblingOffset;\n            const elementToOffset = isDraggedItem ? item.getPlaceholderElement() :\n                sibling.drag.getRootElement();\n            // Update the offset to reflect the new position.\n            sibling.offset += offset;\n            // Since we're moving the items with a `transform`, we need to adjust their cached\n            // client rects to reflect their new position, as well as swap their positions in the cache.\n            // Note that we shouldn't use `getBoundingClientRect` here to update the cache, because the\n            // elements may be mid-animation which will give us a wrong result.\n            if (isHorizontal) {\n                // Round the transforms since some browsers will\n                // blur the elements, for sub-pixel transforms.\n                elementToOffset.style.transform = `translate3d(${Math.round(sibling.offset)}px, 0, 0)`;\n                adjustClientRect(sibling.clientRect, 0, offset);\n            }\n            else {\n                elementToOffset.style.transform = `translate3d(0, ${Math.round(sibling.offset)}px, 0)`;\n                adjustClientRect(sibling.clientRect, offset, 0);\n            }\n        });\n        // Note that it's important that we do this after the client rects have been adjusted.\n        this._previousSwap.overlaps = isInsideClientRect(newPosition, pointerX, pointerY);\n        this._previousSwap.drag = siblingAtNewPosition.drag;\n        this._previousSwap.delta = isHorizontal ? pointerDelta.x : pointerDelta.y;\n    }\n    /**\n     * Checks whether the user's pointer is close to the edges of either the\n     * viewport or the drop list and starts the auto-scroll sequence.\n     * @param pointerX User's pointer position along the x axis.\n     * @param pointerY User's pointer position along the y axis.\n     */\n    _startScrollingIfNecessary(pointerX, pointerY) {\n        if (this.autoScrollDisabled) {\n            return;\n        }\n        let scrollNode;\n        let verticalScrollDirection = 0 /* NONE */;\n        let horizontalScrollDirection = 0 /* NONE */;\n        // Check whether we should start scrolling any of the parent containers.\n        this._parentPositions.positions.forEach((position, element) => {\n            // We have special handling for the `document` below. Also this would be\n            // nicer with a  for...of loop, but it requires changing a compiler flag.\n            if (element === this._document || !position.clientRect || scrollNode) {\n                return;\n            }\n            if (isPointerNearClientRect(position.clientRect, DROP_PROXIMITY_THRESHOLD, pointerX, pointerY)) {\n                [verticalScrollDirection, horizontalScrollDirection] = getElementScrollDirections(element, position.clientRect, pointerX, pointerY);\n                if (verticalScrollDirection || horizontalScrollDirection) {\n                    scrollNode = element;\n                }\n            }\n        });\n        // Otherwise check if we can start scrolling the viewport.\n        if (!verticalScrollDirection && !horizontalScrollDirection) {\n            const { width, height } = this._viewportRuler.getViewportSize();\n            const clientRect = { width, height, top: 0, right: width, bottom: height, left: 0 };\n            verticalScrollDirection = getVerticalScrollDirection(clientRect, pointerY);\n            horizontalScrollDirection = getHorizontalScrollDirection(clientRect, pointerX);\n            scrollNode = window;\n        }\n        if (scrollNode && (verticalScrollDirection !== this._verticalScrollDirection ||\n            horizontalScrollDirection !== this._horizontalScrollDirection ||\n            scrollNode !== this._scrollNode)) {\n            this._verticalScrollDirection = verticalScrollDirection;\n            this._horizontalScrollDirection = horizontalScrollDirection;\n            this._scrollNode = scrollNode;\n            if ((verticalScrollDirection || horizontalScrollDirection) && scrollNode) {\n                this._ngZone.runOutsideAngular(this._startScrollInterval);\n            }\n            else {\n                this._stopScrolling();\n            }\n        }\n    }\n    /** Stops any currently-running auto-scroll sequences. */\n    _stopScrolling() {\n        this._stopScrollTimers.next();\n    }\n    /** Caches the positions of the configured scrollable parents. */\n    _cacheParentPositions() {\n        const element = Object(coercion[\"e\" /* coerceElement */])(this.element);\n        this._parentPositions.cache(this._scrollableElements);\n        // The list element is always in the `scrollableElements`\n        // so we can take advantage of the cached `ClientRect`.\n        this._clientRect = this._parentPositions.positions.get(element).clientRect;\n    }\n    /** Refreshes the position cache of the items and sibling containers. */\n    _cacheItemPositions() {\n        const isHorizontal = this._orientation === 'horizontal';\n        this._itemPositions = this._activeDraggables.map(drag => {\n            const elementToMeasure = drag.getVisibleElement();\n            return { drag, offset: 0, clientRect: getMutableClientRect(elementToMeasure) };\n        }).sort((a, b) => {\n            return isHorizontal ? a.clientRect.left - b.clientRect.left :\n                a.clientRect.top - b.clientRect.top;\n        });\n    }\n    /** Resets the container to its initial state. */\n    _reset() {\n        this._isDragging = false;\n        const styles = Object(coercion[\"e\" /* coerceElement */])(this.element).style;\n        styles.scrollSnapType = styles.msScrollSnapType = this._initialScrollSnap;\n        // TODO(crisbeto): may have to wait for the animations to finish.\n        this._activeDraggables.forEach(item => {\n            const rootElement = item.getRootElement();\n            if (rootElement) {\n                rootElement.style.transform = '';\n            }\n        });\n        this._siblings.forEach(sibling => sibling._stopReceiving(this));\n        this._activeDraggables = [];\n        this._itemPositions = [];\n        this._previousSwap.drag = null;\n        this._previousSwap.delta = 0;\n        this._previousSwap.overlaps = false;\n        this._stopScrolling();\n        this._viewportScrollSubscription.unsubscribe();\n        this._parentPositions.clear();\n    }\n    /**\n     * Gets the offset in pixels by which the items that aren't being dragged should be moved.\n     * @param currentIndex Index of the item currently being dragged.\n     * @param siblings All of the items in the list.\n     * @param delta Direction in which the user is moving.\n     */\n    _getSiblingOffsetPx(currentIndex, siblings, delta) {\n        const isHorizontal = this._orientation === 'horizontal';\n        const currentPosition = siblings[currentIndex].clientRect;\n        const immediateSibling = siblings[currentIndex + delta * -1];\n        let siblingOffset = currentPosition[isHorizontal ? 'width' : 'height'] * delta;\n        if (immediateSibling) {\n            const start = isHorizontal ? 'left' : 'top';\n            const end = isHorizontal ? 'right' : 'bottom';\n            // Get the spacing between the start of the current item and the end of the one immediately\n            // after it in the direction in which the user is dragging, or vice versa. We add it to the\n            // offset in order to push the element to where it will be when it's inline and is influenced\n            // by the `margin` of its siblings.\n            if (delta === -1) {\n                siblingOffset -= immediateSibling.clientRect[start] - currentPosition[end];\n            }\n            else {\n                siblingOffset += currentPosition[start] - immediateSibling.clientRect[end];\n            }\n        }\n        return siblingOffset;\n    }\n    /**\n     * Gets the offset in pixels by which the item that is being dragged should be moved.\n     * @param currentPosition Current position of the item.\n     * @param newPosition Position of the item where the current item should be moved.\n     * @param delta Direction in which the user is moving.\n     */\n    _getItemOffsetPx(currentPosition, newPosition, delta) {\n        const isHorizontal = this._orientation === 'horizontal';\n        let itemOffset = isHorizontal ? newPosition.left - currentPosition.left :\n            newPosition.top - currentPosition.top;\n        // Account for differences in the item width/height.\n        if (delta === -1) {\n            itemOffset += isHorizontal ? newPosition.width - currentPosition.width :\n                newPosition.height - currentPosition.height;\n        }\n        return itemOffset;\n    }\n    /**\n     * Checks if pointer is entering in the first position\n     * @param pointerX Position of the user's pointer along the X axis.\n     * @param pointerY Position of the user's pointer along the Y axis.\n     */\n    _shouldEnterAsFirstChild(pointerX, pointerY) {\n        if (!this._activeDraggables.length) {\n            return false;\n        }\n        const itemPositions = this._itemPositions;\n        const isHorizontal = this._orientation === 'horizontal';\n        // `itemPositions` are sorted by position while `activeDraggables` are sorted by child index\n        // check if container is using some sort of \"reverse\" ordering (eg: flex-direction: row-reverse)\n        const reversed = itemPositions[0].drag !== this._activeDraggables[0];\n        if (reversed) {\n            const lastItemRect = itemPositions[itemPositions.length - 1].clientRect;\n            return isHorizontal ? pointerX >= lastItemRect.right : pointerY >= lastItemRect.bottom;\n        }\n        else {\n            const firstItemRect = itemPositions[0].clientRect;\n            return isHorizontal ? pointerX <= firstItemRect.left : pointerY <= firstItemRect.top;\n        }\n    }\n    /**\n     * Gets the index of an item in the drop container, based on the position of the user's pointer.\n     * @param item Item that is being sorted.\n     * @param pointerX Position of the user's pointer along the X axis.\n     * @param pointerY Position of the user's pointer along the Y axis.\n     * @param delta Direction in which the user is moving their pointer.\n     */\n    _getItemIndexFromPointerPosition(item, pointerX, pointerY, delta) {\n        const isHorizontal = this._orientation === 'horizontal';\n        const index = findIndex(this._itemPositions, ({ drag, clientRect }, _, array) => {\n            if (drag === item) {\n                // If there's only one item left in the container, it must be\n                // the dragged item itself so we use it as a reference.\n                return array.length < 2;\n            }\n            if (delta) {\n                const direction = isHorizontal ? delta.x : delta.y;\n                // If the user is still hovering over the same item as last time, their cursor hasn't left\n                // the item after we made the swap, and they didn't change the direction in which they're\n                // dragging, we don't consider it a direction swap.\n                if (drag === this._previousSwap.drag && this._previousSwap.overlaps &&\n                    direction === this._previousSwap.delta) {\n                    return false;\n                }\n            }\n            return isHorizontal ?\n                // Round these down since most browsers report client rects with\n                // sub-pixel precision, whereas the pointer coordinates are rounded to pixels.\n                pointerX >= Math.floor(clientRect.left) && pointerX < Math.floor(clientRect.right) :\n                pointerY >= Math.floor(clientRect.top) && pointerY < Math.floor(clientRect.bottom);\n        });\n        return (index === -1 || !this.sortPredicate(index, item, this)) ? -1 : index;\n    }\n    /** Caches the current items in the list and their positions. */\n    _cacheItems() {\n        this._activeDraggables = this._draggables.slice();\n        this._cacheItemPositions();\n        this._cacheParentPositions();\n    }\n    /**\n     * Checks whether the user's pointer is positioned over the container.\n     * @param x Pointer position along the X axis.\n     * @param y Pointer position along the Y axis.\n     */\n    _isOverContainer(x, y) {\n        return isInsideClientRect(this._clientRect, x, y);\n    }\n    /**\n     * Figures out whether an item should be moved into a sibling\n     * drop container, based on its current position.\n     * @param item Drag item that is being moved.\n     * @param x Position of the item along the X axis.\n     * @param y Position of the item along the Y axis.\n     */\n    _getSiblingContainerFromPosition(item, x, y) {\n        return this._siblings.find(sibling => sibling._canReceive(item, x, y));\n    }\n    /**\n     * Checks whether the drop list can receive the passed-in item.\n     * @param item Item that is being dragged into the list.\n     * @param x Position of the item along the X axis.\n     * @param y Position of the item along the Y axis.\n     */\n    _canReceive(item, x, y) {\n        if (!isInsideClientRect(this._clientRect, x, y) || !this.enterPredicate(item, this)) {\n            return false;\n        }\n        const elementFromPoint = this._getShadowRoot().elementFromPoint(x, y);\n        // If there's no element at the pointer position, then\n        // the client rect is probably scrolled out of the view.\n        if (!elementFromPoint) {\n            return false;\n        }\n        const nativeElement = Object(coercion[\"e\" /* coerceElement */])(this.element);\n        // The `ClientRect`, that we're using to find the container over which the user is\n        // hovering, doesn't give us any information on whether the element has been scrolled\n        // out of the view or whether it's overlapping with other containers. This means that\n        // we could end up transferring the item into a container that's invisible or is positioned\n        // below another one. We use the result from `elementFromPoint` to get the top-most element\n        // at the pointer position and to find whether it's one of the intersecting drop containers.\n        return elementFromPoint === nativeElement || nativeElement.contains(elementFromPoint);\n    }\n    /**\n     * Called by one of the connected drop lists when a dragging sequence has started.\n     * @param sibling Sibling in which dragging has started.\n     */\n    _startReceiving(sibling) {\n        const activeSiblings = this._activeSiblings;\n        if (!activeSiblings.has(sibling)) {\n            activeSiblings.add(sibling);\n            this._cacheParentPositions();\n            this._listenToScrollEvents();\n        }\n    }\n    /**\n     * Called by a connected drop list when dragging has stopped.\n     * @param sibling Sibling whose dragging has stopped.\n     */\n    _stopReceiving(sibling) {\n        this._activeSiblings.delete(sibling);\n        this._viewportScrollSubscription.unsubscribe();\n    }\n    /**\n     * Starts listening to scroll events on the viewport.\n     * Used for updating the internal state of the list.\n     */\n    _listenToScrollEvents() {\n        this._viewportScrollSubscription = this._dragDropRegistry.scroll.subscribe(event => {\n            if (this.isDragging()) {\n                const scrollDifference = this._parentPositions.handleScroll(event);\n                if (scrollDifference) {\n                    // Since we know the amount that the user has scrolled we can shift all of the\n                    // client rectangles ourselves. This is cheaper than re-measuring everything and\n                    // we can avoid inconsistent behavior where we might be measuring the element before\n                    // its position has changed.\n                    this._itemPositions.forEach(({ clientRect }) => {\n                        adjustClientRect(clientRect, scrollDifference.top, scrollDifference.left);\n                    });\n                    // We need two loops for this, because we want all of the cached\n                    // positions to be up-to-date before we re-sort the item.\n                    this._itemPositions.forEach(({ drag }) => {\n                        if (this._dragDropRegistry.isDragging(drag)) {\n                            // We need to re-sort the item manually, because the pointer move\n                            // events won't be dispatched while the user is scrolling.\n                            drag._sortFromLastPointerPosition();\n                        }\n                    });\n                }\n            }\n            else if (this.isReceiving()) {\n                this._cacheParentPositions();\n            }\n        });\n    }\n    /**\n     * Lazily resolves and returns the shadow root of the element. We do this in a function, rather\n     * than saving it in property directly on init, because we want to resolve it as late as possible\n     * in order to ensure that the element has been moved into the shadow DOM. Doing it inside the\n     * constructor might be too early if the element is inside of something like `ngFor` or `ngIf`.\n     */\n    _getShadowRoot() {\n        if (!this._cachedShadowRoot) {\n            const shadowRoot = Object(platform[\"c\" /* _getShadowRoot */])(Object(coercion[\"e\" /* coerceElement */])(this.element));\n            this._cachedShadowRoot = shadowRoot || this._document;\n        }\n        return this._cachedShadowRoot;\n    }\n}\n/**\n * Finds the index of an item that matches a predicate function. Used as an equivalent\n * of `Array.prototype.findIndex` which isn't part of the standard Google typings.\n * @param array Array in which to look for matches.\n * @param predicate Function used to determine whether an item is a match.\n */\nfunction findIndex(array, predicate) {\n    for (let i = 0; i < array.length; i++) {\n        if (predicate(array[i], i, array)) {\n            return i;\n        }\n    }\n    return -1;\n}\n/**\n * Increments the vertical scroll position of a node.\n * @param node Node whose scroll position should change.\n * @param amount Amount of pixels that the `node` should be scrolled.\n */\nfunction incrementVerticalScroll(node, amount) {\n    if (node === window) {\n        node.scrollBy(0, amount);\n    }\n    else {\n        // Ideally we could use `Element.scrollBy` here as well, but IE and Edge don't support it.\n        node.scrollTop += amount;\n    }\n}\n/**\n * Increments the horizontal scroll position of a node.\n * @param node Node whose scroll position should change.\n * @param amount Amount of pixels that the `node` should be scrolled.\n */\nfunction incrementHorizontalScroll(node, amount) {\n    if (node === window) {\n        node.scrollBy(amount, 0);\n    }\n    else {\n        // Ideally we could use `Element.scrollBy` here as well, but IE and Edge don't support it.\n        node.scrollLeft += amount;\n    }\n}\n/**\n * Gets whether the vertical auto-scroll direction of a node.\n * @param clientRect Dimensions of the node.\n * @param pointerY Position of the user's pointer along the y axis.\n */\nfunction getVerticalScrollDirection(clientRect, pointerY) {\n    const { top, bottom, height } = clientRect;\n    const yThreshold = height * SCROLL_PROXIMITY_THRESHOLD;\n    if (pointerY >= top - yThreshold && pointerY <= top + yThreshold) {\n        return 1 /* UP */;\n    }\n    else if (pointerY >= bottom - yThreshold && pointerY <= bottom + yThreshold) {\n        return 2 /* DOWN */;\n    }\n    return 0 /* NONE */;\n}\n/**\n * Gets whether the horizontal auto-scroll direction of a node.\n * @param clientRect Dimensions of the node.\n * @param pointerX Position of the user's pointer along the x axis.\n */\nfunction getHorizontalScrollDirection(clientRect, pointerX) {\n    const { left, right, width } = clientRect;\n    const xThreshold = width * SCROLL_PROXIMITY_THRESHOLD;\n    if (pointerX >= left - xThreshold && pointerX <= left + xThreshold) {\n        return 1 /* LEFT */;\n    }\n    else if (pointerX >= right - xThreshold && pointerX <= right + xThreshold) {\n        return 2 /* RIGHT */;\n    }\n    return 0 /* NONE */;\n}\n/**\n * Gets the directions in which an element node should be scrolled,\n * assuming that the user's pointer is already within it scrollable region.\n * @param element Element for which we should calculate the scroll direction.\n * @param clientRect Bounding client rectangle of the element.\n * @param pointerX Position of the user's pointer along the x axis.\n * @param pointerY Position of the user's pointer along the y axis.\n */\nfunction getElementScrollDirections(element, clientRect, pointerX, pointerY) {\n    const computedVertical = getVerticalScrollDirection(clientRect, pointerY);\n    const computedHorizontal = getHorizontalScrollDirection(clientRect, pointerX);\n    let verticalScrollDirection = 0 /* NONE */;\n    let horizontalScrollDirection = 0 /* NONE */;\n    // Note that we here we do some extra checks for whether the element is actually scrollable in\n    // a certain direction and we only assign the scroll direction if it is. We do this so that we\n    // can allow other elements to be scrolled, if the current element can't be scrolled anymore.\n    // This allows us to handle cases where the scroll regions of two scrollable elements overlap.\n    if (computedVertical) {\n        const scrollTop = element.scrollTop;\n        if (computedVertical === 1 /* UP */) {\n            if (scrollTop > 0) {\n                verticalScrollDirection = 1 /* UP */;\n            }\n        }\n        else if (element.scrollHeight - scrollTop > element.clientHeight) {\n            verticalScrollDirection = 2 /* DOWN */;\n        }\n    }\n    if (computedHorizontal) {\n        const scrollLeft = element.scrollLeft;\n        if (computedHorizontal === 1 /* LEFT */) {\n            if (scrollLeft > 0) {\n                horizontalScrollDirection = 1 /* LEFT */;\n            }\n        }\n        else if (element.scrollWidth - scrollLeft > element.clientWidth) {\n            horizontalScrollDirection = 2 /* RIGHT */;\n        }\n    }\n    return [verticalScrollDirection, horizontalScrollDirection];\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Event options that can be used to bind an active, capturing event. */\nconst activeCapturingEventOptions = /*@__PURE__*/ Object(platform[\"f\" /* normalizePassiveListenerOptions */])({\n    passive: false,\n    capture: true\n});\nlet drag_drop_DragDropRegistry = /*@__PURE__*/ (() => {\n    class DragDropRegistry {\n        constructor(_ngZone, _document) {\n            this._ngZone = _ngZone;\n            /** Registered drop container instances. */\n            this._dropInstances = new Set();\n            /** Registered drag item instances. */\n            this._dragInstances = new Set();\n            /** Drag item instances that are currently being dragged. */\n            this._activeDragInstances = new Set();\n            /** Keeps track of the event listeners that we've bound to the `document`. */\n            this._globalListeners = new Map();\n            /**\n             * Emits the `touchmove` or `mousemove` events that are dispatched\n             * while the user is dragging a drag item instance.\n             */\n            this.pointerMove = new Subject[\"a\" /* Subject */]();\n            /**\n             * Emits the `touchend` or `mouseup` events that are dispatched\n             * while the user is dragging a drag item instance.\n             */\n            this.pointerUp = new Subject[\"a\" /* Subject */]();\n            /** Emits when the viewport has been scrolled while the user is dragging an item. */\n            this.scroll = new Subject[\"a\" /* Subject */]();\n            /**\n             * Event listener that will prevent the default browser action while the user is dragging.\n             * @param event Event whose default action should be prevented.\n             */\n            this._preventDefaultWhileDragging = (event) => {\n                if (this._activeDragInstances.size) {\n                    event.preventDefault();\n                }\n            };\n            /** Event listener for `touchmove` that is bound even if no dragging is happening. */\n            this._persistentTouchmoveListener = (event) => {\n                if (this._activeDragInstances.size) {\n                    event.preventDefault();\n                    this.pointerMove.next(event);\n                }\n            };\n            this._document = _document;\n        }\n        /** Adds a drop container to the registry. */\n        registerDropContainer(drop) {\n            if (!this._dropInstances.has(drop)) {\n                this._dropInstances.add(drop);\n            }\n        }\n        /** Adds a drag item instance to the registry. */\n        registerDragItem(drag) {\n            this._dragInstances.add(drag);\n            // The `touchmove` event gets bound once, ahead of time, because WebKit\n            // won't preventDefault on a dynamically-added `touchmove` listener.\n            // See https://bugs.webkit.org/show_bug.cgi?id=184250.\n            if (this._dragInstances.size === 1) {\n                this._ngZone.runOutsideAngular(() => {\n                    // The event handler has to be explicitly active,\n                    // because newer browsers make it passive by default.\n                    this._document.addEventListener('touchmove', this._persistentTouchmoveListener, activeCapturingEventOptions);\n                });\n            }\n        }\n        /** Removes a drop container from the registry. */\n        removeDropContainer(drop) {\n            this._dropInstances.delete(drop);\n        }\n        /** Removes a drag item instance from the registry. */\n        removeDragItem(drag) {\n            this._dragInstances.delete(drag);\n            this.stopDragging(drag);\n            if (this._dragInstances.size === 0) {\n                this._document.removeEventListener('touchmove', this._persistentTouchmoveListener, activeCapturingEventOptions);\n            }\n        }\n        /**\n         * Starts the dragging sequence for a drag instance.\n         * @param drag Drag instance which is being dragged.\n         * @param event Event that initiated the dragging.\n         */\n        startDragging(drag, event) {\n            // Do not process the same drag twice to avoid memory leaks and redundant listeners\n            if (this._activeDragInstances.has(drag)) {\n                return;\n            }\n            this._activeDragInstances.add(drag);\n            if (this._activeDragInstances.size === 1) {\n                const isTouchEvent = event.type.startsWith('touch');\n                // We explicitly bind __active__ listeners here, because newer browsers will default to\n                // passive ones for `mousemove` and `touchmove`. The events need to be active, because we\n                // use `preventDefault` to prevent the page from scrolling while the user is dragging.\n                this._globalListeners\n                    .set(isTouchEvent ? 'touchend' : 'mouseup', {\n                    handler: (e) => this.pointerUp.next(e),\n                    options: true\n                })\n                    .set('scroll', {\n                    handler: (e) => this.scroll.next(e),\n                    // Use capturing so that we pick up scroll changes in any scrollable nodes that aren't\n                    // the document. See https://github.com/angular/components/issues/17144.\n                    options: true\n                })\n                    // Preventing the default action on `mousemove` isn't enough to disable text selection\n                    // on Safari so we need to prevent the selection event as well. Alternatively this can\n                    // be done by setting `user-select: none` on the `body`, however it has causes a style\n                    // recalculation which can be expensive on pages with a lot of elements.\n                    .set('selectstart', {\n                    handler: this._preventDefaultWhileDragging,\n                    options: activeCapturingEventOptions\n                });\n                // We don't have to bind a move event for touch drag sequences, because\n                // we already have a persistent global one bound from `registerDragItem`.\n                if (!isTouchEvent) {\n                    this._globalListeners.set('mousemove', {\n                        handler: (e) => this.pointerMove.next(e),\n                        options: activeCapturingEventOptions\n                    });\n                }\n                this._ngZone.runOutsideAngular(() => {\n                    this._globalListeners.forEach((config, name) => {\n                        this._document.addEventListener(name, config.handler, config.options);\n                    });\n                });\n            }\n        }\n        /** Stops dragging a drag item instance. */\n        stopDragging(drag) {\n            this._activeDragInstances.delete(drag);\n            if (this._activeDragInstances.size === 0) {\n                this._clearGlobalListeners();\n            }\n        }\n        /** Gets whether a drag item instance is currently being dragged. */\n        isDragging(drag) {\n            return this._activeDragInstances.has(drag);\n        }\n        ngOnDestroy() {\n            this._dragInstances.forEach(instance => this.removeDragItem(instance));\n            this._dropInstances.forEach(instance => this.removeDropContainer(instance));\n            this._clearGlobalListeners();\n            this.pointerMove.complete();\n            this.pointerUp.complete();\n        }\n        /** Clears out the global event listeners from the `document`. */\n        _clearGlobalListeners() {\n            this._globalListeners.forEach((config, name) => {\n                this._document.removeEventListener(name, config.handler, config.options);\n            });\n            this._globalListeners.clear();\n        }\n    }\n    DragDropRegistry.ɵfac = function DragDropRegistry_Factory(t) { return new (t || DragDropRegistry)(core[\"cc\" /* ɵɵinject */](core[\"B\" /* NgZone */]), core[\"cc\" /* ɵɵinject */](common[\"d\" /* DOCUMENT */])); };\n    DragDropRegistry.ɵprov = /*@__PURE__*/ Object(core[\"Lb\" /* ɵɵdefineInjectable */])({ factory: function DragDropRegistry_Factory() { return new DragDropRegistry(Object(core[\"cc\" /* ɵɵinject */])(core[\"B\" /* NgZone */]), Object(core[\"cc\" /* ɵɵinject */])(common[\"d\" /* DOCUMENT */])); }, token: DragDropRegistry, providedIn: \"root\" });\n    return DragDropRegistry;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Default configuration to be used when creating a `DragRef`. */\nconst DEFAULT_CONFIG = {\n    dragStartThreshold: 5,\n    pointerDirectionChangeThreshold: 5\n};\nlet drag_drop_DragDrop = /*@__PURE__*/ (() => {\n    class DragDrop {\n        constructor(_document, _ngZone, _viewportRuler, _dragDropRegistry) {\n            this._document = _document;\n            this._ngZone = _ngZone;\n            this._viewportRuler = _viewportRuler;\n            this._dragDropRegistry = _dragDropRegistry;\n        }\n        /**\n         * Turns an element into a draggable item.\n         * @param element Element to which to attach the dragging functionality.\n         * @param config Object used to configure the dragging behavior.\n         */\n        createDrag(element, config = DEFAULT_CONFIG) {\n            return new drag_drop_DragRef(element, config, this._document, this._ngZone, this._viewportRuler, this._dragDropRegistry);\n        }\n        /**\n         * Turns an element into a drop list.\n         * @param element Element to which to attach the drop list functionality.\n         */\n        createDropList(element) {\n            return new drag_drop_DropListRef(element, this._dragDropRegistry, this._document, this._ngZone, this._viewportRuler);\n        }\n    }\n    DragDrop.ɵfac = function DragDrop_Factory(t) { return new (t || DragDrop)(core[\"cc\" /* ɵɵinject */](common[\"d\" /* DOCUMENT */]), core[\"cc\" /* ɵɵinject */](core[\"B\" /* NgZone */]), core[\"cc\" /* ɵɵinject */](scrolling[\"e\" /* ViewportRuler */]), core[\"cc\" /* ɵɵinject */](drag_drop_DragDropRegistry)); };\n    DragDrop.ɵprov = /*@__PURE__*/ Object(core[\"Lb\" /* ɵɵdefineInjectable */])({ factory: function DragDrop_Factory() { return new DragDrop(Object(core[\"cc\" /* ɵɵinject */])(common[\"d\" /* DOCUMENT */]), Object(core[\"cc\" /* ɵɵinject */])(core[\"B\" /* NgZone */]), Object(core[\"cc\" /* ɵɵinject */])(scrolling[\"e\" /* ViewportRuler */]), Object(core[\"cc\" /* ɵɵinject */])(drag_drop_DragDropRegistry)); }, token: DragDrop, providedIn: \"root\" });\n    return DragDrop;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injection token that can be used for a `CdkDrag` to provide itself as a parent to the\n * drag-specific child directive (`CdkDragHandle`, `CdkDragPreview` etc.). Used primarily\n * to avoid circular imports.\n * @docs-private\n */\nconst CDK_DRAG_PARENT = /*@__PURE__*/ new core[\"s\" /* InjectionToken */]('CDK_DRAG_PARENT');\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injection token that can be used to reference instances of `CdkDropListGroup`. It serves as\n * alternative token to the actual `CdkDropListGroup` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nconst CDK_DROP_LIST_GROUP = /*@__PURE__*/ new core[\"s\" /* InjectionToken */]('CdkDropListGroup');\nlet drag_drop_CdkDropListGroup = /*@__PURE__*/ (() => {\n    class CdkDropListGroup {\n        constructor() {\n            /** Drop lists registered inside the group. */\n            this._items = new Set();\n            this._disabled = false;\n        }\n        /** Whether starting a dragging sequence from inside this group is disabled. */\n        get disabled() { return this._disabled; }\n        set disabled(value) {\n            this._disabled = Object(coercion[\"c\" /* coerceBooleanProperty */])(value);\n        }\n        ngOnDestroy() {\n            this._items.clear();\n        }\n    }\n    CdkDropListGroup.ɵfac = function CdkDropListGroup_Factory(t) { return new (t || CdkDropListGroup)(); };\n    CdkDropListGroup.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: CdkDropListGroup, selectors: [[\"\", \"cdkDropListGroup\", \"\"]], inputs: { disabled: [\"cdkDropListGroupDisabled\", \"disabled\"] }, exportAs: [\"cdkDropListGroup\"], features: [/*@__PURE__*/ core[\"Bb\" /* ɵɵProvidersFeature */]([{ provide: CDK_DROP_LIST_GROUP, useExisting: CdkDropListGroup }])] });\n    return CdkDropListGroup;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injection token that can be used to configure the\n * behavior of the drag&drop-related components.\n */\nconst CDK_DRAG_CONFIG = /*@__PURE__*/ new core[\"s\" /* InjectionToken */]('CDK_DRAG_CONFIG');\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Asserts that a particular node is an element.\n * @param node Node to be checked.\n * @param name Name to attach to the error message.\n */\nfunction assertElementNode(node, name) {\n    if (node.nodeType !== 1) {\n        throw Error(`${name} must be attached to an element node. ` +\n            `Currently attached to \"${node.nodeName}\".`);\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Counter used to generate unique ids for drop zones. */\nlet _uniqueIdCounter = 0;\n/**\n * Injection token that can be used to reference instances of `CdkDropList`. It serves as\n * alternative token to the actual `CdkDropList` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nconst CDK_DROP_LIST = /*@__PURE__*/ new core[\"s\" /* InjectionToken */]('CdkDropList');\nconst ɵ0 = undefined;\nlet drag_drop_CdkDropList = /*@__PURE__*/ (() => {\n    class CdkDropList {\n        constructor(\n        /** Element that the drop list is attached to. */\n        element, dragDrop, _changeDetectorRef, _scrollDispatcher, _dir, _group, config) {\n            this.element = element;\n            this._changeDetectorRef = _changeDetectorRef;\n            this._scrollDispatcher = _scrollDispatcher;\n            this._dir = _dir;\n            this._group = _group;\n            /** Emits when the list has been destroyed. */\n            this._destroyed = new Subject[\"a\" /* Subject */]();\n            /**\n             * Other draggable containers that this container is connected to and into which the\n             * container's items can be transferred. Can either be references to other drop containers,\n             * or their unique IDs.\n             */\n            this.connectedTo = [];\n            /**\n             * Unique ID for the drop zone. Can be used as a reference\n             * in the `connectedTo` of another `CdkDropList`.\n             */\n            this.id = `cdk-drop-list-${_uniqueIdCounter++}`;\n            /**\n             * Function that is used to determine whether an item\n             * is allowed to be moved into a drop container.\n             */\n            this.enterPredicate = () => true;\n            /** Functions that is used to determine whether an item can be sorted into a particular index. */\n            this.sortPredicate = () => true;\n            /** Emits when the user drops an item inside the container. */\n            this.dropped = new core[\"o\" /* EventEmitter */]();\n            /**\n             * Emits when the user has moved a new drag item into this container.\n             */\n            this.entered = new core[\"o\" /* EventEmitter */]();\n            /**\n             * Emits when the user removes an item from the container\n             * by dragging it into another container.\n             */\n            this.exited = new core[\"o\" /* EventEmitter */]();\n            /** Emits as the user is swapping items while actively dragging. */\n            this.sorted = new core[\"o\" /* EventEmitter */]();\n            /**\n             * Keeps track of the items that are registered with this container. Historically we used to\n             * do this with a `ContentChildren` query, however queries don't handle transplanted views very\n             * well which means that we can't handle cases like dragging the headers of a `mat-table`\n             * correctly. What we do instead is to have the items register themselves with the container\n             * and then we sort them based on their position in the DOM.\n             */\n            this._unsortedItems = new Set();\n            if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                assertElementNode(element.nativeElement, 'cdkDropList');\n            }\n            this._dropListRef = dragDrop.createDropList(element);\n            this._dropListRef.data = this;\n            if (config) {\n                this._assignDefaults(config);\n            }\n            this._dropListRef.enterPredicate = (drag, drop) => {\n                return this.enterPredicate(drag.data, drop.data);\n            };\n            this._dropListRef.sortPredicate =\n                (index, drag, drop) => {\n                    return this.sortPredicate(index, drag.data, drop.data);\n                };\n            this._setupInputSyncSubscription(this._dropListRef);\n            this._handleEvents(this._dropListRef);\n            CdkDropList._dropLists.push(this);\n            if (_group) {\n                _group._items.add(this);\n            }\n        }\n        /** Whether starting a dragging sequence from this container is disabled. */\n        get disabled() {\n            return this._disabled || (!!this._group && this._group.disabled);\n        }\n        set disabled(value) {\n            // Usually we sync the directive and ref state right before dragging starts, in order to have\n            // a single point of failure and to avoid having to use setters for everything. `disabled` is\n            // a special case, because it can prevent the `beforeStarted` event from firing, which can lock\n            // the user in a disabled state, so we also need to sync it as it's being set.\n            this._dropListRef.disabled = this._disabled = Object(coercion[\"c\" /* coerceBooleanProperty */])(value);\n        }\n        /** Registers an items with the drop list. */\n        addItem(item) {\n            this._unsortedItems.add(item);\n            if (this._dropListRef.isDragging()) {\n                this._syncItemsWithRef();\n            }\n        }\n        /** Removes an item from the drop list. */\n        removeItem(item) {\n            this._unsortedItems.delete(item);\n            if (this._dropListRef.isDragging()) {\n                this._syncItemsWithRef();\n            }\n        }\n        /** Gets the registered items in the list, sorted by their position in the DOM. */\n        getSortedItems() {\n            return Array.from(this._unsortedItems).sort((a, b) => {\n                const documentPosition = a._dragRef.getVisibleElement().compareDocumentPosition(b._dragRef.getVisibleElement());\n                // `compareDocumentPosition` returns a bitmask so we have to use a bitwise operator.\n                // https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n                // tslint:disable-next-line:no-bitwise\n                return documentPosition & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;\n            });\n        }\n        ngOnDestroy() {\n            const index = CdkDropList._dropLists.indexOf(this);\n            if (index > -1) {\n                CdkDropList._dropLists.splice(index, 1);\n            }\n            if (this._group) {\n                this._group._items.delete(this);\n            }\n            this._unsortedItems.clear();\n            this._dropListRef.dispose();\n            this._destroyed.next();\n            this._destroyed.complete();\n        }\n        /** Syncs the inputs of the CdkDropList with the options of the underlying DropListRef. */\n        _setupInputSyncSubscription(ref) {\n            if (this._dir) {\n                this._dir.change\n                    .pipe(Object(startWith[\"a\" /* startWith */])(this._dir.value), Object(takeUntil[\"a\" /* takeUntil */])(this._destroyed))\n                    .subscribe(value => ref.withDirection(value));\n            }\n            ref.beforeStarted.subscribe(() => {\n                const siblings = Object(coercion[\"b\" /* coerceArray */])(this.connectedTo).map(drop => {\n                    if (typeof drop === 'string') {\n                        const correspondingDropList = CdkDropList._dropLists.find(list => list.id === drop);\n                        if (!correspondingDropList && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                            console.warn(`CdkDropList could not find connected drop list with id \"${drop}\"`);\n                        }\n                        return correspondingDropList;\n                    }\n                    return drop;\n                });\n                if (this._group) {\n                    this._group._items.forEach(drop => {\n                        if (siblings.indexOf(drop) === -1) {\n                            siblings.push(drop);\n                        }\n                    });\n                }\n                // Note that we resolve the scrollable parents here so that we delay the resolution\n                // as long as possible, ensuring that the element is in its final place in the DOM.\n                if (!this._scrollableParentsResolved) {\n                    const scrollableParents = this._scrollDispatcher\n                        .getAncestorScrollContainers(this.element)\n                        .map(scrollable => scrollable.getElementRef().nativeElement);\n                    this._dropListRef.withScrollableParents(scrollableParents);\n                    // Only do this once since it involves traversing the DOM and the parents\n                    // shouldn't be able to change without the drop list being destroyed.\n                    this._scrollableParentsResolved = true;\n                }\n                ref.disabled = this.disabled;\n                ref.lockAxis = this.lockAxis;\n                ref.sortingDisabled = Object(coercion[\"c\" /* coerceBooleanProperty */])(this.sortingDisabled);\n                ref.autoScrollDisabled = Object(coercion[\"c\" /* coerceBooleanProperty */])(this.autoScrollDisabled);\n                ref\n                    .connectedTo(siblings.filter(drop => drop && drop !== this).map(list => list._dropListRef))\n                    .withOrientation(this.orientation);\n            });\n        }\n        /** Handles events from the underlying DropListRef. */\n        _handleEvents(ref) {\n            ref.beforeStarted.subscribe(() => {\n                this._syncItemsWithRef();\n                this._changeDetectorRef.markForCheck();\n            });\n            ref.entered.subscribe(event => {\n                this.entered.emit({\n                    container: this,\n                    item: event.item.data,\n                    currentIndex: event.currentIndex\n                });\n            });\n            ref.exited.subscribe(event => {\n                this.exited.emit({\n                    container: this,\n                    item: event.item.data\n                });\n                this._changeDetectorRef.markForCheck();\n            });\n            ref.sorted.subscribe(event => {\n                this.sorted.emit({\n                    previousIndex: event.previousIndex,\n                    currentIndex: event.currentIndex,\n                    container: this,\n                    item: event.item.data\n                });\n            });\n            ref.dropped.subscribe(event => {\n                this.dropped.emit({\n                    previousIndex: event.previousIndex,\n                    currentIndex: event.currentIndex,\n                    previousContainer: event.previousContainer.data,\n                    container: event.container.data,\n                    item: event.item.data,\n                    isPointerOverContainer: event.isPointerOverContainer,\n                    distance: event.distance\n                });\n                // Mark for check since all of these events run outside of change\n                // detection and we're not guaranteed for something else to have triggered it.\n                this._changeDetectorRef.markForCheck();\n            });\n        }\n        /** Assigns the default input values based on a provided config object. */\n        _assignDefaults(config) {\n            const { lockAxis, draggingDisabled, sortingDisabled, listAutoScrollDisabled, listOrientation } = config;\n            this.disabled = draggingDisabled == null ? false : draggingDisabled;\n            this.sortingDisabled = sortingDisabled == null ? false : sortingDisabled;\n            this.autoScrollDisabled = listAutoScrollDisabled == null ? false : listAutoScrollDisabled;\n            this.orientation = listOrientation || 'vertical';\n            if (lockAxis) {\n                this.lockAxis = lockAxis;\n            }\n        }\n        /** Syncs up the registered drag items with underlying drop list ref. */\n        _syncItemsWithRef() {\n            this._dropListRef.withItems(this.getSortedItems().map(item => item._dragRef));\n        }\n    }\n    CdkDropList.ɵfac = function CdkDropList_Factory(t) { return new (t || CdkDropList)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](drag_drop_DragDrop), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"h\" /* ChangeDetectorRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](scrolling[\"c\" /* ScrollDispatcher */]), core[\"Pb\" /* ɵɵdirectiveInject */](bidi[\"b\" /* Directionality */], 8), core[\"Pb\" /* ɵɵdirectiveInject */](CDK_DROP_LIST_GROUP, 12), core[\"Pb\" /* ɵɵdirectiveInject */](CDK_DRAG_CONFIG, 8)); };\n    CdkDropList.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: CdkDropList, selectors: [[\"\", \"cdkDropList\", \"\"], [\"cdk-drop-list\"]], hostAttrs: [1, \"cdk-drop-list\"], hostVars: 7, hostBindings: function CdkDropList_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Db\" /* ɵɵattribute */](\"id\", ctx.id);\n                core[\"Hb\" /* ɵɵclassProp */](\"cdk-drop-list-disabled\", ctx.disabled)(\"cdk-drop-list-dragging\", ctx._dropListRef.isDragging())(\"cdk-drop-list-receiving\", ctx._dropListRef.isReceiving());\n            }\n        }, inputs: { connectedTo: [\"cdkDropListConnectedTo\", \"connectedTo\"], id: \"id\", enterPredicate: [\"cdkDropListEnterPredicate\", \"enterPredicate\"], sortPredicate: [\"cdkDropListSortPredicate\", \"sortPredicate\"], disabled: [\"cdkDropListDisabled\", \"disabled\"], sortingDisabled: [\"cdkDropListSortingDisabled\", \"sortingDisabled\"], autoScrollDisabled: [\"cdkDropListAutoScrollDisabled\", \"autoScrollDisabled\"], orientation: [\"cdkDropListOrientation\", \"orientation\"], lockAxis: [\"cdkDropListLockAxis\", \"lockAxis\"], data: [\"cdkDropListData\", \"data\"] }, outputs: { dropped: \"cdkDropListDropped\", entered: \"cdkDropListEntered\", exited: \"cdkDropListExited\", sorted: \"cdkDropListSorted\" }, exportAs: [\"cdkDropList\"], features: [/*@__PURE__*/ core[\"Bb\" /* ɵɵProvidersFeature */]([\n                // Prevent child drop lists from picking up the same group as their parent.\n                { provide: CDK_DROP_LIST_GROUP, useValue: ɵ0 },\n                { provide: CDK_DROP_LIST, useExisting: CdkDropList },\n            ])] });\n    /** Keeps track of the drop lists that are currently on the page. */\n    CdkDropList._dropLists = [];\n    return CdkDropList;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injection token that can be used to reference instances of `CdkDragHandle`. It serves as\n * alternative token to the actual `CdkDragHandle` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nconst CDK_DRAG_HANDLE = /*@__PURE__*/ new core[\"s\" /* InjectionToken */]('CdkDragHandle');\nlet drag_drop_CdkDragHandle = /*@__PURE__*/ (() => {\n    class CdkDragHandle {\n        constructor(element, parentDrag) {\n            this.element = element;\n            /** Emits when the state of the handle has changed. */\n            this._stateChanges = new Subject[\"a\" /* Subject */]();\n            this._disabled = false;\n            if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                assertElementNode(element.nativeElement, 'cdkDragHandle');\n            }\n            this._parentDrag = parentDrag;\n        }\n        /** Whether starting to drag through this handle is disabled. */\n        get disabled() { return this._disabled; }\n        set disabled(value) {\n            this._disabled = Object(coercion[\"c\" /* coerceBooleanProperty */])(value);\n            this._stateChanges.next(this);\n        }\n        ngOnDestroy() {\n            this._stateChanges.complete();\n        }\n    }\n    CdkDragHandle.ɵfac = function CdkDragHandle_Factory(t) { return new (t || CdkDragHandle)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](CDK_DRAG_PARENT, 12)); };\n    CdkDragHandle.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: CdkDragHandle, selectors: [[\"\", \"cdkDragHandle\", \"\"]], hostAttrs: [1, \"cdk-drag-handle\"], inputs: { disabled: [\"cdkDragHandleDisabled\", \"disabled\"] }, features: [/*@__PURE__*/ core[\"Bb\" /* ɵɵProvidersFeature */]([{ provide: CDK_DRAG_HANDLE, useExisting: CdkDragHandle }])] });\n    return CdkDragHandle;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injection token that can be used to reference instances of `CdkDragPlaceholder`. It serves as\n * alternative token to the actual `CdkDragPlaceholder` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nconst CDK_DRAG_PLACEHOLDER = /*@__PURE__*/ new core[\"s\" /* InjectionToken */]('CdkDragPlaceholder');\nlet drag_drop_CdkDragPlaceholder = /*@__PURE__*/ (() => {\n    class CdkDragPlaceholder {\n        constructor(templateRef) {\n            this.templateRef = templateRef;\n        }\n    }\n    CdkDragPlaceholder.ɵfac = function CdkDragPlaceholder_Factory(t) { return new (t || CdkDragPlaceholder)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"O\" /* TemplateRef */])); };\n    CdkDragPlaceholder.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: CdkDragPlaceholder, selectors: [[\"ng-template\", \"cdkDragPlaceholder\", \"\"]], inputs: { data: \"data\" }, features: [/*@__PURE__*/ core[\"Bb\" /* ɵɵProvidersFeature */]([{ provide: CDK_DRAG_PLACEHOLDER, useExisting: CdkDragPlaceholder }])] });\n    return CdkDragPlaceholder;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injection token that can be used to reference instances of `CdkDragPreview`. It serves as\n * alternative token to the actual `CdkDragPreview` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nconst CDK_DRAG_PREVIEW = /*@__PURE__*/ new core[\"s\" /* InjectionToken */]('CdkDragPreview');\nlet drag_drop_CdkDragPreview = /*@__PURE__*/ (() => {\n    class CdkDragPreview {\n        constructor(templateRef) {\n            this.templateRef = templateRef;\n            this._matchSize = false;\n        }\n        /** Whether the preview should preserve the same size as the item that is being dragged. */\n        get matchSize() { return this._matchSize; }\n        set matchSize(value) { this._matchSize = Object(coercion[\"c\" /* coerceBooleanProperty */])(value); }\n    }\n    CdkDragPreview.ɵfac = function CdkDragPreview_Factory(t) { return new (t || CdkDragPreview)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"O\" /* TemplateRef */])); };\n    CdkDragPreview.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: CdkDragPreview, selectors: [[\"ng-template\", \"cdkDragPreview\", \"\"]], inputs: { matchSize: \"matchSize\", data: \"data\" }, features: [/*@__PURE__*/ core[\"Bb\" /* ɵɵProvidersFeature */]([{ provide: CDK_DRAG_PREVIEW, useExisting: CdkDragPreview }])] });\n    return CdkDragPreview;\n})();\nlet drag_drop_CdkDrag = /*@__PURE__*/ (() => {\n    class CdkDrag {\n        constructor(\n        /** Element that the draggable is attached to. */\n        element, \n        /** Droppable container that the draggable is a part of. */\n        dropContainer, \n        /**\n         * @deprecated `_document` parameter no longer being used and will be removed.\n         * @breaking-change 12.0.0\n         */\n        _document, _ngZone, _viewContainerRef, config, _dir, dragDrop, _changeDetectorRef, _selfHandle) {\n            this.element = element;\n            this.dropContainer = dropContainer;\n            this._ngZone = _ngZone;\n            this._viewContainerRef = _viewContainerRef;\n            this._dir = _dir;\n            this._changeDetectorRef = _changeDetectorRef;\n            this._selfHandle = _selfHandle;\n            this._destroyed = new Subject[\"a\" /* Subject */]();\n            /** Emits when the user starts dragging the item. */\n            this.started = new core[\"o\" /* EventEmitter */]();\n            /** Emits when the user has released a drag item, before any animations have started. */\n            this.released = new core[\"o\" /* EventEmitter */]();\n            /** Emits when the user stops dragging an item in the container. */\n            this.ended = new core[\"o\" /* EventEmitter */]();\n            /** Emits when the user has moved the item into a new container. */\n            this.entered = new core[\"o\" /* EventEmitter */]();\n            /** Emits when the user removes the item its container by dragging it into another container. */\n            this.exited = new core[\"o\" /* EventEmitter */]();\n            /** Emits when the user drops the item inside a container. */\n            this.dropped = new core[\"o\" /* EventEmitter */]();\n            /**\n             * Emits as the user is dragging the item. Use with caution,\n             * because this event will fire for every pixel that the user has dragged.\n             */\n            this.moved = new Observable[\"a\" /* Observable */]((observer) => {\n                const subscription = this._dragRef.moved.pipe(Object(map[\"a\" /* map */])(movedEvent => ({\n                    source: this,\n                    pointerPosition: movedEvent.pointerPosition,\n                    event: movedEvent.event,\n                    delta: movedEvent.delta,\n                    distance: movedEvent.distance\n                }))).subscribe(observer);\n                return () => {\n                    subscription.unsubscribe();\n                };\n            });\n            this._dragRef = dragDrop.createDrag(element, {\n                dragStartThreshold: config && config.dragStartThreshold != null ?\n                    config.dragStartThreshold : 5,\n                pointerDirectionChangeThreshold: config && config.pointerDirectionChangeThreshold != null ?\n                    config.pointerDirectionChangeThreshold : 5,\n                zIndex: config === null || config === void 0 ? void 0 : config.zIndex\n            });\n            this._dragRef.data = this;\n            if (config) {\n                this._assignDefaults(config);\n            }\n            // Note that usually the container is assigned when the drop list is picks up the item, but in\n            // some cases (mainly transplanted views with OnPush, see #18341) we may end up in a situation\n            // where there are no items on the first change detection pass, but the items get picked up as\n            // soon as the user triggers another pass by dragging. This is a problem, because the item would\n            // have to switch from standalone mode to drag mode in the middle of the dragging sequence which\n            // is too late since the two modes save different kinds of information. We work around it by\n            // assigning the drop container both from here and the list.\n            if (dropContainer) {\n                this._dragRef._withDropContainer(dropContainer._dropListRef);\n                dropContainer.addItem(this);\n            }\n            this._syncInputs(this._dragRef);\n            this._handleEvents(this._dragRef);\n        }\n        /** Whether starting to drag this element is disabled. */\n        get disabled() {\n            return this._disabled || (this.dropContainer && this.dropContainer.disabled);\n        }\n        set disabled(value) {\n            this._disabled = Object(coercion[\"c\" /* coerceBooleanProperty */])(value);\n            this._dragRef.disabled = this._disabled;\n        }\n        /**\n         * Returns the element that is being used as a placeholder\n         * while the current element is being dragged.\n         */\n        getPlaceholderElement() {\n            return this._dragRef.getPlaceholderElement();\n        }\n        /** Returns the root draggable element. */\n        getRootElement() {\n            return this._dragRef.getRootElement();\n        }\n        /** Resets a standalone drag item to its initial position. */\n        reset() {\n            this._dragRef.reset();\n        }\n        /**\n         * Gets the pixel coordinates of the draggable outside of a drop container.\n         */\n        getFreeDragPosition() {\n            return this._dragRef.getFreeDragPosition();\n        }\n        ngAfterViewInit() {\n            // We need to wait for the zone to stabilize, in order for the reference\n            // element to be in the proper place in the DOM. This is mostly relevant\n            // for draggable elements inside portals since they get stamped out in\n            // their original DOM position and then they get transferred to the portal.\n            this._ngZone.onStable\n                .pipe(Object(take[\"a\" /* take */])(1), Object(takeUntil[\"a\" /* takeUntil */])(this._destroyed))\n                .subscribe(() => {\n                this._updateRootElement();\n                // Listen for any newly-added handles.\n                this._handles.changes.pipe(Object(startWith[\"a\" /* startWith */])(this._handles), \n                // Sync the new handles with the DragRef.\n                Object(tap[\"a\" /* tap */])((handles) => {\n                    const childHandleElements = handles\n                        .filter(handle => handle._parentDrag === this)\n                        .map(handle => handle.element);\n                    // Usually handles are only allowed to be a descendant of the drag element, but if\n                    // the consumer defined a different drag root, we should allow the drag element\n                    // itself to be a handle too.\n                    if (this._selfHandle && this.rootElementSelector) {\n                        childHandleElements.push(this.element);\n                    }\n                    this._dragRef.withHandles(childHandleElements);\n                }), \n                // Listen if the state of any of the handles changes.\n                Object(switchMap[\"a\" /* switchMap */])((handles) => {\n                    return Object(merge[\"a\" /* merge */])(...handles.map(item => {\n                        return item._stateChanges.pipe(Object(startWith[\"a\" /* startWith */])(item));\n                    }));\n                }), Object(takeUntil[\"a\" /* takeUntil */])(this._destroyed)).subscribe(handleInstance => {\n                    // Enabled/disable the handle that changed in the DragRef.\n                    const dragRef = this._dragRef;\n                    const handle = handleInstance.element.nativeElement;\n                    handleInstance.disabled ? dragRef.disableHandle(handle) : dragRef.enableHandle(handle);\n                });\n                if (this.freeDragPosition) {\n                    this._dragRef.setFreeDragPosition(this.freeDragPosition);\n                }\n            });\n        }\n        ngOnChanges(changes) {\n            const rootSelectorChange = changes['rootElementSelector'];\n            const positionChange = changes['freeDragPosition'];\n            // We don't have to react to the first change since it's being\n            // handled in `ngAfterViewInit` where it needs to be deferred.\n            if (rootSelectorChange && !rootSelectorChange.firstChange) {\n                this._updateRootElement();\n            }\n            // Skip the first change since it's being handled in `ngAfterViewInit`.\n            if (positionChange && !positionChange.firstChange && this.freeDragPosition) {\n                this._dragRef.setFreeDragPosition(this.freeDragPosition);\n            }\n        }\n        ngOnDestroy() {\n            if (this.dropContainer) {\n                this.dropContainer.removeItem(this);\n            }\n            this._destroyed.next();\n            this._destroyed.complete();\n            this._dragRef.dispose();\n        }\n        /** Syncs the root element with the `DragRef`. */\n        _updateRootElement() {\n            const element = this.element.nativeElement;\n            const rootElement = this.rootElementSelector ?\n                getClosestMatchingAncestor(element, this.rootElementSelector) : element;\n            if (rootElement && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                assertElementNode(rootElement, 'cdkDrag');\n            }\n            this._dragRef.withRootElement(rootElement || element);\n        }\n        /** Gets the boundary element, based on the `boundaryElement` value. */\n        _getBoundaryElement() {\n            const boundary = this.boundaryElement;\n            if (!boundary) {\n                return null;\n            }\n            if (typeof boundary === 'string') {\n                return getClosestMatchingAncestor(this.element.nativeElement, boundary);\n            }\n            const element = Object(coercion[\"e\" /* coerceElement */])(boundary);\n            if ((typeof ngDevMode === 'undefined' || ngDevMode) &&\n                !element.contains(this.element.nativeElement)) {\n                throw Error('Draggable element is not inside of the node passed into cdkDragBoundary.');\n            }\n            return element;\n        }\n        /** Syncs the inputs of the CdkDrag with the options of the underlying DragRef. */\n        _syncInputs(ref) {\n            ref.beforeStarted.subscribe(() => {\n                if (!ref.isDragging()) {\n                    const dir = this._dir;\n                    const dragStartDelay = this.dragStartDelay;\n                    const placeholder = this._placeholderTemplate ? {\n                        template: this._placeholderTemplate.templateRef,\n                        context: this._placeholderTemplate.data,\n                        viewContainer: this._viewContainerRef\n                    } : null;\n                    const preview = this._previewTemplate ? {\n                        template: this._previewTemplate.templateRef,\n                        context: this._previewTemplate.data,\n                        matchSize: this._previewTemplate.matchSize,\n                        viewContainer: this._viewContainerRef\n                    } : null;\n                    ref.disabled = this.disabled;\n                    ref.lockAxis = this.lockAxis;\n                    ref.dragStartDelay = (typeof dragStartDelay === 'object' && dragStartDelay) ?\n                        dragStartDelay : Object(coercion[\"f\" /* coerceNumberProperty */])(dragStartDelay);\n                    ref.constrainPosition = this.constrainPosition;\n                    ref.previewClass = this.previewClass;\n                    ref\n                        .withBoundaryElement(this._getBoundaryElement())\n                        .withPlaceholderTemplate(placeholder)\n                        .withPreviewTemplate(preview);\n                    if (dir) {\n                        ref.withDirection(dir.value);\n                    }\n                }\n            });\n        }\n        /** Handles the events from the underlying `DragRef`. */\n        _handleEvents(ref) {\n            ref.started.subscribe(() => {\n                this.started.emit({ source: this });\n                // Since all of these events run outside of change detection,\n                // we need to ensure that everything is marked correctly.\n                this._changeDetectorRef.markForCheck();\n            });\n            ref.released.subscribe(() => {\n                this.released.emit({ source: this });\n            });\n            ref.ended.subscribe(event => {\n                this.ended.emit({ source: this, distance: event.distance });\n                // Since all of these events run outside of change detection,\n                // we need to ensure that everything is marked correctly.\n                this._changeDetectorRef.markForCheck();\n            });\n            ref.entered.subscribe(event => {\n                this.entered.emit({\n                    container: event.container.data,\n                    item: this,\n                    currentIndex: event.currentIndex\n                });\n            });\n            ref.exited.subscribe(event => {\n                this.exited.emit({\n                    container: event.container.data,\n                    item: this\n                });\n            });\n            ref.dropped.subscribe(event => {\n                this.dropped.emit({\n                    previousIndex: event.previousIndex,\n                    currentIndex: event.currentIndex,\n                    previousContainer: event.previousContainer.data,\n                    container: event.container.data,\n                    isPointerOverContainer: event.isPointerOverContainer,\n                    item: this,\n                    distance: event.distance\n                });\n            });\n        }\n        /** Assigns the default input values based on a provided config object. */\n        _assignDefaults(config) {\n            const { lockAxis, dragStartDelay, constrainPosition, previewClass, boundaryElement, draggingDisabled, rootElementSelector } = config;\n            this.disabled = draggingDisabled == null ? false : draggingDisabled;\n            this.dragStartDelay = dragStartDelay || 0;\n            if (lockAxis) {\n                this.lockAxis = lockAxis;\n            }\n            if (constrainPosition) {\n                this.constrainPosition = constrainPosition;\n            }\n            if (previewClass) {\n                this.previewClass = previewClass;\n            }\n            if (boundaryElement) {\n                this.boundaryElement = boundaryElement;\n            }\n            if (rootElementSelector) {\n                this.rootElementSelector = rootElementSelector;\n            }\n        }\n    }\n    CdkDrag.ɵfac = function CdkDrag_Factory(t) { return new (t || CdkDrag)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](CDK_DROP_LIST, 12), core[\"Pb\" /* ɵɵdirectiveInject */](common[\"d\" /* DOCUMENT */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"S\" /* ViewContainerRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](CDK_DRAG_CONFIG, 8), core[\"Pb\" /* ɵɵdirectiveInject */](bidi[\"b\" /* Directionality */], 8), core[\"Pb\" /* ɵɵdirectiveInject */](drag_drop_DragDrop), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"h\" /* ChangeDetectorRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](CDK_DRAG_HANDLE, 10)); };\n    CdkDrag.ɵdir = /*@__PURE__*/ core[\"Kb\" /* ɵɵdefineDirective */]({ type: CdkDrag, selectors: [[\"\", \"cdkDrag\", \"\"]], contentQueries: function CdkDrag_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                core[\"Ib\" /* ɵɵcontentQuery */](dirIndex, CDK_DRAG_PREVIEW, true);\n                core[\"Ib\" /* ɵɵcontentQuery */](dirIndex, CDK_DRAG_PLACEHOLDER, true);\n                core[\"Ib\" /* ɵɵcontentQuery */](dirIndex, CDK_DRAG_HANDLE, true);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx._previewTemplate = _t.first);\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx._placeholderTemplate = _t.first);\n                core[\"wc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx._handles = _t);\n            }\n        }, hostAttrs: [1, \"cdk-drag\"], hostVars: 4, hostBindings: function CdkDrag_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Hb\" /* ɵɵclassProp */](\"cdk-drag-disabled\", ctx.disabled)(\"cdk-drag-dragging\", ctx._dragRef.isDragging());\n            }\n        }, inputs: { disabled: [\"cdkDragDisabled\", \"disabled\"], dragStartDelay: [\"cdkDragStartDelay\", \"dragStartDelay\"], lockAxis: [\"cdkDragLockAxis\", \"lockAxis\"], constrainPosition: [\"cdkDragConstrainPosition\", \"constrainPosition\"], previewClass: [\"cdkDragPreviewClass\", \"previewClass\"], boundaryElement: [\"cdkDragBoundary\", \"boundaryElement\"], rootElementSelector: [\"cdkDragRootElement\", \"rootElementSelector\"], data: [\"cdkDragData\", \"data\"], freeDragPosition: [\"cdkDragFreeDragPosition\", \"freeDragPosition\"] }, outputs: { started: \"cdkDragStarted\", released: \"cdkDragReleased\", ended: \"cdkDragEnded\", entered: \"cdkDragEntered\", exited: \"cdkDragExited\", dropped: \"cdkDragDropped\", moved: \"cdkDragMoved\" }, exportAs: [\"cdkDrag\"], features: [/*@__PURE__*/ core[\"Bb\" /* ɵɵProvidersFeature */]([{ provide: CDK_DRAG_PARENT, useExisting: CdkDrag }]), core[\"Ab\" /* ɵɵNgOnChangesFeature */]] });\n    return CdkDrag;\n})();\n/** Gets the closest ancestor of an element that matches a selector. */\nfunction getClosestMatchingAncestor(element, selector) {\n    let currentElement = element.parentElement;\n    while (currentElement) {\n        // IE doesn't support `matches` so we have to fall back to `msMatchesSelector`.\n        if (currentElement.matches ? currentElement.matches(selector) :\n            currentElement.msMatchesSelector(selector)) {\n            return currentElement;\n        }\n        currentElement = currentElement.parentElement;\n    }\n    return null;\n}\nlet drag_drop_DragDropModule = /*@__PURE__*/ (() => {\n    class DragDropModule {\n    }\n    DragDropModule.ɵmod = /*@__PURE__*/ core[\"Nb\" /* ɵɵdefineNgModule */]({ type: DragDropModule });\n    DragDropModule.ɵinj = /*@__PURE__*/ core[\"Mb\" /* ɵɵdefineInjector */]({ factory: function DragDropModule_Factory(t) { return new (t || DragDropModule)(); }, providers: [\n            drag_drop_DragDrop,\n        ], imports: [scrolling[\"b\" /* CdkScrollableModule */]] });\n    return DragDropModule;\n})();\n/*@__PURE__*/ (function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ec\" /* ɵɵsetNgModuleScope */](drag_drop_DragDropModule, { declarations: function () { return [drag_drop_CdkDropList, drag_drop_CdkDropListGroup, drag_drop_CdkDrag, drag_drop_CdkDragHandle, drag_drop_CdkDragPreview, drag_drop_CdkDragPlaceholder]; }, exports: function () { return [scrolling[\"b\" /* CdkScrollableModule */], drag_drop_CdkDropList, drag_drop_CdkDropListGroup, drag_drop_CdkDrag, drag_drop_CdkDragHandle, drag_drop_CdkDragPreview, drag_drop_CdkDragPlaceholder]; } }); })();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=drag-drop.js.map\n\n\n/***/ }),\n\n/***/ \"mCIx\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return DeleteComponent; });\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"fXoL\");\n/* harmony import */ var _ng_bootstrap_ng_bootstrap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"1kSV\");\n\n\nlet DeleteComponent = /*@__PURE__*/ (() => {\n    class DeleteComponent {\n        constructor(modalService, modal) {\n            this.modalService = modalService;\n            this.modal = modal;\n        }\n        ngOnInit() {\n        }\n    }\n    DeleteComponent.ɵfac = function DeleteComponent_Factory(t) { return new (t || DeleteComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdirectiveInject */ \"Pb\"](_ng_bootstrap_ng_bootstrap__WEBPACK_IMPORTED_MODULE_1__[/* NgbModal */ \"c\"]), _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdirectiveInject */ \"Pb\"](_ng_bootstrap_ng_bootstrap__WEBPACK_IMPORTED_MODULE_1__[/* NgbActiveModal */ \"b\"])); };\n    DeleteComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdefineComponent */ \"Jb\"]({ type: DeleteComponent, selectors: [[\"app-delete\"]], decls: 12, vars: 0, consts: [[1, \"modal-header\"], [1, \"modal-title\"], [1, \"modal-body\"], [1, \"modal-footer\"], [\"type\", \"button\", 1, \"btn\", \"btn-light\", 3, \"click\"], [\"type\", \"button\", 1, \"btn\", \"btn-danger\", 3, \"click\"]], template: function DeleteComponent_Template(rf, ctx) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵelementStart */ \"Vb\"](0, \"div\");\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵelementStart */ \"Vb\"](1, \"div\", 0);\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵelementStart */ \"Vb\"](2, \"h4\", 1);\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵtext */ \"Mc\"](3, \"Delete\");\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵelementEnd */ \"Ub\"]();\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵelementEnd */ \"Ub\"]();\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵelementStart */ \"Vb\"](4, \"div\", 2);\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵelementStart */ \"Vb\"](5, \"p\");\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵtext */ \"Mc\"](6, \"Do you really want to delete?\");\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵelementEnd */ \"Ub\"]();\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵelementEnd */ \"Ub\"]();\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵelementStart */ \"Vb\"](7, \"div\", 3);\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵelementStart */ \"Vb\"](8, \"button\", 4);\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵlistener */ \"gc\"](\"click\", function DeleteComponent_Template_button_click_8_listener() { return ctx.modal.dismiss(); });\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵtext */ \"Mc\"](9, \"Cancel\");\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵelementEnd */ \"Ub\"]();\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵelementStart */ \"Vb\"](10, \"button\", 5);\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵlistener */ \"gc\"](\"click\", function DeleteComponent_Template_button_click_10_listener() { return ctx.modal.close(); });\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵtext */ \"Mc\"](11, \"Delete\");\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵelementEnd */ \"Ub\"]();\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵelementEnd */ \"Ub\"]();\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵelementEnd */ \"Ub\"]();\n            }\n        }, styles: [\"\"] });\n    return DeleteComponent;\n})();\n\n\n/***/ })\n\n}]);","inputSourceMap":null}