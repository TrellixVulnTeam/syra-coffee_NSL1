{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{\"/1cH\":function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return MatAutocomplete}),__webpack_require__.d(__webpack_exports__,\"b\",function(){return MatAutocompleteModule}),__webpack_require__.d(__webpack_exports__,\"c\",function(){return MatAutocompleteTrigger});var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(\"u47x\"),_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(\"8LU1\"),_angular_core__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(\"fXoL\"),_angular_material_core__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(\"FKr1\"),rxjs__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(\"quSY\"),rxjs__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__(\"XNiG\"),rxjs__WEBPACK_IMPORTED_MODULE_6__=__webpack_require__(\"NXyV\"),rxjs__WEBPACK_IMPORTED_MODULE_7__=__webpack_require__(\"VRyK\"),rxjs__WEBPACK_IMPORTED_MODULE_8__=__webpack_require__(\"LRne\"),rxjs__WEBPACK_IMPORTED_MODULE_9__=__webpack_require__(\"xgIS\"),_angular_common__WEBPACK_IMPORTED_MODULE_10__=__webpack_require__(\"ofXK\"),_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_11__=__webpack_require__(\"rDax\"),_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_12__=__webpack_require__(\"vxfF\"),_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_13__=__webpack_require__(\"FtGj\"),_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_14__=__webpack_require__(\"nLfN\"),_angular_cdk_portal__WEBPACK_IMPORTED_MODULE_15__=__webpack_require__(\"+rOU\"),_angular_forms__WEBPACK_IMPORTED_MODULE_16__=__webpack_require__(\"3Pt+\"),_angular_material_form_field__WEBPACK_IMPORTED_MODULE_17__=__webpack_require__(\"kmnG\"),rxjs_operators__WEBPACK_IMPORTED_MODULE_18__=__webpack_require__(\"IzEk\"),rxjs_operators__WEBPACK_IMPORTED_MODULE_19__=__webpack_require__(\"eIep\"),rxjs_operators__WEBPACK_IMPORTED_MODULE_20__=__webpack_require__(\"pLZG\"),rxjs_operators__WEBPACK_IMPORTED_MODULE_21__=__webpack_require__(\"lJxs\"),rxjs_operators__WEBPACK_IMPORTED_MODULE_22__=__webpack_require__(\"vkgz\"),rxjs_operators__WEBPACK_IMPORTED_MODULE_23__=__webpack_require__(\"3E0/\"),_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_24__=__webpack_require__(\"cH1L\");const _c0=[\"panel\"];function MatAutocomplete_ng_template_0_Template(rf,ctx){if(1&rf&&(_angular_core__WEBPACK_IMPORTED_MODULE_2__.Vb(0,\"div\",0,1),_angular_core__WEBPACK_IMPORTED_MODULE_2__.nc(2),_angular_core__WEBPACK_IMPORTED_MODULE_2__.Ub()),2&rf){const formFieldId_r1=ctx.id,ctx_r0=_angular_core__WEBPACK_IMPORTED_MODULE_2__.kc();_angular_core__WEBPACK_IMPORTED_MODULE_2__.pc(\"id\",ctx_r0.id)(\"ngClass\",ctx_r0._classList),_angular_core__WEBPACK_IMPORTED_MODULE_2__.Db(\"aria-label\",ctx_r0.ariaLabel||null)(\"aria-labelledby\",ctx_r0._getPanelAriaLabelledby(formFieldId_r1))}}const _c1=[\"*\"];let _uniqueAutocompleteIdCounter=0;class MatAutocompleteSelectedEvent{constructor(source,option){this.source=source,this.option=option}}class MatAutocompleteBase{}const _MatAutocompleteMixinBase=Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_3__.v)(MatAutocompleteBase),MAT_AUTOCOMPLETE_DEFAULT_OPTIONS=new _angular_core__WEBPACK_IMPORTED_MODULE_2__.s(\"mat-autocomplete-default-options\",{providedIn:\"root\",factory:function(){return{autoActiveFirstOption:!1}}});let _MatAutocompleteBase=(()=>{class _MatAutocompleteBase extends _MatAutocompleteMixinBase{constructor(_changeDetectorRef,_elementRef,defaults){super(),this._changeDetectorRef=_changeDetectorRef,this._elementRef=_elementRef,this._activeOptionChanges=rxjs__WEBPACK_IMPORTED_MODULE_4__.a.EMPTY,this.showPanel=!1,this._isOpen=!1,this.displayWith=null,this.optionSelected=new _angular_core__WEBPACK_IMPORTED_MODULE_2__.o,this.opened=new _angular_core__WEBPACK_IMPORTED_MODULE_2__.o,this.closed=new _angular_core__WEBPACK_IMPORTED_MODULE_2__.o,this.optionActivated=new _angular_core__WEBPACK_IMPORTED_MODULE_2__.o,this._classList={},this.id=\"mat-autocomplete-\"+_uniqueAutocompleteIdCounter++,this._autoActiveFirstOption=!!defaults.autoActiveFirstOption}get isOpen(){return this._isOpen&&this.showPanel}get autoActiveFirstOption(){return this._autoActiveFirstOption}set autoActiveFirstOption(value){this._autoActiveFirstOption=Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__.c)(value)}set classList(value){this._classList=value&&value.length?Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__.g)(value).reduce((classList,className)=>(classList[className]=!0,classList),{}):{},this._setVisibilityClasses(this._classList),this._elementRef.nativeElement.className=\"\"}ngAfterContentInit(){this._keyManager=new _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__.b(this.options).withWrap(),this._activeOptionChanges=this._keyManager.change.subscribe(index=>{this.optionActivated.emit({source:this,option:this.options.toArray()[index]||null})}),this._setVisibility()}ngOnDestroy(){this._activeOptionChanges.unsubscribe()}_setScrollTop(scrollTop){this.panel&&(this.panel.nativeElement.scrollTop=scrollTop)}_getScrollTop(){return this.panel?this.panel.nativeElement.scrollTop:0}_setVisibility(){this.showPanel=!!this.options.length,this._setVisibilityClasses(this._classList),this._changeDetectorRef.markForCheck()}_emitSelectEvent(option){const event=new MatAutocompleteSelectedEvent(this,option);this.optionSelected.emit(event)}_getPanelAriaLabelledby(labelId){return this.ariaLabel?null:this.ariaLabelledby?labelId+\" \"+this.ariaLabelledby:labelId}_setVisibilityClasses(classList){classList[this._visibleClass]=this.showPanel,classList[this._hiddenClass]=!this.showPanel}}return _MatAutocompleteBase.ɵfac=function(t){return new(t||_MatAutocompleteBase)(_angular_core__WEBPACK_IMPORTED_MODULE_2__.Pb(_angular_core__WEBPACK_IMPORTED_MODULE_2__.h),_angular_core__WEBPACK_IMPORTED_MODULE_2__.Pb(_angular_core__WEBPACK_IMPORTED_MODULE_2__.l),_angular_core__WEBPACK_IMPORTED_MODULE_2__.Pb(MAT_AUTOCOMPLETE_DEFAULT_OPTIONS))},_MatAutocompleteBase.ɵdir=_angular_core__WEBPACK_IMPORTED_MODULE_2__.Kb({type:_MatAutocompleteBase,viewQuery:function(rf,ctx){if(1&rf&&(_angular_core__WEBPACK_IMPORTED_MODULE_2__.Gc(_angular_core__WEBPACK_IMPORTED_MODULE_2__.O,!0),_angular_core__WEBPACK_IMPORTED_MODULE_2__.Rc(_c0,!0)),2&rf){let _t;_angular_core__WEBPACK_IMPORTED_MODULE_2__.wc(_t=_angular_core__WEBPACK_IMPORTED_MODULE_2__.hc())&&(ctx.template=_t.first),_angular_core__WEBPACK_IMPORTED_MODULE_2__.wc(_t=_angular_core__WEBPACK_IMPORTED_MODULE_2__.hc())&&(ctx.panel=_t.first)}},inputs:{displayWith:\"displayWith\",autoActiveFirstOption:\"autoActiveFirstOption\",classList:[\"class\",\"classList\"],ariaLabel:[\"aria-label\",\"ariaLabel\"],ariaLabelledby:[\"aria-labelledby\",\"ariaLabelledby\"],panelWidth:\"panelWidth\"},outputs:{optionSelected:\"optionSelected\",opened:\"opened\",closed:\"closed\",optionActivated:\"optionActivated\"},features:[_angular_core__WEBPACK_IMPORTED_MODULE_2__.zb]}),_MatAutocompleteBase})(),MatAutocomplete=(()=>{class MatAutocomplete extends _MatAutocompleteBase{constructor(){super(...arguments),this._visibleClass=\"mat-autocomplete-visible\",this._hiddenClass=\"mat-autocomplete-hidden\"}}return MatAutocomplete.ɵfac=function(t){return ɵMatAutocomplete_BaseFactory(t||MatAutocomplete)},MatAutocomplete.ɵcmp=_angular_core__WEBPACK_IMPORTED_MODULE_2__.Jb({type:MatAutocomplete,selectors:[[\"mat-autocomplete\"]],contentQueries:function(rf,ctx,dirIndex){if(1&rf&&(_angular_core__WEBPACK_IMPORTED_MODULE_2__.Ib(dirIndex,_angular_material_core__WEBPACK_IMPORTED_MODULE_3__.f,!0),_angular_core__WEBPACK_IMPORTED_MODULE_2__.Ib(dirIndex,_angular_material_core__WEBPACK_IMPORTED_MODULE_3__.l,!0)),2&rf){let _t;_angular_core__WEBPACK_IMPORTED_MODULE_2__.wc(_t=_angular_core__WEBPACK_IMPORTED_MODULE_2__.hc())&&(ctx.optionGroups=_t),_angular_core__WEBPACK_IMPORTED_MODULE_2__.wc(_t=_angular_core__WEBPACK_IMPORTED_MODULE_2__.hc())&&(ctx.options=_t)}},hostAttrs:[1,\"mat-autocomplete\"],inputs:{disableRipple:\"disableRipple\"},exportAs:[\"matAutocomplete\"],features:[_angular_core__WEBPACK_IMPORTED_MODULE_2__.Bb([{provide:_angular_material_core__WEBPACK_IMPORTED_MODULE_3__.g,useExisting:MatAutocomplete}]),_angular_core__WEBPACK_IMPORTED_MODULE_2__.zb],ngContentSelectors:_c1,decls:1,vars:0,consts:[[\"role\",\"listbox\",1,\"mat-autocomplete-panel\",3,\"id\",\"ngClass\"],[\"panel\",\"\"]],template:function(rf,ctx){1&rf&&(_angular_core__WEBPACK_IMPORTED_MODULE_2__.oc(),_angular_core__WEBPACK_IMPORTED_MODULE_2__.Kc(0,MatAutocomplete_ng_template_0_Template,3,4,\"ng-template\"))},directives:[_angular_common__WEBPACK_IMPORTED_MODULE_10__.j],styles:[\".mat-autocomplete-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;visibility:hidden;max-width:none;max-height:256px;position:relative;width:100%;border-bottom-left-radius:4px;border-bottom-right-radius:4px}.mat-autocomplete-panel.mat-autocomplete-visible{visibility:visible}.mat-autocomplete-panel.mat-autocomplete-hidden{visibility:hidden}.mat-autocomplete-panel-above .mat-autocomplete-panel{border-radius:0;border-top-left-radius:4px;border-top-right-radius:4px}.mat-autocomplete-panel .mat-divider-horizontal{margin-top:-1px}.cdk-high-contrast-active .mat-autocomplete-panel{outline:solid 1px}\\n\"],encapsulation:2,changeDetection:0}),MatAutocomplete})();const ɵMatAutocomplete_BaseFactory=_angular_core__WEBPACK_IMPORTED_MODULE_2__.Xb(MatAutocomplete),MAT_AUTOCOMPLETE_SCROLL_STRATEGY=new _angular_core__WEBPACK_IMPORTED_MODULE_2__.s(\"mat-autocomplete-scroll-strategy\"),MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER={provide:MAT_AUTOCOMPLETE_SCROLL_STRATEGY,deps:[_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_11__.c],useFactory:function(overlay){return()=>overlay.scrollStrategies.reposition()}},MAT_AUTOCOMPLETE_VALUE_ACCESSOR={provide:_angular_forms__WEBPACK_IMPORTED_MODULE_16__.k,useExisting:Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__.W)(()=>MatAutocompleteTrigger),multi:!0};let _MatAutocompleteTriggerBase=(()=>{class _MatAutocompleteTriggerBase{constructor(_element,_overlay,_viewContainerRef,_zone,_changeDetectorRef,scrollStrategy,_dir,_formField,_document,_viewportRuler,_defaults){this._element=_element,this._overlay=_overlay,this._viewContainerRef=_viewContainerRef,this._zone=_zone,this._changeDetectorRef=_changeDetectorRef,this._dir=_dir,this._formField=_formField,this._document=_document,this._viewportRuler=_viewportRuler,this._defaults=_defaults,this._componentDestroyed=!1,this._autocompleteDisabled=!1,this._manuallyFloatingLabel=!1,this._viewportSubscription=rxjs__WEBPACK_IMPORTED_MODULE_4__.a.EMPTY,this._canOpenOnNextFocus=!0,this._closeKeyEventStream=new rxjs__WEBPACK_IMPORTED_MODULE_5__.a,this._windowBlurHandler=()=>{this._canOpenOnNextFocus=this._document.activeElement!==this._element.nativeElement||this.panelOpen},this._onChange=()=>{},this._onTouched=()=>{},this.position=\"auto\",this.autocompleteAttribute=\"off\",this._overlayAttached=!1,this.optionSelections=Object(rxjs__WEBPACK_IMPORTED_MODULE_6__.a)(()=>this.autocomplete&&this.autocomplete.options?Object(rxjs__WEBPACK_IMPORTED_MODULE_7__.a)(...this.autocomplete.options.map(option=>option.onSelectionChange)):this._zone.onStable.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_18__.a)(1),Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_19__.a)(()=>this.optionSelections))),this._scrollStrategy=scrollStrategy}get autocompleteDisabled(){return this._autocompleteDisabled}set autocompleteDisabled(value){this._autocompleteDisabled=Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__.c)(value)}ngAfterViewInit(){const window=this._getWindow();void 0!==window&&this._zone.runOutsideAngular(()=>window.addEventListener(\"blur\",this._windowBlurHandler))}ngOnChanges(changes){changes.position&&this._positionStrategy&&(this._setStrategyPositions(this._positionStrategy),this.panelOpen&&this._overlayRef.updatePosition())}ngOnDestroy(){const window=this._getWindow();void 0!==window&&window.removeEventListener(\"blur\",this._windowBlurHandler),this._viewportSubscription.unsubscribe(),this._componentDestroyed=!0,this._destroyPanel(),this._closeKeyEventStream.complete()}get panelOpen(){return this._overlayAttached&&this.autocomplete.showPanel}openPanel(){this._attachOverlay(),this._floatLabel()}closePanel(){this._resetLabel(),this._overlayAttached&&(this.panelOpen&&this.autocomplete.closed.emit(),this.autocomplete._isOpen=this._overlayAttached=!1,this._overlayRef&&this._overlayRef.hasAttached()&&(this._overlayRef.detach(),this._closingActionsSubscription.unsubscribe()),this._componentDestroyed||this._changeDetectorRef.detectChanges())}updatePosition(){this._overlayAttached&&this._overlayRef.updatePosition()}get panelClosingActions(){return Object(rxjs__WEBPACK_IMPORTED_MODULE_7__.a)(this.optionSelections,this.autocomplete._keyManager.tabOut.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_20__.a)(()=>this._overlayAttached)),this._closeKeyEventStream,this._getOutsideClickStream(),this._overlayRef?this._overlayRef.detachments().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_20__.a)(()=>this._overlayAttached)):Object(rxjs__WEBPACK_IMPORTED_MODULE_8__.a)()).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_21__.a)(event=>event instanceof _angular_material_core__WEBPACK_IMPORTED_MODULE_3__.n?event:null))}get activeOption(){return this.autocomplete&&this.autocomplete._keyManager?this.autocomplete._keyManager.activeItem:null}_getOutsideClickStream(){return Object(rxjs__WEBPACK_IMPORTED_MODULE_7__.a)(Object(rxjs__WEBPACK_IMPORTED_MODULE_9__.a)(this._document,\"click\"),Object(rxjs__WEBPACK_IMPORTED_MODULE_9__.a)(this._document,\"touchend\")).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_20__.a)(event=>{const clickTarget=this._isInsideShadowRoot&&event.composedPath?event.composedPath()[0]:event.target,formField=this._formField?this._formField._elementRef.nativeElement:null,customOrigin=this.connectedTo?this.connectedTo.elementRef.nativeElement:null;return this._overlayAttached&&clickTarget!==this._element.nativeElement&&(!formField||!formField.contains(clickTarget))&&(!customOrigin||!customOrigin.contains(clickTarget))&&!!this._overlayRef&&!this._overlayRef.overlayElement.contains(clickTarget)}))}writeValue(value){Promise.resolve(null).then(()=>this._setTriggerValue(value))}registerOnChange(fn){this._onChange=fn}registerOnTouched(fn){this._onTouched=fn}setDisabledState(isDisabled){this._element.nativeElement.disabled=isDisabled}_handleKeydown(event){const keyCode=event.keyCode;if(keyCode!==_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_13__.h||Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_13__.t)(event)||event.preventDefault(),this.activeOption&&keyCode===_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_13__.g&&this.panelOpen)this.activeOption._selectViaInteraction(),this._resetActiveItem(),event.preventDefault();else if(this.autocomplete){const prevActiveItem=this.autocomplete._keyManager.activeItem,isArrowKey=keyCode===_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_13__.q||keyCode===_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_13__.e;this.panelOpen||keyCode===_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_13__.p?this.autocomplete._keyManager.onKeydown(event):isArrowKey&&this._canOpen()&&this.openPanel(),(isArrowKey||this.autocomplete._keyManager.activeItem!==prevActiveItem)&&this._scrollToOption(this.autocomplete._keyManager.activeItemIndex||0)}}_handleInput(event){let target=event.target,value=target.value;\"number\"===target.type&&(value=\"\"==value?null:parseFloat(value)),this._previousValue!==value&&(this._previousValue=value,this._onChange(value),this._canOpen()&&this._document.activeElement===event.target&&this.openPanel())}_handleFocus(){this._canOpenOnNextFocus?this._canOpen()&&(this._previousValue=this._element.nativeElement.value,this._attachOverlay(),this._floatLabel(!0)):this._canOpenOnNextFocus=!0}_floatLabel(shouldAnimate=!1){this._formField&&\"auto\"===this._formField.floatLabel&&(shouldAnimate?this._formField._animateAndLockLabel():this._formField.floatLabel=\"always\",this._manuallyFloatingLabel=!0)}_resetLabel(){this._manuallyFloatingLabel&&(this._formField.floatLabel=\"auto\",this._manuallyFloatingLabel=!1)}_subscribeToClosingActions(){const firstStable=this._zone.onStable.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_18__.a)(1)),optionChanges=this.autocomplete.options.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_22__.a)(()=>this._positionStrategy.reapplyLastPosition()),Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__.a)(0));return Object(rxjs__WEBPACK_IMPORTED_MODULE_7__.a)(firstStable,optionChanges).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_19__.a)(()=>{const wasOpen=this.panelOpen;return this._resetActiveItem(),this.autocomplete._setVisibility(),this.panelOpen&&(this._overlayRef.updatePosition(),wasOpen!==this.panelOpen&&this.autocomplete.opened.emit()),this.panelClosingActions}),Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_18__.a)(1)).subscribe(event=>this._setValueAndClose(event))}_destroyPanel(){this._overlayRef&&(this.closePanel(),this._overlayRef.dispose(),this._overlayRef=null)}_setTriggerValue(value){const toDisplay=this.autocomplete&&this.autocomplete.displayWith?this.autocomplete.displayWith(value):value,inputValue=null!=toDisplay?toDisplay:\"\";this._formField?this._formField._control.value=inputValue:this._element.nativeElement.value=inputValue,this._previousValue=inputValue}_setValueAndClose(event){event&&event.source&&(this._clearPreviousSelectedOption(event.source),this._setTriggerValue(event.source.value),this._onChange(event.source.value),this._element.nativeElement.focus(),this.autocomplete._emitSelectEvent(event.source)),this.closePanel()}_clearPreviousSelectedOption(skip){this.autocomplete.options.forEach(option=>{option!==skip&&option.selected&&option.deselect()})}_attachOverlay(){var _a;null==this._isInsideShadowRoot&&(this._isInsideShadowRoot=!!Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_14__.c)(this._element.nativeElement));let overlayRef=this._overlayRef;overlayRef?(this._positionStrategy.setOrigin(this._getConnectedElement()),overlayRef.updateSize({width:this._getPanelWidth()})):(this._portal=new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_15__.h(this.autocomplete.template,this._viewContainerRef,{id:null===(_a=this._formField)||void 0===_a?void 0:_a._labelId}),overlayRef=this._overlay.create(this._getOverlayConfig()),this._overlayRef=overlayRef,overlayRef.keydownEvents().subscribe(event=>{(event.keyCode===_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_13__.h&&!Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_13__.t)(event)||event.keyCode===_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_13__.q&&Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_13__.t)(event,\"altKey\"))&&(this._resetActiveItem(),this._closeKeyEventStream.next(),event.stopPropagation(),event.preventDefault())}),this._viewportSubscription=this._viewportRuler.change().subscribe(()=>{this.panelOpen&&overlayRef&&overlayRef.updateSize({width:this._getPanelWidth()})})),overlayRef&&!overlayRef.hasAttached()&&(overlayRef.attach(this._portal),this._closingActionsSubscription=this._subscribeToClosingActions());const wasOpen=this.panelOpen;this.autocomplete._setVisibility(),this.autocomplete._isOpen=this._overlayAttached=!0,this.panelOpen&&wasOpen!==this.panelOpen&&this.autocomplete.opened.emit()}_getOverlayConfig(){var _a;return new _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_11__.d({positionStrategy:this._getOverlayPosition(),scrollStrategy:this._scrollStrategy(),width:this._getPanelWidth(),direction:this._dir,panelClass:null===(_a=this._defaults)||void 0===_a?void 0:_a.overlayPanelClass})}_getOverlayPosition(){const strategy=this._overlay.position().flexibleConnectedTo(this._getConnectedElement()).withFlexibleDimensions(!1).withPush(!1);return this._setStrategyPositions(strategy),this._positionStrategy=strategy,strategy}_setStrategyPositions(positionStrategy){const belowPositions=[{originX:\"start\",originY:\"bottom\",overlayX:\"start\",overlayY:\"top\"},{originX:\"end\",originY:\"bottom\",overlayX:\"end\",overlayY:\"top\"}],panelClass=this._aboveClass,abovePositions=[{originX:\"start\",originY:\"top\",overlayX:\"start\",overlayY:\"bottom\",panelClass:panelClass},{originX:\"end\",originY:\"top\",overlayX:\"end\",overlayY:\"bottom\",panelClass:panelClass}];let positions;positions=\"above\"===this.position?abovePositions:\"below\"===this.position?belowPositions:[...belowPositions,...abovePositions],positionStrategy.withPositions(positions)}_getConnectedElement(){return this.connectedTo?this.connectedTo.elementRef:this._formField?this._formField.getConnectedOverlayOrigin():this._element}_getPanelWidth(){return this.autocomplete.panelWidth||this._getHostWidth()}_getHostWidth(){return this._getConnectedElement().nativeElement.getBoundingClientRect().width}_resetActiveItem(){this.autocomplete._keyManager.setActiveItem(this.autocomplete.autoActiveFirstOption?0:-1)}_canOpen(){const element=this._element.nativeElement;return!element.readOnly&&!element.disabled&&!this._autocompleteDisabled}_getWindow(){var _a;return(null===(_a=this._document)||void 0===_a?void 0:_a.defaultView)||window}_scrollToOption(index){const autocomplete=this.autocomplete,labelCount=Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_3__.s)(index,autocomplete.options,autocomplete.optionGroups);if(0===index&&1===labelCount)autocomplete._setScrollTop(0);else{const option=autocomplete.options.toArray()[index];if(option){const element=option._getHostElement(),newScrollPosition=Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_3__.t)(element.offsetTop,element.offsetHeight,autocomplete._getScrollTop(),autocomplete.panel.nativeElement.offsetHeight);autocomplete._setScrollTop(newScrollPosition)}}}}return _MatAutocompleteTriggerBase.ɵfac=function(t){return new(t||_MatAutocompleteTriggerBase)(_angular_core__WEBPACK_IMPORTED_MODULE_2__.Pb(_angular_core__WEBPACK_IMPORTED_MODULE_2__.l),_angular_core__WEBPACK_IMPORTED_MODULE_2__.Pb(_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_11__.c),_angular_core__WEBPACK_IMPORTED_MODULE_2__.Pb(_angular_core__WEBPACK_IMPORTED_MODULE_2__.S),_angular_core__WEBPACK_IMPORTED_MODULE_2__.Pb(_angular_core__WEBPACK_IMPORTED_MODULE_2__.B),_angular_core__WEBPACK_IMPORTED_MODULE_2__.Pb(_angular_core__WEBPACK_IMPORTED_MODULE_2__.h),_angular_core__WEBPACK_IMPORTED_MODULE_2__.Pb(MAT_AUTOCOMPLETE_SCROLL_STRATEGY),_angular_core__WEBPACK_IMPORTED_MODULE_2__.Pb(_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_24__.b,8),_angular_core__WEBPACK_IMPORTED_MODULE_2__.Pb(_angular_material_form_field__WEBPACK_IMPORTED_MODULE_17__.a,9),_angular_core__WEBPACK_IMPORTED_MODULE_2__.Pb(_angular_common__WEBPACK_IMPORTED_MODULE_10__.d,8),_angular_core__WEBPACK_IMPORTED_MODULE_2__.Pb(_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_12__.e),_angular_core__WEBPACK_IMPORTED_MODULE_2__.Pb(MAT_AUTOCOMPLETE_DEFAULT_OPTIONS,8))},_MatAutocompleteTriggerBase.ɵdir=_angular_core__WEBPACK_IMPORTED_MODULE_2__.Kb({type:_MatAutocompleteTriggerBase,inputs:{position:[\"matAutocompletePosition\",\"position\"],autocompleteAttribute:[\"autocomplete\",\"autocompleteAttribute\"],autocompleteDisabled:[\"matAutocompleteDisabled\",\"autocompleteDisabled\"],autocomplete:[\"matAutocomplete\",\"autocomplete\"],connectedTo:[\"matAutocompleteConnectedTo\",\"connectedTo\"]},features:[_angular_core__WEBPACK_IMPORTED_MODULE_2__.Ab]}),_MatAutocompleteTriggerBase})(),MatAutocompleteTrigger=(()=>{class MatAutocompleteTrigger extends _MatAutocompleteTriggerBase{constructor(){super(...arguments),this._aboveClass=\"mat-autocomplete-panel-above\"}}return MatAutocompleteTrigger.ɵfac=function(t){return ɵMatAutocompleteTrigger_BaseFactory(t||MatAutocompleteTrigger)},MatAutocompleteTrigger.ɵdir=_angular_core__WEBPACK_IMPORTED_MODULE_2__.Kb({type:MatAutocompleteTrigger,selectors:[[\"input\",\"matAutocomplete\",\"\"],[\"textarea\",\"matAutocomplete\",\"\"]],hostAttrs:[1,\"mat-autocomplete-trigger\"],hostVars:7,hostBindings:function(rf,ctx){1&rf&&_angular_core__WEBPACK_IMPORTED_MODULE_2__.gc(\"focusin\",function(){return ctx._handleFocus()})(\"blur\",function(){return ctx._onTouched()})(\"input\",function($event){return ctx._handleInput($event)})(\"keydown\",function($event){return ctx._handleKeydown($event)}),2&rf&&_angular_core__WEBPACK_IMPORTED_MODULE_2__.Db(\"autocomplete\",ctx.autocompleteAttribute)(\"role\",ctx.autocompleteDisabled?null:\"combobox\")(\"aria-autocomplete\",ctx.autocompleteDisabled?null:\"list\")(\"aria-activedescendant\",ctx.panelOpen&&ctx.activeOption?ctx.activeOption.id:null)(\"aria-expanded\",ctx.autocompleteDisabled?null:ctx.panelOpen.toString())(\"aria-owns\",ctx.autocompleteDisabled||!ctx.panelOpen||null==ctx.autocomplete?null:ctx.autocomplete.id)(\"aria-haspopup\",!ctx.autocompleteDisabled)},exportAs:[\"matAutocompleteTrigger\"],features:[_angular_core__WEBPACK_IMPORTED_MODULE_2__.Bb([MAT_AUTOCOMPLETE_VALUE_ACCESSOR]),_angular_core__WEBPACK_IMPORTED_MODULE_2__.zb]}),MatAutocompleteTrigger})();const ɵMatAutocompleteTrigger_BaseFactory=_angular_core__WEBPACK_IMPORTED_MODULE_2__.Xb(MatAutocompleteTrigger);let MatAutocompleteModule=(()=>{class MatAutocompleteModule{}return MatAutocompleteModule.ɵmod=_angular_core__WEBPACK_IMPORTED_MODULE_2__.Nb({type:MatAutocompleteModule}),MatAutocompleteModule.ɵinj=_angular_core__WEBPACK_IMPORTED_MODULE_2__.Mb({factory:function(t){return new(t||MatAutocompleteModule)},providers:[MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER],imports:[[_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_11__.f,_angular_material_core__WEBPACK_IMPORTED_MODULE_3__.m,_angular_material_core__WEBPACK_IMPORTED_MODULE_3__.i,_angular_common__WEBPACK_IMPORTED_MODULE_10__.c],_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_12__.b,_angular_material_core__WEBPACK_IMPORTED_MODULE_3__.m,_angular_material_core__WEBPACK_IMPORTED_MODULE_3__.i]}),MatAutocompleteModule})()}}]);","name":"12-es2015.07c12d6ab973c35ad389.js","input":"(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[12],{\n\n/***/ \"/1cH\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export AUTOCOMPLETE_OPTION_HEIGHT */\n/* unused harmony export AUTOCOMPLETE_PANEL_HEIGHT */\n/* unused harmony export MAT_AUTOCOMPLETE_DEFAULT_OPTIONS */\n/* unused harmony export MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY */\n/* unused harmony export MAT_AUTOCOMPLETE_SCROLL_STRATEGY */\n/* unused harmony export MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY */\n/* unused harmony export MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER */\n/* unused harmony export MAT_AUTOCOMPLETE_VALUE_ACCESSOR */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return MatAutocomplete; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return MatAutocompleteModule; });\n/* unused harmony export MatAutocompleteOrigin */\n/* unused harmony export MatAutocompleteSelectedEvent */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return MatAutocompleteTrigger; });\n/* unused harmony export _MatAutocompleteBase */\n/* unused harmony export _MatAutocompleteOriginBase */\n/* unused harmony export _MatAutocompleteTriggerBase */\n/* unused harmony export getMatAutocompleteMissingPanelError */\n/* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"u47x\");\n/* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(\"8LU1\");\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(\"fXoL\");\n/* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(\"FKr1\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(\"quSY\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(\"XNiG\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(\"NXyV\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(\"VRyK\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(\"LRne\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(\"xgIS\");\n/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(\"ofXK\");\n/* harmony import */ var _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(\"rDax\");\n/* harmony import */ var _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(\"vxfF\");\n/* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(\"FtGj\");\n/* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(\"nLfN\");\n/* harmony import */ var _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(\"+rOU\");\n/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(\"3Pt+\");\n/* harmony import */ var _angular_material_form_field__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(\"kmnG\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(\"IzEk\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(\"eIep\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(\"pLZG\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(\"lJxs\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(\"vkgz\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(\"3E0/\");\n/* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(\"cH1L\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Autocomplete IDs need to be unique across components, so this counter exists outside of\n * the component definition.\n */\n\n\n\n\n\n\nconst _c0 = [\"panel\"];\nfunction MatAutocomplete_ng_template_0_Template(rf, ctx) {\n    if (rf & 1) {\n        _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵelementStart */ \"Vb\"](0, \"div\", 0, 1);\n        _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵprojection */ \"nc\"](2);\n        _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵelementEnd */ \"Ub\"]();\n    }\n    if (rf & 2) {\n        const formFieldId_r1 = ctx.id;\n        const ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵnextContext */ \"kc\"]();\n        _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵproperty */ \"pc\"](\"id\", ctx_r0.id)(\"ngClass\", ctx_r0._classList);\n        _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵattribute */ \"Db\"](\"aria-label\", ctx_r0.ariaLabel || null)(\"aria-labelledby\", ctx_r0._getPanelAriaLabelledby(formFieldId_r1));\n    }\n}\nconst _c1 = [\"*\"];\nlet _uniqueAutocompleteIdCounter = 0;\n/** Event object that is emitted when an autocomplete option is selected. */\nclass MatAutocompleteSelectedEvent {\n    constructor(\n    /** Reference to the autocomplete panel that emitted the event. */\n    source, \n    /** Option that was selected. */\n    option) {\n        this.source = source;\n        this.option = option;\n    }\n}\n// Boilerplate for applying mixins to MatAutocomplete.\n/** @docs-private */\nclass MatAutocompleteBase {\n}\nconst _MatAutocompleteMixinBase = /*@__PURE__*/ Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_3__[/* mixinDisableRipple */ \"v\"])(MatAutocompleteBase);\n/** Injection token to be used to override the default options for `mat-autocomplete`. */\nconst MAT_AUTOCOMPLETE_DEFAULT_OPTIONS = /*@__PURE__*/ new _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* InjectionToken */ \"s\"]('mat-autocomplete-default-options', {\n    providedIn: 'root',\n    factory: MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY,\n});\n/** @docs-private */\nfunction MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY() {\n    return { autoActiveFirstOption: false };\n}\nlet _MatAutocompleteBase = /*@__PURE__*/ (() => {\n    class _MatAutocompleteBase extends _MatAutocompleteMixinBase {\n        constructor(_changeDetectorRef, _elementRef, defaults) {\n            super();\n            this._changeDetectorRef = _changeDetectorRef;\n            this._elementRef = _elementRef;\n            this._activeOptionChanges = rxjs__WEBPACK_IMPORTED_MODULE_4__[/* Subscription */ \"a\"].EMPTY;\n            /** Whether the autocomplete panel should be visible, depending on option length. */\n            this.showPanel = false;\n            this._isOpen = false;\n            /** Function that maps an option's control value to its display value in the trigger. */\n            this.displayWith = null;\n            /** Event that is emitted whenever an option from the list is selected. */\n            this.optionSelected = new _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* EventEmitter */ \"o\"]();\n            /** Event that is emitted when the autocomplete panel is opened. */\n            this.opened = new _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* EventEmitter */ \"o\"]();\n            /** Event that is emitted when the autocomplete panel is closed. */\n            this.closed = new _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* EventEmitter */ \"o\"]();\n            /** Emits whenever an option is activated using the keyboard. */\n            this.optionActivated = new _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* EventEmitter */ \"o\"]();\n            this._classList = {};\n            /** Unique ID to be used by autocomplete trigger's \"aria-owns\" property. */\n            this.id = `mat-autocomplete-${_uniqueAutocompleteIdCounter++}`;\n            this._autoActiveFirstOption = !!defaults.autoActiveFirstOption;\n        }\n        /** Whether the autocomplete panel is open. */\n        get isOpen() { return this._isOpen && this.showPanel; }\n        /**\n         * Whether the first option should be highlighted when the autocomplete panel is opened.\n         * Can be configured globally through the `MAT_AUTOCOMPLETE_DEFAULT_OPTIONS` token.\n         */\n        get autoActiveFirstOption() { return this._autoActiveFirstOption; }\n        set autoActiveFirstOption(value) {\n            this._autoActiveFirstOption = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__[/* coerceBooleanProperty */ \"c\"])(value);\n        }\n        /**\n         * Takes classes set on the host mat-autocomplete element and applies them to the panel\n         * inside the overlay container to allow for easy styling.\n         */\n        set classList(value) {\n            if (value && value.length) {\n                this._classList = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__[/* coerceStringArray */ \"g\"])(value).reduce((classList, className) => {\n                    classList[className] = true;\n                    return classList;\n                }, {});\n            }\n            else {\n                this._classList = {};\n            }\n            this._setVisibilityClasses(this._classList);\n            this._elementRef.nativeElement.className = '';\n        }\n        ngAfterContentInit() {\n            this._keyManager = new _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_0__[/* ActiveDescendantKeyManager */ \"b\"](this.options).withWrap();\n            this._activeOptionChanges = this._keyManager.change.subscribe(index => {\n                this.optionActivated.emit({ source: this, option: this.options.toArray()[index] || null });\n            });\n            // Set the initial visibility state.\n            this._setVisibility();\n        }\n        ngOnDestroy() {\n            this._activeOptionChanges.unsubscribe();\n        }\n        /**\n         * Sets the panel scrollTop. This allows us to manually scroll to display options\n         * above or below the fold, as they are not actually being focused when active.\n         */\n        _setScrollTop(scrollTop) {\n            if (this.panel) {\n                this.panel.nativeElement.scrollTop = scrollTop;\n            }\n        }\n        /** Returns the panel's scrollTop. */\n        _getScrollTop() {\n            return this.panel ? this.panel.nativeElement.scrollTop : 0;\n        }\n        /** Panel should hide itself when the option list is empty. */\n        _setVisibility() {\n            this.showPanel = !!this.options.length;\n            this._setVisibilityClasses(this._classList);\n            this._changeDetectorRef.markForCheck();\n        }\n        /** Emits the `select` event. */\n        _emitSelectEvent(option) {\n            const event = new MatAutocompleteSelectedEvent(this, option);\n            this.optionSelected.emit(event);\n        }\n        /** Gets the aria-labelledby for the autocomplete panel. */\n        _getPanelAriaLabelledby(labelId) {\n            if (this.ariaLabel) {\n                return null;\n            }\n            return this.ariaLabelledby ? labelId + ' ' + this.ariaLabelledby : labelId;\n        }\n        /** Sets the autocomplete visibility classes on a classlist based on the panel is visible. */\n        _setVisibilityClasses(classList) {\n            classList[this._visibleClass] = this.showPanel;\n            classList[this._hiddenClass] = !this.showPanel;\n        }\n    }\n    _MatAutocompleteBase.ɵfac = function _MatAutocompleteBase_Factory(t) { return new (t || _MatAutocompleteBase)(_angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵdirectiveInject */ \"Pb\"](_angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ChangeDetectorRef */ \"h\"]), _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵdirectiveInject */ \"Pb\"](_angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ElementRef */ \"l\"]), _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵdirectiveInject */ \"Pb\"](MAT_AUTOCOMPLETE_DEFAULT_OPTIONS)); };\n    _MatAutocompleteBase.ɵdir = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵdefineDirective */ \"Kb\"]({ type: _MatAutocompleteBase, viewQuery: function _MatAutocompleteBase_Query(rf, ctx) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵstaticViewQuery */ \"Gc\"](_angular_core__WEBPACK_IMPORTED_MODULE_2__[/* TemplateRef */ \"O\"], true);\n                _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵviewQuery */ \"Rc\"](_c0, true);\n            }\n            if (rf & 2) {\n                let _t;\n                _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵqueryRefresh */ \"wc\"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵloadQuery */ \"hc\"]()) && (ctx.template = _t.first);\n                _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵqueryRefresh */ \"wc\"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵloadQuery */ \"hc\"]()) && (ctx.panel = _t.first);\n            }\n        }, inputs: { displayWith: \"displayWith\", autoActiveFirstOption: \"autoActiveFirstOption\", classList: [\"class\", \"classList\"], ariaLabel: [\"aria-label\", \"ariaLabel\"], ariaLabelledby: [\"aria-labelledby\", \"ariaLabelledby\"], panelWidth: \"panelWidth\" }, outputs: { optionSelected: \"optionSelected\", opened: \"opened\", closed: \"closed\", optionActivated: \"optionActivated\" }, features: [_angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵInheritDefinitionFeature */ \"zb\"]] });\n    return _MatAutocompleteBase;\n})();\nlet MatAutocomplete = /*@__PURE__*/ (() => {\n    class MatAutocomplete extends _MatAutocompleteBase {\n        constructor() {\n            super(...arguments);\n            this._visibleClass = 'mat-autocomplete-visible';\n            this._hiddenClass = 'mat-autocomplete-hidden';\n        }\n    }\n    MatAutocomplete.ɵfac = function MatAutocomplete_Factory(t) { return ɵMatAutocomplete_BaseFactory(t || MatAutocomplete); };\n    MatAutocomplete.ɵcmp = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵdefineComponent */ \"Jb\"]({ type: MatAutocomplete, selectors: [[\"mat-autocomplete\"]], contentQueries: function MatAutocomplete_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵcontentQuery */ \"Ib\"](dirIndex, _angular_material_core__WEBPACK_IMPORTED_MODULE_3__[/* MAT_OPTGROUP */ \"f\"], true);\n                _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵcontentQuery */ \"Ib\"](dirIndex, _angular_material_core__WEBPACK_IMPORTED_MODULE_3__[/* MatOption */ \"l\"], true);\n            }\n            if (rf & 2) {\n                let _t;\n                _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵqueryRefresh */ \"wc\"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵloadQuery */ \"hc\"]()) && (ctx.optionGroups = _t);\n                _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵqueryRefresh */ \"wc\"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵloadQuery */ \"hc\"]()) && (ctx.options = _t);\n            }\n        }, hostAttrs: [1, \"mat-autocomplete\"], inputs: { disableRipple: \"disableRipple\" }, exportAs: [\"matAutocomplete\"], features: [/*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵProvidersFeature */ \"Bb\"]([\n                { provide: _angular_material_core__WEBPACK_IMPORTED_MODULE_3__[/* MAT_OPTION_PARENT_COMPONENT */ \"g\"], useExisting: MatAutocomplete }\n            ]), _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵInheritDefinitionFeature */ \"zb\"]], ngContentSelectors: _c1, decls: 1, vars: 0, consts: [[\"role\", \"listbox\", 1, \"mat-autocomplete-panel\", 3, \"id\", \"ngClass\"], [\"panel\", \"\"]], template: function MatAutocomplete_Template(rf, ctx) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵprojectionDef */ \"oc\"]();\n                _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵtemplate */ \"Kc\"](0, MatAutocomplete_ng_template_0_Template, 3, 4, \"ng-template\");\n            }\n        }, directives: [_angular_common__WEBPACK_IMPORTED_MODULE_10__[/* NgClass */ \"j\"]], styles: [\".mat-autocomplete-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;visibility:hidden;max-width:none;max-height:256px;position:relative;width:100%;border-bottom-left-radius:4px;border-bottom-right-radius:4px}.mat-autocomplete-panel.mat-autocomplete-visible{visibility:visible}.mat-autocomplete-panel.mat-autocomplete-hidden{visibility:hidden}.mat-autocomplete-panel-above .mat-autocomplete-panel{border-radius:0;border-top-left-radius:4px;border-top-right-radius:4px}.mat-autocomplete-panel .mat-divider-horizontal{margin-top:-1px}.cdk-high-contrast-active .mat-autocomplete-panel{outline:solid 1px}\\n\"], encapsulation: 2, changeDetection: 0 });\n    return MatAutocomplete;\n})();\nconst ɵMatAutocomplete_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵgetInheritedFactory */ \"Xb\"](MatAutocomplete);\nlet _MatAutocompleteOriginBase = /*@__PURE__*/ (() => {\n    class _MatAutocompleteOriginBase {\n        constructor(\n        /** Reference to the element on which the directive is applied. */\n        elementRef) {\n            this.elementRef = elementRef;\n        }\n    }\n    _MatAutocompleteOriginBase.ɵfac = function _MatAutocompleteOriginBase_Factory(t) { return new (t || _MatAutocompleteOriginBase)(_angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵdirectiveInject */ \"Pb\"](_angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ElementRef */ \"l\"])); };\n    _MatAutocompleteOriginBase.ɵdir = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵdefineDirective */ \"Kb\"]({ type: _MatAutocompleteOriginBase });\n    return _MatAutocompleteOriginBase;\n})();\nlet MatAutocompleteOrigin = /*@__PURE__*/ (() => {\n    class MatAutocompleteOrigin extends _MatAutocompleteOriginBase {\n    }\n    MatAutocompleteOrigin.ɵfac = function MatAutocompleteOrigin_Factory(t) { return ɵMatAutocompleteOrigin_BaseFactory(t || MatAutocompleteOrigin); };\n    MatAutocompleteOrigin.ɵdir = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵdefineDirective */ \"Kb\"]({ type: MatAutocompleteOrigin, selectors: [[\"\", \"matAutocompleteOrigin\", \"\"]], exportAs: [\"matAutocompleteOrigin\"], features: [_angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵInheritDefinitionFeature */ \"zb\"]] });\n    return MatAutocompleteOrigin;\n})();\nconst ɵMatAutocompleteOrigin_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵgetInheritedFactory */ \"Xb\"](MatAutocompleteOrigin);\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * The following style constants are necessary to save here in order\n * to properly calculate the scrollTop of the panel. Because we are not\n * actually focusing the active item, scroll must be handled manually.\n */\n/**\n * The height of each autocomplete option.\n * @deprecated No longer being used. To be removed.\n * @breaking-change 12.0.0\n */\nconst AUTOCOMPLETE_OPTION_HEIGHT = 48;\n/**\n * The total height of the autocomplete panel.\n * @deprecated No longer being used. To be removed.\n * @breaking-change 12.0.0\n */\nconst AUTOCOMPLETE_PANEL_HEIGHT = 256;\n/** Injection token that determines the scroll handling while the autocomplete panel is open. */\nconst MAT_AUTOCOMPLETE_SCROLL_STRATEGY = /*@__PURE__*/ new _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* InjectionToken */ \"s\"]('mat-autocomplete-scroll-strategy');\n/** @docs-private */\nfunction MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY(overlay) {\n    return () => overlay.scrollStrategies.reposition();\n}\n/** @docs-private */\nconst MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n    provide: MAT_AUTOCOMPLETE_SCROLL_STRATEGY,\n    deps: [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_11__[/* Overlay */ \"c\"]],\n    useFactory: MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY,\n};\n/**\n * Provider that allows the autocomplete to register as a ControlValueAccessor.\n * @docs-private\n */\nconst MAT_AUTOCOMPLETE_VALUE_ACCESSOR = {\n    provide: _angular_forms__WEBPACK_IMPORTED_MODULE_16__[/* NG_VALUE_ACCESSOR */ \"k\"],\n    useExisting: /*@__PURE__*/ Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__[/* forwardRef */ \"W\"])(() => MatAutocompleteTrigger),\n    multi: true\n};\n/**\n * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.\n * @docs-private\n */\nfunction getMatAutocompleteMissingPanelError() {\n    return Error('Attempting to open an undefined instance of `mat-autocomplete`. ' +\n        'Make sure that the id passed to the `matAutocomplete` is correct and that ' +\n        'you\\'re attempting to open it after the ngAfterContentInit hook.');\n}\nlet _MatAutocompleteTriggerBase = /*@__PURE__*/ (() => {\n    class _MatAutocompleteTriggerBase {\n        constructor(_element, _overlay, _viewContainerRef, _zone, _changeDetectorRef, scrollStrategy, _dir, _formField, _document, _viewportRuler, _defaults) {\n            this._element = _element;\n            this._overlay = _overlay;\n            this._viewContainerRef = _viewContainerRef;\n            this._zone = _zone;\n            this._changeDetectorRef = _changeDetectorRef;\n            this._dir = _dir;\n            this._formField = _formField;\n            this._document = _document;\n            this._viewportRuler = _viewportRuler;\n            this._defaults = _defaults;\n            this._componentDestroyed = false;\n            this._autocompleteDisabled = false;\n            /** Whether or not the label state is being overridden. */\n            this._manuallyFloatingLabel = false;\n            /** Subscription to viewport size changes. */\n            this._viewportSubscription = rxjs__WEBPACK_IMPORTED_MODULE_4__[/* Subscription */ \"a\"].EMPTY;\n            /**\n             * Whether the autocomplete can open the next time it is focused. Used to prevent a focused,\n             * closed autocomplete from being reopened if the user switches to another browser tab and then\n             * comes back.\n             */\n            this._canOpenOnNextFocus = true;\n            /** Stream of keyboard events that can close the panel. */\n            this._closeKeyEventStream = new rxjs__WEBPACK_IMPORTED_MODULE_5__[/* Subject */ \"a\"]();\n            /**\n             * Event handler for when the window is blurred. Needs to be an\n             * arrow function in order to preserve the context.\n             */\n            this._windowBlurHandler = () => {\n                // If the user blurred the window while the autocomplete is focused, it means that it'll be\n                // refocused when they come back. In this case we want to skip the first focus event, if the\n                // pane was closed, in order to avoid reopening it unintentionally.\n                this._canOpenOnNextFocus =\n                    this._document.activeElement !== this._element.nativeElement || this.panelOpen;\n            };\n            /** `View -> model callback called when value changes` */\n            this._onChange = () => { };\n            /** `View -> model callback called when autocomplete has been touched` */\n            this._onTouched = () => { };\n            /**\n             * Position of the autocomplete panel relative to the trigger element. A position of `auto`\n             * will render the panel underneath the trigger if there is enough space for it to fit in\n             * the viewport, otherwise the panel will be shown above it. If the position is set to\n             * `above` or `below`, the panel will always be shown above or below the trigger. no matter\n             * whether it fits completely in the viewport.\n             */\n            this.position = 'auto';\n            /**\n             * `autocomplete` attribute to be set on the input element.\n             * @docs-private\n             */\n            this.autocompleteAttribute = 'off';\n            this._overlayAttached = false;\n            /** Stream of autocomplete option selections. */\n            this.optionSelections = Object(rxjs__WEBPACK_IMPORTED_MODULE_6__[/* defer */ \"a\"])(() => {\n                if (this.autocomplete && this.autocomplete.options) {\n                    return Object(rxjs__WEBPACK_IMPORTED_MODULE_7__[/* merge */ \"a\"])(...this.autocomplete.options.map(option => option.onSelectionChange));\n                }\n                // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.\n                // Return a stream that we'll replace with the real one once everything is in place.\n                return this._zone.onStable\n                    .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_18__[/* take */ \"a\"])(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_19__[/* switchMap */ \"a\"])(() => this.optionSelections));\n            });\n            this._scrollStrategy = scrollStrategy;\n        }\n        /**\n         * Whether the autocomplete is disabled. When disabled, the element will\n         * act as a regular input and the user won't be able to open the panel.\n         */\n        get autocompleteDisabled() { return this._autocompleteDisabled; }\n        set autocompleteDisabled(value) {\n            this._autocompleteDisabled = Object(_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__[/* coerceBooleanProperty */ \"c\"])(value);\n        }\n        ngAfterViewInit() {\n            const window = this._getWindow();\n            if (typeof window !== 'undefined') {\n                this._zone.runOutsideAngular(() => window.addEventListener('blur', this._windowBlurHandler));\n            }\n        }\n        ngOnChanges(changes) {\n            if (changes['position'] && this._positionStrategy) {\n                this._setStrategyPositions(this._positionStrategy);\n                if (this.panelOpen) {\n                    this._overlayRef.updatePosition();\n                }\n            }\n        }\n        ngOnDestroy() {\n            const window = this._getWindow();\n            if (typeof window !== 'undefined') {\n                window.removeEventListener('blur', this._windowBlurHandler);\n            }\n            this._viewportSubscription.unsubscribe();\n            this._componentDestroyed = true;\n            this._destroyPanel();\n            this._closeKeyEventStream.complete();\n        }\n        /** Whether or not the autocomplete panel is open. */\n        get panelOpen() {\n            return this._overlayAttached && this.autocomplete.showPanel;\n        }\n        /** Opens the autocomplete suggestion panel. */\n        openPanel() {\n            this._attachOverlay();\n            this._floatLabel();\n        }\n        /** Closes the autocomplete suggestion panel. */\n        closePanel() {\n            this._resetLabel();\n            if (!this._overlayAttached) {\n                return;\n            }\n            if (this.panelOpen) {\n                // Only emit if the panel was visible.\n                this.autocomplete.closed.emit();\n            }\n            this.autocomplete._isOpen = this._overlayAttached = false;\n            if (this._overlayRef && this._overlayRef.hasAttached()) {\n                this._overlayRef.detach();\n                this._closingActionsSubscription.unsubscribe();\n            }\n            // Note that in some cases this can end up being called after the component is destroyed.\n            // Add a check to ensure that we don't try to run change detection on a destroyed view.\n            if (!this._componentDestroyed) {\n                // We need to trigger change detection manually, because\n                // `fromEvent` doesn't seem to do it at the proper time.\n                // This ensures that the label is reset when the\n                // user clicks outside.\n                this._changeDetectorRef.detectChanges();\n            }\n        }\n        /**\n         * Updates the position of the autocomplete suggestion panel to ensure that it fits all options\n         * within the viewport.\n         */\n        updatePosition() {\n            if (this._overlayAttached) {\n                this._overlayRef.updatePosition();\n            }\n        }\n        /**\n         * A stream of actions that should close the autocomplete panel, including\n         * when an option is selected, on blur, and when TAB is pressed.\n         */\n        get panelClosingActions() {\n            return Object(rxjs__WEBPACK_IMPORTED_MODULE_7__[/* merge */ \"a\"])(this.optionSelections, this.autocomplete._keyManager.tabOut.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_20__[/* filter */ \"a\"])(() => this._overlayAttached)), this._closeKeyEventStream, this._getOutsideClickStream(), this._overlayRef ?\n                this._overlayRef.detachments().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_20__[/* filter */ \"a\"])(() => this._overlayAttached)) :\n                Object(rxjs__WEBPACK_IMPORTED_MODULE_8__[/* of */ \"a\"])()).pipe(\n            // Normalize the output so we return a consistent type.\n            Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_21__[/* map */ \"a\"])(event => event instanceof _angular_material_core__WEBPACK_IMPORTED_MODULE_3__[/* MatOptionSelectionChange */ \"n\"] ? event : null));\n        }\n        /** The currently active option, coerced to MatOption type. */\n        get activeOption() {\n            if (this.autocomplete && this.autocomplete._keyManager) {\n                return this.autocomplete._keyManager.activeItem;\n            }\n            return null;\n        }\n        /** Stream of clicks outside of the autocomplete panel. */\n        _getOutsideClickStream() {\n            return Object(rxjs__WEBPACK_IMPORTED_MODULE_7__[/* merge */ \"a\"])(Object(rxjs__WEBPACK_IMPORTED_MODULE_9__[/* fromEvent */ \"a\"])(this._document, 'click'), Object(rxjs__WEBPACK_IMPORTED_MODULE_9__[/* fromEvent */ \"a\"])(this._document, 'touchend'))\n                .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_20__[/* filter */ \"a\"])(event => {\n                // If we're in the Shadow DOM, the event target will be the shadow root, so we have to\n                // fall back to check the first element in the path of the click event.\n                const clickTarget = (this._isInsideShadowRoot && event.composedPath ? event.composedPath()[0] :\n                    event.target);\n                const formField = this._formField ? this._formField._elementRef.nativeElement : null;\n                const customOrigin = this.connectedTo ? this.connectedTo.elementRef.nativeElement : null;\n                return this._overlayAttached && clickTarget !== this._element.nativeElement &&\n                    (!formField || !formField.contains(clickTarget)) &&\n                    (!customOrigin || !customOrigin.contains(clickTarget)) &&\n                    (!!this._overlayRef && !this._overlayRef.overlayElement.contains(clickTarget));\n            }));\n        }\n        // Implemented as part of ControlValueAccessor.\n        writeValue(value) {\n            Promise.resolve(null).then(() => this._setTriggerValue(value));\n        }\n        // Implemented as part of ControlValueAccessor.\n        registerOnChange(fn) {\n            this._onChange = fn;\n        }\n        // Implemented as part of ControlValueAccessor.\n        registerOnTouched(fn) {\n            this._onTouched = fn;\n        }\n        // Implemented as part of ControlValueAccessor.\n        setDisabledState(isDisabled) {\n            this._element.nativeElement.disabled = isDisabled;\n        }\n        _handleKeydown(event) {\n            const keyCode = event.keyCode;\n            // Prevent the default action on all escape key presses. This is here primarily to bring IE\n            // in line with other browsers. By default, pressing escape on IE will cause it to revert\n            // the input value to the one that it had on focus, however it won't dispatch any events\n            // which means that the model value will be out of sync with the view.\n            if (keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_13__[/* ESCAPE */ \"h\"] && !Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_13__[/* hasModifierKey */ \"t\"])(event)) {\n                event.preventDefault();\n            }\n            if (this.activeOption && keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_13__[/* ENTER */ \"g\"] && this.panelOpen) {\n                this.activeOption._selectViaInteraction();\n                this._resetActiveItem();\n                event.preventDefault();\n            }\n            else if (this.autocomplete) {\n                const prevActiveItem = this.autocomplete._keyManager.activeItem;\n                const isArrowKey = keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_13__[/* UP_ARROW */ \"q\"] || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_13__[/* DOWN_ARROW */ \"e\"];\n                if (this.panelOpen || keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_13__[/* TAB */ \"p\"]) {\n                    this.autocomplete._keyManager.onKeydown(event);\n                }\n                else if (isArrowKey && this._canOpen()) {\n                    this.openPanel();\n                }\n                if (isArrowKey || this.autocomplete._keyManager.activeItem !== prevActiveItem) {\n                    this._scrollToOption(this.autocomplete._keyManager.activeItemIndex || 0);\n                }\n            }\n        }\n        _handleInput(event) {\n            let target = event.target;\n            let value = target.value;\n            // Based on `NumberValueAccessor` from forms.\n            if (target.type === 'number') {\n                value = value == '' ? null : parseFloat(value);\n            }\n            // If the input has a placeholder, IE will fire the `input` event on page load,\n            // focus and blur, in addition to when the user actually changed the value. To\n            // filter out all of the extra events, we save the value on focus and between\n            // `input` events, and we check whether it changed.\n            // See: https://connect.microsoft.com/IE/feedback/details/885747/\n            if (this._previousValue !== value) {\n                this._previousValue = value;\n                this._onChange(value);\n                if (this._canOpen() && this._document.activeElement === event.target) {\n                    this.openPanel();\n                }\n            }\n        }\n        _handleFocus() {\n            if (!this._canOpenOnNextFocus) {\n                this._canOpenOnNextFocus = true;\n            }\n            else if (this._canOpen()) {\n                this._previousValue = this._element.nativeElement.value;\n                this._attachOverlay();\n                this._floatLabel(true);\n            }\n        }\n        /**\n         * In \"auto\" mode, the label will animate down as soon as focus is lost.\n         * This causes the value to jump when selecting an option with the mouse.\n         * This method manually floats the label until the panel can be closed.\n         * @param shouldAnimate Whether the label should be animated when it is floated.\n         */\n        _floatLabel(shouldAnimate = false) {\n            if (this._formField && this._formField.floatLabel === 'auto') {\n                if (shouldAnimate) {\n                    this._formField._animateAndLockLabel();\n                }\n                else {\n                    this._formField.floatLabel = 'always';\n                }\n                this._manuallyFloatingLabel = true;\n            }\n        }\n        /** If the label has been manually elevated, return it to its normal state. */\n        _resetLabel() {\n            if (this._manuallyFloatingLabel) {\n                this._formField.floatLabel = 'auto';\n                this._manuallyFloatingLabel = false;\n            }\n        }\n        /**\n         * This method listens to a stream of panel closing actions and resets the\n         * stream every time the option list changes.\n         */\n        _subscribeToClosingActions() {\n            const firstStable = this._zone.onStable.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_18__[/* take */ \"a\"])(1));\n            const optionChanges = this.autocomplete.options.changes.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_22__[/* tap */ \"a\"])(() => this._positionStrategy.reapplyLastPosition()), \n            // Defer emitting to the stream until the next tick, because changing\n            // bindings in here will cause \"changed after checked\" errors.\n            Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_23__[/* delay */ \"a\"])(0));\n            // When the zone is stable initially, and when the option list changes...\n            return Object(rxjs__WEBPACK_IMPORTED_MODULE_7__[/* merge */ \"a\"])(firstStable, optionChanges)\n                .pipe(\n            // create a new stream of panelClosingActions, replacing any previous streams\n            // that were created, and flatten it so our stream only emits closing events...\n            Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_19__[/* switchMap */ \"a\"])(() => {\n                const wasOpen = this.panelOpen;\n                this._resetActiveItem();\n                this.autocomplete._setVisibility();\n                if (this.panelOpen) {\n                    this._overlayRef.updatePosition();\n                    // If the `panelOpen` state changed, we need to make sure to emit the `opened`\n                    // event, because we may not have emitted it when the panel was attached. This\n                    // can happen if the users opens the panel and there are no options, but the\n                    // options come in slightly later or as a result of the value changing.\n                    if (wasOpen !== this.panelOpen) {\n                        this.autocomplete.opened.emit();\n                    }\n                }\n                return this.panelClosingActions;\n            }), \n            // when the first closing event occurs...\n            Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_18__[/* take */ \"a\"])(1))\n                // set the value, close the panel, and complete.\n                .subscribe(event => this._setValueAndClose(event));\n        }\n        /** Destroys the autocomplete suggestion panel. */\n        _destroyPanel() {\n            if (this._overlayRef) {\n                this.closePanel();\n                this._overlayRef.dispose();\n                this._overlayRef = null;\n            }\n        }\n        _setTriggerValue(value) {\n            const toDisplay = this.autocomplete && this.autocomplete.displayWith ?\n                this.autocomplete.displayWith(value) :\n                value;\n            // Simply falling back to an empty string if the display value is falsy does not work properly.\n            // The display value can also be the number zero and shouldn't fall back to an empty string.\n            const inputValue = toDisplay != null ? toDisplay : '';\n            // If it's used within a `MatFormField`, we should set it through the property so it can go\n            // through change detection.\n            if (this._formField) {\n                this._formField._control.value = inputValue;\n            }\n            else {\n                this._element.nativeElement.value = inputValue;\n            }\n            this._previousValue = inputValue;\n        }\n        /**\n         * This method closes the panel, and if a value is specified, also sets the associated\n         * control to that value. It will also mark the control as dirty if this interaction\n         * stemmed from the user.\n         */\n        _setValueAndClose(event) {\n            if (event && event.source) {\n                this._clearPreviousSelectedOption(event.source);\n                this._setTriggerValue(event.source.value);\n                this._onChange(event.source.value);\n                this._element.nativeElement.focus();\n                this.autocomplete._emitSelectEvent(event.source);\n            }\n            this.closePanel();\n        }\n        /**\n         * Clear any previous selected option and emit a selection change event for this option\n         */\n        _clearPreviousSelectedOption(skip) {\n            this.autocomplete.options.forEach(option => {\n                if (option !== skip && option.selected) {\n                    option.deselect();\n                }\n            });\n        }\n        _attachOverlay() {\n            var _a;\n            if (!this.autocomplete && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw getMatAutocompleteMissingPanelError();\n            }\n            // We want to resolve this once, as late as possible so that we can be\n            // sure that the element has been moved into its final place in the DOM.\n            if (this._isInsideShadowRoot == null) {\n                this._isInsideShadowRoot = !!Object(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_14__[/* _getShadowRoot */ \"c\"])(this._element.nativeElement);\n            }\n            let overlayRef = this._overlayRef;\n            if (!overlayRef) {\n                this._portal = new _angular_cdk_portal__WEBPACK_IMPORTED_MODULE_15__[/* TemplatePortal */ \"h\"](this.autocomplete.template, this._viewContainerRef, { id: (_a = this._formField) === null || _a === void 0 ? void 0 : _a._labelId });\n                overlayRef = this._overlay.create(this._getOverlayConfig());\n                this._overlayRef = overlayRef;\n                // Use the `keydownEvents` in order to take advantage of\n                // the overlay event targeting provided by the CDK overlay.\n                overlayRef.keydownEvents().subscribe(event => {\n                    // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.\n                    // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction\n                    if ((event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_13__[/* ESCAPE */ \"h\"] && !Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_13__[/* hasModifierKey */ \"t\"])(event)) ||\n                        (event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_13__[/* UP_ARROW */ \"q\"] && Object(_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_13__[/* hasModifierKey */ \"t\"])(event, 'altKey'))) {\n                        this._resetActiveItem();\n                        this._closeKeyEventStream.next();\n                        // We need to stop propagation, otherwise the event will eventually\n                        // reach the input itself and cause the overlay to be reopened.\n                        event.stopPropagation();\n                        event.preventDefault();\n                    }\n                });\n                this._viewportSubscription = this._viewportRuler.change().subscribe(() => {\n                    if (this.panelOpen && overlayRef) {\n                        overlayRef.updateSize({ width: this._getPanelWidth() });\n                    }\n                });\n            }\n            else {\n                // Update the trigger, panel width and direction, in case anything has changed.\n                this._positionStrategy.setOrigin(this._getConnectedElement());\n                overlayRef.updateSize({ width: this._getPanelWidth() });\n            }\n            if (overlayRef && !overlayRef.hasAttached()) {\n                overlayRef.attach(this._portal);\n                this._closingActionsSubscription = this._subscribeToClosingActions();\n            }\n            const wasOpen = this.panelOpen;\n            this.autocomplete._setVisibility();\n            this.autocomplete._isOpen = this._overlayAttached = true;\n            // We need to do an extra `panelOpen` check in here, because the\n            // autocomplete won't be shown if there are no options.\n            if (this.panelOpen && wasOpen !== this.panelOpen) {\n                this.autocomplete.opened.emit();\n            }\n        }\n        _getOverlayConfig() {\n            var _a;\n            return new _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_11__[/* OverlayConfig */ \"d\"]({\n                positionStrategy: this._getOverlayPosition(),\n                scrollStrategy: this._scrollStrategy(),\n                width: this._getPanelWidth(),\n                direction: this._dir,\n                panelClass: (_a = this._defaults) === null || _a === void 0 ? void 0 : _a.overlayPanelClass,\n            });\n        }\n        _getOverlayPosition() {\n            const strategy = this._overlay.position()\n                .flexibleConnectedTo(this._getConnectedElement())\n                .withFlexibleDimensions(false)\n                .withPush(false);\n            this._setStrategyPositions(strategy);\n            this._positionStrategy = strategy;\n            return strategy;\n        }\n        /** Sets the positions on a position strategy based on the directive's input state. */\n        _setStrategyPositions(positionStrategy) {\n            // Note that we provide horizontal fallback positions, even though by default the dropdown\n            // width matches the input, because consumers can override the width. See #18854.\n            const belowPositions = [\n                { originX: 'start', originY: 'bottom', overlayX: 'start', overlayY: 'top' },\n                { originX: 'end', originY: 'bottom', overlayX: 'end', overlayY: 'top' }\n            ];\n            // The overlay edge connected to the trigger should have squared corners, while\n            // the opposite end has rounded corners. We apply a CSS class to swap the\n            // border-radius based on the overlay position.\n            const panelClass = this._aboveClass;\n            const abovePositions = [\n                { originX: 'start', originY: 'top', overlayX: 'start', overlayY: 'bottom', panelClass },\n                { originX: 'end', originY: 'top', overlayX: 'end', overlayY: 'bottom', panelClass }\n            ];\n            let positions;\n            if (this.position === 'above') {\n                positions = abovePositions;\n            }\n            else if (this.position === 'below') {\n                positions = belowPositions;\n            }\n            else {\n                positions = [...belowPositions, ...abovePositions];\n            }\n            positionStrategy.withPositions(positions);\n        }\n        _getConnectedElement() {\n            if (this.connectedTo) {\n                return this.connectedTo.elementRef;\n            }\n            return this._formField ? this._formField.getConnectedOverlayOrigin() : this._element;\n        }\n        _getPanelWidth() {\n            return this.autocomplete.panelWidth || this._getHostWidth();\n        }\n        /** Returns the width of the input element, so the panel width can match it. */\n        _getHostWidth() {\n            return this._getConnectedElement().nativeElement.getBoundingClientRect().width;\n        }\n        /**\n         * Resets the active item to -1 so arrow events will activate the\n         * correct options, or to 0 if the consumer opted into it.\n         */\n        _resetActiveItem() {\n            this.autocomplete._keyManager.setActiveItem(this.autocomplete.autoActiveFirstOption ? 0 : -1);\n        }\n        /** Determines whether the panel can be opened. */\n        _canOpen() {\n            const element = this._element.nativeElement;\n            return !element.readOnly && !element.disabled && !this._autocompleteDisabled;\n        }\n        /** Use defaultView of injected document if available or fallback to global window reference */\n        _getWindow() {\n            var _a;\n            return ((_a = this._document) === null || _a === void 0 ? void 0 : _a.defaultView) || window;\n        }\n        /** Scrolls to a particular option in the list. */\n        _scrollToOption(index) {\n            // Given that we are not actually focusing active options, we must manually adjust scroll\n            // to reveal options below the fold. First, we find the offset of the option from the top\n            // of the panel. If that offset is below the fold, the new scrollTop will be the offset -\n            // the panel height + the option height, so the active option will be just visible at the\n            // bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop\n            // will become the offset. If that offset is visible within the panel already, the scrollTop is\n            // not adjusted.\n            const autocomplete = this.autocomplete;\n            const labelCount = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_3__[/* _countGroupLabelsBeforeOption */ \"s\"])(index, autocomplete.options, autocomplete.optionGroups);\n            if (index === 0 && labelCount === 1) {\n                // If we've got one group label before the option and we're at the top option,\n                // scroll the list to the top. This is better UX than scrolling the list to the\n                // top of the option, because it allows the user to read the top group's label.\n                autocomplete._setScrollTop(0);\n            }\n            else {\n                const option = autocomplete.options.toArray()[index];\n                if (option) {\n                    const element = option._getHostElement();\n                    const newScrollPosition = Object(_angular_material_core__WEBPACK_IMPORTED_MODULE_3__[/* _getOptionScrollPosition */ \"t\"])(element.offsetTop, element.offsetHeight, autocomplete._getScrollTop(), autocomplete.panel.nativeElement.offsetHeight);\n                    autocomplete._setScrollTop(newScrollPosition);\n                }\n            }\n        }\n    }\n    _MatAutocompleteTriggerBase.ɵfac = function _MatAutocompleteTriggerBase_Factory(t) { return new (t || _MatAutocompleteTriggerBase)(_angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵdirectiveInject */ \"Pb\"](_angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ElementRef */ \"l\"]), _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵdirectiveInject */ \"Pb\"](_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_11__[/* Overlay */ \"c\"]), _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵdirectiveInject */ \"Pb\"](_angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ViewContainerRef */ \"S\"]), _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵdirectiveInject */ \"Pb\"](_angular_core__WEBPACK_IMPORTED_MODULE_2__[/* NgZone */ \"B\"]), _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵdirectiveInject */ \"Pb\"](_angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ChangeDetectorRef */ \"h\"]), _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵdirectiveInject */ \"Pb\"](MAT_AUTOCOMPLETE_SCROLL_STRATEGY), _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵdirectiveInject */ \"Pb\"](_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_24__[/* Directionality */ \"b\"], 8), _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵdirectiveInject */ \"Pb\"](_angular_material_form_field__WEBPACK_IMPORTED_MODULE_17__[/* MAT_FORM_FIELD */ \"a\"], 9), _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵdirectiveInject */ \"Pb\"](_angular_common__WEBPACK_IMPORTED_MODULE_10__[/* DOCUMENT */ \"d\"], 8), _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵdirectiveInject */ \"Pb\"](_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_12__[/* ViewportRuler */ \"e\"]), _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵdirectiveInject */ \"Pb\"](MAT_AUTOCOMPLETE_DEFAULT_OPTIONS, 8)); };\n    _MatAutocompleteTriggerBase.ɵdir = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵdefineDirective */ \"Kb\"]({ type: _MatAutocompleteTriggerBase, inputs: { position: [\"matAutocompletePosition\", \"position\"], autocompleteAttribute: [\"autocomplete\", \"autocompleteAttribute\"], autocompleteDisabled: [\"matAutocompleteDisabled\", \"autocompleteDisabled\"], autocomplete: [\"matAutocomplete\", \"autocomplete\"], connectedTo: [\"matAutocompleteConnectedTo\", \"connectedTo\"] }, features: [_angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵNgOnChangesFeature */ \"Ab\"]] });\n    return _MatAutocompleteTriggerBase;\n})();\nlet MatAutocompleteTrigger = /*@__PURE__*/ (() => {\n    class MatAutocompleteTrigger extends _MatAutocompleteTriggerBase {\n        constructor() {\n            super(...arguments);\n            this._aboveClass = 'mat-autocomplete-panel-above';\n        }\n    }\n    MatAutocompleteTrigger.ɵfac = function MatAutocompleteTrigger_Factory(t) { return ɵMatAutocompleteTrigger_BaseFactory(t || MatAutocompleteTrigger); };\n    MatAutocompleteTrigger.ɵdir = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵdefineDirective */ \"Kb\"]({ type: MatAutocompleteTrigger, selectors: [[\"input\", \"matAutocomplete\", \"\"], [\"textarea\", \"matAutocomplete\", \"\"]], hostAttrs: [1, \"mat-autocomplete-trigger\"], hostVars: 7, hostBindings: function MatAutocompleteTrigger_HostBindings(rf, ctx) {\n            if (rf & 1) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵlistener */ \"gc\"](\"focusin\", function MatAutocompleteTrigger_focusin_HostBindingHandler() { return ctx._handleFocus(); })(\"blur\", function MatAutocompleteTrigger_blur_HostBindingHandler() { return ctx._onTouched(); })(\"input\", function MatAutocompleteTrigger_input_HostBindingHandler($event) { return ctx._handleInput($event); })(\"keydown\", function MatAutocompleteTrigger_keydown_HostBindingHandler($event) { return ctx._handleKeydown($event); });\n            }\n            if (rf & 2) {\n                _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵattribute */ \"Db\"](\"autocomplete\", ctx.autocompleteAttribute)(\"role\", ctx.autocompleteDisabled ? null : \"combobox\")(\"aria-autocomplete\", ctx.autocompleteDisabled ? null : \"list\")(\"aria-activedescendant\", ctx.panelOpen && ctx.activeOption ? ctx.activeOption.id : null)(\"aria-expanded\", ctx.autocompleteDisabled ? null : ctx.panelOpen.toString())(\"aria-owns\", ctx.autocompleteDisabled || !ctx.panelOpen ? null : ctx.autocomplete == null ? null : ctx.autocomplete.id)(\"aria-haspopup\", !ctx.autocompleteDisabled);\n            }\n        }, exportAs: [\"matAutocompleteTrigger\"], features: [/*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵProvidersFeature */ \"Bb\"]([MAT_AUTOCOMPLETE_VALUE_ACCESSOR]), _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵInheritDefinitionFeature */ \"zb\"]] });\n    return MatAutocompleteTrigger;\n})();\nconst ɵMatAutocompleteTrigger_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵgetInheritedFactory */ \"Xb\"](MatAutocompleteTrigger);\nlet MatAutocompleteModule = /*@__PURE__*/ (() => {\n    class MatAutocompleteModule {\n    }\n    MatAutocompleteModule.ɵmod = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵdefineNgModule */ \"Nb\"]({ type: MatAutocompleteModule });\n    MatAutocompleteModule.ɵinj = /*@__PURE__*/ _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵdefineInjector */ \"Mb\"]({ factory: function MatAutocompleteModule_Factory(t) { return new (t || MatAutocompleteModule)(); }, providers: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER], imports: [[\n                _angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_11__[/* OverlayModule */ \"f\"],\n                _angular_material_core__WEBPACK_IMPORTED_MODULE_3__[/* MatOptionModule */ \"m\"],\n                _angular_material_core__WEBPACK_IMPORTED_MODULE_3__[/* MatCommonModule */ \"i\"],\n                _angular_common__WEBPACK_IMPORTED_MODULE_10__[/* CommonModule */ \"c\"]\n            ], _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_12__[/* CdkScrollableModule */ \"b\"],\n            _angular_material_core__WEBPACK_IMPORTED_MODULE_3__[/* MatOptionModule */ \"m\"],\n            _angular_material_core__WEBPACK_IMPORTED_MODULE_3__[/* MatCommonModule */ \"i\"]] });\n    return MatAutocompleteModule;\n})();\n/*@__PURE__*/ (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__[/* ɵɵsetNgModuleScope */ \"Ec\"](MatAutocompleteModule, { declarations: function () { return [MatAutocomplete, MatAutocompleteTrigger, MatAutocompleteOrigin]; }, imports: function () {\n            return [_angular_cdk_overlay__WEBPACK_IMPORTED_MODULE_11__[/* OverlayModule */ \"f\"],\n                _angular_material_core__WEBPACK_IMPORTED_MODULE_3__[/* MatOptionModule */ \"m\"],\n                _angular_material_core__WEBPACK_IMPORTED_MODULE_3__[/* MatCommonModule */ \"i\"],\n                _angular_common__WEBPACK_IMPORTED_MODULE_10__[/* CommonModule */ \"c\"]];\n        }, exports: function () {\n            return [MatAutocomplete, MatAutocompleteTrigger, MatAutocompleteOrigin, _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_12__[/* CdkScrollableModule */ \"b\"],\n                _angular_material_core__WEBPACK_IMPORTED_MODULE_3__[/* MatOptionModule */ \"m\"],\n                _angular_material_core__WEBPACK_IMPORTED_MODULE_3__[/* MatCommonModule */ \"i\"]];\n        } });\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=autocomplete.js.map\n\n\n/***/ })\n\n}]);","inputSourceMap":null}