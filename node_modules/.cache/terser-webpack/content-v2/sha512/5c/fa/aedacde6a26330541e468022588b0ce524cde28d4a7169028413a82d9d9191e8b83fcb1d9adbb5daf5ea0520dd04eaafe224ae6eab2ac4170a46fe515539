{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{CzEO:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return ngx_quill_QuillEditorComponent}),__webpack_require__.d(__webpack_exports__,\"b\",function(){return ngx_quill_QuillModule});var common=__webpack_require__(\"ofXK\"),core=__webpack_require__(\"fXoL\");function __awaiter(thisArg,_arguments,P,generator){return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator.throw(value))}catch(e){reject(e)}}function step(result){var value;result.done?resolve(result.value):(value=result.value,value instanceof P?value:new P(function(resolve){resolve(value)})).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})}var platform_browser=__webpack_require__(\"jhN1\"),Subscription=__webpack_require__(\"quSY\"),fromEvent=__webpack_require__(\"xgIS\"),debounceTime=__webpack_require__(\"Kj3r\"),fesm2015_forms=__webpack_require__(\"3Pt+\");const _c0=[[[\"\",\"quill-editor-toolbar\",\"\"]]],_c1=[\"[quill-editor-toolbar]\"],defaultModules={toolbar:[[\"bold\",\"italic\",\"underline\",\"strike\"],[\"blockquote\",\"code-block\"],[{header:1},{header:2}],[{list:\"ordered\"},{list:\"bullet\"}],[{script:\"sub\"},{script:\"super\"}],[{indent:\"-1\"},{indent:\"+1\"}],[{direction:\"rtl\"}],[{size:[\"small\",!1,\"large\",\"huge\"]}],[{header:[1,2,3,4,5,6,!1]}],[{color:[]},{background:[]}],[{font:[]}],[{align:[]}],[\"clean\"],[\"link\",\"image\",\"video\"]]},getFormat=(format,configFormat)=>format||configFormat||\"html\",QUILL_CONFIG_TOKEN=new core.s(\"config\");let ngx_quill_QuillService=(()=>{class QuillService{constructor(injector,config){this.config=config,this.count=0,this.document=injector.get(common.d),this.config||(this.config={modules:defaultModules})}getQuill(){return this.count++,this.Quill||1!==this.count||(this.$importPromise=new Promise(resolve=>__awaiter(this,void 0,void 0,function*(){var _a,_b;const maybePatchedAddEventListener=this.document.addEventListener;this.document.addEventListener=this.document.__zone_symbol__addEventListener||this.document.addEventListener;const quillImport=yield __webpack_require__.e(38).then(__webpack_require__.t.bind(null,\"kzlf\",7));this.document.addEventListener=maybePatchedAddEventListener,this.Quill=quillImport.default?quillImport.default:quillImport,null===(_a=this.config.customOptions)||void 0===_a||_a.forEach(customOption=>{const newCustomOption=this.Quill.import(customOption.import);newCustomOption.whitelist=customOption.whitelist,this.Quill.register(newCustomOption,!0,this.config.suppressGlobalRegisterWarning)}),null===(_b=this.config.customModules)||void 0===_b||_b.forEach(({implementation:implementation,path:path})=>{this.Quill.register(path,implementation,this.config.suppressGlobalRegisterWarning)}),resolve(this.Quill)}))),this.$importPromise}}return QuillService.ɵfac=function(t){return new(t||QuillService)(core.cc(core.t),core.cc(QUILL_CONFIG_TOKEN))},QuillService.ɵprov=core.Lb({factory:function(){return new QuillService(core.cc(core.p),core.cc(QUILL_CONFIG_TOKEN))},token:QuillService,providedIn:\"root\"}),QuillService})(),ngx_quill_QuillEditorBase=(()=>{class QuillEditorBase{constructor(injector,elementRef,domSanitizer,platformId,renderer,zone,service){this.elementRef=elementRef,this.domSanitizer=domSanitizer,this.platformId=platformId,this.renderer=renderer,this.zone=zone,this.service=service,this.required=!1,this.customToolbarPosition=\"top\",this.sanitize=!1,this.styles=null,this.strict=!0,this.customOptions=[],this.customModules=[],this.preserveWhitespace=!1,this.trimOnValidation=!1,this.compareValues=!1,this.filterNull=!1,this.defaultEmptyValue=null,this.onEditorCreated=new core.o,this.onEditorChanged=new core.o,this.onContentChanged=new core.o,this.onSelectionChanged=new core.o,this.onFocus=new core.o,this.onBlur=new core.o,this.disabled=!1,this.subscription=null,this.valueGetter=(quillEditor,editorElement)=>{let html=editorElement.querySelector(\".ql-editor\").innerHTML;\"<p><br></p>\"!==html&&\"<div><br></div>\"!==html||(html=this.defaultEmptyValue);let modelValue=html;const format=getFormat(this.format,this.service.config.format);if(\"text\"===format)modelValue=quillEditor.getText();else if(\"object\"===format)modelValue=quillEditor.getContents();else if(\"json\"===format)try{modelValue=JSON.stringify(quillEditor.getContents())}catch(e){modelValue=quillEditor.getText()}return modelValue},this.valueSetter=(quillEditor,value)=>{const format=getFormat(this.format,this.service.config.format);if(\"html\"===format)return this.sanitize&&(value=this.domSanitizer.sanitize(core.K.HTML,value)),quillEditor.clipboard.convert(value);if(\"json\"===format)try{return JSON.parse(value)}catch(e){return[{insert:value}]}return value},this.selectionChangeHandler=(range,oldRange,source)=>{const shouldTriggerOnModelTouched=!range&&!!this.onModelTouched;(this.onBlur.observers.length||this.onFocus.observers.length||this.onSelectionChanged.observers.length||shouldTriggerOnModelTouched)&&this.zone.run(()=>{null===range?this.onBlur.emit({editor:this.quillEditor,source:source}):null===oldRange&&this.onFocus.emit({editor:this.quillEditor,source:source}),this.onSelectionChanged.emit({editor:this.quillEditor,oldRange:oldRange,range:range,source:source}),shouldTriggerOnModelTouched&&this.onModelTouched()})},this.textChangeHandler=(delta,oldDelta,source)=>{const text=this.quillEditor.getText(),content=this.quillEditor.getContents();let html=this.editorElem.querySelector(\".ql-editor\").innerHTML;\"<p><br></p>\"!==html&&\"<div><br></div>\"!==html||(html=this.defaultEmptyValue);const trackChanges=this.trackChanges||this.service.config.trackChanges,shouldTriggerOnModelChange=(\"user\"===source||trackChanges&&\"all\"===trackChanges)&&!!this.onModelChange;(this.onContentChanged.observers.length||shouldTriggerOnModelChange)&&this.zone.run(()=>{shouldTriggerOnModelChange&&this.onModelChange(this.valueGetter(this.quillEditor,this.editorElem)),this.onContentChanged.emit({content:content,delta:delta,editor:this.quillEditor,html:html,oldDelta:oldDelta,source:source,text:text})})},this.editorChangeHandler=(event,current,old,source)=>{if(this.onEditorChanged.observers.length)if(\"text-change\"===event){const text=this.quillEditor.getText(),content=this.quillEditor.getContents();let html=this.editorElem.querySelector(\".ql-editor\").innerHTML;\"<p><br></p>\"!==html&&\"<div><br></div>\"!==html||(html=this.defaultEmptyValue),this.zone.run(()=>{this.onEditorChanged.emit({content:content,delta:current,editor:this.quillEditor,event:event,html:html,oldDelta:old,source:source,text:text})})}else this.zone.run(()=>{this.onEditorChanged.emit({editor:this.quillEditor,event:event,oldRange:old,range:current,source:source})})},this.document=injector.get(common.d)}static normalizeClassNames(classes){return classes.trim().split(\" \").reduce((prev,cur)=>{const trimmed=cur.trim();return trimmed&&prev.push(trimmed),prev},[])}ngAfterViewInit(){return __awaiter(this,void 0,void 0,function*(){if(Object(common.B)(this.platformId))return;const Quill=yield this.service.getQuill();this.elementRef.nativeElement.insertAdjacentHTML(\"top\"===this.customToolbarPosition?\"beforeend\":\"afterbegin\",this.preserveWhitespace?\"<pre quill-editor-element></pre>\":\"<div quill-editor-element></div>\"),this.editorElem=this.elementRef.nativeElement.querySelector(\"[quill-editor-element]\");const toolbarElem=this.elementRef.nativeElement.querySelector(\"[quill-editor-toolbar]\"),modules=Object.assign({},this.modules||this.service.config.modules);toolbarElem?modules.toolbar=toolbarElem:void 0===modules.toolbar&&(modules.toolbar=defaultModules.toolbar);let placeholder=void 0!==this.placeholder?this.placeholder:this.service.config.placeholder;void 0===placeholder&&(placeholder=\"Insert text here ...\"),this.styles&&Object.keys(this.styles).forEach(key=>{this.renderer.setStyle(this.editorElem,key,this.styles[key])}),this.classes&&this.addClasses(this.classes),this.customOptions.forEach(customOption=>{const newCustomOption=Quill.import(customOption.import);newCustomOption.whitelist=customOption.whitelist,Quill.register(newCustomOption,!0)}),this.customModules.forEach(({implementation:implementation,path:path})=>{Quill.register(path,implementation)});let bounds=this.bounds&&\"self\"===this.bounds?this.editorElem:this.bounds;bounds||(bounds=this.service.config.bounds?this.service.config.bounds:this.document.body);let debug=this.debug;!debug&&!1!==debug&&this.service.config.debug&&(debug=this.service.config.debug);let readOnly=this.readOnly;readOnly||!1===this.readOnly||(readOnly=void 0!==this.service.config.readOnly&&this.service.config.readOnly);let defaultEmptyValue=this.defaultEmptyValue;this.service.config.hasOwnProperty(\"defaultEmptyValue\")&&(defaultEmptyValue=this.service.config.defaultEmptyValue);let scrollingContainer=this.scrollingContainer;scrollingContainer||null===this.scrollingContainer||(scrollingContainer=null===this.service.config.scrollingContainer||this.service.config.scrollingContainer?this.service.config.scrollingContainer:null);let formats=this.formats;if(formats||void 0!==formats||(formats=this.service.config.formats?[...this.service.config.formats]:null===this.service.config.formats?null:void 0),this.zone.runOutsideAngular(()=>{var _a,_b,_c;if(this.quillEditor=new Quill(this.editorElem,{bounds:bounds,debug:debug,formats:formats,modules:modules,placeholder:placeholder,readOnly:readOnly,defaultEmptyValue:defaultEmptyValue,scrollingContainer:scrollingContainer,strict:this.strict,theme:this.theme||(this.service.config.theme?this.service.config.theme:\"snow\")}),this.linkPlaceholder){const tooltip=null===(_b=null===(_a=this.quillEditor)||void 0===_a?void 0:_a.theme)||void 0===_b?void 0:_b.tooltip,input=null===(_c=null==tooltip?void 0:tooltip.root)||void 0===_c?void 0:_c.querySelector(\"input[data-link]\");(null==input?void 0:input.dataset)&&(input.dataset.link=this.linkPlaceholder)}}),this.content){if(\"text\"===getFormat(this.format,this.service.config.format))this.quillEditor.setText(this.content,\"silent\");else{const newValue=this.valueSetter(this.quillEditor,this.content);this.quillEditor.setContents(newValue,\"silent\")}this.quillEditor.getModule(\"history\").clear()}this.setDisabledState(),this.addQuillEventListeners(),(this.onEditorCreated.observers.length||this.onValidatorChanged)&&requestAnimationFrame(()=>{this.onValidatorChanged&&this.onValidatorChanged(),this.onEditorCreated.emit(this.quillEditor)})})}ngOnDestroy(){this.dispose()}ngOnChanges(changes){if(this.quillEditor){if(changes.readOnly&&this.quillEditor.enable(!changes.readOnly.currentValue),changes.placeholder&&(this.quillEditor.root.dataset.placeholder=changes.placeholder.currentValue),changes.defaultEmptyValue&&(this.quillEditor.root.dataset.defaultEmptyValue=changes.defaultEmptyValue.currentValue),changes.styles){const currentStyling=changes.styles.currentValue,previousStyling=changes.styles.previousValue;previousStyling&&Object.keys(previousStyling).forEach(key=>{this.renderer.removeStyle(this.editorElem,key)}),currentStyling&&Object.keys(currentStyling).forEach(key=>{this.renderer.setStyle(this.editorElem,key,this.styles[key])})}if(changes.classes){const currentClasses=changes.classes.currentValue,previousClasses=changes.classes.previousValue;previousClasses&&this.removeClasses(previousClasses),currentClasses&&this.addClasses(currentClasses)}changes.debounceTime&&this.addQuillEventListeners()}}addClasses(classList){QuillEditorBase.normalizeClassNames(classList).forEach(c=>{this.renderer.addClass(this.editorElem,c)})}removeClasses(classList){QuillEditorBase.normalizeClassNames(classList).forEach(c=>{this.renderer.removeClass(this.editorElem,c)})}writeValue(currentValue){if(this.filterNull&&null===currentValue)return;if(this.content=currentValue,!this.quillEditor)return;const format=getFormat(this.format,this.service.config.format),newValue=this.valueSetter(this.quillEditor,currentValue);if(this.compareValues){const currentEditorValue=this.quillEditor.getContents();if(JSON.stringify(currentEditorValue)===JSON.stringify(newValue))return}currentValue?\"text\"===format?this.quillEditor.setText(currentValue):this.quillEditor.setContents(newValue):this.quillEditor.setText(\"\")}setDisabledState(isDisabled=this.disabled){this.disabled=isDisabled,this.quillEditor&&(isDisabled?(this.quillEditor.disable(),this.renderer.setAttribute(this.elementRef.nativeElement,\"disabled\",\"disabled\")):(this.readOnly||this.quillEditor.enable(),this.renderer.removeAttribute(this.elementRef.nativeElement,\"disabled\")))}registerOnChange(fn){this.onModelChange=fn}registerOnTouched(fn){this.onModelTouched=fn}registerOnValidatorChange(fn){this.onValidatorChanged=fn}validate(){if(!this.quillEditor)return null;const err={};let valid=!0;const text=this.quillEditor.getText(),textLength=this.trimOnValidation?text.trim().length:1===text.length&&0===text.trim().length?0:text.length-1;return this.minLength&&textLength&&textLength<this.minLength&&(err.minLengthError={given:textLength,minLength:this.minLength},valid=!1),this.maxLength&&textLength>this.maxLength&&(err.maxLengthError={given:textLength,maxLength:this.maxLength},valid=!1),this.required&&!textLength&&(err.requiredError={empty:!0},valid=!1),valid?null:err}addQuillEventListeners(){this.dispose(),this.zone.runOutsideAngular(()=>{this.subscription=new Subscription.a,this.subscription.add(Object(fromEvent.a)(this.quillEditor,\"selection-change\").subscribe(([range,oldRange,source])=>{this.selectionChangeHandler(range,oldRange,source)}));let textChange$=Object(fromEvent.a)(this.quillEditor,\"text-change\"),editorChange$=Object(fromEvent.a)(this.quillEditor,\"editor-change\");\"number\"==typeof this.debounceTime&&(textChange$=textChange$.pipe(Object(debounceTime.a)(this.debounceTime)),editorChange$=editorChange$.pipe(Object(debounceTime.a)(this.debounceTime))),this.subscription.add(textChange$.subscribe(([delta,oldDelta,source])=>{this.textChangeHandler(delta,oldDelta,source)})),this.subscription.add(editorChange$.subscribe(([event,current,old,source])=>{this.editorChangeHandler(event,current,old,source)}))})}dispose(){null!==this.subscription&&(this.subscription.unsubscribe(),this.subscription=null)}}return QuillEditorBase.ɵfac=function(t){return new(t||QuillEditorBase)(core.Pb(core.t),core.Pb(core.l),core.Pb(platform_browser.b),core.Pb(core.D),core.Pb(core.G),core.Pb(core.B),core.Pb(ngx_quill_QuillService))},QuillEditorBase.ɵdir=core.Kb({type:QuillEditorBase,inputs:{required:\"required\",customToolbarPosition:\"customToolbarPosition\",sanitize:\"sanitize\",styles:\"styles\",strict:\"strict\",customOptions:\"customOptions\",customModules:\"customModules\",preserveWhitespace:\"preserveWhitespace\",trimOnValidation:\"trimOnValidation\",compareValues:\"compareValues\",filterNull:\"filterNull\",defaultEmptyValue:\"defaultEmptyValue\",valueGetter:\"valueGetter\",valueSetter:\"valueSetter\",format:\"format\",theme:\"theme\",modules:\"modules\",debug:\"debug\",readOnly:\"readOnly\",placeholder:\"placeholder\",maxLength:\"maxLength\",minLength:\"minLength\",formats:\"formats\",scrollingContainer:\"scrollingContainer\",bounds:\"bounds\",trackChanges:\"trackChanges\",classes:\"classes\",linkPlaceholder:\"linkPlaceholder\",debounceTime:\"debounceTime\"},outputs:{onEditorCreated:\"onEditorCreated\",onEditorChanged:\"onEditorChanged\",onContentChanged:\"onContentChanged\",onSelectionChanged:\"onSelectionChanged\",onFocus:\"onFocus\",onBlur:\"onBlur\"},features:[core.Ab]}),QuillEditorBase})(),ngx_quill_QuillEditorComponent=(()=>{class QuillEditorComponent extends ngx_quill_QuillEditorBase{constructor(injector,elementRef,domSanitizer,platformId,renderer,zone,service){super(injector,elementRef,domSanitizer,platformId,renderer,zone,service)}}return QuillEditorComponent.ɵfac=function(t){return new(t||QuillEditorComponent)(core.Pb(core.t),core.Pb(core.l),core.Pb(platform_browser.b),core.Pb(core.D),core.Pb(core.G),core.Pb(core.B),core.Pb(ngx_quill_QuillService))},QuillEditorComponent.ɵcmp=core.Jb({type:QuillEditorComponent,selectors:[[\"quill-editor\"]],features:[core.Bb([{multi:!0,provide:fesm2015_forms.k,useExisting:Object(core.W)(()=>QuillEditorComponent)},{multi:!0,provide:fesm2015_forms.j,useExisting:Object(core.W)(()=>QuillEditorComponent)}]),core.zb],ngContentSelectors:_c1,decls:1,vars:0,template:function(rf,ctx){1&rf&&(core.oc(_c0),core.nc(0))},encapsulation:2}),QuillEditorComponent})(),ngx_quill_QuillModule=(()=>{class QuillModule{static forRoot(config){return{ngModule:QuillModule,providers:[{provide:QUILL_CONFIG_TOKEN,useValue:config}]}}}return QuillModule.ɵmod=core.Nb({type:QuillModule}),QuillModule.ɵinj=core.Mb({factory:function(t){return new(t||QuillModule)},providers:[ngx_quill_QuillService],imports:[[common.c]]}),QuillModule})()}}]);","name":"15-es2015.b4bbfa16acb5adc7fb70.js","input":"(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[15],{\n\n/***/ \"CzEO\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ ngx_quill_QuillEditorComponent; });\n__webpack_require__.d(__webpack_exports__, \"b\", function() { return /* binding */ ngx_quill_QuillModule; });\n\n// UNUSED EXPORTS: QUILL_CONFIG_TOKEN, QuillEditorBase, QuillService, QuillViewComponent, QuillViewHTMLComponent, defaultModules\n\n// EXTERNAL MODULE: ./node_modules/@angular/common/__ivy_ngcc__/fesm2015/common.js\nvar common = __webpack_require__(\"ofXK\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js\nvar core = __webpack_require__(\"fXoL\");\n\n// CONCATENATED MODULE: ./node_modules/ngx-quill/node_modules/tslib/tslib.es6.js\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nfunction __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || from);\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\n// EXTERNAL MODULE: ./node_modules/@angular/platform-browser/__ivy_ngcc__/fesm2015/platform-browser.js\nvar platform_browser = __webpack_require__(\"jhN1\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subscription.js + 1 modules\nvar Subscription = __webpack_require__(\"quSY\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/fromEvent.js\nvar fromEvent = __webpack_require__(\"xgIS\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/debounceTime.js\nvar debounceTime = __webpack_require__(\"Kj3r\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/forms/__ivy_ngcc__/fesm2015/forms.js\nvar fesm2015_forms = __webpack_require__(\"3Pt+\");\n\n// CONCATENATED MODULE: ./node_modules/ngx-quill/__ivy_ngcc__/fesm2015/ngx-quill.js\n\n\n\n\n\n\n\n\n\n\n\nconst _c0 = [[[\"\", \"quill-editor-toolbar\", \"\"]]];\nconst _c1 = [\"[quill-editor-toolbar]\"];\nconst defaultModules = {\n    toolbar: [\n        ['bold', 'italic', 'underline', 'strike'],\n        ['blockquote', 'code-block'],\n        [{ header: 1 }, { header: 2 }],\n        [{ list: 'ordered' }, { list: 'bullet' }],\n        [{ script: 'sub' }, { script: 'super' }],\n        [{ indent: '-1' }, { indent: '+1' }],\n        [{ direction: 'rtl' }],\n        [{ size: ['small', false, 'large', 'huge'] }],\n        [{ header: [1, 2, 3, 4, 5, 6, false] }],\n        [\n            { color: [] },\n            { background: [] }\n        ],\n        [{ font: [] }],\n        [{ align: [] }],\n        ['clean'],\n        ['link', 'image', 'video'] // link and image, video\n    ]\n};\nconst getFormat = (format, configFormat) => {\n    const passedFormat = format || configFormat;\n    return passedFormat || 'html';\n};\nconst QUILL_CONFIG_TOKEN = new core[\"s\" /* InjectionToken */]('config');\nlet ngx_quill_QuillService = /*@__PURE__*/ (() => {\n    class QuillService {\n        constructor(injector, config) {\n            this.config = config;\n            this.count = 0;\n            this.document = injector.get(common[\"d\" /* DOCUMENT */]);\n            if (!this.config) {\n                this.config = { modules: defaultModules };\n            }\n        }\n        getQuill() {\n            this.count++;\n            if (!this.Quill && this.count === 1) {\n                this.$importPromise = new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n                    var _a, _b;\n                    // Quill adds events listeners on import https://github.com/quilljs/quill/blob/develop/core/emitter.js#L8\n                    // We'd want to use the unpatched `addEventListener` method to have all event callbacks to be run outside of zone.\n                    // We don't know yet if the `zone.js` is used or not, just save the value to restore it back further.\n                    const maybePatchedAddEventListener = this.document.addEventListener;\n                    // There're 2 types of Angular applications:\n                    // 1) zone-full (by default)\n                    // 2) zone-less\n                    // The developer can avoid importing the `zone.js` package and tells Angular that he/she is responsible for running\n                    // the change detection by himself. This is done by \"nooping\" the zone through `CompilerOptions` when bootstrapping\n                    // the root module. We fallback to `document.addEventListener` if `__zone_symbol__addEventListener` is not defined,\n                    // this means the `zone.js` is not imported.\n                    // The `__zone_symbol__addEventListener` is basically a native DOM API, which is not patched by zone.js, thus not even going\n                    // through the `zone.js` task lifecycle. You can also access the native DOM API as follows `target[Zone.__symbol__('methodName')]`.\n                    // eslint-disable-next-line @typescript-eslint/dot-notation\n                    this.document.addEventListener = this.document['__zone_symbol__addEventListener'] || this.document.addEventListener;\n                    const quillImport = yield __webpack_require__.e(/* import() */ 38).then(__webpack_require__.t.bind(null, \"kzlf\", 7));\n                    this.document.addEventListener = maybePatchedAddEventListener;\n                    this.Quill = (quillImport.default ? quillImport.default : quillImport);\n                    // Only register custom options and modules once\n                    (_a = this.config.customOptions) === null || _a === void 0 ? void 0 : _a.forEach((customOption) => {\n                        const newCustomOption = this.Quill.import(customOption.import);\n                        newCustomOption.whitelist = customOption.whitelist;\n                        this.Quill.register(newCustomOption, true, this.config.suppressGlobalRegisterWarning);\n                    });\n                    (_b = this.config.customModules) === null || _b === void 0 ? void 0 : _b.forEach(({ implementation, path }) => {\n                        this.Quill.register(path, implementation, this.config.suppressGlobalRegisterWarning);\n                    });\n                    resolve(this.Quill);\n                }));\n            }\n            return this.$importPromise;\n        }\n    }\n    QuillService.ɵfac = function QuillService_Factory(t) { return new (t || QuillService)(core[\"cc\" /* ɵɵinject */](core[\"t\" /* Injector */]), core[\"cc\" /* ɵɵinject */](QUILL_CONFIG_TOKEN)); };\n    QuillService.ɵprov = core[\"Lb\" /* ɵɵdefineInjectable */]({ factory: function QuillService_Factory() { return new QuillService(core[\"cc\" /* ɵɵinject */](core[\"p\" /* INJECTOR */]), core[\"cc\" /* ɵɵinject */](QUILL_CONFIG_TOKEN)); }, token: QuillService, providedIn: \"root\" });\n    return QuillService;\n})();\nlet ngx_quill_QuillEditorBase = /*@__PURE__*/ (() => {\n    class QuillEditorBase {\n        constructor(injector, elementRef, domSanitizer, platformId, renderer, zone, service) {\n            this.elementRef = elementRef;\n            this.domSanitizer = domSanitizer;\n            this.platformId = platformId;\n            this.renderer = renderer;\n            this.zone = zone;\n            this.service = service;\n            this.required = false;\n            this.customToolbarPosition = 'top';\n            this.sanitize = false;\n            this.styles = null;\n            this.strict = true;\n            this.customOptions = [];\n            this.customModules = [];\n            this.preserveWhitespace = false;\n            this.trimOnValidation = false;\n            this.compareValues = false;\n            this.filterNull = false;\n            /*\n            https://github.com/KillerCodeMonkey/ngx-quill/issues/1257 - fix null value set\n          \n            provide default empty value\n            by default null\n          \n            e.g. defaultEmptyValue=\"\" - empty string\n          \n            <quill-editor\n              defaultEmptyValue=\"\"\n              formControlName=\"message\"\n            ></quill-editor>\n            */\n            this.defaultEmptyValue = null;\n            this.onEditorCreated = new core[\"o\" /* EventEmitter */]();\n            this.onEditorChanged = new core[\"o\" /* EventEmitter */]();\n            this.onContentChanged = new core[\"o\" /* EventEmitter */]();\n            this.onSelectionChanged = new core[\"o\" /* EventEmitter */]();\n            this.onFocus = new core[\"o\" /* EventEmitter */]();\n            this.onBlur = new core[\"o\" /* EventEmitter */]();\n            this.disabled = false; // used to store initial value before ViewInit\n            this.subscription = null;\n            this.valueGetter = (quillEditor, editorElement) => {\n                let html = editorElement.querySelector('.ql-editor').innerHTML;\n                if (html === '<p><br></p>' || html === '<div><br></div>') {\n                    html = this.defaultEmptyValue;\n                }\n                let modelValue = html;\n                const format = getFormat(this.format, this.service.config.format);\n                if (format === 'text') {\n                    modelValue = quillEditor.getText();\n                }\n                else if (format === 'object') {\n                    modelValue = quillEditor.getContents();\n                }\n                else if (format === 'json') {\n                    try {\n                        modelValue = JSON.stringify(quillEditor.getContents());\n                    }\n                    catch (e) {\n                        modelValue = quillEditor.getText();\n                    }\n                }\n                return modelValue;\n            };\n            this.valueSetter = (quillEditor, value) => {\n                const format = getFormat(this.format, this.service.config.format);\n                if (format === 'html') {\n                    if (this.sanitize) {\n                        value = this.domSanitizer.sanitize(core[\"K\" /* SecurityContext */].HTML, value);\n                    }\n                    return quillEditor.clipboard.convert(value);\n                }\n                else if (format === 'json') {\n                    try {\n                        return JSON.parse(value);\n                    }\n                    catch (e) {\n                        return [{ insert: value }];\n                    }\n                }\n                return value;\n            };\n            this.selectionChangeHandler = (range, oldRange, source) => {\n                const shouldTriggerOnModelTouched = !range && !!this.onModelTouched;\n                // only emit changes when there's any listener\n                if (!this.onBlur.observers.length &&\n                    !this.onFocus.observers.length &&\n                    !this.onSelectionChanged.observers.length &&\n                    !shouldTriggerOnModelTouched) {\n                    return;\n                }\n                this.zone.run(() => {\n                    if (range === null) {\n                        this.onBlur.emit({\n                            editor: this.quillEditor,\n                            source\n                        });\n                    }\n                    else if (oldRange === null) {\n                        this.onFocus.emit({\n                            editor: this.quillEditor,\n                            source\n                        });\n                    }\n                    this.onSelectionChanged.emit({\n                        editor: this.quillEditor,\n                        oldRange,\n                        range,\n                        source\n                    });\n                    if (shouldTriggerOnModelTouched) {\n                        this.onModelTouched();\n                    }\n                });\n            };\n            this.textChangeHandler = (delta, oldDelta, source) => {\n                // only emit changes emitted by user interactions\n                const text = this.quillEditor.getText();\n                const content = this.quillEditor.getContents();\n                let html = this.editorElem.querySelector('.ql-editor').innerHTML;\n                if (html === '<p><br></p>' || html === '<div><br></div>') {\n                    html = this.defaultEmptyValue;\n                }\n                const trackChanges = this.trackChanges || this.service.config.trackChanges;\n                const shouldTriggerOnModelChange = (source === 'user' || trackChanges && trackChanges === 'all') && !!this.onModelChange;\n                // only emit changes when there's any listener\n                if (!this.onContentChanged.observers.length && !shouldTriggerOnModelChange) {\n                    return;\n                }\n                this.zone.run(() => {\n                    if (shouldTriggerOnModelChange) {\n                        this.onModelChange(this.valueGetter(this.quillEditor, this.editorElem));\n                    }\n                    this.onContentChanged.emit({\n                        content,\n                        delta,\n                        editor: this.quillEditor,\n                        html,\n                        oldDelta,\n                        source,\n                        text\n                    });\n                });\n            };\n            // eslint-disable-next-line max-len\n            this.editorChangeHandler = (event, current, old, source) => {\n                // only emit changes when there's any listener\n                if (!this.onEditorChanged.observers.length) {\n                    return;\n                }\n                // only emit changes emitted by user interactions\n                if (event === 'text-change') {\n                    const text = this.quillEditor.getText();\n                    const content = this.quillEditor.getContents();\n                    let html = this.editorElem.querySelector('.ql-editor').innerHTML;\n                    if (html === '<p><br></p>' || html === '<div><br></div>') {\n                        html = this.defaultEmptyValue;\n                    }\n                    this.zone.run(() => {\n                        this.onEditorChanged.emit({\n                            content,\n                            delta: current,\n                            editor: this.quillEditor,\n                            event,\n                            html,\n                            oldDelta: old,\n                            source,\n                            text\n                        });\n                    });\n                }\n                else {\n                    this.zone.run(() => {\n                        this.onEditorChanged.emit({\n                            editor: this.quillEditor,\n                            event,\n                            oldRange: old,\n                            range: current,\n                            source\n                        });\n                    });\n                }\n            };\n            this.document = injector.get(common[\"d\" /* DOCUMENT */]);\n        }\n        static normalizeClassNames(classes) {\n            const classList = classes.trim().split(' ');\n            return classList.reduce((prev, cur) => {\n                const trimmed = cur.trim();\n                if (trimmed) {\n                    prev.push(trimmed);\n                }\n                return prev;\n            }, []);\n        }\n        ngAfterViewInit() {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (Object(common[\"B\" /* isPlatformServer */])(this.platformId)) {\n                    return;\n                }\n                // eslint-disable-next-line @typescript-eslint/naming-convention\n                const Quill = yield this.service.getQuill();\n                this.elementRef.nativeElement.insertAdjacentHTML(this.customToolbarPosition === 'top' ? 'beforeend' : 'afterbegin', this.preserveWhitespace ? '<pre quill-editor-element></pre>' : '<div quill-editor-element></div>');\n                this.editorElem = this.elementRef.nativeElement.querySelector('[quill-editor-element]');\n                const toolbarElem = this.elementRef.nativeElement.querySelector('[quill-editor-toolbar]');\n                const modules = Object.assign({}, this.modules || this.service.config.modules);\n                if (toolbarElem) {\n                    modules.toolbar = toolbarElem;\n                }\n                else if (modules.toolbar === undefined) {\n                    modules.toolbar = defaultModules.toolbar;\n                }\n                let placeholder = this.placeholder !== undefined ? this.placeholder : this.service.config.placeholder;\n                if (placeholder === undefined) {\n                    placeholder = 'Insert text here ...';\n                }\n                if (this.styles) {\n                    Object.keys(this.styles).forEach((key) => {\n                        this.renderer.setStyle(this.editorElem, key, this.styles[key]);\n                    });\n                }\n                if (this.classes) {\n                    this.addClasses(this.classes);\n                }\n                this.customOptions.forEach((customOption) => {\n                    const newCustomOption = Quill.import(customOption.import);\n                    newCustomOption.whitelist = customOption.whitelist;\n                    Quill.register(newCustomOption, true);\n                });\n                this.customModules.forEach(({ implementation, path }) => {\n                    Quill.register(path, implementation);\n                });\n                let bounds = this.bounds && this.bounds === 'self' ? this.editorElem : this.bounds;\n                if (!bounds) {\n                    bounds = this.service.config.bounds ? this.service.config.bounds : this.document.body;\n                }\n                let debug = this.debug;\n                if (!debug && debug !== false && this.service.config.debug) {\n                    debug = this.service.config.debug;\n                }\n                let readOnly = this.readOnly;\n                if (!readOnly && this.readOnly !== false) {\n                    readOnly = this.service.config.readOnly !== undefined ? this.service.config.readOnly : false;\n                }\n                let defaultEmptyValue = this.defaultEmptyValue;\n                if (this.service.config.hasOwnProperty('defaultEmptyValue')) {\n                    defaultEmptyValue = this.service.config.defaultEmptyValue;\n                }\n                let scrollingContainer = this.scrollingContainer;\n                if (!scrollingContainer && this.scrollingContainer !== null) {\n                    scrollingContainer =\n                        this.service.config.scrollingContainer === null\n                            || this.service.config.scrollingContainer ? this.service.config.scrollingContainer : null;\n                }\n                let formats = this.formats;\n                if (!formats && formats === undefined) {\n                    formats = this.service.config.formats ? [...this.service.config.formats] : (this.service.config.formats === null ? null : undefined);\n                }\n                this.zone.runOutsideAngular(() => {\n                    var _a, _b, _c;\n                    this.quillEditor = new Quill(this.editorElem, {\n                        bounds,\n                        debug: debug,\n                        formats: formats,\n                        modules,\n                        placeholder,\n                        readOnly,\n                        defaultEmptyValue,\n                        scrollingContainer: scrollingContainer,\n                        strict: this.strict,\n                        theme: this.theme || (this.service.config.theme ? this.service.config.theme : 'snow')\n                    });\n                    // Set optional link placeholder, Quill has no native API for it so using workaround\n                    if (this.linkPlaceholder) {\n                        const tooltip = (_b = (_a = this.quillEditor) === null || _a === void 0 ? void 0 : _a.theme) === null || _b === void 0 ? void 0 : _b.tooltip;\n                        const input = (_c = tooltip === null || tooltip === void 0 ? void 0 : tooltip.root) === null || _c === void 0 ? void 0 : _c.querySelector('input[data-link]');\n                        if (input === null || input === void 0 ? void 0 : input.dataset) {\n                            input.dataset.link = this.linkPlaceholder;\n                        }\n                    }\n                });\n                if (this.content) {\n                    const format = getFormat(this.format, this.service.config.format);\n                    if (format === 'text') {\n                        this.quillEditor.setText(this.content, 'silent');\n                    }\n                    else {\n                        const newValue = this.valueSetter(this.quillEditor, this.content);\n                        this.quillEditor.setContents(newValue, 'silent');\n                    }\n                    this.quillEditor.getModule('history').clear();\n                }\n                // initialize disabled status based on this.disabled as default value\n                this.setDisabledState();\n                this.addQuillEventListeners();\n                // The `requestAnimationFrame` triggers change detection. There's no sense to invoke the `requestAnimationFrame` if anyone is\n                // listening to the `onEditorCreated` event inside the template, for instance `<quill-view (onEditorCreated)=\"...\">`.\n                if (!this.onEditorCreated.observers.length && !this.onValidatorChanged) {\n                    return;\n                }\n                // The `requestAnimationFrame` will trigger change detection and `onEditorCreated` will also call `markDirty()`\n                // internally, since Angular wraps template event listeners into `listener` instruction. We're using the `requestAnimationFrame`\n                // to prevent the frame drop and avoid `ExpressionChangedAfterItHasBeenCheckedError` error.\n                requestAnimationFrame(() => {\n                    if (this.onValidatorChanged) {\n                        this.onValidatorChanged();\n                    }\n                    this.onEditorCreated.emit(this.quillEditor);\n                });\n            });\n        }\n        ngOnDestroy() {\n            this.dispose();\n        }\n        ngOnChanges(changes) {\n            if (!this.quillEditor) {\n                return;\n            }\n            /* eslint-disable @typescript-eslint/dot-notation */\n            if (changes.readOnly) {\n                this.quillEditor.enable(!changes.readOnly.currentValue);\n            }\n            if (changes.placeholder) {\n                this.quillEditor.root.dataset.placeholder =\n                    changes.placeholder.currentValue;\n            }\n            if (changes.defaultEmptyValue) {\n                this.quillEditor.root.dataset.defaultEmptyValue =\n                    changes.defaultEmptyValue.currentValue;\n            }\n            if (changes.styles) {\n                const currentStyling = changes.styles.currentValue;\n                const previousStyling = changes.styles.previousValue;\n                if (previousStyling) {\n                    Object.keys(previousStyling).forEach((key) => {\n                        this.renderer.removeStyle(this.editorElem, key);\n                    });\n                }\n                if (currentStyling) {\n                    Object.keys(currentStyling).forEach((key) => {\n                        this.renderer.setStyle(this.editorElem, key, this.styles[key]);\n                    });\n                }\n            }\n            if (changes.classes) {\n                const currentClasses = changes.classes.currentValue;\n                const previousClasses = changes.classes.previousValue;\n                if (previousClasses) {\n                    this.removeClasses(previousClasses);\n                }\n                if (currentClasses) {\n                    this.addClasses(currentClasses);\n                }\n            }\n            // We'd want to re-apply event listeners if the `debounceTime` binding changes to apply the\n            // `debounceTime` operator or vice-versa remove it.\n            if (changes.debounceTime) {\n                this.addQuillEventListeners();\n            }\n            /* eslint-enable @typescript-eslint/dot-notation */\n        }\n        addClasses(classList) {\n            QuillEditorBase.normalizeClassNames(classList).forEach((c) => {\n                this.renderer.addClass(this.editorElem, c);\n            });\n        }\n        removeClasses(classList) {\n            QuillEditorBase.normalizeClassNames(classList).forEach((c) => {\n                this.renderer.removeClass(this.editorElem, c);\n            });\n        }\n        writeValue(currentValue) {\n            // optional fix for https://github.com/angular/angular/issues/14988\n            if (this.filterNull && currentValue === null) {\n                return;\n            }\n            this.content = currentValue;\n            if (!this.quillEditor) {\n                return;\n            }\n            const format = getFormat(this.format, this.service.config.format);\n            const newValue = this.valueSetter(this.quillEditor, currentValue);\n            if (this.compareValues) {\n                const currentEditorValue = this.quillEditor.getContents();\n                if (JSON.stringify(currentEditorValue) === JSON.stringify(newValue)) {\n                    return;\n                }\n            }\n            if (currentValue) {\n                if (format === 'text') {\n                    this.quillEditor.setText(currentValue);\n                }\n                else {\n                    this.quillEditor.setContents(newValue);\n                }\n                return;\n            }\n            this.quillEditor.setText('');\n        }\n        setDisabledState(isDisabled = this.disabled) {\n            // store initial value to set appropriate disabled status after ViewInit\n            this.disabled = isDisabled;\n            if (this.quillEditor) {\n                if (isDisabled) {\n                    this.quillEditor.disable();\n                    this.renderer.setAttribute(this.elementRef.nativeElement, 'disabled', 'disabled');\n                }\n                else {\n                    if (!this.readOnly) {\n                        this.quillEditor.enable();\n                    }\n                    this.renderer.removeAttribute(this.elementRef.nativeElement, 'disabled');\n                }\n            }\n        }\n        registerOnChange(fn) {\n            this.onModelChange = fn;\n        }\n        registerOnTouched(fn) {\n            this.onModelTouched = fn;\n        }\n        registerOnValidatorChange(fn) {\n            this.onValidatorChanged = fn;\n        }\n        validate() {\n            if (!this.quillEditor) {\n                return null;\n            }\n            const err = {};\n            let valid = true;\n            const text = this.quillEditor.getText();\n            // trim text if wanted + handle special case that an empty editor contains a new line\n            const textLength = this.trimOnValidation ? text.trim().length : (text.length === 1 && text.trim().length === 0 ? 0 : text.length - 1);\n            if (this.minLength && textLength && textLength < this.minLength) {\n                err.minLengthError = {\n                    given: textLength,\n                    minLength: this.minLength\n                };\n                valid = false;\n            }\n            if (this.maxLength && textLength > this.maxLength) {\n                err.maxLengthError = {\n                    given: textLength,\n                    maxLength: this.maxLength\n                };\n                valid = false;\n            }\n            if (this.required && !textLength) {\n                err.requiredError = {\n                    empty: true\n                };\n                valid = false;\n            }\n            return valid ? null : err;\n        }\n        addQuillEventListeners() {\n            this.dispose();\n            // We have to enter the `<root>` zone when adding event listeners, so `debounceTime` will spawn the\n            // `AsyncAction` there w/o triggering change detections. We still re-enter the Angular's zone through\n            // `zone.run` when we emit an event to the parent component.\n            this.zone.runOutsideAngular(() => {\n                this.subscription = new Subscription[\"a\" /* Subscription */]();\n                this.subscription.add(\n                // mark model as touched if editor lost focus\n                Object(fromEvent[\"a\" /* fromEvent */])(this.quillEditor, 'selection-change').subscribe(([range, oldRange, source]) => {\n                    this.selectionChangeHandler(range, oldRange, source);\n                }));\n                // The `fromEvent` supports passing JQuery-style event targets, the editor has `on` and `off` methods which\n                // will be invoked upon subscription and teardown.\n                let textChange$ = Object(fromEvent[\"a\" /* fromEvent */])(this.quillEditor, 'text-change');\n                let editorChange$ = Object(fromEvent[\"a\" /* fromEvent */])(this.quillEditor, 'editor-change');\n                if (typeof this.debounceTime === 'number') {\n                    textChange$ = textChange$.pipe(Object(debounceTime[\"a\" /* debounceTime */])(this.debounceTime));\n                    editorChange$ = editorChange$.pipe(Object(debounceTime[\"a\" /* debounceTime */])(this.debounceTime));\n                }\n                this.subscription.add(\n                // update model if text changes\n                textChange$.subscribe(([delta, oldDelta, source]) => {\n                    this.textChangeHandler(delta, oldDelta, source);\n                }));\n                this.subscription.add(\n                // triggered if selection or text changed\n                editorChange$.subscribe(([event, current, old, source]) => {\n                    this.editorChangeHandler(event, current, old, source);\n                }));\n            });\n        }\n        dispose() {\n            if (this.subscription !== null) {\n                this.subscription.unsubscribe();\n                this.subscription = null;\n            }\n        }\n    }\n    QuillEditorBase.ɵfac = function QuillEditorBase_Factory(t) { return new (t || QuillEditorBase)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"t\" /* Injector */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](platform_browser[\"b\" /* DomSanitizer */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"D\" /* PLATFORM_ID */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"G\" /* Renderer2 */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */]), core[\"Pb\" /* ɵɵdirectiveInject */](ngx_quill_QuillService)); };\n    QuillEditorBase.ɵdir = core[\"Kb\" /* ɵɵdefineDirective */]({ type: QuillEditorBase, inputs: { required: \"required\", customToolbarPosition: \"customToolbarPosition\", sanitize: \"sanitize\", styles: \"styles\", strict: \"strict\", customOptions: \"customOptions\", customModules: \"customModules\", preserveWhitespace: \"preserveWhitespace\", trimOnValidation: \"trimOnValidation\", compareValues: \"compareValues\", filterNull: \"filterNull\", defaultEmptyValue: \"defaultEmptyValue\", valueGetter: \"valueGetter\", valueSetter: \"valueSetter\", format: \"format\", theme: \"theme\", modules: \"modules\", debug: \"debug\", readOnly: \"readOnly\", placeholder: \"placeholder\", maxLength: \"maxLength\", minLength: \"minLength\", formats: \"formats\", scrollingContainer: \"scrollingContainer\", bounds: \"bounds\", trackChanges: \"trackChanges\", classes: \"classes\", linkPlaceholder: \"linkPlaceholder\", debounceTime: \"debounceTime\" }, outputs: { onEditorCreated: \"onEditorCreated\", onEditorChanged: \"onEditorChanged\", onContentChanged: \"onContentChanged\", onSelectionChanged: \"onSelectionChanged\", onFocus: \"onFocus\", onBlur: \"onBlur\" }, features: [core[\"Ab\" /* ɵɵNgOnChangesFeature */]] });\n    return QuillEditorBase;\n})();\nlet ngx_quill_QuillEditorComponent = /*@__PURE__*/ (() => {\n    class QuillEditorComponent extends ngx_quill_QuillEditorBase {\n        constructor(injector, elementRef, domSanitizer, platformId, renderer, zone, service) {\n            super(injector, elementRef, domSanitizer, platformId, renderer, zone, service);\n        }\n    }\n    QuillEditorComponent.ɵfac = function QuillEditorComponent_Factory(t) { return new (t || QuillEditorComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"t\" /* Injector */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](platform_browser[\"b\" /* DomSanitizer */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"D\" /* PLATFORM_ID */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"G\" /* Renderer2 */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */]), core[\"Pb\" /* ɵɵdirectiveInject */](ngx_quill_QuillService)); };\n    QuillEditorComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: QuillEditorComponent, selectors: [[\"quill-editor\"]], features: [core[\"Bb\" /* ɵɵProvidersFeature */]([\n                {\n                    multi: true,\n                    provide: fesm2015_forms[\"k\" /* NG_VALUE_ACCESSOR */],\n                    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                    useExisting: Object(core[\"W\" /* forwardRef */])(() => QuillEditorComponent)\n                },\n                {\n                    multi: true,\n                    provide: fesm2015_forms[\"j\" /* NG_VALIDATORS */],\n                    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                    useExisting: Object(core[\"W\" /* forwardRef */])(() => QuillEditorComponent)\n                }\n            ]), core[\"zb\" /* ɵɵInheritDefinitionFeature */]], ngContentSelectors: _c1, decls: 1, vars: 0, template: function QuillEditorComponent_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"oc\" /* ɵɵprojectionDef */](_c0);\n                core[\"nc\" /* ɵɵprojection */](0);\n            }\n        }, encapsulation: 2 });\n    return QuillEditorComponent;\n})();\nlet ngx_quill_QuillViewHTMLComponent = /*@__PURE__*/ (() => {\n    class QuillViewHTMLComponent {\n        constructor(sanitizer, service) {\n            this.sanitizer = sanitizer;\n            this.service = service;\n            this.content = '';\n            this.sanitize = false;\n            this.innerHTML = '';\n            this.themeClass = 'ql-snow';\n        }\n        ngOnChanges(changes) {\n            if (changes.theme) {\n                const theme = changes.theme.currentValue || (this.service.config.theme ? this.service.config.theme : 'snow');\n                this.themeClass = `ql-${theme} ngx-quill-view-html`;\n            }\n            else if (!this.theme) {\n                const theme = this.service.config.theme ? this.service.config.theme : 'snow';\n                this.themeClass = `ql-${theme} ngx-quill-view-html`;\n            }\n            if (changes.content) {\n                const content = changes.content.currentValue;\n                this.innerHTML = this.sanitize ? content : this.sanitizer.bypassSecurityTrustHtml(content);\n            }\n        }\n    }\n    QuillViewHTMLComponent.ɵfac = function QuillViewHTMLComponent_Factory(t) { return new (t || QuillViewHTMLComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](platform_browser[\"b\" /* DomSanitizer */]), core[\"Pb\" /* ɵɵdirectiveInject */](ngx_quill_QuillService)); };\n    QuillViewHTMLComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: QuillViewHTMLComponent, selectors: [[\"quill-view-html\"]], inputs: { content: \"content\", sanitize: \"sanitize\", theme: \"theme\" }, features: [core[\"Ab\" /* ɵɵNgOnChangesFeature */]], decls: 2, vars: 2, consts: [[1, \"ql-container\", 3, \"ngClass\"], [1, \"ql-editor\", 3, \"innerHTML\"]], template: function QuillViewHTMLComponent_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"Vb\" /* ɵɵelementStart */](0, \"div\", 0);\n                core[\"Qb\" /* ɵɵelement */](1, \"div\", 1);\n                core[\"Ub\" /* ɵɵelementEnd */]();\n            }\n            if (rf & 2) {\n                core[\"pc\" /* ɵɵproperty */](\"ngClass\", ctx.themeClass);\n                core[\"Cb\" /* ɵɵadvance */](1);\n                core[\"pc\" /* ɵɵproperty */](\"innerHTML\", ctx.innerHTML, core[\"Bc\" /* ɵɵsanitizeHtml */]);\n            }\n        }, directives: [common[\"j\" /* NgClass */]], styles: [\"\\n.ql-container.ngx-quill-view-html {\\n  border: 0;\\n}\\n\"], encapsulation: 2 });\n    return QuillViewHTMLComponent;\n})();\nlet ngx_quill_QuillViewComponent = /*@__PURE__*/ (() => {\n    class QuillViewComponent {\n        constructor(elementRef, renderer, zone, service, domSanitizer, platformId) {\n            this.elementRef = elementRef;\n            this.renderer = renderer;\n            this.zone = zone;\n            this.service = service;\n            this.domSanitizer = domSanitizer;\n            this.platformId = platformId;\n            this.sanitize = false;\n            this.strict = true;\n            this.customModules = [];\n            this.customOptions = [];\n            this.preserveWhitespace = false;\n            this.onEditorCreated = new core[\"o\" /* EventEmitter */]();\n            this.valueSetter = (quillEditor, value) => {\n                const format = getFormat(this.format, this.service.config.format);\n                let content = value;\n                if (format === 'text') {\n                    quillEditor.setText(content);\n                }\n                else {\n                    if (format === 'html') {\n                        if (this.sanitize) {\n                            value = this.domSanitizer.sanitize(core[\"K\" /* SecurityContext */].HTML, value);\n                        }\n                        content = quillEditor.clipboard.convert(value);\n                    }\n                    else if (format === 'json') {\n                        try {\n                            content = JSON.parse(value);\n                        }\n                        catch (e) {\n                            content = [{ insert: value }];\n                        }\n                    }\n                    quillEditor.setContents(content);\n                }\n            };\n        }\n        ngOnChanges(changes) {\n            if (!this.quillEditor) {\n                return;\n            }\n            if (changes.content) {\n                this.valueSetter(this.quillEditor, changes.content.currentValue);\n            }\n        }\n        ngAfterViewInit() {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (Object(common[\"B\" /* isPlatformServer */])(this.platformId)) {\n                    return;\n                }\n                // eslint-disable-next-line @typescript-eslint/naming-convention\n                const Quill = yield this.service.getQuill();\n                const modules = Object.assign({}, this.modules || this.service.config.modules);\n                modules.toolbar = false;\n                this.customOptions.forEach((customOption) => {\n                    const newCustomOption = Quill.import(customOption.import);\n                    newCustomOption.whitelist = customOption.whitelist;\n                    Quill.register(newCustomOption, true);\n                });\n                this.customModules.forEach(({ implementation, path }) => {\n                    Quill.register(path, implementation);\n                });\n                let debug = this.debug;\n                if (!debug && debug !== false && this.service.config.debug) {\n                    debug = this.service.config.debug;\n                }\n                let formats = this.formats;\n                if (!formats && formats === undefined) {\n                    formats = this.service.config.formats ?\n                        Object.assign({}, this.service.config.formats) : (this.service.config.formats === null ? null : undefined);\n                }\n                const theme = this.theme || (this.service.config.theme ? this.service.config.theme : 'snow');\n                this.elementRef.nativeElement.insertAdjacentHTML('afterbegin', this.preserveWhitespace ? '<pre quill-view-element></pre>' : '<div quill-view-element></div>');\n                this.editorElem = this.elementRef.nativeElement.querySelector('[quill-view-element]');\n                this.zone.runOutsideAngular(() => {\n                    this.quillEditor = new Quill(this.editorElem, {\n                        debug: debug,\n                        formats: formats,\n                        modules,\n                        readOnly: true,\n                        strict: this.strict,\n                        theme\n                    });\n                });\n                this.renderer.addClass(this.editorElem, 'ngx-quill-view');\n                if (this.content) {\n                    this.valueSetter(this.quillEditor, this.content);\n                }\n                // The `requestAnimationFrame` triggers change detection. There's no sense to invoke the `requestAnimationFrame` if anyone is\n                // listening to the `onEditorCreated` event inside the template, for instance `<quill-view (onEditorCreated)=\"...\">`.\n                if (!this.onEditorCreated.observers.length) {\n                    return;\n                }\n                // The `requestAnimationFrame` will trigger change detection and `onEditorCreated` will also call `markDirty()`\n                // internally, since Angular wraps template event listeners into `listener` instruction. We're using the `requestAnimationFrame`\n                // to prevent the frame drop and avoid `ExpressionChangedAfterItHasBeenCheckedError` error.\n                requestAnimationFrame(() => {\n                    this.onEditorCreated.emit(this.quillEditor);\n                });\n            });\n        }\n    }\n    QuillViewComponent.ɵfac = function QuillViewComponent_Factory(t) { return new (t || QuillViewComponent)(core[\"Pb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"G\" /* Renderer2 */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"B\" /* NgZone */]), core[\"Pb\" /* ɵɵdirectiveInject */](ngx_quill_QuillService), core[\"Pb\" /* ɵɵdirectiveInject */](platform_browser[\"b\" /* DomSanitizer */]), core[\"Pb\" /* ɵɵdirectiveInject */](core[\"D\" /* PLATFORM_ID */])); };\n    QuillViewComponent.ɵcmp = core[\"Jb\" /* ɵɵdefineComponent */]({ type: QuillViewComponent, selectors: [[\"quill-view\"]], inputs: { sanitize: \"sanitize\", strict: \"strict\", customModules: \"customModules\", customOptions: \"customOptions\", preserveWhitespace: \"preserveWhitespace\", format: \"format\", theme: \"theme\", modules: \"modules\", debug: \"debug\", formats: \"formats\", content: \"content\" }, outputs: { onEditorCreated: \"onEditorCreated\" }, features: [core[\"Ab\" /* ɵɵNgOnChangesFeature */]], decls: 0, vars: 0, template: function QuillViewComponent_Template(rf, ctx) { }, styles: [\"\\n.ql-container.ngx-quill-view {\\n  border: 0;\\n}\\n\"], encapsulation: 2 });\n    return QuillViewComponent;\n})();\nlet ngx_quill_QuillModule = /*@__PURE__*/ (() => {\n    class QuillModule {\n        static forRoot(config) {\n            return {\n                ngModule: QuillModule,\n                providers: [\n                    {\n                        provide: QUILL_CONFIG_TOKEN,\n                        useValue: config\n                    }\n                ]\n            };\n        }\n    }\n    QuillModule.ɵmod = core[\"Nb\" /* ɵɵdefineNgModule */]({ type: QuillModule });\n    QuillModule.ɵinj = core[\"Mb\" /* ɵɵdefineInjector */]({ factory: function QuillModule_Factory(t) { return new (t || QuillModule)(); }, providers: [ngx_quill_QuillService], imports: [[common[\"c\" /* CommonModule */]]] });\n    return QuillModule;\n})();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ec\" /* ɵɵsetNgModuleScope */](ngx_quill_QuillModule, { declarations: function () { return [ngx_quill_QuillEditorComponent, ngx_quill_QuillViewComponent, ngx_quill_QuillViewHTMLComponent]; }, imports: function () { return [common[\"c\" /* CommonModule */]]; }, exports: function () { return [ngx_quill_QuillEditorComponent, ngx_quill_QuillViewComponent, ngx_quill_QuillViewHTMLComponent]; } }); })();\n/*\n * Public API Surface of ngx-quill\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=ngx-quill.js.map\n\n\n/***/ })\n\n}]);","inputSourceMap":null}